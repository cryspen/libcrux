/* 
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>
  KaRaMeL invocation: /Users/franziskus/repos/eurydice/eurydice libcrux_kyber.llbc
  F* version: d0aa54cf
  KaRaMeL version: f0b4a9a9
 */

#include "libcrux_kyber.h"

const int32_t libcrux_kyber_constants_FIELD_MODULUS = (int32_t)3329;

const size_t libcrux_kyber_constants_BITS_PER_COEFFICIENT = (size_t)12U;

const size_t libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT = (size_t)256U;

const
size_t
libcrux_kyber_constants_BITS_PER_RING_ELEMENT =
  libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT
  * (size_t)12U;

const
size_t
libcrux_kyber_constants_BYTES_PER_RING_ELEMENT =
  libcrux_kyber_constants_BITS_PER_RING_ELEMENT
  / (size_t)8U;

const size_t libcrux_kyber_constants_REJECTION_SAMPLING_SEED_SIZE = (size_t)168U * (size_t)5U;

const size_t libcrux_kyber_constants_SHARED_SECRET_SIZE = (size_t)32U;

const size_t libcrux_kyber_constants_CPA_PKE_KEY_GENERATION_SEED_SIZE = (size_t)32U;

const
size_t
libcrux_kyber_constants_H_DIGEST_SIZE = libcrux_digest_digest_size(libcrux_digest_Sha3_256);

const uint8_t libcrux_kyber_arithmetic_MONTGOMERY_SHIFT = 16U;

const
int32_t
libcrux_kyber_arithmetic_MONTGOMERY_R =
  (int32_t)1
  << (uint32_t)libcrux_kyber_arithmetic_MONTGOMERY_SHIFT;

uint32_t libcrux_kyber_arithmetic_get_n_least_significant_bits(uint8_t n, uint32_t value)
{
  return value & ((1U << (uint32_t)n) - 1U);
}

const int64_t libcrux_kyber_arithmetic_BARRETT_SHIFT = (int64_t)26;

const
int64_t
libcrux_kyber_arithmetic_BARRETT_R =
  (int64_t)1
  << (uint32_t)libcrux_kyber_arithmetic_BARRETT_SHIFT;

const int64_t libcrux_kyber_arithmetic_BARRETT_MULTIPLIER = (int64_t)20159;

int32_t libcrux_kyber_arithmetic_barrett_reduce(int32_t value)
{
  int64_t
  t =
    core_convert_num__i64_59__from(value)
    * libcrux_kyber_arithmetic_BARRETT_MULTIPLIER
    + (libcrux_kyber_arithmetic_BARRETT_R >> 1U);
  int32_t quotient = (int32_t)(t >> (uint32_t)libcrux_kyber_arithmetic_BARRETT_SHIFT);
  return value - quotient * libcrux_kyber_constants_FIELD_MODULUS;
}

const uint32_t libcrux_kyber_arithmetic_INVERSE_OF_MODULUS_MOD_R = 62209U;

int32_t libcrux_kyber_arithmetic_montgomery_reduce(int32_t value)
{
  uint32_t
  t =
    libcrux_kyber_arithmetic_get_n_least_significant_bits(libcrux_kyber_arithmetic_MONTGOMERY_SHIFT,
      (uint32_t)value)
    * libcrux_kyber_arithmetic_INVERSE_OF_MODULUS_MOD_R;
  int16_t
  k =
    (int16_t)libcrux_kyber_arithmetic_get_n_least_significant_bits(libcrux_kyber_arithmetic_MONTGOMERY_SHIFT,
      t);
  int32_t k_times_modulus = (int32_t)k * libcrux_kyber_constants_FIELD_MODULUS;
  int32_t c = k_times_modulus >> (uint32_t)libcrux_kyber_arithmetic_MONTGOMERY_SHIFT;
  int32_t value_high = value >> (uint32_t)libcrux_kyber_arithmetic_MONTGOMERY_SHIFT;
  return value_high - c;
}

int32_t libcrux_kyber_arithmetic_montgomery_multiply_sfe_by_fer(int32_t fe, int32_t fer)
{
  return libcrux_kyber_arithmetic_montgomery_reduce(fe * fer);
}

const int32_t libcrux_kyber_arithmetic_MONTGOMERY_R_SQUARED_MOD_FIELD_MODULUS = (int32_t)1353;

int32_t libcrux_kyber_arithmetic_to_standard_domain(int32_t mfe)
{
  return
    libcrux_kyber_arithmetic_montgomery_reduce(mfe
      * libcrux_kyber_arithmetic_MONTGOMERY_R_SQUARED_MOD_FIELD_MODULUS);
}

uint16_t libcrux_kyber_arithmetic_to_unsigned_representative(int32_t fe)
{
  return (uint16_t)(fe + (libcrux_kyber_constants_FIELD_MODULUS & fe >> 31U));
}

void
libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement_2__clone(
  int32_t (*self)[256U],
  int32_t ret[256U]
)
{
  memcpy(ret, self[0U], (size_t)256U * sizeof (int32_t));
}

bool
libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement_5__eq(
  int32_t (*self)[256U],
  int32_t (*other)[256U]
)
{
  return
    core_array_equality___Array_A__N___eq((size_t)256U,
      self[0U],
      other[0U],
      int32_t,
      int32_t);
}

void
libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement_7__assert_receiver_is_total_eq(
  int32_t (*self)[256U]
)
{

}

const
int32_t
libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO[256U] = { 0U };

uint8_t libcrux_kyber_compress_compress_message_coefficient(uint16_t fe)
{
  int16_t shifted = (int16_t)1664 - (int16_t)fe;
  int16_t mask = shifted >> 15U;
  int16_t shifted_to_positive = mask ^ shifted;
  int16_t shifted_positive_in_range = shifted_to_positive - (int16_t)832;
  return (uint8_t)(shifted_positive_in_range >> 15U & (int16_t)1);
}

int32_t
libcrux_kyber_compress_compress_ciphertext_coefficient(uint8_t coefficient_bits, uint16_t fe)
{
  uint32_t compressed = (uint32_t)fe << (uint32_t)((uint32_t)coefficient_bits + 1U);
  compressed = compressed + (uint32_t)libcrux_kyber_constants_FIELD_MODULUS;
  compressed = compressed / (uint32_t)(libcrux_kyber_constants_FIELD_MODULUS << 1U);
  return
    (int32_t)libcrux_kyber_arithmetic_get_n_least_significant_bits(coefficient_bits, compressed);
}

int32_t libcrux_kyber_compress_decompress_message_coefficient(int32_t fe)
{
  return -fe & (libcrux_kyber_constants_FIELD_MODULUS + (int32_t)1) / (int32_t)2;
}

int32_t
libcrux_kyber_compress_decompress_ciphertext_coefficient(uint8_t coefficient_bits, int32_t fe)
{
  uint32_t decompressed = (uint32_t)fe * (uint32_t)libcrux_kyber_constants_FIELD_MODULUS;
  decompressed = (decompressed << 1U) + (1U << (uint32_t)coefficient_bits);
  decompressed = decompressed >> (uint32_t)((uint32_t)coefficient_bits + 1U);
  return (int32_t)decompressed;
}

uint8_t libcrux_kyber_constant_time_ops_is_non_zero(uint8_t value)
{
  uint16_t value0 = (uint16_t)value;
  uint16_t uu____0 = value0;
  uint16_t
  result =
    (((uint32_t)uu____0 | (uint32_t)core_num__u16_7__wrapping_add(~value0, 1U)) & 0xFFFFU)
    >> 8U
    & 1U;
  return (uint8_t)result;
}

void
libcrux_kyber_constant_time_ops_select_shared_secret_in_constant_time(
  Eurydice_slice lhs,
  Eurydice_slice rhs,
  uint8_t selector,
  uint8_t ret[32U]
)
{
  uint8_t
  mask = core_num__u8_6__wrapping_sub(libcrux_kyber_constant_time_ops_is_non_zero(selector), 1U);
  uint8_t out[32U];
  for (size_t i = (size_t)0U; i < (size_t)32U; i++)
    out[i] = 0U;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = libcrux_kyber_constants_SHARED_SECRET_SIZE;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        uint8_t uu____1 = (uint32_t)Eurydice_slice_index(lhs, i, uint8_t) & (uint32_t)mask;
        uint8_t *uu____2 = &Eurydice_slice_index(rhs, i, uint8_t);
        size_t uu____3 = i;
        out[uu____3] =
          (uint32_t)out[uu____3]
          | ((uint32_t)uu____1 | ((uint32_t)uu____2[0U] & (uint32_t)~mask));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____4[32U];
    memcpy(uu____4, out, (size_t)32U * sizeof (uint8_t));
    memcpy(ret, uu____4, (size_t)32U * sizeof (uint8_t));
    return;
  }
}

void libcrux_kyber_hash_functions_G(Eurydice_slice input, uint8_t ret[64U])
{
  uint8_t ret0[64U];
  libcrux_digest_sha3_512(input, ret0);
  memcpy(ret, ret0, (size_t)64U * sizeof (uint8_t));
}

void libcrux_kyber_hash_functions_H(Eurydice_slice input, uint8_t ret[32U])
{
  uint8_t ret0[32U];
  libcrux_digest_sha3_256(input, ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

K___uint8_t_uint8_t_uint8_t
libcrux_kyber_serialize_compress_coefficients_3(uint16_t coefficient1, uint16_t coefficient2)
{
  uint8_t coef1 = (uint8_t)((uint32_t)coefficient1 & 255U);
  uint8_t coef2 = (uint8_t)((uint32_t)coefficient1 >> 8U | ((uint32_t)coefficient2 & 15U) << 4U);
  uint8_t coef3 = (uint8_t)((uint32_t)coefficient2 >> 4U & 255U);
  K___uint8_t_uint8_t_uint8_t lit;
  lit.fst = coef1;
  lit.snd = coef2;
  lit.thd = coef3;
  return lit;
}

void
libcrux_kyber_serialize_serialize_uncompressed_ring_element(
  int32_t re[256U],
  uint8_t ret[384U]
)
{
  uint8_t serialized[384U];
  for (size_t i = (size_t)0U; i < (size_t)384U; i++)
    serialized[i] = 0U;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t),
      int32_t)
    / (size_t)2U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        uint16_t
        coefficient1 =
          libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)2U + (size_t)0U]);
        uint16_t
        coefficient2 =
          libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)2U + (size_t)1U]);
        K___uint8_t_uint8_t_uint8_t
        uu____1 = libcrux_kyber_serialize_compress_coefficients_3(coefficient1, coefficient2);
        uint8_t coef1 = uu____1.fst;
        uint8_t coef2 = uu____1.snd;
        uint8_t coef3 = uu____1.thd;
        serialized[(size_t)3U * i] = coef1;
        serialized[(size_t)3U * i + (size_t)1U] = coef2;
        serialized[(size_t)3U * i + (size_t)2U] = coef3;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____2[384U];
    memcpy(uu____2, serialized, (size_t)384U * sizeof (uint8_t));
    memcpy(ret, uu____2, (size_t)384U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_serialize_deserialize_to_uncompressed_ring_element(
  Eurydice_slice serialized,
  int32_t ret[256U]
)
{
  int32_t re[256U];
  memcpy(re,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(serialized, uint8_t) / (size_t)3U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t
        byte1 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)3U + (size_t)0U, uint8_t);
        int32_t
        byte2 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)3U + (size_t)1U, uint8_t);
        int32_t
        byte3 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)3U + (size_t)2U, uint8_t);
        re[(size_t)2U * i] = (byte2 & (int32_t)15) << 8U | (byte1 & (int32_t)255);
        re[(size_t)2U * i + (size_t)1U] = byte3 << 4U | (byte2 >> 4U & (int32_t)15);
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, re, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_sampling_sample_from_binomial_distribution_2(
  Eurydice_slice randomness,
  int32_t ret[256U]
)
{
  int32_t sampled[256U];
  memcpy(sampled,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = core_slice___Slice_T___len(randomness, uint8_t) / (size_t)4U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        uint32_t
        uu____1 = (uint32_t)Eurydice_slice_index(randomness, i * (size_t)4U + (size_t)0U, uint8_t);
        uint32_t
        uu____2 =
          uu____1
          | (uint32_t)Eurydice_slice_index(randomness, i * (size_t)4U + (size_t)1U, uint8_t) << 8U;
        uint32_t
        uu____3 =
          uu____2
          | (uint32_t)Eurydice_slice_index(randomness, i * (size_t)4U + (size_t)2U, uint8_t) << 16U;
        uint32_t
        random_bits_as_u32 =
          uu____3
          | (uint32_t)Eurydice_slice_index(randomness, i * (size_t)4U + (size_t)3U, uint8_t) << 24U;
        uint32_t even_bits = random_bits_as_u32 & 1431655765U;
        uint32_t odd_bits = random_bits_as_u32 >> 1U & 1431655765U;
        uint32_t coin_toss_outcomes = even_bits + odd_bits;
        core_ops_range_Range__uint32_t lit;
        lit.start = 0U;
        lit.end = core_num__u32_8__BITS / 4U;
        core_ops_range_Range__uint32_t
        iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__uint32_t);
        while (true)
        {
          core_option_Option__uint32_t
          uu____4 = core_iter_range__core__ops__range__Range_A__3__next(&iter, uint32_t);
          if (uu____4.tag == core_option_None)
            break;
          else if (uu____4.tag == core_option_Some)
          {
            uint32_t outcome_set_ = uu____4.f0;
            uint32_t outcome_set = outcome_set_ * 4U;
            int32_t outcome_1 = (int32_t)(coin_toss_outcomes >> (uint32_t)outcome_set & 3U);
            int32_t outcome_2 = (int32_t)(coin_toss_outcomes >> (uint32_t)(outcome_set + 2U) & 3U);
            size_t offset = (size_t)(outcome_set >> 2U);
            sampled[(size_t)8U * i + offset] = outcome_1 - outcome_2;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, sampled, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_sampling_sample_from_binomial_distribution_3(
  Eurydice_slice randomness,
  int32_t ret[256U]
)
{
  int32_t sampled[256U];
  memcpy(sampled,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = core_slice___Slice_T___len(randomness, uint8_t) / (size_t)3U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        uint32_t
        uu____1 = (uint32_t)Eurydice_slice_index(randomness, i * (size_t)3U + (size_t)0U, uint8_t);
        uint32_t
        uu____2 =
          uu____1
          | (uint32_t)Eurydice_slice_index(randomness, i * (size_t)3U + (size_t)1U, uint8_t) << 8U;
        uint32_t
        random_bits_as_u24 =
          uu____2
          | (uint32_t)Eurydice_slice_index(randomness, i * (size_t)3U + (size_t)2U, uint8_t) << 16U;
        uint32_t first_bits = random_bits_as_u24 & 2396745U;
        uint32_t second_bits = random_bits_as_u24 >> 1U & 2396745U;
        uint32_t third_bits = random_bits_as_u24 >> 2U & 2396745U;
        uint32_t coin_toss_outcomes = first_bits + second_bits + third_bits;
        core_ops_range_Range__int32_t lit;
        lit.start = (int32_t)0;
        lit.end = (int32_t)24 / (int32_t)6;
        core_ops_range_Range__int32_t
        iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__int32_t);
        while (true)
        {
          core_option_Option__int32_t
          uu____3 = core_iter_range__core__ops__range__Range_A__3__next(&iter, int32_t);
          if (uu____3.tag == core_option_None)
            break;
          else if (uu____3.tag == core_option_Some)
          {
            int32_t outcome_set_ = uu____3.f0;
            int32_t outcome_set = outcome_set_ * (int32_t)6;
            int32_t outcome_1 = (int32_t)(coin_toss_outcomes >> (uint32_t)outcome_set & 7U);
            int32_t
            outcome_2 = (int32_t)(coin_toss_outcomes >> (uint32_t)(outcome_set + (int32_t)3) & 7U);
            size_t offset = (size_t)(outcome_set / (int32_t)6);
            sampled[(size_t)4U * i + offset] = outcome_1 - outcome_2;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, sampled, (size_t)256U * sizeof (int32_t));
    return;
  }
}

const
int32_t
libcrux_kyber_ntt_ZETAS_TIMES_MONTGOMERY_R[128U] =
  {
    (int32_t)-1044, (int32_t)-758, (int32_t)-359, (int32_t)-1517, (int32_t)1493, (int32_t)1422,
    (int32_t)287, (int32_t)202, (int32_t)-171, (int32_t)622, (int32_t)1577, (int32_t)182,
    (int32_t)962, (int32_t)-1202, (int32_t)-1474, (int32_t)1468, (int32_t)573, (int32_t)-1325,
    (int32_t)264, (int32_t)383, (int32_t)-829, (int32_t)1458, (int32_t)-1602, (int32_t)-130,
    (int32_t)-681, (int32_t)1017, (int32_t)732, (int32_t)608, (int32_t)-1542, (int32_t)411,
    (int32_t)-205, (int32_t)-1571, (int32_t)1223, (int32_t)652, (int32_t)-552, (int32_t)1015,
    (int32_t)-1293, (int32_t)1491, (int32_t)-282, (int32_t)-1544, (int32_t)516, (int32_t)-8,
    (int32_t)-320, (int32_t)-666, (int32_t)-1618, (int32_t)-1162, (int32_t)126, (int32_t)1469,
    (int32_t)-853, (int32_t)-90, (int32_t)-271, (int32_t)830, (int32_t)107, (int32_t)-1421,
    (int32_t)-247, (int32_t)-951, (int32_t)-398, (int32_t)961, (int32_t)-1508, (int32_t)-725,
    (int32_t)448, (int32_t)-1065, (int32_t)677, (int32_t)-1275, (int32_t)-1103, (int32_t)430,
    (int32_t)555, (int32_t)843, (int32_t)-1251, (int32_t)871, (int32_t)1550, (int32_t)105,
    (int32_t)422, (int32_t)587, (int32_t)177, (int32_t)-235, (int32_t)-291, (int32_t)-460,
    (int32_t)1574, (int32_t)1653, (int32_t)-246, (int32_t)778, (int32_t)1159, (int32_t)-147,
    (int32_t)-777, (int32_t)1483, (int32_t)-602, (int32_t)1119, (int32_t)-1590, (int32_t)644,
    (int32_t)-872, (int32_t)349, (int32_t)418, (int32_t)329, (int32_t)-156, (int32_t)-75,
    (int32_t)817, (int32_t)1097, (int32_t)603, (int32_t)610, (int32_t)1322, (int32_t)-1285,
    (int32_t)-1465, (int32_t)384, (int32_t)-1215, (int32_t)-136, (int32_t)1218, (int32_t)-1335,
    (int32_t)-874, (int32_t)220, (int32_t)-1187, (int32_t)-1659, (int32_t)-1185, (int32_t)-1530,
    (int32_t)-1278, (int32_t)794, (int32_t)-1510, (int32_t)-854, (int32_t)-870, (int32_t)478,
    (int32_t)-108, (int32_t)-308, (int32_t)996, (int32_t)991, (int32_t)958, (int32_t)-1460,
    (int32_t)1522, (int32_t)1628
  };

void
libcrux_kyber_ntt_ntt_at_layer(
  size_t *zeta_i,
  int32_t re[256U],
  size_t layer,
  size_t initial_coefficient_bound,
  int32_t ret[256U]
)
{
  size_t step = (size_t)1U << (uint32_t)layer;
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = (size_t)128U / step;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t round = uu____0.f0;
        zeta_i[0U] = zeta_i[0U] + (size_t)1U;
        size_t offset = round * step * (size_t)2U;
        core_ops_range_Range__size_t lit;
        lit.start = offset;
        lit.end = offset + step;
        core_ops_range_Range__size_t
        iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
          if (uu____1.tag == core_option_None)
            break;
          else if (uu____1.tag == core_option_Some)
          {
            size_t j = uu____1.f0;
            int32_t
            t =
              libcrux_kyber_arithmetic_montgomery_multiply_sfe_by_fer(re[j + step],
                libcrux_kyber_ntt_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
            re[j + step] = re[j] - t;
            re[j] = re[j] + t;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, re, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_ntt_ntt_at_layer_3(
  size_t *zeta_i,
  int32_t re[256U],
  size_t layer,
  int32_t ret[256U]
)
{
  int32_t ret0[256U];
  libcrux_kyber_ntt_ntt_at_layer(zeta_i, re, layer, (size_t)3U, ret0);
  memcpy(ret, ret0, (size_t)256U * sizeof (int32_t));
}

void libcrux_kyber_ntt_ntt_binomially_sampled_ring_element(int32_t re[256U], int32_t ret[256U])
{
  size_t zeta_i = (size_t)1U;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)128U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (uu____0.tag == core_option_None)
      break;
    else if (uu____0.tag == core_option_Some)
    {
      size_t j = uu____0.f0;
      int32_t t = re[j + (size_t)128U] * (int32_t)-1600;
      re[j + (size_t)128U] = re[j] - t;
      re[j] = re[j] + t;
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
      KRML_HOST_EXIT(255U);
    }
  }
  libcrux_kyber_ntt_ntt_at_layer_3(&zeta_i, re, (size_t)6U, re);
  libcrux_kyber_ntt_ntt_at_layer_3(&zeta_i, re, (size_t)5U, re);
  libcrux_kyber_ntt_ntt_at_layer_3(&zeta_i, re, (size_t)4U, re);
  libcrux_kyber_ntt_ntt_at_layer_3(&zeta_i, re, (size_t)3U, re);
  libcrux_kyber_ntt_ntt_at_layer_3(&zeta_i, re, (size_t)2U, re);
  libcrux_kyber_ntt_ntt_at_layer_3(&zeta_i, re, (size_t)1U, re);
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter0 = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
    if (!(uu____1.tag == core_option_None))
    {
      if (uu____1.tag == core_option_Some)
      {
        size_t i = uu____1.f0;
        int32_t uu____2 = libcrux_kyber_arithmetic_barrett_reduce(re[i]);
        re[i] = uu____2;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, re, (size_t)256U * sizeof (int32_t));
    return;
  }
}

K___int32_t_int32_t
libcrux_kyber_ntt_ntt_multiply_binomials(
  K___int32_t_int32_t _,
  K___int32_t_int32_t _0,
  int32_t zeta
)
{
  int32_t a0 = _.fst;
  int32_t a1 = _.snd;
  int32_t b0 = _0.fst;
  int32_t b1 = _0.snd;
  int32_t uu____0 = a0 * b0;
  K___int32_t_int32_t lit;
  lit.fst =
    libcrux_kyber_arithmetic_montgomery_reduce(uu____0
      + libcrux_kyber_arithmetic_montgomery_reduce(a1 * b1) * zeta);
  lit.snd = libcrux_kyber_arithmetic_montgomery_reduce(a0 * b1 + a1 * b0);
  return lit;
}

void
libcrux_kyber_ntt_ntt_multiply(int32_t (*lhs)[256U], int32_t (*rhs)[256U], int32_t ret[256U])
{
  int32_t out[256U];
  memcpy(out,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT / (size_t)4U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        K___int32_t_int32_t lit0;
        lit0.fst = lhs[0U][(size_t)4U * i];
        lit0.snd = lhs[0U][(size_t)4U * i + (size_t)1U];
        K___int32_t_int32_t lit1;
        lit1.fst = rhs[0U][(size_t)4U * i];
        lit1.snd = rhs[0U][(size_t)4U * i + (size_t)1U];
        K___int32_t_int32_t
        product =
          libcrux_kyber_ntt_ntt_multiply_binomials(lit0,
            lit1,
            libcrux_kyber_ntt_ZETAS_TIMES_MONTGOMERY_R[(size_t)64U + i]);
        out[(size_t)4U * i] = product.fst;
        out[(size_t)4U * i + (size_t)1U] = product.snd;
        K___int32_t_int32_t lit2;
        lit2.fst = lhs[0U][(size_t)4U * i + (size_t)2U];
        lit2.snd = lhs[0U][(size_t)4U * i + (size_t)3U];
        K___int32_t_int32_t lit;
        lit.fst = rhs[0U][(size_t)4U * i + (size_t)2U];
        lit.snd = rhs[0U][(size_t)4U * i + (size_t)3U];
        K___int32_t_int32_t
        product0 =
          libcrux_kyber_ntt_ntt_multiply_binomials(lit2,
            lit,
            -libcrux_kyber_ntt_ZETAS_TIMES_MONTGOMERY_R[(size_t)64U + i]);
        out[(size_t)4U * i + (size_t)2U] = product0.fst;
        out[(size_t)4U * i + (size_t)3U] = product0.snd;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, out, (size_t)256U * sizeof (int32_t));
    return;
  }
}

K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
libcrux_kyber_serialize_compress_coefficients_10(
  int32_t coefficient1,
  int32_t coefficient2,
  int32_t coefficient3,
  int32_t coefficient4
)
{
  uint8_t coef1 = (uint8_t)(coefficient1 & (int32_t)255);
  uint8_t
  coef2 =
    (uint32_t)(uint8_t)(coefficient2 & (int32_t)63)
    << 2U
    | (uint32_t)(uint8_t)(coefficient1 >> 8U & (int32_t)3);
  uint8_t
  coef3 =
    (uint32_t)(uint8_t)(coefficient3 & (int32_t)15)
    << 4U
    | (uint32_t)(uint8_t)(coefficient2 >> 6U & (int32_t)15);
  uint8_t
  coef4 =
    (uint32_t)(uint8_t)(coefficient4 & (int32_t)3)
    << 6U
    | (uint32_t)(uint8_t)(coefficient3 >> 4U & (int32_t)63);
  uint8_t coef5 = (uint8_t)(coefficient4 >> 2U & (int32_t)255);
  K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t lit;
  lit.fst = coef1;
  lit.snd = coef2;
  lit.thd = coef3;
  lit.f3 = coef4;
  lit.f4 = coef5;
  return lit;
}

K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
libcrux_kyber_serialize_compress_coefficients_11(
  int32_t coefficient1,
  int32_t coefficient2,
  int32_t coefficient3,
  int32_t coefficient4,
  int32_t coefficient5,
  int32_t coefficient6,
  int32_t coefficient7,
  int32_t coefficient8
)
{
  uint8_t coef1 = (uint8_t)coefficient1;
  uint8_t
  coef2 =
    (uint32_t)(uint8_t)(coefficient2 & (int32_t)31)
    << 3U
    | (uint32_t)(uint8_t)(coefficient1 >> 8U);
  uint8_t
  coef3 =
    (uint32_t)(uint8_t)(coefficient3 & (int32_t)3)
    << 6U
    | (uint32_t)(uint8_t)(coefficient2 >> 5U);
  uint8_t coef4 = (uint8_t)(coefficient3 >> 2U & (int32_t)255);
  uint8_t
  coef5 =
    (uint32_t)(uint8_t)(coefficient4 & (int32_t)127)
    << 1U
    | (uint32_t)(uint8_t)(coefficient3 >> 10U);
  uint8_t
  coef6 =
    (uint32_t)(uint8_t)(coefficient5 & (int32_t)15)
    << 4U
    | (uint32_t)(uint8_t)(coefficient4 >> 7U);
  uint8_t
  coef7 =
    (uint32_t)(uint8_t)(coefficient6 & (int32_t)1)
    << 7U
    | (uint32_t)(uint8_t)(coefficient5 >> 4U);
  uint8_t coef8 = (uint8_t)(coefficient6 >> 1U & (int32_t)255);
  uint8_t
  coef9 =
    (uint32_t)(uint8_t)(coefficient7 & (int32_t)63)
    << 2U
    | (uint32_t)(uint8_t)(coefficient6 >> 9U);
  uint8_t
  coef10 =
    (uint32_t)(uint8_t)(coefficient8 & (int32_t)7)
    << 5U
    | (uint32_t)(uint8_t)(coefficient7 >> 6U);
  uint8_t coef11 = (uint8_t)(coefficient8 >> 3U);
  K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
  lit;
  lit.fst = coef1;
  lit.snd = coef2;
  lit.thd = coef3;
  lit.f3 = coef4;
  lit.f4 = coef5;
  lit.f5 = coef6;
  lit.f6 = coef7;
  lit.f7 = coef8;
  lit.f8 = coef9;
  lit.f9 = coef10;
  lit.f10 = coef11;
  return lit;
}

void
libcrux_kyber_ntt_invert_ntt_at_layer(
  size_t *zeta_i,
  int32_t re[256U],
  size_t layer,
  int32_t ret[256U]
)
{
  size_t step = (size_t)1U << (uint32_t)layer;
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = (size_t)128U / step;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t round = uu____0.f0;
        zeta_i[0U] = zeta_i[0U] - (size_t)1U;
        size_t offset = round * step * (size_t)2U;
        core_ops_range_Range__size_t lit;
        lit.start = offset;
        lit.end = offset + step;
        core_ops_range_Range__size_t
        iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
          if (uu____1.tag == core_option_None)
            break;
          else if (uu____1.tag == core_option_Some)
          {
            size_t j = uu____1.f0;
            int32_t a_minus_b = re[j + step] - re[j];
            re[j] = re[j] + re[j + step];
            int32_t
            uu____2 =
              libcrux_kyber_arithmetic_montgomery_reduce(a_minus_b
                * libcrux_kyber_ntt_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
            re[j + step] = uu____2;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, re, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_serialize_deserialize_then_decompress_message(
  uint8_t serialized[32U],
  int32_t ret[256U]
)
{
  int32_t re[256U];
  memcpy(re,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)32U, serialized, uint8_t),
      uint8_t);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        core_ops_range_Range__size_t lit;
        lit.start = (size_t)0U;
        lit.end = (size_t)8U;
        core_ops_range_Range__size_t
        iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
          if (uu____1.tag == core_option_None)
            break;
          else if (uu____1.tag == core_option_Some)
          {
            size_t j = uu____1.f0;
            int32_t coefficient_compressed = (int32_t)((uint32_t)serialized[i] >> (uint32_t)j & 1U);
            int32_t
            uu____2 = libcrux_kyber_compress_decompress_message_coefficient(coefficient_compressed);
            re[(size_t)8U * i + j] = uu____2;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, re, (size_t)256U * sizeof (int32_t));
    return;
  }
}

K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
libcrux_kyber_serialize_compress_coefficients_5(
  uint8_t coefficient2,
  uint8_t coefficient1,
  uint8_t coefficient4,
  uint8_t coefficient3,
  uint8_t coefficient5,
  uint8_t coefficient7,
  uint8_t coefficient6,
  uint8_t coefficient8
)
{
  uint8_t coef1 = ((uint32_t)coefficient2 & 7U) << 5U | (uint32_t)coefficient1;
  uint8_t
  coef2 =
    (((uint32_t)coefficient4 & 1U) << 7U | (uint32_t)coefficient3 << 2U)
    | (uint32_t)coefficient2 >> 3U;
  uint8_t coef3 = ((uint32_t)coefficient5 & 15U) << 4U | (uint32_t)coefficient4 >> 1U;
  uint8_t
  coef4 =
    (((uint32_t)coefficient7 & 3U) << 6U | (uint32_t)coefficient6 << 1U)
    | (uint32_t)coefficient5 >> 4U;
  uint8_t coef5 = (uint32_t)coefficient8 << 3U | (uint32_t)coefficient7 >> 2U;
  K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t lit;
  lit.fst = coef1;
  lit.snd = coef2;
  lit.thd = coef3;
  lit.f3 = coef4;
  lit.f4 = coef5;
  return lit;
}

K___int32_t_int32_t_int32_t_int32_t
libcrux_kyber_serialize_decompress_coefficients_10(
  int32_t byte2,
  int32_t byte1,
  int32_t byte3,
  int32_t byte4,
  int32_t byte5
)
{
  int32_t coefficient1 = (byte2 & (int32_t)3) << 8U | (byte1 & (int32_t)255);
  int32_t coefficient2 = (byte3 & (int32_t)15) << 6U | byte2 >> 2U;
  int32_t coefficient3 = (byte4 & (int32_t)63) << 4U | byte3 >> 4U;
  int32_t coefficient4 = byte5 << 2U | byte4 >> 6U;
  K___int32_t_int32_t_int32_t_int32_t lit;
  lit.fst = coefficient1;
  lit.snd = coefficient2;
  lit.thd = coefficient3;
  lit.f3 = coefficient4;
  return lit;
}

void
libcrux_kyber_serialize_deserialize_then_decompress_10(
  Eurydice_slice serialized,
  int32_t ret[256U]
)
{
  int32_t re[256U];
  memcpy(re,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(serialized, uint8_t) / (size_t)5U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t
        byte1 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)5U + (size_t)0U, uint8_t);
        int32_t
        byte2 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)5U + (size_t)1U, uint8_t);
        int32_t
        byte3 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)5U + (size_t)2U, uint8_t);
        int32_t
        byte4 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)5U + (size_t)3U, uint8_t);
        int32_t
        byte5 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)5U + (size_t)4U, uint8_t);
        K___int32_t_int32_t_int32_t_int32_t
        uu____1 =
          libcrux_kyber_serialize_decompress_coefficients_10(byte2,
            byte1,
            byte3,
            byte4,
            byte5);
        int32_t coefficient1 = uu____1.fst;
        int32_t coefficient2 = uu____1.snd;
        int32_t coefficient3 = uu____1.thd;
        int32_t coefficient4 = uu____1.f3;
        int32_t
        uu____2 = libcrux_kyber_compress_decompress_ciphertext_coefficient(10U, coefficient1);
        re[(size_t)4U * i] = uu____2;
        int32_t
        uu____3 = libcrux_kyber_compress_decompress_ciphertext_coefficient(10U, coefficient2);
        re[(size_t)4U * i + (size_t)1U] = uu____3;
        int32_t
        uu____4 = libcrux_kyber_compress_decompress_ciphertext_coefficient(10U, coefficient3);
        re[(size_t)4U * i + (size_t)2U] = uu____4;
        int32_t
        uu____5 = libcrux_kyber_compress_decompress_ciphertext_coefficient(10U, coefficient4);
        re[(size_t)4U * i + (size_t)3U] = uu____5;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, re, (size_t)256U * sizeof (int32_t));
    return;
  }
}

K___int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t
libcrux_kyber_serialize_decompress_coefficients_11(
  int32_t byte2,
  int32_t byte1,
  int32_t byte3,
  int32_t byte5,
  int32_t byte4,
  int32_t byte6,
  int32_t byte7,
  int32_t byte9,
  int32_t byte8,
  int32_t byte10,
  int32_t byte11
)
{
  int32_t coefficient1 = (byte2 & (int32_t)7) << 8U | byte1;
  int32_t coefficient2 = (byte3 & (int32_t)63) << 5U | byte2 >> 3U;
  int32_t coefficient3 = ((byte5 & (int32_t)1) << 10U | byte4 << 2U) | byte3 >> 6U;
  int32_t coefficient4 = (byte6 & (int32_t)15) << 7U | byte5 >> 1U;
  int32_t coefficient5 = (byte7 & (int32_t)127) << 4U | byte6 >> 4U;
  int32_t coefficient6 = ((byte9 & (int32_t)3) << 9U | byte8 << 1U) | byte7 >> 7U;
  int32_t coefficient7 = (byte10 & (int32_t)31) << 6U | byte9 >> 2U;
  int32_t coefficient8 = byte11 << 3U | byte10 >> 5U;
  K___int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t lit;
  lit.fst = coefficient1;
  lit.snd = coefficient2;
  lit.thd = coefficient3;
  lit.f3 = coefficient4;
  lit.f4 = coefficient5;
  lit.f5 = coefficient6;
  lit.f6 = coefficient7;
  lit.f7 = coefficient8;
  return lit;
}

void
libcrux_kyber_serialize_deserialize_then_decompress_11(
  Eurydice_slice serialized,
  int32_t ret[256U]
)
{
  int32_t re[256U];
  memcpy(re,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(serialized, uint8_t) / (size_t)11U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t
        byte1 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)11U + (size_t)0U, uint8_t);
        int32_t
        byte2 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)11U + (size_t)1U, uint8_t);
        int32_t
        byte3 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)11U + (size_t)2U, uint8_t);
        int32_t
        byte4 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)11U + (size_t)3U, uint8_t);
        int32_t
        byte5 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)11U + (size_t)4U, uint8_t);
        int32_t
        byte6 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)11U + (size_t)5U, uint8_t);
        int32_t
        byte7 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)11U + (size_t)6U, uint8_t);
        int32_t
        byte8 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)11U + (size_t)7U, uint8_t);
        int32_t
        byte9 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)11U + (size_t)8U, uint8_t);
        int32_t
        byte10 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)11U + (size_t)9U, uint8_t);
        int32_t
        byte11 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)11U + (size_t)10U, uint8_t);
        K___int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t
        uu____1 =
          libcrux_kyber_serialize_decompress_coefficients_11(byte2,
            byte1,
            byte3,
            byte5,
            byte4,
            byte6,
            byte7,
            byte9,
            byte8,
            byte10,
            byte11);
        int32_t coefficient1 = uu____1.fst;
        int32_t coefficient2 = uu____1.snd;
        int32_t coefficient3 = uu____1.thd;
        int32_t coefficient4 = uu____1.f3;
        int32_t coefficient5 = uu____1.f4;
        int32_t coefficient6 = uu____1.f5;
        int32_t coefficient7 = uu____1.f6;
        int32_t coefficient8 = uu____1.f7;
        int32_t
        uu____2 = libcrux_kyber_compress_decompress_ciphertext_coefficient(11U, coefficient1);
        re[(size_t)8U * i] = uu____2;
        int32_t
        uu____3 = libcrux_kyber_compress_decompress_ciphertext_coefficient(11U, coefficient2);
        re[(size_t)8U * i + (size_t)1U] = uu____3;
        int32_t
        uu____4 = libcrux_kyber_compress_decompress_ciphertext_coefficient(11U, coefficient3);
        re[(size_t)8U * i + (size_t)2U] = uu____4;
        int32_t
        uu____5 = libcrux_kyber_compress_decompress_ciphertext_coefficient(11U, coefficient4);
        re[(size_t)8U * i + (size_t)3U] = uu____5;
        int32_t
        uu____6 = libcrux_kyber_compress_decompress_ciphertext_coefficient(11U, coefficient5);
        re[(size_t)8U * i + (size_t)4U] = uu____6;
        int32_t
        uu____7 = libcrux_kyber_compress_decompress_ciphertext_coefficient(11U, coefficient6);
        re[(size_t)8U * i + (size_t)5U] = uu____7;
        int32_t
        uu____8 = libcrux_kyber_compress_decompress_ciphertext_coefficient(11U, coefficient7);
        re[(size_t)8U * i + (size_t)6U] = uu____8;
        int32_t
        uu____9 = libcrux_kyber_compress_decompress_ciphertext_coefficient(11U, coefficient8);
        re[(size_t)8U * i + (size_t)7U] = uu____9;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, re, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_ntt_ntt_at_layer_3328(
  size_t *zeta_i,
  int32_t re[256U],
  size_t layer,
  int32_t ret[256U]
)
{
  int32_t ret0[256U];
  libcrux_kyber_ntt_ntt_at_layer(zeta_i, re, layer, (size_t)3328U, ret0);
  memcpy(ret, ret0, (size_t)256U * sizeof (int32_t));
}

K___int32_t_int32_t libcrux_kyber_serialize_decompress_coefficients_4(uint8_t *byte)
{
  int32_t coefficient1 = (int32_t)Eurydice_bitand_pv_u8(byte, 15U);
  int32_t coefficient2 = (int32_t)((uint32_t)Eurydice_shr_pv_u8(byte, (int32_t)4) & 15U);
  K___int32_t_int32_t lit;
  lit.fst = coefficient1;
  lit.snd = coefficient2;
  return lit;
}

void
libcrux_kyber_serialize_deserialize_then_decompress_4(
  Eurydice_slice serialized,
  int32_t ret[256U]
)
{
  int32_t re[256U];
  memcpy(re,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(serialized, uint8_t);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        K___int32_t_int32_t
        uu____1 =
          libcrux_kyber_serialize_decompress_coefficients_4(&Eurydice_slice_index(serialized,
              i,
              uint8_t));
        int32_t coefficient1 = uu____1.fst;
        int32_t coefficient2 = uu____1.snd;
        int32_t
        uu____2 = libcrux_kyber_compress_decompress_ciphertext_coefficient(4U, coefficient1);
        re[(size_t)2U * i] = uu____2;
        int32_t
        uu____3 = libcrux_kyber_compress_decompress_ciphertext_coefficient(4U, coefficient2);
        re[(size_t)2U * i + (size_t)1U] = uu____3;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, re, (size_t)256U * sizeof (int32_t));
    return;
  }
}

K___int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t
libcrux_kyber_serialize_decompress_coefficients_5(
  int32_t byte1,
  int32_t byte2,
  int32_t byte3,
  int32_t byte4,
  int32_t byte5
)
{
  int32_t coefficient1 = byte1 & (int32_t)31;
  int32_t coefficient2 = (byte2 & (int32_t)3) << 3U | byte1 >> 5U;
  int32_t coefficient3 = byte2 >> 2U & (int32_t)31;
  int32_t coefficient4 = (byte3 & (int32_t)15) << 1U | byte2 >> 7U;
  int32_t coefficient5 = (byte4 & (int32_t)1) << 4U | byte3 >> 4U;
  int32_t coefficient6 = byte4 >> 1U & (int32_t)31;
  int32_t coefficient7 = (byte5 & (int32_t)7) << 2U | byte4 >> 6U;
  int32_t coefficient8 = byte5 >> 3U;
  K___int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t lit;
  lit.fst = coefficient1;
  lit.snd = coefficient2;
  lit.thd = coefficient3;
  lit.f3 = coefficient4;
  lit.f4 = coefficient5;
  lit.f5 = coefficient6;
  lit.f6 = coefficient7;
  lit.f7 = coefficient8;
  return lit;
}

void
libcrux_kyber_serialize_deserialize_then_decompress_5(
  Eurydice_slice serialized,
  int32_t ret[256U]
)
{
  int32_t re[256U];
  memcpy(re,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(serialized, uint8_t) / (size_t)5U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t
        byte1 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)5U + (size_t)0U, uint8_t);
        int32_t
        byte2 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)5U + (size_t)1U, uint8_t);
        int32_t
        byte3 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)5U + (size_t)2U, uint8_t);
        int32_t
        byte4 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)5U + (size_t)3U, uint8_t);
        int32_t
        byte5 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)5U + (size_t)4U, uint8_t);
        K___int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t
        uu____1 =
          libcrux_kyber_serialize_decompress_coefficients_5(byte1,
            byte2,
            byte3,
            byte4,
            byte5);
        int32_t coefficient1 = uu____1.fst;
        int32_t coefficient2 = uu____1.snd;
        int32_t coefficient3 = uu____1.thd;
        int32_t coefficient4 = uu____1.f3;
        int32_t coefficient5 = uu____1.f4;
        int32_t coefficient6 = uu____1.f5;
        int32_t coefficient7 = uu____1.f6;
        int32_t coefficient8 = uu____1.f7;
        int32_t
        uu____2 = libcrux_kyber_compress_decompress_ciphertext_coefficient(5U, coefficient1);
        re[(size_t)8U * i] = uu____2;
        int32_t
        uu____3 = libcrux_kyber_compress_decompress_ciphertext_coefficient(5U, coefficient2);
        re[(size_t)8U * i + (size_t)1U] = uu____3;
        int32_t
        uu____4 = libcrux_kyber_compress_decompress_ciphertext_coefficient(5U, coefficient3);
        re[(size_t)8U * i + (size_t)2U] = uu____4;
        int32_t
        uu____5 = libcrux_kyber_compress_decompress_ciphertext_coefficient(5U, coefficient4);
        re[(size_t)8U * i + (size_t)3U] = uu____5;
        int32_t
        uu____6 = libcrux_kyber_compress_decompress_ciphertext_coefficient(5U, coefficient5);
        re[(size_t)8U * i + (size_t)4U] = uu____6;
        int32_t
        uu____7 = libcrux_kyber_compress_decompress_ciphertext_coefficient(5U, coefficient6);
        re[(size_t)8U * i + (size_t)5U] = uu____7;
        int32_t
        uu____8 = libcrux_kyber_compress_decompress_ciphertext_coefficient(5U, coefficient7);
        re[(size_t)8U * i + (size_t)6U] = uu____8;
        int32_t
        uu____9 = libcrux_kyber_compress_decompress_ciphertext_coefficient(5U, coefficient8);
        re[(size_t)8U * i + (size_t)7U] = uu____9;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, re, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_serialize_compress_then_serialize_message(int32_t re[256U], uint8_t ret[32U])
{
  uint8_t serialized[32U];
  for (size_t i = (size_t)0U; i < (size_t)32U; i++)
    serialized[i] = 0U;
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t),
      int32_t)
    / (size_t)8U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        core_ops_range_Range__size_t lit;
        lit.start = (size_t)0U;
        lit.end = (size_t)8U;
        core_ops_range_Range__size_t
        iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
          if (uu____1.tag == core_option_None)
            break;
          else if (uu____1.tag == core_option_Some)
          {
            size_t j = uu____1.f0;
            uint16_t
            coefficient =
              libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + j]);
            uint8_t
            coefficient_compressed =
              libcrux_kyber_compress_compress_message_coefficient(coefficient);
            size_t uu____2 = i;
            serialized[uu____2] =
              (uint32_t)serialized[uu____2]
              | (uint32_t)coefficient_compressed << (uint32_t)j;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____3[32U];
    memcpy(uu____3, serialized, (size_t)32U * sizeof (uint8_t));
    memcpy(ret, uu____3, (size_t)32U * sizeof (uint8_t));
    return;
  }
}

libcrux_kyber_types_Error
libcrux_kyber_types__libcrux_kyber__types__Error_19__clone(libcrux_kyber_types_Error *self)
{
  return self[0U];
}

const size_t libcrux_kyber_kyber1024_RANK_1024 = (size_t)4U;

const
size_t
libcrux_kyber_kyber1024_RANKED_BYTES_PER_RING_ELEMENT_1024 =
  libcrux_kyber_kyber1024_RANK_1024
  * libcrux_kyber_constants_BITS_PER_RING_ELEMENT
  / (size_t)8U;

const
size_t
libcrux_kyber_kyber1024_T_AS_NTT_ENCODED_SIZE_1024 =
  libcrux_kyber_kyber1024_RANK_1024
  * libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT
  * libcrux_kyber_constants_BITS_PER_COEFFICIENT
  / (size_t)8U;

const size_t libcrux_kyber_kyber1024_VECTOR_U_COMPRESSION_FACTOR_1024 = (size_t)11U;

const
size_t
libcrux_kyber_kyber1024_C1_BLOCK_SIZE_1024 =
  libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT
  * libcrux_kyber_kyber1024_VECTOR_U_COMPRESSION_FACTOR_1024
  / (size_t)8U;

const
size_t
libcrux_kyber_kyber1024_C1_SIZE_1024 =
  libcrux_kyber_kyber1024_C1_BLOCK_SIZE_1024
  * libcrux_kyber_kyber1024_RANK_1024;

const size_t libcrux_kyber_kyber1024_VECTOR_V_COMPRESSION_FACTOR_1024 = (size_t)5U;

const
size_t
libcrux_kyber_kyber1024_C2_SIZE_1024 =
  libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT
  * libcrux_kyber_kyber1024_VECTOR_V_COMPRESSION_FACTOR_1024
  / (size_t)8U;

const
size_t
libcrux_kyber_kyber1024_CPA_PKE_SECRET_KEY_SIZE_1024 =
  libcrux_kyber_kyber1024_RANK_1024
  * libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT
  * libcrux_kyber_constants_BITS_PER_COEFFICIENT
  / (size_t)8U;

const
size_t
libcrux_kyber_kyber1024_CPA_PKE_PUBLIC_KEY_SIZE_1024 =
  libcrux_kyber_kyber1024_T_AS_NTT_ENCODED_SIZE_1024
  + (size_t)32U;

const
size_t
libcrux_kyber_kyber1024_CPA_PKE_CIPHERTEXT_SIZE_1024 =
  libcrux_kyber_kyber1024_C1_SIZE_1024
  + libcrux_kyber_kyber1024_C2_SIZE_1024;

const
size_t
libcrux_kyber_kyber1024_SECRET_KEY_SIZE_1024 =
  libcrux_kyber_kyber1024_CPA_PKE_SECRET_KEY_SIZE_1024
  + libcrux_kyber_kyber1024_CPA_PKE_PUBLIC_KEY_SIZE_1024
  + libcrux_kyber_constants_H_DIGEST_SIZE
  + libcrux_kyber_constants_SHARED_SECRET_SIZE;

const size_t libcrux_kyber_kyber1024_ETA1 = (size_t)2U;

const
size_t
libcrux_kyber_kyber1024_ETA1_RANDOMNESS_SIZE = libcrux_kyber_kyber1024_ETA1 * (size_t)64U;

const size_t libcrux_kyber_kyber1024_ETA2 = (size_t)2U;

const
size_t
libcrux_kyber_kyber1024_ETA2_RANDOMNESS_SIZE = libcrux_kyber_kyber1024_ETA2 * (size_t)64U;

const
size_t
libcrux_kyber_kyber1024_IMPLICIT_REJECTION_HASH_INPUT_SIZE =
  libcrux_kyber_constants_SHARED_SECRET_SIZE
  + libcrux_kyber_kyber1024_CPA_PKE_CIPHERTEXT_SIZE_1024;

typedef struct __uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t__s
{
  uint8_t fst[840U];
  uint8_t snd[840U];
  uint8_t thd[840U];
  uint8_t f3[840U];
}
__uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t_;

void
libcrux_kyber_hash_functions_XOFx4___4size_t(uint8_t input[4U][34U], uint8_t ret[4U][840U])
{
  uint8_t out[4U][840U];
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
  {
    out[i][0U] = 0U;
    out[i][1U] = 0U;
    out[i][2U] = 0U;
    out[i][3U] = 0U;
    out[i][4U] = 0U;
    out[i][5U] = 0U;
    out[i][6U] = 0U;
    out[i][7U] = 0U;
    out[i][8U] = 0U;
    out[i][9U] = 0U;
    out[i][10U] = 0U;
    out[i][11U] = 0U;
    out[i][12U] = 0U;
    out[i][13U] = 0U;
    out[i][14U] = 0U;
    out[i][15U] = 0U;
    out[i][16U] = 0U;
    out[i][17U] = 0U;
    out[i][18U] = 0U;
    out[i][19U] = 0U;
    out[i][20U] = 0U;
    out[i][21U] = 0U;
    out[i][22U] = 0U;
    out[i][23U] = 0U;
    out[i][24U] = 0U;
    out[i][25U] = 0U;
    out[i][26U] = 0U;
    out[i][27U] = 0U;
    out[i][28U] = 0U;
    out[i][29U] = 0U;
    out[i][30U] = 0U;
    out[i][31U] = 0U;
    out[i][32U] = 0U;
    out[i][33U] = 0U;
    out[i][34U] = 0U;
    out[i][35U] = 0U;
    out[i][36U] = 0U;
    out[i][37U] = 0U;
    out[i][38U] = 0U;
    out[i][39U] = 0U;
    out[i][40U] = 0U;
    out[i][41U] = 0U;
    out[i][42U] = 0U;
    out[i][43U] = 0U;
    out[i][44U] = 0U;
    out[i][45U] = 0U;
    out[i][46U] = 0U;
    out[i][47U] = 0U;
    out[i][48U] = 0U;
    out[i][49U] = 0U;
    out[i][50U] = 0U;
    out[i][51U] = 0U;
    out[i][52U] = 0U;
    out[i][53U] = 0U;
    out[i][54U] = 0U;
    out[i][55U] = 0U;
    out[i][56U] = 0U;
    out[i][57U] = 0U;
    out[i][58U] = 0U;
    out[i][59U] = 0U;
    out[i][60U] = 0U;
    out[i][61U] = 0U;
    out[i][62U] = 0U;
    out[i][63U] = 0U;
    out[i][64U] = 0U;
    out[i][65U] = 0U;
    out[i][66U] = 0U;
    out[i][67U] = 0U;
    out[i][68U] = 0U;
    out[i][69U] = 0U;
    out[i][70U] = 0U;
    out[i][71U] = 0U;
    out[i][72U] = 0U;
    out[i][73U] = 0U;
    out[i][74U] = 0U;
    out[i][75U] = 0U;
    out[i][76U] = 0U;
    out[i][77U] = 0U;
    out[i][78U] = 0U;
    out[i][79U] = 0U;
    out[i][80U] = 0U;
    out[i][81U] = 0U;
    out[i][82U] = 0U;
    out[i][83U] = 0U;
    out[i][84U] = 0U;
    out[i][85U] = 0U;
    out[i][86U] = 0U;
    out[i][87U] = 0U;
    out[i][88U] = 0U;
    out[i][89U] = 0U;
    out[i][90U] = 0U;
    out[i][91U] = 0U;
    out[i][92U] = 0U;
    out[i][93U] = 0U;
    out[i][94U] = 0U;
    out[i][95U] = 0U;
    out[i][96U] = 0U;
    out[i][97U] = 0U;
    out[i][98U] = 0U;
    out[i][99U] = 0U;
    out[i][100U] = 0U;
    out[i][101U] = 0U;
    out[i][102U] = 0U;
    out[i][103U] = 0U;
    out[i][104U] = 0U;
    out[i][105U] = 0U;
    out[i][106U] = 0U;
    out[i][107U] = 0U;
    out[i][108U] = 0U;
    out[i][109U] = 0U;
    out[i][110U] = 0U;
    out[i][111U] = 0U;
    out[i][112U] = 0U;
    out[i][113U] = 0U;
    out[i][114U] = 0U;
    out[i][115U] = 0U;
    out[i][116U] = 0U;
    out[i][117U] = 0U;
    out[i][118U] = 0U;
    out[i][119U] = 0U;
    out[i][120U] = 0U;
    out[i][121U] = 0U;
    out[i][122U] = 0U;
    out[i][123U] = 0U;
    out[i][124U] = 0U;
    out[i][125U] = 0U;
    out[i][126U] = 0U;
    out[i][127U] = 0U;
    out[i][128U] = 0U;
    out[i][129U] = 0U;
    out[i][130U] = 0U;
    out[i][131U] = 0U;
    out[i][132U] = 0U;
    out[i][133U] = 0U;
    out[i][134U] = 0U;
    out[i][135U] = 0U;
    out[i][136U] = 0U;
    out[i][137U] = 0U;
    out[i][138U] = 0U;
    out[i][139U] = 0U;
    out[i][140U] = 0U;
    out[i][141U] = 0U;
    out[i][142U] = 0U;
    out[i][143U] = 0U;
    out[i][144U] = 0U;
    out[i][145U] = 0U;
    out[i][146U] = 0U;
    out[i][147U] = 0U;
    out[i][148U] = 0U;
    out[i][149U] = 0U;
    out[i][150U] = 0U;
    out[i][151U] = 0U;
    out[i][152U] = 0U;
    out[i][153U] = 0U;
    out[i][154U] = 0U;
    out[i][155U] = 0U;
    out[i][156U] = 0U;
    out[i][157U] = 0U;
    out[i][158U] = 0U;
    out[i][159U] = 0U;
    out[i][160U] = 0U;
    out[i][161U] = 0U;
    out[i][162U] = 0U;
    out[i][163U] = 0U;
    out[i][164U] = 0U;
    out[i][165U] = 0U;
    out[i][166U] = 0U;
    out[i][167U] = 0U;
    out[i][168U] = 0U;
    out[i][169U] = 0U;
    out[i][170U] = 0U;
    out[i][171U] = 0U;
    out[i][172U] = 0U;
    out[i][173U] = 0U;
    out[i][174U] = 0U;
    out[i][175U] = 0U;
    out[i][176U] = 0U;
    out[i][177U] = 0U;
    out[i][178U] = 0U;
    out[i][179U] = 0U;
    out[i][180U] = 0U;
    out[i][181U] = 0U;
    out[i][182U] = 0U;
    out[i][183U] = 0U;
    out[i][184U] = 0U;
    out[i][185U] = 0U;
    out[i][186U] = 0U;
    out[i][187U] = 0U;
    out[i][188U] = 0U;
    out[i][189U] = 0U;
    out[i][190U] = 0U;
    out[i][191U] = 0U;
    out[i][192U] = 0U;
    out[i][193U] = 0U;
    out[i][194U] = 0U;
    out[i][195U] = 0U;
    out[i][196U] = 0U;
    out[i][197U] = 0U;
    out[i][198U] = 0U;
    out[i][199U] = 0U;
    out[i][200U] = 0U;
    out[i][201U] = 0U;
    out[i][202U] = 0U;
    out[i][203U] = 0U;
    out[i][204U] = 0U;
    out[i][205U] = 0U;
    out[i][206U] = 0U;
    out[i][207U] = 0U;
    out[i][208U] = 0U;
    out[i][209U] = 0U;
    out[i][210U] = 0U;
    out[i][211U] = 0U;
    out[i][212U] = 0U;
    out[i][213U] = 0U;
    out[i][214U] = 0U;
    out[i][215U] = 0U;
    out[i][216U] = 0U;
    out[i][217U] = 0U;
    out[i][218U] = 0U;
    out[i][219U] = 0U;
    out[i][220U] = 0U;
    out[i][221U] = 0U;
    out[i][222U] = 0U;
    out[i][223U] = 0U;
    out[i][224U] = 0U;
    out[i][225U] = 0U;
    out[i][226U] = 0U;
    out[i][227U] = 0U;
    out[i][228U] = 0U;
    out[i][229U] = 0U;
    out[i][230U] = 0U;
    out[i][231U] = 0U;
    out[i][232U] = 0U;
    out[i][233U] = 0U;
    out[i][234U] = 0U;
    out[i][235U] = 0U;
    out[i][236U] = 0U;
    out[i][237U] = 0U;
    out[i][238U] = 0U;
    out[i][239U] = 0U;
    out[i][240U] = 0U;
    out[i][241U] = 0U;
    out[i][242U] = 0U;
    out[i][243U] = 0U;
    out[i][244U] = 0U;
    out[i][245U] = 0U;
    out[i][246U] = 0U;
    out[i][247U] = 0U;
    out[i][248U] = 0U;
    out[i][249U] = 0U;
    out[i][250U] = 0U;
    out[i][251U] = 0U;
    out[i][252U] = 0U;
    out[i][253U] = 0U;
    out[i][254U] = 0U;
    out[i][255U] = 0U;
    out[i][256U] = 0U;
    out[i][257U] = 0U;
    out[i][258U] = 0U;
    out[i][259U] = 0U;
    out[i][260U] = 0U;
    out[i][261U] = 0U;
    out[i][262U] = 0U;
    out[i][263U] = 0U;
    out[i][264U] = 0U;
    out[i][265U] = 0U;
    out[i][266U] = 0U;
    out[i][267U] = 0U;
    out[i][268U] = 0U;
    out[i][269U] = 0U;
    out[i][270U] = 0U;
    out[i][271U] = 0U;
    out[i][272U] = 0U;
    out[i][273U] = 0U;
    out[i][274U] = 0U;
    out[i][275U] = 0U;
    out[i][276U] = 0U;
    out[i][277U] = 0U;
    out[i][278U] = 0U;
    out[i][279U] = 0U;
    out[i][280U] = 0U;
    out[i][281U] = 0U;
    out[i][282U] = 0U;
    out[i][283U] = 0U;
    out[i][284U] = 0U;
    out[i][285U] = 0U;
    out[i][286U] = 0U;
    out[i][287U] = 0U;
    out[i][288U] = 0U;
    out[i][289U] = 0U;
    out[i][290U] = 0U;
    out[i][291U] = 0U;
    out[i][292U] = 0U;
    out[i][293U] = 0U;
    out[i][294U] = 0U;
    out[i][295U] = 0U;
    out[i][296U] = 0U;
    out[i][297U] = 0U;
    out[i][298U] = 0U;
    out[i][299U] = 0U;
    out[i][300U] = 0U;
    out[i][301U] = 0U;
    out[i][302U] = 0U;
    out[i][303U] = 0U;
    out[i][304U] = 0U;
    out[i][305U] = 0U;
    out[i][306U] = 0U;
    out[i][307U] = 0U;
    out[i][308U] = 0U;
    out[i][309U] = 0U;
    out[i][310U] = 0U;
    out[i][311U] = 0U;
    out[i][312U] = 0U;
    out[i][313U] = 0U;
    out[i][314U] = 0U;
    out[i][315U] = 0U;
    out[i][316U] = 0U;
    out[i][317U] = 0U;
    out[i][318U] = 0U;
    out[i][319U] = 0U;
    out[i][320U] = 0U;
    out[i][321U] = 0U;
    out[i][322U] = 0U;
    out[i][323U] = 0U;
    out[i][324U] = 0U;
    out[i][325U] = 0U;
    out[i][326U] = 0U;
    out[i][327U] = 0U;
    out[i][328U] = 0U;
    out[i][329U] = 0U;
    out[i][330U] = 0U;
    out[i][331U] = 0U;
    out[i][332U] = 0U;
    out[i][333U] = 0U;
    out[i][334U] = 0U;
    out[i][335U] = 0U;
    out[i][336U] = 0U;
    out[i][337U] = 0U;
    out[i][338U] = 0U;
    out[i][339U] = 0U;
    out[i][340U] = 0U;
    out[i][341U] = 0U;
    out[i][342U] = 0U;
    out[i][343U] = 0U;
    out[i][344U] = 0U;
    out[i][345U] = 0U;
    out[i][346U] = 0U;
    out[i][347U] = 0U;
    out[i][348U] = 0U;
    out[i][349U] = 0U;
    out[i][350U] = 0U;
    out[i][351U] = 0U;
    out[i][352U] = 0U;
    out[i][353U] = 0U;
    out[i][354U] = 0U;
    out[i][355U] = 0U;
    out[i][356U] = 0U;
    out[i][357U] = 0U;
    out[i][358U] = 0U;
    out[i][359U] = 0U;
    out[i][360U] = 0U;
    out[i][361U] = 0U;
    out[i][362U] = 0U;
    out[i][363U] = 0U;
    out[i][364U] = 0U;
    out[i][365U] = 0U;
    out[i][366U] = 0U;
    out[i][367U] = 0U;
    out[i][368U] = 0U;
    out[i][369U] = 0U;
    out[i][370U] = 0U;
    out[i][371U] = 0U;
    out[i][372U] = 0U;
    out[i][373U] = 0U;
    out[i][374U] = 0U;
    out[i][375U] = 0U;
    out[i][376U] = 0U;
    out[i][377U] = 0U;
    out[i][378U] = 0U;
    out[i][379U] = 0U;
    out[i][380U] = 0U;
    out[i][381U] = 0U;
    out[i][382U] = 0U;
    out[i][383U] = 0U;
    out[i][384U] = 0U;
    out[i][385U] = 0U;
    out[i][386U] = 0U;
    out[i][387U] = 0U;
    out[i][388U] = 0U;
    out[i][389U] = 0U;
    out[i][390U] = 0U;
    out[i][391U] = 0U;
    out[i][392U] = 0U;
    out[i][393U] = 0U;
    out[i][394U] = 0U;
    out[i][395U] = 0U;
    out[i][396U] = 0U;
    out[i][397U] = 0U;
    out[i][398U] = 0U;
    out[i][399U] = 0U;
    out[i][400U] = 0U;
    out[i][401U] = 0U;
    out[i][402U] = 0U;
    out[i][403U] = 0U;
    out[i][404U] = 0U;
    out[i][405U] = 0U;
    out[i][406U] = 0U;
    out[i][407U] = 0U;
    out[i][408U] = 0U;
    out[i][409U] = 0U;
    out[i][410U] = 0U;
    out[i][411U] = 0U;
    out[i][412U] = 0U;
    out[i][413U] = 0U;
    out[i][414U] = 0U;
    out[i][415U] = 0U;
    out[i][416U] = 0U;
    out[i][417U] = 0U;
    out[i][418U] = 0U;
    out[i][419U] = 0U;
    out[i][420U] = 0U;
    out[i][421U] = 0U;
    out[i][422U] = 0U;
    out[i][423U] = 0U;
    out[i][424U] = 0U;
    out[i][425U] = 0U;
    out[i][426U] = 0U;
    out[i][427U] = 0U;
    out[i][428U] = 0U;
    out[i][429U] = 0U;
    out[i][430U] = 0U;
    out[i][431U] = 0U;
    out[i][432U] = 0U;
    out[i][433U] = 0U;
    out[i][434U] = 0U;
    out[i][435U] = 0U;
    out[i][436U] = 0U;
    out[i][437U] = 0U;
    out[i][438U] = 0U;
    out[i][439U] = 0U;
    out[i][440U] = 0U;
    out[i][441U] = 0U;
    out[i][442U] = 0U;
    out[i][443U] = 0U;
    out[i][444U] = 0U;
    out[i][445U] = 0U;
    out[i][446U] = 0U;
    out[i][447U] = 0U;
    out[i][448U] = 0U;
    out[i][449U] = 0U;
    out[i][450U] = 0U;
    out[i][451U] = 0U;
    out[i][452U] = 0U;
    out[i][453U] = 0U;
    out[i][454U] = 0U;
    out[i][455U] = 0U;
    out[i][456U] = 0U;
    out[i][457U] = 0U;
    out[i][458U] = 0U;
    out[i][459U] = 0U;
    out[i][460U] = 0U;
    out[i][461U] = 0U;
    out[i][462U] = 0U;
    out[i][463U] = 0U;
    out[i][464U] = 0U;
    out[i][465U] = 0U;
    out[i][466U] = 0U;
    out[i][467U] = 0U;
    out[i][468U] = 0U;
    out[i][469U] = 0U;
    out[i][470U] = 0U;
    out[i][471U] = 0U;
    out[i][472U] = 0U;
    out[i][473U] = 0U;
    out[i][474U] = 0U;
    out[i][475U] = 0U;
    out[i][476U] = 0U;
    out[i][477U] = 0U;
    out[i][478U] = 0U;
    out[i][479U] = 0U;
    out[i][480U] = 0U;
    out[i][481U] = 0U;
    out[i][482U] = 0U;
    out[i][483U] = 0U;
    out[i][484U] = 0U;
    out[i][485U] = 0U;
    out[i][486U] = 0U;
    out[i][487U] = 0U;
    out[i][488U] = 0U;
    out[i][489U] = 0U;
    out[i][490U] = 0U;
    out[i][491U] = 0U;
    out[i][492U] = 0U;
    out[i][493U] = 0U;
    out[i][494U] = 0U;
    out[i][495U] = 0U;
    out[i][496U] = 0U;
    out[i][497U] = 0U;
    out[i][498U] = 0U;
    out[i][499U] = 0U;
    out[i][500U] = 0U;
    out[i][501U] = 0U;
    out[i][502U] = 0U;
    out[i][503U] = 0U;
    out[i][504U] = 0U;
    out[i][505U] = 0U;
    out[i][506U] = 0U;
    out[i][507U] = 0U;
    out[i][508U] = 0U;
    out[i][509U] = 0U;
    out[i][510U] = 0U;
    out[i][511U] = 0U;
    out[i][512U] = 0U;
    out[i][513U] = 0U;
    out[i][514U] = 0U;
    out[i][515U] = 0U;
    out[i][516U] = 0U;
    out[i][517U] = 0U;
    out[i][518U] = 0U;
    out[i][519U] = 0U;
    out[i][520U] = 0U;
    out[i][521U] = 0U;
    out[i][522U] = 0U;
    out[i][523U] = 0U;
    out[i][524U] = 0U;
    out[i][525U] = 0U;
    out[i][526U] = 0U;
    out[i][527U] = 0U;
    out[i][528U] = 0U;
    out[i][529U] = 0U;
    out[i][530U] = 0U;
    out[i][531U] = 0U;
    out[i][532U] = 0U;
    out[i][533U] = 0U;
    out[i][534U] = 0U;
    out[i][535U] = 0U;
    out[i][536U] = 0U;
    out[i][537U] = 0U;
    out[i][538U] = 0U;
    out[i][539U] = 0U;
    out[i][540U] = 0U;
    out[i][541U] = 0U;
    out[i][542U] = 0U;
    out[i][543U] = 0U;
    out[i][544U] = 0U;
    out[i][545U] = 0U;
    out[i][546U] = 0U;
    out[i][547U] = 0U;
    out[i][548U] = 0U;
    out[i][549U] = 0U;
    out[i][550U] = 0U;
    out[i][551U] = 0U;
    out[i][552U] = 0U;
    out[i][553U] = 0U;
    out[i][554U] = 0U;
    out[i][555U] = 0U;
    out[i][556U] = 0U;
    out[i][557U] = 0U;
    out[i][558U] = 0U;
    out[i][559U] = 0U;
    out[i][560U] = 0U;
    out[i][561U] = 0U;
    out[i][562U] = 0U;
    out[i][563U] = 0U;
    out[i][564U] = 0U;
    out[i][565U] = 0U;
    out[i][566U] = 0U;
    out[i][567U] = 0U;
    out[i][568U] = 0U;
    out[i][569U] = 0U;
    out[i][570U] = 0U;
    out[i][571U] = 0U;
    out[i][572U] = 0U;
    out[i][573U] = 0U;
    out[i][574U] = 0U;
    out[i][575U] = 0U;
    out[i][576U] = 0U;
    out[i][577U] = 0U;
    out[i][578U] = 0U;
    out[i][579U] = 0U;
    out[i][580U] = 0U;
    out[i][581U] = 0U;
    out[i][582U] = 0U;
    out[i][583U] = 0U;
    out[i][584U] = 0U;
    out[i][585U] = 0U;
    out[i][586U] = 0U;
    out[i][587U] = 0U;
    out[i][588U] = 0U;
    out[i][589U] = 0U;
    out[i][590U] = 0U;
    out[i][591U] = 0U;
    out[i][592U] = 0U;
    out[i][593U] = 0U;
    out[i][594U] = 0U;
    out[i][595U] = 0U;
    out[i][596U] = 0U;
    out[i][597U] = 0U;
    out[i][598U] = 0U;
    out[i][599U] = 0U;
    out[i][600U] = 0U;
    out[i][601U] = 0U;
    out[i][602U] = 0U;
    out[i][603U] = 0U;
    out[i][604U] = 0U;
    out[i][605U] = 0U;
    out[i][606U] = 0U;
    out[i][607U] = 0U;
    out[i][608U] = 0U;
    out[i][609U] = 0U;
    out[i][610U] = 0U;
    out[i][611U] = 0U;
    out[i][612U] = 0U;
    out[i][613U] = 0U;
    out[i][614U] = 0U;
    out[i][615U] = 0U;
    out[i][616U] = 0U;
    out[i][617U] = 0U;
    out[i][618U] = 0U;
    out[i][619U] = 0U;
    out[i][620U] = 0U;
    out[i][621U] = 0U;
    out[i][622U] = 0U;
    out[i][623U] = 0U;
    out[i][624U] = 0U;
    out[i][625U] = 0U;
    out[i][626U] = 0U;
    out[i][627U] = 0U;
    out[i][628U] = 0U;
    out[i][629U] = 0U;
    out[i][630U] = 0U;
    out[i][631U] = 0U;
    out[i][632U] = 0U;
    out[i][633U] = 0U;
    out[i][634U] = 0U;
    out[i][635U] = 0U;
    out[i][636U] = 0U;
    out[i][637U] = 0U;
    out[i][638U] = 0U;
    out[i][639U] = 0U;
    out[i][640U] = 0U;
    out[i][641U] = 0U;
    out[i][642U] = 0U;
    out[i][643U] = 0U;
    out[i][644U] = 0U;
    out[i][645U] = 0U;
    out[i][646U] = 0U;
    out[i][647U] = 0U;
    out[i][648U] = 0U;
    out[i][649U] = 0U;
    out[i][650U] = 0U;
    out[i][651U] = 0U;
    out[i][652U] = 0U;
    out[i][653U] = 0U;
    out[i][654U] = 0U;
    out[i][655U] = 0U;
    out[i][656U] = 0U;
    out[i][657U] = 0U;
    out[i][658U] = 0U;
    out[i][659U] = 0U;
    out[i][660U] = 0U;
    out[i][661U] = 0U;
    out[i][662U] = 0U;
    out[i][663U] = 0U;
    out[i][664U] = 0U;
    out[i][665U] = 0U;
    out[i][666U] = 0U;
    out[i][667U] = 0U;
    out[i][668U] = 0U;
    out[i][669U] = 0U;
    out[i][670U] = 0U;
    out[i][671U] = 0U;
    out[i][672U] = 0U;
    out[i][673U] = 0U;
    out[i][674U] = 0U;
    out[i][675U] = 0U;
    out[i][676U] = 0U;
    out[i][677U] = 0U;
    out[i][678U] = 0U;
    out[i][679U] = 0U;
    out[i][680U] = 0U;
    out[i][681U] = 0U;
    out[i][682U] = 0U;
    out[i][683U] = 0U;
    out[i][684U] = 0U;
    out[i][685U] = 0U;
    out[i][686U] = 0U;
    out[i][687U] = 0U;
    out[i][688U] = 0U;
    out[i][689U] = 0U;
    out[i][690U] = 0U;
    out[i][691U] = 0U;
    out[i][692U] = 0U;
    out[i][693U] = 0U;
    out[i][694U] = 0U;
    out[i][695U] = 0U;
    out[i][696U] = 0U;
    out[i][697U] = 0U;
    out[i][698U] = 0U;
    out[i][699U] = 0U;
    out[i][700U] = 0U;
    out[i][701U] = 0U;
    out[i][702U] = 0U;
    out[i][703U] = 0U;
    out[i][704U] = 0U;
    out[i][705U] = 0U;
    out[i][706U] = 0U;
    out[i][707U] = 0U;
    out[i][708U] = 0U;
    out[i][709U] = 0U;
    out[i][710U] = 0U;
    out[i][711U] = 0U;
    out[i][712U] = 0U;
    out[i][713U] = 0U;
    out[i][714U] = 0U;
    out[i][715U] = 0U;
    out[i][716U] = 0U;
    out[i][717U] = 0U;
    out[i][718U] = 0U;
    out[i][719U] = 0U;
    out[i][720U] = 0U;
    out[i][721U] = 0U;
    out[i][722U] = 0U;
    out[i][723U] = 0U;
    out[i][724U] = 0U;
    out[i][725U] = 0U;
    out[i][726U] = 0U;
    out[i][727U] = 0U;
    out[i][728U] = 0U;
    out[i][729U] = 0U;
    out[i][730U] = 0U;
    out[i][731U] = 0U;
    out[i][732U] = 0U;
    out[i][733U] = 0U;
    out[i][734U] = 0U;
    out[i][735U] = 0U;
    out[i][736U] = 0U;
    out[i][737U] = 0U;
    out[i][738U] = 0U;
    out[i][739U] = 0U;
    out[i][740U] = 0U;
    out[i][741U] = 0U;
    out[i][742U] = 0U;
    out[i][743U] = 0U;
    out[i][744U] = 0U;
    out[i][745U] = 0U;
    out[i][746U] = 0U;
    out[i][747U] = 0U;
    out[i][748U] = 0U;
    out[i][749U] = 0U;
    out[i][750U] = 0U;
    out[i][751U] = 0U;
    out[i][752U] = 0U;
    out[i][753U] = 0U;
    out[i][754U] = 0U;
    out[i][755U] = 0U;
    out[i][756U] = 0U;
    out[i][757U] = 0U;
    out[i][758U] = 0U;
    out[i][759U] = 0U;
    out[i][760U] = 0U;
    out[i][761U] = 0U;
    out[i][762U] = 0U;
    out[i][763U] = 0U;
    out[i][764U] = 0U;
    out[i][765U] = 0U;
    out[i][766U] = 0U;
    out[i][767U] = 0U;
    out[i][768U] = 0U;
    out[i][769U] = 0U;
    out[i][770U] = 0U;
    out[i][771U] = 0U;
    out[i][772U] = 0U;
    out[i][773U] = 0U;
    out[i][774U] = 0U;
    out[i][775U] = 0U;
    out[i][776U] = 0U;
    out[i][777U] = 0U;
    out[i][778U] = 0U;
    out[i][779U] = 0U;
    out[i][780U] = 0U;
    out[i][781U] = 0U;
    out[i][782U] = 0U;
    out[i][783U] = 0U;
    out[i][784U] = 0U;
    out[i][785U] = 0U;
    out[i][786U] = 0U;
    out[i][787U] = 0U;
    out[i][788U] = 0U;
    out[i][789U] = 0U;
    out[i][790U] = 0U;
    out[i][791U] = 0U;
    out[i][792U] = 0U;
    out[i][793U] = 0U;
    out[i][794U] = 0U;
    out[i][795U] = 0U;
    out[i][796U] = 0U;
    out[i][797U] = 0U;
    out[i][798U] = 0U;
    out[i][799U] = 0U;
    out[i][800U] = 0U;
    out[i][801U] = 0U;
    out[i][802U] = 0U;
    out[i][803U] = 0U;
    out[i][804U] = 0U;
    out[i][805U] = 0U;
    out[i][806U] = 0U;
    out[i][807U] = 0U;
    out[i][808U] = 0U;
    out[i][809U] = 0U;
    out[i][810U] = 0U;
    out[i][811U] = 0U;
    out[i][812U] = 0U;
    out[i][813U] = 0U;
    out[i][814U] = 0U;
    out[i][815U] = 0U;
    out[i][816U] = 0U;
    out[i][817U] = 0U;
    out[i][818U] = 0U;
    out[i][819U] = 0U;
    out[i][820U] = 0U;
    out[i][821U] = 0U;
    out[i][822U] = 0U;
    out[i][823U] = 0U;
    out[i][824U] = 0U;
    out[i][825U] = 0U;
    out[i][826U] = 0U;
    out[i][827U] = 0U;
    out[i][828U] = 0U;
    out[i][829U] = 0U;
    out[i][830U] = 0U;
    out[i][831U] = 0U;
    out[i][832U] = 0U;
    out[i][833U] = 0U;
    out[i][834U] = 0U;
    out[i][835U] = 0U;
    out[i][836U] = 0U;
    out[i][837U] = 0U;
    out[i][838U] = 0U;
    out[i][839U] = 0U;
  }
  bool uu____0;
  if (!libcrux_platform_simd256_support())
    uu____0 = true;
  else
    uu____0 = !false;
  if (uu____0)
  {
    core_ops_range_Range__size_t lit;
    lit.start = (size_t)0U;
    lit.end = (size_t)4U;
    core_ops_range_Range__size_t
    iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
    while (true)
    {
      core_option_Option__size_t
      uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
      if (!(uu____1.tag == core_option_None))
      {
        if (uu____1.tag == core_option_Some)
        {
          size_t i = uu____1.f0;
          uint8_t uu____2[840U];
          libcrux_digest_shake128((size_t)840U,
            Eurydice_array_to_slice((size_t)34U, input[i], uint8_t),
            uu____2);
          memcpy(out[i], uu____2, (size_t)840U * sizeof (uint8_t));
        }
        else
        {
          KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
          KRML_HOST_EXIT(255U);
        }
      }
    }
  }
  else
  {
    Eurydice_slice uu____3 = Eurydice_array_to_slice((size_t)34U, input[0U], uint8_t);
    Eurydice_slice uu____4 = Eurydice_array_to_slice((size_t)34U, input[1U], uint8_t);
    Eurydice_slice uu____5 = Eurydice_array_to_slice((size_t)34U, input[2U], uint8_t);
    __uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t_
    uu____6 =
      libcrux_digest_shake128x4((size_t)840U,
        uu____3,
        uu____4,
        uu____5,
        Eurydice_array_to_slice((size_t)34U, input[3U], uint8_t));
    uint8_t d0[840U];
    memcpy(d0, uu____6.fst, (size_t)840U * sizeof (uint8_t));
    uint8_t d1[840U];
    memcpy(d1, uu____6.snd, (size_t)840U * sizeof (uint8_t));
    uint8_t d2[840U];
    memcpy(d2, uu____6.thd, (size_t)840U * sizeof (uint8_t));
    uint8_t d3[840U];
    memcpy(d3, uu____6.f3, (size_t)840U * sizeof (uint8_t));
    uint8_t uu____7[840U];
    memcpy(uu____7, d0, (size_t)840U * sizeof (uint8_t));
    memcpy(out[0U], uu____7, (size_t)840U * sizeof (uint8_t));
    uint8_t uu____8[840U];
    memcpy(uu____8, d1, (size_t)840U * sizeof (uint8_t));
    memcpy(out[1U], uu____8, (size_t)840U * sizeof (uint8_t));
    uint8_t uu____9[840U];
    memcpy(uu____9, d2, (size_t)840U * sizeof (uint8_t));
    memcpy(out[2U], uu____9, (size_t)840U * sizeof (uint8_t));
    uint8_t uu____10[840U];
    memcpy(uu____10, d3, (size_t)840U * sizeof (uint8_t));
    memcpy(out[3U], uu____10, (size_t)840U * sizeof (uint8_t));
  }
  uint8_t uu____11[4U][840U];
  memcpy(uu____11, out, (size_t)4U * sizeof (uint8_t [840U]));
  memcpy(ret, uu____11, (size_t)4U * sizeof (uint8_t [840U]));
}

K___libcrux_kyber_arithmetic_PolynomialRingElement_core_option_Option_libcrux_kyber_types_Error
libcrux_kyber_sampling_sample_from_uniform_distribution___840size_t(uint8_t randomness[840U])
{
  size_t sampled_coefficients = (size_t)0U;
  int32_t out[256U];
  memcpy(out,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  bool done = false;
  core_slice_iter_Chunks
  iter =
    core_iter_traits_collect__I__into_iter(core_slice___Slice_T___chunks(Eurydice_array_to_slice((size_t)840U,
          randomness,
          uint8_t),
        (size_t)3U,
        uint8_t),
      core_slice_iter_Chunks);
  while (true)
  {
    core_option_Option__Eurydice_slice_uint8_t
    uu____0 = core_slice_iter__core__slice__iter__Chunks__a__T__70__next(&iter, uint8_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        Eurydice_slice bytes = uu____0.f0;
        if (!done)
        {
          int32_t b1 = (int32_t)Eurydice_slice_index(bytes, (size_t)0U, uint8_t);
          int32_t b2 = (int32_t)Eurydice_slice_index(bytes, (size_t)1U, uint8_t);
          int32_t b3 = (int32_t)Eurydice_slice_index(bytes, (size_t)2U, uint8_t);
          int32_t d1 = (b2 & (int32_t)15) << 8U | b1;
          int32_t d2 = b3 << 4U | b2 >> 4U;
          bool uu____1;
          int32_t uu____2;
          size_t uu____3;
          bool uu____4;
          bool uu____5;
          int32_t uu____6;
          bool uu____7;
          size_t uu____8;
          int32_t uu____9;
          size_t uu____10;
          bool uu____11;
          size_t uu____12;
          int32_t uu____13;
          size_t uu____14;
          size_t uu____15;
          if (d1 < libcrux_kyber_constants_FIELD_MODULUS)
          {
            uu____1 = sampled_coefficients < libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
            if (uu____1)
            {
              uu____2 = d1;
              uu____3 = sampled_coefficients;
              out[uu____3] = uu____2;
              sampled_coefficients++;
              uu____6 = d2;
              uu____13 = libcrux_kyber_constants_FIELD_MODULUS;
              uu____5 = uu____6 < uu____13;
              if (uu____5)
              {
                uu____8 = sampled_coefficients;
                uu____14 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                uu____7 = uu____8 < uu____14;
                uu____4 = uu____7;
                if (uu____4)
                {
                  uu____9 = d2;
                  uu____10 = sampled_coefficients;
                  out[uu____10] = uu____9;
                  sampled_coefficients++;
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
                else
                {
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
              }
              else
              {
                uu____4 = false;
                if (uu____4)
                {
                  uu____9 = d2;
                  uu____10 = sampled_coefficients;
                  out[uu____10] = uu____9;
                  sampled_coefficients++;
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
                else
                {
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
              }
            }
            else
            {
              uu____6 = d2;
              uu____13 = libcrux_kyber_constants_FIELD_MODULUS;
              uu____5 = uu____6 < uu____13;
              if (uu____5)
              {
                uu____8 = sampled_coefficients;
                uu____14 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                uu____7 = uu____8 < uu____14;
                uu____4 = uu____7;
                if (uu____4)
                {
                  uu____9 = d2;
                  uu____10 = sampled_coefficients;
                  out[uu____10] = uu____9;
                  sampled_coefficients++;
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
                else
                {
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
              }
              else
              {
                uu____4 = false;
                if (uu____4)
                {
                  uu____9 = d2;
                  uu____10 = sampled_coefficients;
                  out[uu____10] = uu____9;
                  sampled_coefficients++;
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
                else
                {
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
              }
            }
          }
          else
          {
            uu____1 = false;
            if (uu____1)
            {
              uu____2 = d1;
              uu____3 = sampled_coefficients;
              out[uu____3] = uu____2;
              sampled_coefficients++;
              uu____6 = d2;
              uu____13 = libcrux_kyber_constants_FIELD_MODULUS;
              uu____5 = uu____6 < uu____13;
              if (uu____5)
              {
                uu____8 = sampled_coefficients;
                uu____14 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                uu____7 = uu____8 < uu____14;
                uu____4 = uu____7;
                if (uu____4)
                {
                  uu____9 = d2;
                  uu____10 = sampled_coefficients;
                  out[uu____10] = uu____9;
                  sampled_coefficients++;
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
                else
                {
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
              }
              else
              {
                uu____4 = false;
                if (uu____4)
                {
                  uu____9 = d2;
                  uu____10 = sampled_coefficients;
                  out[uu____10] = uu____9;
                  sampled_coefficients++;
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
                else
                {
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
              }
            }
            else
            {
              uu____6 = d2;
              uu____13 = libcrux_kyber_constants_FIELD_MODULUS;
              uu____5 = uu____6 < uu____13;
              if (uu____5)
              {
                uu____8 = sampled_coefficients;
                uu____14 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                uu____7 = uu____8 < uu____14;
                uu____4 = uu____7;
                if (uu____4)
                {
                  uu____9 = d2;
                  uu____10 = sampled_coefficients;
                  out[uu____10] = uu____9;
                  sampled_coefficients++;
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
                else
                {
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
              }
              else
              {
                uu____4 = false;
                if (uu____4)
                {
                  uu____9 = d2;
                  uu____10 = sampled_coefficients;
                  out[uu____10] = uu____9;
                  sampled_coefficients++;
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
                else
                {
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
              }
            }
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    K___libcrux_kyber_arithmetic_PolynomialRingElement_core_option_Option_libcrux_kyber_types_Error
    uu____16;
    if (done)
    {
      K___libcrux_kyber_arithmetic_PolynomialRingElement_core_option_Option_libcrux_kyber_types_Error
      lit;
      memcpy(lit.fst, out, (size_t)256U * sizeof (int32_t));
      lit.snd.tag = core_option_None;
      uu____16 = lit;
    }
    else
    {
      K___libcrux_kyber_arithmetic_PolynomialRingElement_core_option_Option_libcrux_kyber_types_Error
      lit;
      memcpy(lit.fst, out, (size_t)256U * sizeof (int32_t));
      lit.snd.tag = core_option_Some;
      lit.snd.f0 = libcrux_kyber_types_RejectionSampling;
      uu____16 = lit;
    }
    return uu____16;
  }
}

K___libcrux_kyber_arithmetic_PolynomialRingElement_4size_t__4size_t__core_option_Option__libcrux_kyber_types_Error
libcrux_kyber_matrix_sample_matrix_A___4size_t(uint8_t seed[34U], bool transpose)
{
  int32_t A_transpose[4U][4U][256U];
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
    memcpy(A_transpose[i][0U],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  core_option_Option__libcrux_kyber_types_Error sampling_A_error;
  sampling_A_error.tag = core_option_None;
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = (size_t)4U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i0 = uu____0.f0;
        uint8_t uu____1[34U];
        memcpy(uu____1, seed, (size_t)34U * sizeof (uint8_t));
        uint8_t seeds[4U][34U];
        for (size_t i = (size_t)0U; i < (size_t)4U; i++)
          memcpy(seeds[i], uu____1, (size_t)34U * sizeof (uint8_t));
        core_ops_range_Range__size_t lit0;
        lit0.start = (size_t)0U;
        lit0.end = (size_t)4U;
        core_ops_range_Range__size_t
        iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____2 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
          if (uu____2.tag == core_option_None)
            break;
          else if (uu____2.tag == core_option_Some)
          {
            size_t j = uu____2.f0;
            seeds[j][32U] = (uint8_t)i0;
            seeds[j][33U] = (uint8_t)j;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        uint8_t uu____3[4U][34U];
        memcpy(uu____3, seeds, (size_t)4U * sizeof (uint8_t [34U]));
        uint8_t xof_bytes[4U][840U];
        libcrux_kyber_hash_functions_XOFx4___4size_t(uu____3, xof_bytes);
        core_ops_range_Range__size_t lit;
        lit.start = (size_t)0U;
        lit.end = (size_t)4U;
        core_ops_range_Range__size_t
        iter0 = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____4 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
          if (uu____4.tag == core_option_None)
            break;
          else if (uu____4.tag == core_option_Some)
          {
            size_t j = uu____4.f0;
            uint8_t uu____5[840U];
            memcpy(uu____5, xof_bytes[j], (size_t)840U * sizeof (uint8_t));
            K___libcrux_kyber_arithmetic_PolynomialRingElement_core_option_Option_libcrux_kyber_types_Error
            uu____6 = libcrux_kyber_sampling_sample_from_uniform_distribution___840size_t(uu____5);
            int32_t sampled[256U];
            memcpy(sampled, uu____6.fst, (size_t)256U * sizeof (int32_t));
            core_option_Option__libcrux_kyber_types_Error error = uu____6.snd;
            if (core_option__core__option__Option_T___is_some(&error, libcrux_kyber_types_Error))
              sampling_A_error = error;
            if (transpose)
              memcpy(A_transpose[j][i0], sampled, (size_t)256U * sizeof (int32_t));
            else
              memcpy(A_transpose[i0][j], sampled, (size_t)256U * sizeof (int32_t));
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____7[4U][4U][256U];
    memcpy(uu____7, A_transpose, (size_t)4U * sizeof (int32_t [4U][256U]));
    K___libcrux_kyber_arithmetic_PolynomialRingElement_4size_t__4size_t__core_option_Option__libcrux_kyber_types_Error
    lit;
    memcpy(lit.fst, uu____7, (size_t)4U * sizeof (int32_t [4U][256U]));
    lit.snd = sampling_A_error;
    return lit;
  }
}

void libcrux_kyber_ind_cpa_into_padded_array___34size_t(Eurydice_slice slice, uint8_t ret[34U])
{
  if (false)
    LowStar_Ignore_ignore(core_slice___Slice_T___len(slice, uint8_t), size_t);
  uint8_t out[34U];
  for (size_t i = (size_t)0U; i < (size_t)34U; i++)
    out[i] = 0U;
  uint8_t *uu____0 = out;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(slice, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)34U,
      uu____0,
      lit,
      uint8_t,
      core_ops_range_Range__size_t),
    slice,
    uint8_t);
  uint8_t uu____1[34U];
  memcpy(uu____1, out, (size_t)34U * sizeof (uint8_t));
  memcpy(ret, uu____1, (size_t)34U * sizeof (uint8_t));
}

void libcrux_kyber_ind_cpa_into_padded_array___33size_t(Eurydice_slice slice, uint8_t ret[33U])
{
  if (false)
    LowStar_Ignore_ignore(core_slice___Slice_T___len(slice, uint8_t), size_t);
  uint8_t out[33U];
  for (size_t i = (size_t)0U; i < (size_t)33U; i++)
    out[i] = 0U;
  uint8_t *uu____0 = out;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(slice, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)33U,
      uu____0,
      lit,
      uint8_t,
      core_ops_range_Range__size_t),
    slice,
    uint8_t);
  uint8_t uu____1[33U];
  memcpy(uu____1, out, (size_t)33U * sizeof (uint8_t));
  memcpy(ret, uu____1, (size_t)33U * sizeof (uint8_t));
}

void libcrux_kyber_hash_functions_PRF___128size_t(Eurydice_slice input, uint8_t ret[128U])
{
  uint8_t ret0[128U];
  libcrux_digest_shake256((size_t)128U, input, ret0);
  memcpy(ret, ret0, (size_t)128U * sizeof (uint8_t));
}

void
libcrux_kyber_sampling_sample_from_binomial_distribution___2size_t(
  Eurydice_slice randomness,
  int32_t ret[256U]
)
{
  int32_t uu____0[256U];
  libcrux_kyber_sampling_sample_from_binomial_distribution_2(randomness, uu____0);
  memcpy(ret, uu____0, (size_t)256U * sizeof (int32_t));
}

K___libcrux_kyber_arithmetic_PolynomialRingElement_4size_t__uint8_t
libcrux_kyber_ind_cpa_sample_vector_cbd_then_ntt___4size_t_2size_t_128size_t(
  uint8_t prf_input[33U],
  uint8_t domain_separator
)
{
  int32_t re_as_ntt[4U][256U];
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
    memcpy(re_as_ntt[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = (size_t)4U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        prf_input[32U] = domain_separator;
        domain_separator = (uint32_t)domain_separator + 1U;
        uint8_t prf_output[128U];
        libcrux_kyber_hash_functions_PRF___128size_t(Eurydice_array_to_slice((size_t)33U,
            prf_input,
            uint8_t),
          prf_output);
        int32_t r[256U];
        libcrux_kyber_sampling_sample_from_binomial_distribution___2size_t(Eurydice_array_to_slice((size_t)128U,
            prf_output,
            uint8_t),
          r);
        int32_t uu____1[256U];
        libcrux_kyber_ntt_ntt_binomially_sampled_ring_element(r, uu____1);
        memcpy(re_as_ntt[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[4U][256U];
    memcpy(uu____2, re_as_ntt, (size_t)4U * sizeof (int32_t [256U]));
    K___libcrux_kyber_arithmetic_PolynomialRingElement_4size_t__uint8_t lit;
    memcpy(lit.fst, uu____2, (size_t)4U * sizeof (int32_t [256U]));
    lit.snd = domain_separator;
    return lit;
  }
}

void
libcrux_kyber_arithmetic_add_to_ring_element___4size_t(
  int32_t lhs[256U],
  int32_t (*rhs)[256U],
  int32_t ret[256U]
)
{
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, lhs, int32_t),
      int32_t);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        size_t uu____1 = i;
        lhs[uu____1] = lhs[uu____1] + rhs[0U][i];
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, lhs, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_matrix_compute_As_plus_e___4size_t(
  int32_t (*matrix_A)[4U][256U],
  int32_t (*s_as_ntt)[256U],
  int32_t (*error_as_ntt)[256U],
  int32_t ret[4U][256U]
)
{
  int32_t result[4U][256U];
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
    memcpy(result[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)4U,
        matrix_A,
        Eurydice_error_t_cg_array),
      int32_t [4U][256U]);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        core_ops_range_Range__size_t lit;
        lit.start = (size_t)0U;
        lit.end =
          core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)4U,
              matrix_A[i],
              int32_t [256U]),
            int32_t [256U]);
        core_ops_range_Range__size_t
        iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
          if (uu____1.tag == core_option_None)
            break;
          else if (uu____1.tag == core_option_Some)
          {
            size_t j = uu____1.f0;
            int32_t product[256U];
            libcrux_kyber_ntt_ntt_multiply(&matrix_A[i][j], &s_as_ntt[j], product);
            int32_t uu____2[256U];
            libcrux_kyber_arithmetic_add_to_ring_element___4size_t(result[i], &product, uu____2);
            memcpy(result[i], uu____2, (size_t)256U * sizeof (int32_t));
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        core_ops_range_Range__size_t lit0;
        lit0.start = (size_t)0U;
        lit0.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
        core_ops_range_Range__size_t
        iter0 = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____3 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
          if (uu____3.tag == core_option_None)
            break;
          else if (uu____3.tag == core_option_Some)
          {
            size_t j = uu____3.f0;
            int32_t
            coefficient_normal_form = libcrux_kyber_arithmetic_to_standard_domain(result[i][j]);
            int32_t
            uu____4 =
              libcrux_kyber_arithmetic_barrett_reduce(coefficient_normal_form + error_as_ntt[i][j]);
            result[i][j] = uu____4;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____5[4U][256U];
    memcpy(uu____5, result, (size_t)4U * sizeof (int32_t [256U]));
    memcpy(ret, uu____5, (size_t)4U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_ind_cpa_serialize_secret_key___4size_t_1536size_t(
  int32_t key[4U][256U],
  uint8_t ret[1536U]
)
{
  uint8_t out[1536U];
  for (size_t i = (size_t)0U; i < (size_t)1536U; i++)
    out[i] = 0U;
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)4U, key, int32_t [256U]),
      int32_t [256U]);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t re[256U];
        memcpy(re, key[i], (size_t)256U * sizeof (int32_t));
        core_ops_range_Range__size_t lit;
        lit.start = i * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        lit.end = (i + (size_t)1U) * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        Eurydice_slice
        uu____1 =
          Eurydice_array_to_subslice((size_t)1536U,
            out,
            lit,
            uint8_t,
            core_ops_range_Range__size_t);
        uint8_t ret[384U];
        libcrux_kyber_serialize_serialize_uncompressed_ring_element(re, ret);
        core_slice___Slice_T___copy_from_slice(uu____1,
          Eurydice_array_to_slice((size_t)384U, ret, uint8_t),
          uint8_t);
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____2[1536U];
    memcpy(uu____2, out, (size_t)1536U * sizeof (uint8_t));
    memcpy(ret, uu____2, (size_t)1536U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_ind_cpa_serialize_public_key___4size_t_1536size_t_1568size_t(
  int32_t t_as_ntt[4U][256U],
  Eurydice_slice seed_for_a,
  uint8_t ret[1568U]
)
{
  uint8_t public_key_serialized[1568U];
  for (size_t i = (size_t)0U; i < (size_t)1568U; i++)
    public_key_serialized[i] = 0U;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)1536U;
  Eurydice_slice
  uu____0 =
    Eurydice_array_to_subslice((size_t)1568U,
      public_key_serialized,
      lit,
      uint8_t,
      core_ops_range_Range__size_t);
  int32_t uu____1[4U][256U];
  memcpy(uu____1, t_as_ntt, (size_t)4U * sizeof (int32_t [256U]));
  uint8_t ret0[1536U];
  libcrux_kyber_ind_cpa_serialize_secret_key___4size_t_1536size_t(uu____1, ret0);
  core_slice___Slice_T___copy_from_slice(uu____0,
    Eurydice_array_to_slice((size_t)1536U, ret0, uint8_t),
    uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice_from((size_t)1568U,
      public_key_serialized,
      (size_t)1536U,
      uint8_t,
      size_t),
    seed_for_a,
    uint8_t);
  uint8_t uu____2[1568U];
  memcpy(uu____2, public_key_serialized, (size_t)1568U * sizeof (uint8_t));
  memcpy(ret, uu____2, (size_t)1568U * sizeof (uint8_t));
}

K___uint8_t_1536size_t____uint8_t_1568size_t__core_option_Option__libcrux_kyber_types_Error
libcrux_kyber_ind_cpa_generate_keypair___4size_t_1536size_t_1568size_t_1536size_t_2size_t_128size_t(
  Eurydice_slice key_generation_seed
)
{
  uint8_t hashed[64U];
  libcrux_kyber_hash_functions_G(key_generation_seed, hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____0 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U, hashed, uint8_t),
      (size_t)32U,
      uint8_t);
  Eurydice_slice seed_for_A = uu____0.fst;
  Eurydice_slice seed_for_secret_and_error = uu____0.snd;
  uint8_t ret[34U];
  libcrux_kyber_ind_cpa_into_padded_array___34size_t(seed_for_A, ret);
  K___libcrux_kyber_arithmetic_PolynomialRingElement_4size_t__4size_t__core_option_Option__libcrux_kyber_types_Error
  uu____1 = libcrux_kyber_matrix_sample_matrix_A___4size_t(ret, true);
  int32_t A_transpose[4U][4U][256U];
  memcpy(A_transpose, uu____1.fst, (size_t)4U * sizeof (int32_t [4U][256U]));
  core_option_Option__libcrux_kyber_types_Error sampling_A_error = uu____1.snd;
  uint8_t prf_input[33U];
  libcrux_kyber_ind_cpa_into_padded_array___33size_t(seed_for_secret_and_error, prf_input);
  uint8_t uu____2[33U];
  memcpy(uu____2, prf_input, (size_t)33U * sizeof (uint8_t));
  K___libcrux_kyber_arithmetic_PolynomialRingElement_4size_t__uint8_t
  uu____3 =
    libcrux_kyber_ind_cpa_sample_vector_cbd_then_ntt___4size_t_2size_t_128size_t(uu____2,
      0U);
  int32_t secret_as_ntt[4U][256U];
  memcpy(secret_as_ntt, uu____3.fst, (size_t)4U * sizeof (int32_t [256U]));
  uint8_t domain_separator = uu____3.snd;
  uint8_t uu____4[33U];
  memcpy(uu____4, prf_input, (size_t)33U * sizeof (uint8_t));
  int32_t error_as_ntt[4U][256U];
  memcpy(error_as_ntt,
    libcrux_kyber_ind_cpa_sample_vector_cbd_then_ntt___4size_t_2size_t_128size_t(uu____4,
      domain_separator).fst,
    (size_t)4U * sizeof (int32_t [256U]));
  int32_t t_as_ntt[4U][256U];
  libcrux_kyber_matrix_compute_As_plus_e___4size_t(A_transpose,
    secret_as_ntt,
    error_as_ntt,
    t_as_ntt);
  int32_t uu____5[4U][256U];
  memcpy(uu____5, t_as_ntt, (size_t)4U * sizeof (int32_t [256U]));
  uint8_t public_key_serialized[1568U];
  libcrux_kyber_ind_cpa_serialize_public_key___4size_t_1536size_t_1568size_t(uu____5,
    seed_for_A,
    public_key_serialized);
  int32_t uu____6[4U][256U];
  memcpy(uu____6, secret_as_ntt, (size_t)4U * sizeof (int32_t [256U]));
  uint8_t secret_key_serialized[1536U];
  libcrux_kyber_ind_cpa_serialize_secret_key___4size_t_1536size_t(uu____6,
    secret_key_serialized);
  uint8_t uu____7[1536U];
  memcpy(uu____7, secret_key_serialized, (size_t)1536U * sizeof (uint8_t));
  uint8_t uu____8[1568U];
  memcpy(uu____8, public_key_serialized, (size_t)1568U * sizeof (uint8_t));
  K___uint8_t_1536size_t____uint8_t_1568size_t__core_option_Option__libcrux_kyber_types_Error
  lit;
  memcpy(lit.fst.fst, uu____7, (size_t)1536U * sizeof (uint8_t));
  memcpy(lit.fst.snd, uu____8, (size_t)1568U * sizeof (uint8_t));
  lit.snd = sampling_A_error;
  return lit;
}

void
libcrux_kyber_serialize_kem_secret_key___3168size_t(
  Eurydice_slice private_key,
  Eurydice_slice public_key,
  Eurydice_slice implicit_rejection_value,
  uint8_t ret[3168U]
)
{
  uint8_t out[3168U];
  for (size_t i = (size_t)0U; i < (size_t)3168U; i++)
    out[i] = 0U;
  size_t pointer = (size_t)0U;
  uint8_t *uu____0 = out;
  size_t uu____1 = pointer;
  core_ops_range_Range__size_t lit0;
  lit0.start = pointer;
  lit0.end = uu____1 + core_slice___Slice_T___len(private_key, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)3168U,
      uu____0,
      lit0,
      uint8_t,
      core_ops_range_Range__size_t),
    private_key,
    uint8_t);
  pointer = pointer + core_slice___Slice_T___len(private_key, uint8_t);
  uint8_t *uu____2 = out;
  size_t uu____3 = pointer;
  core_ops_range_Range__size_t lit1;
  lit1.start = pointer;
  lit1.end = uu____3 + core_slice___Slice_T___len(public_key, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)3168U,
      uu____2,
      lit1,
      uint8_t,
      core_ops_range_Range__size_t),
    public_key,
    uint8_t);
  pointer = pointer + core_slice___Slice_T___len(public_key, uint8_t);
  core_ops_range_Range__size_t lit2;
  lit2.start = pointer;
  lit2.end = pointer + libcrux_kyber_constants_H_DIGEST_SIZE;
  Eurydice_slice
  uu____4 =
    Eurydice_array_to_subslice((size_t)3168U,
      out,
      lit2,
      uint8_t,
      core_ops_range_Range__size_t);
  uint8_t ret0[32U];
  libcrux_kyber_hash_functions_H(public_key, ret0);
  core_slice___Slice_T___copy_from_slice(uu____4,
    Eurydice_array_to_slice((size_t)32U, ret0, uint8_t),
    uint8_t);
  pointer = pointer + libcrux_kyber_constants_H_DIGEST_SIZE;
  uint8_t *uu____5 = out;
  size_t uu____6 = pointer;
  core_ops_range_Range__size_t lit;
  lit.start = pointer;
  lit.end = uu____6 + core_slice___Slice_T___len(implicit_rejection_value, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)3168U,
      uu____5,
      lit,
      uint8_t,
      core_ops_range_Range__size_t),
    implicit_rejection_value,
    uint8_t);
  uint8_t uu____7[3168U];
  memcpy(uu____7, out, (size_t)3168U * sizeof (uint8_t));
  memcpy(ret, uu____7, (size_t)3168U * sizeof (uint8_t));
}

void
libcrux_kyber_types__libcrux_kyber__types__KyberPrivateKey_SIZE__8__from___3168size_t(
  uint8_t value[3168U],
  uint8_t ret[3168U]
)
{
  uint8_t uu____0[3168U];
  memcpy(uu____0, value, (size_t)3168U * sizeof (uint8_t));
  memcpy(ret, uu____0, (size_t)3168U * sizeof (uint8_t));
}

libcrux_kyber_types_KyberKeyPair___3168size_t_1568size_t
libcrux_kyber_types__libcrux_kyber__types__KyberKeyPair_PRIVATE_KEY_SIZE__PUBLIC_KEY_SIZE___from___3168size_t_1568size_t(
  uint8_t sk[3168U],
  uint8_t pk[1568U]
)
{
  libcrux_kyber_types_KyberKeyPair___3168size_t_1568size_t lit;
  memcpy(lit.sk, sk, (size_t)3168U * sizeof (uint8_t));
  memcpy(lit.pk, pk, (size_t)1568U * sizeof (uint8_t));
  return lit;
}

core_result_Result__libcrux_kyber_types_KyberKeyPair__1568size_t____3168size_t___libcrux_kyber_types_Error
libcrux_kyber_generate_keypair___4size_t_1536size_t_3168size_t_1568size_t_1536size_t_2size_t_128size_t(
  uint8_t randomness[64U]
)
{
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = libcrux_kyber_constants_CPA_PKE_KEY_GENERATION_SEED_SIZE;
  Eurydice_slice
  ind_cpa_keypair_randomness =
    Eurydice_array_to_subslice((size_t)64U,
      randomness,
      lit0,
      uint8_t,
      core_ops_range_Range__size_t);
  Eurydice_slice
  implicit_rejection_value =
    Eurydice_array_to_subslice_from((size_t)64U,
      randomness,
      libcrux_kyber_constants_CPA_PKE_KEY_GENERATION_SEED_SIZE,
      uint8_t,
      size_t);
  K___uint8_t_1536size_t____uint8_t_1568size_t__core_option_Option__libcrux_kyber_types_Error
  uu____0 =
    libcrux_kyber_ind_cpa_generate_keypair___4size_t_1536size_t_1568size_t_1536size_t_2size_t_128size_t(ind_cpa_keypair_randomness);
  uint8_t ind_cpa_private_key[1536U];
  memcpy(ind_cpa_private_key, uu____0.fst.fst, (size_t)1536U * sizeof (uint8_t));
  uint8_t public_key[1568U];
  memcpy(public_key, uu____0.fst.snd, (size_t)1568U * sizeof (uint8_t));
  core_option_Option__libcrux_kyber_types_Error sampling_a_error = uu____0.snd;
  Eurydice_slice uu____1 = Eurydice_array_to_slice((size_t)1536U, ind_cpa_private_key, uint8_t);
  uint8_t secret_key_serialized[3168U];
  libcrux_kyber_serialize_kem_secret_key___3168size_t(uu____1,
    Eurydice_array_to_slice((size_t)1568U, public_key, uint8_t),
    implicit_rejection_value,
    secret_key_serialized);
  core_result_Result__libcrux_kyber_types_KyberKeyPair__1568size_t____3168size_t___libcrux_kyber_types_Error
  uu____2;
  if (sampling_a_error.tag == core_option_Some)
  {
    libcrux_kyber_types_Error error = sampling_a_error.f0;
    core_result_Result__libcrux_kyber_types_KyberKeyPair__1568size_t____3168size_t___libcrux_kyber_types_Error
    lit;
    lit.tag = core_result_Err;
    lit.val.case_Err = error;
    uu____2 = lit;
  }
  else
  {
    uint8_t uu____3[3168U];
    memcpy(uu____3, secret_key_serialized, (size_t)3168U * sizeof (uint8_t));
    uint8_t private_key[3168U];
    libcrux_kyber_types__libcrux_kyber__types__KyberPrivateKey_SIZE__8__from___3168size_t(uu____3,
      private_key);
    uint8_t uu____4[3168U];
    memcpy(uu____4, private_key, (size_t)3168U * sizeof (uint8_t));
    uint8_t uu____5[1568U];
    memcpy(uu____5, public_key, (size_t)1568U * sizeof (uint8_t));
    core_result_Result__libcrux_kyber_types_KyberKeyPair__1568size_t____3168size_t___libcrux_kyber_types_Error
    lit;
    lit.tag = core_result_Ok;
    lit.val.case_Ok =
      libcrux_kyber_types__libcrux_kyber__types__KyberKeyPair_PRIVATE_KEY_SIZE__PUBLIC_KEY_SIZE___from___3168size_t_1568size_t(uu____4,
        uu____5);
    uu____2 = lit;
  }
  return uu____2;
}

core_result_Result__libcrux_kyber_types_KyberKeyPair__1568size_t____3168size_t___libcrux_kyber_types_Error
libcrux_kyber_kyber1024_generate_key_pair_1024(uint8_t randomness[64U])
{
  uint8_t uu____0[64U];
  memcpy(uu____0, randomness, (size_t)64U * sizeof (uint8_t));
  return
    libcrux_kyber_generate_keypair___4size_t_1536size_t_3168size_t_1568size_t_1536size_t_2size_t_128size_t(uu____0);
}

void libcrux_kyber_ind_cpa_into_padded_array___64size_t(Eurydice_slice slice, uint8_t ret[64U])
{
  if (false)
    LowStar_Ignore_ignore(core_slice___Slice_T___len(slice, uint8_t), size_t);
  uint8_t out[64U];
  for (size_t i = (size_t)0U; i < (size_t)64U; i++)
    out[i] = 0U;
  uint8_t *uu____0 = out;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(slice, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)64U,
      uu____0,
      lit,
      uint8_t,
      core_ops_range_Range__size_t),
    slice,
    uint8_t);
  uint8_t uu____1[64U];
  memcpy(uu____1, out, (size_t)64U * sizeof (uint8_t));
  memcpy(ret, uu____1, (size_t)64U * sizeof (uint8_t));
}

uint8_t
*libcrux_kyber_types__libcrux_kyber__types__KyberPublicKey_SIZE__18__as_slice___1568size_t(
  uint8_t (*self)[1568U]
)
{
  return self[0U];
}

void
libcrux_kyber_ind_cpa_deserialize_public_key___4size_t_1536size_t(
  Eurydice_slice public_key,
  int32_t ret[4U][256U]
)
{
  int32_t t_as_ntt[4U][256U];
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
    memcpy(t_as_ntt[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = (size_t)1536U / libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        core_ops_range_Range__size_t lit;
        lit.start = i * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        lit.end = i * (libcrux_kyber_constants_BYTES_PER_RING_ELEMENT + (size_t)1U);
        Eurydice_slice
        t_as_ntt_bytes =
          Eurydice_slice_subslice(public_key,
            lit,
            uint8_t,
            core_ops_range_Range__size_t);
        int32_t uu____1[256U];
        libcrux_kyber_serialize_deserialize_to_uncompressed_ring_element(t_as_ntt_bytes, uu____1);
        memcpy(t_as_ntt[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[4U][256U];
    memcpy(uu____2, t_as_ntt, (size_t)4U * sizeof (int32_t [256U]));
    memcpy(ret, uu____2, (size_t)4U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_ind_cpa_sample_ring_element_cbd___4size_t_128size_t_2size_t(
  uint8_t *prf_input,
  uint8_t *domain_separator,
  int32_t ret[4U][256U]
)
{
  int32_t error_1[4U][256U];
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
    memcpy(error_1[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)4U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        prf_input[32U] = domain_separator[0U];
        domain_separator[0U] = (uint32_t)domain_separator[0U] + 1U;
        uint8_t prf_output[128U];
        libcrux_kyber_hash_functions_PRF___128size_t(Eurydice_array_to_slice((size_t)33U,
            prf_input,
            uint8_t),
          prf_output);
        int32_t uu____1[256U];
        libcrux_kyber_sampling_sample_from_binomial_distribution___2size_t(Eurydice_array_to_slice((size_t)128U,
            prf_output,
            uint8_t),
          uu____1);
        memcpy(error_1[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[4U][256U];
    memcpy(uu____2, error_1, (size_t)4U * sizeof (int32_t [256U]));
    memcpy(ret, uu____2, (size_t)4U * sizeof (int32_t [256U]));
    return;
  }
}

void libcrux_kyber_ntt_invert_ntt_montgomery___4size_t(int32_t re[256U], int32_t ret[256U])
{
  size_t zeta_i = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT / (size_t)2U;
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)1U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)2U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)3U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)4U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)5U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)6U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)7U, re);
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)8U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t uu____1 = libcrux_kyber_arithmetic_barrett_reduce(re[i]);
        re[i] = uu____1;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, re, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_matrix_compute_vector_u___4size_t(
  int32_t (*a_as_ntt)[4U][256U],
  int32_t (*r_as_ntt)[256U],
  int32_t (*error_1)[256U],
  int32_t ret[4U][256U]
)
{
  int32_t result[4U][256U];
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
    memcpy(result[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)4U,
        a_as_ntt,
        Eurydice_error_t_cg_array),
      int32_t [4U][256U]);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        core_ops_range_Range__size_t lit;
        lit.start = (size_t)0U;
        lit.end =
          core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)4U,
              a_as_ntt[i],
              int32_t [256U]),
            int32_t [256U]);
        core_ops_range_Range__size_t
        iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
          if (uu____1.tag == core_option_None)
            break;
          else if (uu____1.tag == core_option_Some)
          {
            size_t j = uu____1.f0;
            int32_t product[256U];
            libcrux_kyber_ntt_ntt_multiply(&a_as_ntt[i][j], &r_as_ntt[j], product);
            int32_t uu____2[256U];
            libcrux_kyber_arithmetic_add_to_ring_element___4size_t(result[i], &product, uu____2);
            memcpy(result[i], uu____2, (size_t)256U * sizeof (int32_t));
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        int32_t uu____3[256U];
        libcrux_kyber_ntt_invert_ntt_montgomery___4size_t(result[i], uu____3);
        memcpy(result[i], uu____3, (size_t)256U * sizeof (int32_t));
        core_ops_range_Range__size_t lit0;
        lit0.start = (size_t)0U;
        lit0.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
        core_ops_range_Range__size_t
        iter0 = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____4 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
          if (uu____4.tag == core_option_None)
            break;
          else if (uu____4.tag == core_option_Some)
          {
            size_t j = uu____4.f0;
            int32_t
            coefficient_normal_form =
              libcrux_kyber_arithmetic_montgomery_reduce(result[i][j] * (int32_t)1441);
            int32_t
            uu____5 =
              libcrux_kyber_arithmetic_barrett_reduce(coefficient_normal_form + error_1[i][j]);
            result[i][j] = uu____5;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____6[4U][256U];
    memcpy(uu____6, result, (size_t)4U * sizeof (int32_t [256U]));
    memcpy(ret, uu____6, (size_t)4U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_matrix_compute_ring_element_v___4size_t(
  int32_t (*t_as_ntt)[256U],
  int32_t (*r_as_ntt)[256U],
  int32_t (*error_2)[256U],
  int32_t (*message)[256U],
  int32_t ret[256U]
)
{
  int32_t result[256U];
  memcpy(result,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)4U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (uu____0.tag == core_option_None)
      break;
    else if (uu____0.tag == core_option_Some)
    {
      size_t i = uu____0.f0;
      int32_t product[256U];
      libcrux_kyber_ntt_ntt_multiply(&t_as_ntt[i], &r_as_ntt[i], product);
      libcrux_kyber_arithmetic_add_to_ring_element___4size_t(result, &product, result);
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
      KRML_HOST_EXIT(255U);
    }
  }
  libcrux_kyber_ntt_invert_ntt_montgomery___4size_t(result, result);
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter0 = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
    if (!(uu____1.tag == core_option_None))
    {
      if (uu____1.tag == core_option_Some)
      {
        size_t i = uu____1.f0;
        int32_t
        coefficient_normal_form =
          libcrux_kyber_arithmetic_montgomery_reduce(result[i] * (int32_t)1441);
        int32_t
        uu____2 =
          libcrux_kyber_arithmetic_barrett_reduce(coefficient_normal_form
            + error_2[0U][i]
            + message[0U][i]);
        result[i] = uu____2;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, result, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_serialize_compress_then_serialize_10___352size_t(
  int32_t re[256U],
  uint8_t ret[352U]
)
{
  uint8_t serialized[352U];
  for (size_t i = (size_t)0U; i < (size_t)352U; i++)
    serialized[i] = 0U;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t),
      int32_t)
    / (size_t)4U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t
        coefficient1 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(10U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)4U + (size_t)0U]));
        int32_t
        coefficient2 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(10U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)4U + (size_t)1U]));
        int32_t
        coefficient3 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(10U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)4U + (size_t)2U]));
        int32_t
        coefficient4 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(10U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)4U + (size_t)3U]));
        K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
        uu____1 =
          libcrux_kyber_serialize_compress_coefficients_10(coefficient1,
            coefficient2,
            coefficient3,
            coefficient4);
        uint8_t coef1 = uu____1.fst;
        uint8_t coef2 = uu____1.snd;
        uint8_t coef3 = uu____1.thd;
        uint8_t coef4 = uu____1.f3;
        uint8_t coef5 = uu____1.f4;
        serialized[(size_t)5U * i] = coef1;
        serialized[(size_t)5U * i + (size_t)1U] = coef2;
        serialized[(size_t)5U * i + (size_t)2U] = coef3;
        serialized[(size_t)5U * i + (size_t)3U] = coef4;
        serialized[(size_t)5U * i + (size_t)4U] = coef5;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____2[352U];
    memcpy(uu____2, serialized, (size_t)352U * sizeof (uint8_t));
    memcpy(ret, uu____2, (size_t)352U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_serialize_compress_then_serialize_11___352size_t(
  int32_t re[256U],
  uint8_t ret[352U]
)
{
  uint8_t serialized[352U];
  for (size_t i = (size_t)0U; i < (size_t)352U; i++)
    serialized[i] = 0U;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t),
      int32_t)
    / (size_t)8U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t
        coefficient1 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)0U]));
        int32_t
        coefficient2 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)1U]));
        int32_t
        coefficient3 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)2U]));
        int32_t
        coefficient4 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)3U]));
        int32_t
        coefficient5 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)4U]));
        int32_t
        coefficient6 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)5U]));
        int32_t
        coefficient7 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)6U]));
        int32_t
        coefficient8 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)7U]));
        K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
        uu____1 =
          libcrux_kyber_serialize_compress_coefficients_11(coefficient1,
            coefficient2,
            coefficient3,
            coefficient4,
            coefficient5,
            coefficient6,
            coefficient7,
            coefficient8);
        uint8_t coef1 = uu____1.fst;
        uint8_t coef2 = uu____1.snd;
        uint8_t coef3 = uu____1.thd;
        uint8_t coef4 = uu____1.f3;
        uint8_t coef5 = uu____1.f4;
        uint8_t coef6 = uu____1.f5;
        uint8_t coef7 = uu____1.f6;
        uint8_t coef8 = uu____1.f7;
        uint8_t coef9 = uu____1.f8;
        uint8_t coef10 = uu____1.f9;
        uint8_t coef11 = uu____1.f10;
        serialized[(size_t)11U * i] = coef1;
        serialized[(size_t)11U * i + (size_t)1U] = coef2;
        serialized[(size_t)11U * i + (size_t)2U] = coef3;
        serialized[(size_t)11U * i + (size_t)3U] = coef4;
        serialized[(size_t)11U * i + (size_t)4U] = coef5;
        serialized[(size_t)11U * i + (size_t)5U] = coef6;
        serialized[(size_t)11U * i + (size_t)6U] = coef7;
        serialized[(size_t)11U * i + (size_t)7U] = coef8;
        serialized[(size_t)11U * i + (size_t)8U] = coef9;
        serialized[(size_t)11U * i + (size_t)9U] = coef10;
        serialized[(size_t)11U * i + (size_t)10U] = coef11;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____2[352U];
    memcpy(uu____2, serialized, (size_t)352U * sizeof (uint8_t));
    memcpy(ret, uu____2, (size_t)352U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_serialize_compress_then_serialize_ring_element_u___11size_t_352size_t(
  int32_t re[256U],
  uint8_t ret[352U]
)
{
  uint8_t uu____0[352U];
  libcrux_kyber_serialize_compress_then_serialize_11___352size_t(re, uu____0);
  memcpy(ret, uu____0, (size_t)352U * sizeof (uint8_t));
}

void
libcrux_kyber_ind_cpa_compress_then_serialize_u___4size_t_1408size_t_11size_t_352size_t(
  int32_t input[4U][256U],
  uint8_t ret[1408U]
)
{
  uint8_t out[1408U];
  for (size_t i = (size_t)0U; i < (size_t)1408U; i++)
    out[i] = 0U;
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)4U, input, int32_t [256U]),
      int32_t [256U]);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t re[256U];
        memcpy(re, input[i], (size_t)256U * sizeof (int32_t));
        core_ops_range_Range__size_t lit;
        lit.start = i * ((size_t)1408U / (size_t)4U);
        lit.end = (i + (size_t)1U) * ((size_t)1408U / (size_t)4U);
        Eurydice_slice
        uu____1 =
          Eurydice_array_to_subslice((size_t)1408U,
            out,
            lit,
            uint8_t,
            core_ops_range_Range__size_t);
        uint8_t ret[352U];
        libcrux_kyber_serialize_compress_then_serialize_ring_element_u___11size_t_352size_t(re,
          ret);
        core_slice___Slice_T___copy_from_slice(uu____1,
          Eurydice_array_to_slice((size_t)352U, ret, uint8_t),
          uint8_t);
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____2[1408U];
    memcpy(uu____2, out, (size_t)1408U * sizeof (uint8_t));
    memcpy(ret, uu____2, (size_t)1408U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_serialize_compress_then_serialize_4___160size_t(
  int32_t re[256U],
  uint8_t ret[160U]
)
{
  uint8_t serialized[160U];
  for (size_t i = (size_t)0U; i < (size_t)160U; i++)
    serialized[i] = 0U;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t),
      int32_t)
    / (size_t)2U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        uint8_t
        coefficient1 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(4U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)2U + (size_t)0U]));
        uint8_t
        coefficient2 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(4U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)2U + (size_t)1U]));
        serialized[i] = (uint32_t)coefficient2 << 4U | (uint32_t)coefficient1;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____1[160U];
    memcpy(uu____1, serialized, (size_t)160U * sizeof (uint8_t));
    memcpy(ret, uu____1, (size_t)160U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_serialize_compress_then_serialize_5___160size_t(
  int32_t re[256U],
  uint8_t ret[160U]
)
{
  uint8_t serialized[160U];
  for (size_t i = (size_t)0U; i < (size_t)160U; i++)
    serialized[i] = 0U;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t),
      int32_t)
    / (size_t)8U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        uint8_t
        coefficient1 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)0U]));
        uint8_t
        coefficient2 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)1U]));
        uint8_t
        coefficient3 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)2U]));
        uint8_t
        coefficient4 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)3U]));
        uint8_t
        coefficient5 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)4U]));
        uint8_t
        coefficient6 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)5U]));
        uint8_t
        coefficient7 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)6U]));
        uint8_t
        coefficient8 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)7U]));
        K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
        uu____1 =
          libcrux_kyber_serialize_compress_coefficients_5(coefficient2,
            coefficient1,
            coefficient4,
            coefficient3,
            coefficient5,
            coefficient7,
            coefficient6,
            coefficient8);
        uint8_t coef1 = uu____1.fst;
        uint8_t coef2 = uu____1.snd;
        uint8_t coef3 = uu____1.thd;
        uint8_t coef4 = uu____1.f3;
        uint8_t coef5 = uu____1.f4;
        serialized[(size_t)5U * i] = coef1;
        serialized[(size_t)5U * i + (size_t)1U] = coef2;
        serialized[(size_t)5U * i + (size_t)2U] = coef3;
        serialized[(size_t)5U * i + (size_t)3U] = coef4;
        serialized[(size_t)5U * i + (size_t)4U] = coef5;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____2[160U];
    memcpy(uu____2, serialized, (size_t)160U * sizeof (uint8_t));
    memcpy(ret, uu____2, (size_t)160U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_serialize_compress_then_serialize_ring_element_v___5size_t_160size_t(
  int32_t re[256U],
  uint8_t ret[160U]
)
{
  uint8_t uu____0[160U];
  libcrux_kyber_serialize_compress_then_serialize_5___160size_t(re, uu____0);
  memcpy(ret, uu____0, (size_t)160U * sizeof (uint8_t));
}

void
libcrux_kyber_ind_cpa_into_padded_array___1568size_t(Eurydice_slice slice, uint8_t ret[1568U])
{
  if (false)
    LowStar_Ignore_ignore(core_slice___Slice_T___len(slice, uint8_t), size_t);
  uint8_t out[1568U];
  for (size_t i = (size_t)0U; i < (size_t)1568U; i++)
    out[i] = 0U;
  uint8_t *uu____0 = out;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(slice, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)1568U,
      uu____0,
      lit,
      uint8_t,
      core_ops_range_Range__size_t),
    slice,
    uint8_t);
  uint8_t uu____1[1568U];
  memcpy(uu____1, out, (size_t)1568U * sizeof (uint8_t));
  memcpy(ret, uu____1, (size_t)1568U * sizeof (uint8_t));
}

K___uint8_t_1568size_t__core_option_Option__libcrux_kyber_types_Error
libcrux_kyber_ind_cpa_encrypt___4size_t_1568size_t_1536size_t_1408size_t_160size_t_11size_t_5size_t_352size_t_2size_t_128size_t_2size_t_128size_t(
  Eurydice_slice public_key,
  uint8_t message[32U],
  Eurydice_slice randomness
)
{
  int32_t t_as_ntt[4U][256U];
  libcrux_kyber_ind_cpa_deserialize_public_key___4size_t_1536size_t(public_key, t_as_ntt);
  Eurydice_slice seed = Eurydice_slice_subslice_from(public_key, (size_t)1536U, uint8_t, size_t);
  uint8_t ret[34U];
  libcrux_kyber_ind_cpa_into_padded_array___34size_t(seed, ret);
  K___libcrux_kyber_arithmetic_PolynomialRingElement_4size_t__4size_t__core_option_Option__libcrux_kyber_types_Error
  uu____0 = libcrux_kyber_matrix_sample_matrix_A___4size_t(ret, false);
  int32_t A_transpose[4U][4U][256U];
  memcpy(A_transpose, uu____0.fst, (size_t)4U * sizeof (int32_t [4U][256U]));
  core_option_Option__libcrux_kyber_types_Error sampling_A_error = uu____0.snd;
  uint8_t prf_input[33U];
  libcrux_kyber_ind_cpa_into_padded_array___33size_t(randomness, prf_input);
  uint8_t uu____1[33U];
  memcpy(uu____1, prf_input, (size_t)33U * sizeof (uint8_t));
  K___libcrux_kyber_arithmetic_PolynomialRingElement_4size_t__uint8_t
  uu____2 =
    libcrux_kyber_ind_cpa_sample_vector_cbd_then_ntt___4size_t_2size_t_128size_t(uu____1,
      0U);
  int32_t r_as_ntt[4U][256U];
  memcpy(r_as_ntt, uu____2.fst, (size_t)4U * sizeof (int32_t [256U]));
  uint8_t domain_separator = uu____2.snd;
  int32_t error_1[4U][256U];
  libcrux_kyber_ind_cpa_sample_ring_element_cbd___4size_t_128size_t_2size_t(prf_input,
    &domain_separator,
    error_1);
  prf_input[32U] = domain_separator;
  uint8_t prf_output[128U];
  libcrux_kyber_hash_functions_PRF___128size_t(Eurydice_array_to_slice((size_t)33U,
      prf_input,
      uint8_t),
    prf_output);
  int32_t error_2[256U];
  libcrux_kyber_sampling_sample_from_binomial_distribution___2size_t(Eurydice_array_to_slice((size_t)128U,
      prf_output,
      uint8_t),
    error_2);
  int32_t u[4U][256U];
  libcrux_kyber_matrix_compute_vector_u___4size_t(A_transpose, r_as_ntt, error_1, u);
  uint8_t uu____3[32U];
  memcpy(uu____3, message, (size_t)32U * sizeof (uint8_t));
  int32_t message_as_ring_element[256U];
  libcrux_kyber_serialize_deserialize_then_decompress_message(uu____3, message_as_ring_element);
  int32_t v[256U];
  libcrux_kyber_matrix_compute_ring_element_v___4size_t(t_as_ntt,
    r_as_ntt,
    &error_2,
    &message_as_ring_element,
    v);
  int32_t uu____4[4U][256U];
  memcpy(uu____4, u, (size_t)4U * sizeof (int32_t [256U]));
  uint8_t c1[1408U];
  libcrux_kyber_ind_cpa_compress_then_serialize_u___4size_t_1408size_t_11size_t_352size_t(uu____4,
    c1);
  uint8_t c2[160U];
  libcrux_kyber_serialize_compress_then_serialize_ring_element_v___5size_t_160size_t(v, c2);
  uint8_t ciphertext[1568U];
  libcrux_kyber_ind_cpa_into_padded_array___1568size_t(Eurydice_array_to_slice((size_t)1408U,
      c1,
      uint8_t),
    ciphertext);
  Eurydice_slice
  uu____5 =
    Eurydice_array_to_subslice_from((size_t)1568U,
      ciphertext,
      (size_t)1408U,
      uint8_t,
      size_t);
  core_slice___Slice_T___copy_from_slice(uu____5,
    core_array___Array_T__N__23__as_slice((size_t)160U, c2, uint8_t),
    uint8_t);
  uint8_t uu____6[1568U];
  memcpy(uu____6, ciphertext, (size_t)1568U * sizeof (uint8_t));
  K___uint8_t_1568size_t__core_option_Option__libcrux_kyber_types_Error lit;
  memcpy(lit.fst, uu____6, (size_t)1568U * sizeof (uint8_t));
  lit.snd = sampling_A_error;
  return lit;
}

core_result_Result__libcrux_kyber_types_KyberCiphertext___1568size_t___uint8_t_32size_t__libcrux_kyber_types_Error
libcrux_kyber_encapsulate___4size_t_1568size_t_1568size_t_1536size_t_1408size_t_160size_t_11size_t_5size_t_352size_t_2size_t_128size_t_2size_t_128size_t(
  uint8_t (*public_key)[1568U],
  uint8_t randomness[32U]
)
{
  uint8_t to_hash[64U];
  libcrux_kyber_ind_cpa_into_padded_array___64size_t(Eurydice_array_to_slice((size_t)32U,
      randomness,
      uint8_t),
    to_hash);
  Eurydice_slice
  uu____0 =
    Eurydice_array_to_subslice_from((size_t)64U,
      to_hash,
      libcrux_kyber_constants_H_DIGEST_SIZE,
      uint8_t,
      size_t);
  uint8_t ret[32U];
  libcrux_kyber_hash_functions_H(Eurydice_array_to_slice((size_t)1568U,
      libcrux_kyber_types__libcrux_kyber__types__KyberPublicKey_SIZE__18__as_slice___1568size_t(public_key),
      uint8_t),
    ret);
  core_slice___Slice_T___copy_from_slice(uu____0,
    Eurydice_array_to_slice((size_t)32U, ret, uint8_t),
    uint8_t);
  uint8_t hashed[64U];
  libcrux_kyber_hash_functions_G(Eurydice_array_to_slice((size_t)64U, to_hash, uint8_t), hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____1 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U, hashed, uint8_t),
      libcrux_kyber_constants_SHARED_SECRET_SIZE,
      uint8_t);
  Eurydice_slice shared_secret = uu____1.fst;
  Eurydice_slice pseudorandomness = uu____1.snd;
  Eurydice_slice
  uu____2 =
    Eurydice_array_to_slice((size_t)1568U,
      libcrux_kyber_types__libcrux_kyber__types__KyberPublicKey_SIZE__18__as_slice___1568size_t(public_key),
      uint8_t);
  uint8_t uu____3[32U];
  memcpy(uu____3, randomness, (size_t)32U * sizeof (uint8_t));
  K___uint8_t_1568size_t__core_option_Option__libcrux_kyber_types_Error
  uu____4 =
    libcrux_kyber_ind_cpa_encrypt___4size_t_1568size_t_1536size_t_1408size_t_160size_t_11size_t_5size_t_352size_t_2size_t_128size_t_2size_t_128size_t(uu____2,
      uu____3,
      pseudorandomness);
  uint8_t ciphertext[1568U];
  memcpy(ciphertext, uu____4.fst, (size_t)1568U * sizeof (uint8_t));
  core_option_Option__libcrux_kyber_types_Error sampling_a_error = uu____4.snd;
  core_result_Result__libcrux_kyber_types_KyberCiphertext___1568size_t___uint8_t_32size_t__libcrux_kyber_types_Error
  uu____5;
  if (sampling_a_error.tag == core_option_None)
  {
    uint8_t uu____6[1568U];
    memcpy(uu____6, ciphertext, (size_t)1568U * sizeof (uint8_t));
    uint8_t uu____7[1568U];
    memcpy(uu____7, uu____6, (size_t)1568U * sizeof (uint8_t));
    core_result_Result__uint8_t_32size_t__core_array_TryFromSliceError
    uu____8 = Eurydice_slice_to_array(shared_secret, Eurydice_slice, uint8_t [32U]);
    if (uu____8.tag == core_result_Ok)
    {
      uint8_t r[32U];
      memcpy(r, uu____8.val.case_Ok, (size_t)32U * sizeof (uint8_t));
      uint8_t uu____9[32U];
      memcpy(uu____9, r, (size_t)32U * sizeof (uint8_t));
      core_result_Result__libcrux_kyber_types_KyberCiphertext___1568size_t___uint8_t_32size_t__libcrux_kyber_types_Error
      lit;
      lit.tag = core_result_Ok;
      memcpy(lit.val.case_Ok.fst, uu____7, (size_t)1568U * sizeof (uint8_t));
      memcpy(lit.val.case_Ok.snd, uu____9, (size_t)32U * sizeof (uint8_t));
      uu____5 = lit;
    }
    else if (uu____8.tag == core_result_Err)
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
      KRML_HOST_EXIT(255U);
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
      KRML_HOST_EXIT(255U);
    }
  }
  else if (sampling_a_error.tag == core_option_Some)
  {
    libcrux_kyber_types_Error e = sampling_a_error.f0;
    core_result_Result__libcrux_kyber_types_KyberCiphertext___1568size_t___uint8_t_32size_t__libcrux_kyber_types_Error
    lit;
    lit.tag = core_result_Err;
    lit.val.case_Err = e;
    uu____5 = lit;
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
    KRML_HOST_EXIT(255U);
  }
  return uu____5;
}

core_result_Result__libcrux_kyber_types_KyberCiphertext___1568size_t___uint8_t_32size_t__libcrux_kyber_types_Error
libcrux_kyber_kyber1024_encapsulate_1024(uint8_t (*public_key)[1568U], uint8_t randomness[32U])
{
  uint8_t (*uu____0)[1568U] = public_key;
  uint8_t uu____1[32U];
  memcpy(uu____1, randomness, (size_t)32U * sizeof (uint8_t));
  return
    libcrux_kyber_encapsulate___4size_t_1568size_t_1568size_t_1536size_t_1408size_t_160size_t_11size_t_5size_t_352size_t_2size_t_128size_t_2size_t_128size_t(uu____0,
      uu____1);
}

K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
libcrux_kyber_types__libcrux_kyber__types__KyberPrivateKey_SIZE__12__split_at___3168size_t(
  uint8_t (*self)[3168U],
  size_t mid
)
{
  return
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)3168U, self[0U], uint8_t),
      mid,
      uint8_t);
}

void
libcrux_kyber_serialize_deserialize_then_decompress_ring_element_u___11size_t(
  Eurydice_slice serialized,
  int32_t ret[256U]
)
{
  int32_t uu____0[256U];
  libcrux_kyber_serialize_deserialize_then_decompress_11(serialized, uu____0);
  memcpy(ret, uu____0, (size_t)256U * sizeof (int32_t));
}

void libcrux_kyber_ntt_ntt_vector_u___11size_t(int32_t re[256U], int32_t ret[256U])
{
  size_t zeta_i = (size_t)0U;
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)7U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)6U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)5U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)4U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)3U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)2U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)1U, re);
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t uu____1 = libcrux_kyber_arithmetic_barrett_reduce(re[i]);
        re[i] = uu____1;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, re, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_ind_cpa_deserialize_then_decompress_u___4size_t_1568size_t_1408size_t_11size_t(
  uint8_t *ciphertext,
  int32_t ret[4U][256U]
)
{
  int32_t u_as_ntt[4U][256U];
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
    memcpy(u_as_ntt[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  size_t
  chunk_size = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT * (size_t)11U / (size_t)8U;
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = (size_t)1408U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        core_ops_range_Range__size_t lit;
        lit.start = i * chunk_size;
        lit.end = i * (chunk_size + (size_t)1U);
        Eurydice_slice
        u_bytes =
          Eurydice_array_to_subslice((size_t)1568U,
            ciphertext,
            lit,
            uint8_t,
            core_ops_range_Range__size_t);
        int32_t u[256U];
        libcrux_kyber_serialize_deserialize_then_decompress_ring_element_u___11size_t(u_bytes, u);
        int32_t uu____1[256U];
        libcrux_kyber_ntt_ntt_vector_u___11size_t(u, uu____1);
        memcpy(u_as_ntt[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[4U][256U];
    memcpy(uu____2, u_as_ntt, (size_t)4U * sizeof (int32_t [256U]));
    memcpy(ret, uu____2, (size_t)4U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_serialize_deserialize_then_decompress_ring_element_v___5size_t(
  Eurydice_slice serialized,
  int32_t ret[256U]
)
{
  int32_t uu____0[256U];
  libcrux_kyber_serialize_deserialize_then_decompress_5(serialized, uu____0);
  memcpy(ret, uu____0, (size_t)256U * sizeof (int32_t));
}

void
libcrux_kyber_ind_cpa_deserialize_secret_key___4size_t(
  Eurydice_slice secret_key,
  int32_t ret[4U][256U]
)
{
  int32_t secret_as_ntt[4U][256U];
  for (size_t i = (size_t)0U; i < (size_t)4U; i++)
    memcpy(secret_as_ntt[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(secret_key,
      uint8_t)
    / libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t uu____1[256U];
        core_ops_range_Range__size_t lit;
        lit.start = i * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        lit.end =
          i
          * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT
          + libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        libcrux_kyber_serialize_deserialize_to_uncompressed_ring_element(Eurydice_slice_subslice(secret_key,
            lit,
            uint8_t,
            core_ops_range_Range__size_t),
          uu____1);
        memcpy(secret_as_ntt[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[4U][256U];
    memcpy(uu____2, secret_as_ntt, (size_t)4U * sizeof (int32_t [256U]));
    memcpy(ret, uu____2, (size_t)4U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_matrix_compute_message___4size_t(
  int32_t (*v)[256U],
  int32_t (*secret_as_ntt)[256U],
  int32_t (*u_as_ntt)[256U],
  int32_t ret[256U]
)
{
  int32_t result[256U];
  memcpy(result,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)4U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (uu____0.tag == core_option_None)
      break;
    else if (uu____0.tag == core_option_Some)
    {
      size_t i = uu____0.f0;
      int32_t product[256U];
      libcrux_kyber_ntt_ntt_multiply(&secret_as_ntt[i], &u_as_ntt[i], product);
      libcrux_kyber_arithmetic_add_to_ring_element___4size_t(result, &product, result);
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
      KRML_HOST_EXIT(255U);
    }
  }
  libcrux_kyber_ntt_invert_ntt_montgomery___4size_t(result, result);
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter0 = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
    if (!(uu____1.tag == core_option_None))
    {
      if (uu____1.tag == core_option_Some)
      {
        size_t i = uu____1.f0;
        int32_t
        coefficient_normal_form =
          libcrux_kyber_arithmetic_montgomery_reduce(result[i] * (int32_t)1441);
        int32_t
        uu____2 = libcrux_kyber_arithmetic_barrett_reduce(v[0U][i] - coefficient_normal_form);
        result[i] = uu____2;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, result, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_ind_cpa_decrypt___4size_t_1568size_t_1408size_t_11size_t_5size_t(
  Eurydice_slice secret_key,
  uint8_t *ciphertext,
  uint8_t ret[32U]
)
{
  int32_t u_as_ntt[4U][256U];
  libcrux_kyber_ind_cpa_deserialize_then_decompress_u___4size_t_1568size_t_1408size_t_11size_t(ciphertext,
    u_as_ntt);
  int32_t v[256U];
  libcrux_kyber_serialize_deserialize_then_decompress_ring_element_v___5size_t(Eurydice_array_to_subslice_from((size_t)1568U,
      ciphertext,
      (size_t)1408U,
      uint8_t,
      size_t),
    v);
  int32_t secret_as_ntt[4U][256U];
  libcrux_kyber_ind_cpa_deserialize_secret_key___4size_t(secret_key, secret_as_ntt);
  int32_t message[256U];
  libcrux_kyber_matrix_compute_message___4size_t(&v, secret_as_ntt, u_as_ntt, message);
  uint8_t ret0[32U];
  libcrux_kyber_serialize_compress_then_serialize_message(message, ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

void
libcrux_kyber_ind_cpa_into_padded_array___1600size_t(Eurydice_slice slice, uint8_t ret[1600U])
{
  if (false)
    LowStar_Ignore_ignore(core_slice___Slice_T___len(slice, uint8_t), size_t);
  uint8_t out[1600U];
  for (size_t i = (size_t)0U; i < (size_t)1600U; i++)
    out[i] = 0U;
  uint8_t *uu____0 = out;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(slice, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)1600U,
      uu____0,
      lit,
      uint8_t,
      core_ops_range_Range__size_t),
    slice,
    uint8_t);
  uint8_t uu____1[1600U];
  memcpy(uu____1, out, (size_t)1600U * sizeof (uint8_t));
  memcpy(ret, uu____1, (size_t)1600U * sizeof (uint8_t));
}

Eurydice_slice
libcrux_kyber_types__libcrux_kyber__types__KyberCiphertext_SIZE__1__as_ref___1568size_t(
  uint8_t (*self)[1568U]
)
{
  return Eurydice_array_to_slice((size_t)1568U, self[0U], uint8_t);
}

void libcrux_kyber_hash_functions_PRF___32size_t(Eurydice_slice input, uint8_t ret[32U])
{
  uint8_t ret0[32U];
  libcrux_digest_shake256((size_t)32U, input, ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

uint8_t
libcrux_kyber_constant_time_ops_compare_ciphertexts_in_constant_time___1568size_t(
  Eurydice_slice lhs,
  Eurydice_slice rhs
)
{
  uint8_t r = 0U;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)1568U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        uint8_t uu____1 = Eurydice_slice_index(lhs, i, uint8_t);
        r = (uint32_t)r | ((uint32_t)uu____1 ^ (uint32_t)Eurydice_slice_index(rhs, i, uint8_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    return libcrux_kyber_constant_time_ops_is_non_zero(r);
  }
}

void
libcrux_kyber_decapsulate___4size_t_3168size_t_1536size_t_1568size_t_1568size_t_1536size_t_1408size_t_160size_t_11size_t_5size_t_352size_t_2size_t_128size_t_2size_t_128size_t_1600size_t(
  uint8_t (*secret_key)[3168U],
  uint8_t (*ciphertext)[1568U],
  uint8_t ret[32U]
)
{
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____0 =
    libcrux_kyber_types__libcrux_kyber__types__KyberPrivateKey_SIZE__12__split_at___3168size_t(secret_key,
      (size_t)1536U);
  Eurydice_slice ind_cpa_secret_key = uu____0.fst;
  Eurydice_slice secret_key0 = uu____0.snd;
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____1 = core_slice___Slice_T___split_at(secret_key0, (size_t)1568U, uint8_t);
  Eurydice_slice ind_cpa_public_key = uu____1.fst;
  Eurydice_slice secret_key1 = uu____1.snd;
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____2 =
    core_slice___Slice_T___split_at(secret_key1,
      libcrux_kyber_constants_H_DIGEST_SIZE,
      uint8_t);
  Eurydice_slice ind_cpa_public_key_hash = uu____2.fst;
  Eurydice_slice implicit_rejection_value = uu____2.snd;
  uint8_t decrypted[32U];
  libcrux_kyber_ind_cpa_decrypt___4size_t_1568size_t_1408size_t_11size_t_5size_t(ind_cpa_secret_key,
    ciphertext[0U],
    decrypted);
  uint8_t to_hash0[64U];
  libcrux_kyber_ind_cpa_into_padded_array___64size_t(Eurydice_array_to_slice((size_t)32U,
      decrypted,
      uint8_t),
    to_hash0);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice_from((size_t)64U,
      to_hash0,
      libcrux_kyber_constants_SHARED_SECRET_SIZE,
      uint8_t,
      size_t),
    ind_cpa_public_key_hash,
    uint8_t);
  uint8_t hashed[64U];
  libcrux_kyber_hash_functions_G(Eurydice_array_to_slice((size_t)64U, to_hash0, uint8_t),
    hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____3 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U, hashed, uint8_t),
      libcrux_kyber_constants_SHARED_SECRET_SIZE,
      uint8_t);
  Eurydice_slice shared_secret = uu____3.fst;
  Eurydice_slice pseudorandomness = uu____3.snd;
  uint8_t to_hash[1600U];
  libcrux_kyber_ind_cpa_into_padded_array___1600size_t(implicit_rejection_value, to_hash);
  Eurydice_slice
  uu____4 =
    Eurydice_array_to_subslice_from((size_t)1600U,
      to_hash,
      libcrux_kyber_constants_SHARED_SECRET_SIZE,
      uint8_t,
      size_t);
  core_slice___Slice_T___copy_from_slice(uu____4,
    libcrux_kyber_types__libcrux_kyber__types__KyberCiphertext_SIZE__1__as_ref___1568size_t(ciphertext),
    uint8_t);
  uint8_t implicit_rejection_shared_secret[32U];
  libcrux_kyber_hash_functions_PRF___32size_t(Eurydice_array_to_slice((size_t)1600U,
      to_hash,
      uint8_t),
    implicit_rejection_shared_secret);
  Eurydice_slice uu____5 = ind_cpa_public_key;
  uint8_t uu____6[32U];
  memcpy(uu____6, decrypted, (size_t)32U * sizeof (uint8_t));
  uint8_t expected_ciphertext[1568U];
  memcpy(expected_ciphertext,
    libcrux_kyber_ind_cpa_encrypt___4size_t_1568size_t_1536size_t_1408size_t_160size_t_11size_t_5size_t_352size_t_2size_t_128size_t_2size_t_128size_t(uu____5,
      uu____6,
      pseudorandomness).fst,
    (size_t)1568U * sizeof (uint8_t));
  Eurydice_slice
  uu____7 =
    libcrux_kyber_types__libcrux_kyber__types__KyberCiphertext_SIZE__1__as_ref___1568size_t(ciphertext);
  uint8_t
  selector =
    libcrux_kyber_constant_time_ops_compare_ciphertexts_in_constant_time___1568size_t(uu____7,
      Eurydice_array_to_slice((size_t)1568U, expected_ciphertext, uint8_t));
  Eurydice_slice uu____8 = shared_secret;
  uint8_t ret0[32U];
  libcrux_kyber_constant_time_ops_select_shared_secret_in_constant_time(uu____8,
    Eurydice_array_to_slice((size_t)32U, implicit_rejection_shared_secret, uint8_t),
    selector,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

void
libcrux_kyber_kyber1024_decapsulate_1024(
  uint8_t (*secret_key)[3168U],
  uint8_t (*ciphertext)[1568U],
  uint8_t ret[32U]
)
{
  uint8_t ret0[32U];
  libcrux_kyber_decapsulate___4size_t_3168size_t_1536size_t_1568size_t_1568size_t_1536size_t_1408size_t_160size_t_11size_t_5size_t_352size_t_2size_t_128size_t_2size_t_128size_t_1600size_t(secret_key,
    ciphertext,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

const size_t libcrux_kyber_kyber512_RANK_512 = (size_t)2U;

const
size_t
libcrux_kyber_kyber512_RANKED_BYTES_PER_RING_ELEMENT_512 =
  libcrux_kyber_kyber512_RANK_512
  * libcrux_kyber_constants_BITS_PER_RING_ELEMENT
  / (size_t)8U;

const
size_t
libcrux_kyber_kyber512_T_AS_NTT_ENCODED_SIZE_512 =
  libcrux_kyber_kyber512_RANK_512
  * libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT
  * libcrux_kyber_constants_BITS_PER_COEFFICIENT
  / (size_t)8U;

const size_t libcrux_kyber_kyber512_VECTOR_U_COMPRESSION_FACTOR_512 = (size_t)10U;

const
size_t
libcrux_kyber_kyber512_C1_BLOCK_SIZE_512 =
  libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT
  * libcrux_kyber_kyber512_VECTOR_U_COMPRESSION_FACTOR_512
  / (size_t)8U;

const
size_t
libcrux_kyber_kyber512_C1_SIZE_512 =
  libcrux_kyber_kyber512_C1_BLOCK_SIZE_512
  * libcrux_kyber_kyber512_RANK_512;

const size_t libcrux_kyber_kyber512_VECTOR_V_COMPRESSION_FACTOR_512 = (size_t)4U;

const
size_t
libcrux_kyber_kyber512_C2_SIZE_512 =
  libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT
  * libcrux_kyber_kyber512_VECTOR_V_COMPRESSION_FACTOR_512
  / (size_t)8U;

const
size_t
libcrux_kyber_kyber512_CPA_PKE_SECRET_KEY_SIZE_512 =
  libcrux_kyber_kyber512_RANK_512
  * libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT
  * libcrux_kyber_constants_BITS_PER_COEFFICIENT
  / (size_t)8U;

const
size_t
libcrux_kyber_kyber512_CPA_PKE_PUBLIC_KEY_SIZE_512 =
  libcrux_kyber_kyber512_T_AS_NTT_ENCODED_SIZE_512
  + (size_t)32U;

const
size_t
libcrux_kyber_kyber512_CPA_PKE_CIPHERTEXT_SIZE_512 =
  libcrux_kyber_kyber512_C1_SIZE_512
  + libcrux_kyber_kyber512_C2_SIZE_512;

const
size_t
libcrux_kyber_kyber512_SECRET_KEY_SIZE_512 =
  libcrux_kyber_kyber512_CPA_PKE_SECRET_KEY_SIZE_512
  + libcrux_kyber_kyber512_CPA_PKE_PUBLIC_KEY_SIZE_512
  + libcrux_kyber_constants_H_DIGEST_SIZE
  + libcrux_kyber_constants_SHARED_SECRET_SIZE;

const size_t libcrux_kyber_kyber512_ETA1 = (size_t)3U;

const
size_t
libcrux_kyber_kyber512_ETA1_RANDOMNESS_SIZE = libcrux_kyber_kyber512_ETA1 * (size_t)64U;

const size_t libcrux_kyber_kyber512_ETA2 = (size_t)2U;

const
size_t
libcrux_kyber_kyber512_ETA2_RANDOMNESS_SIZE = libcrux_kyber_kyber512_ETA2 * (size_t)64U;

const
size_t
libcrux_kyber_kyber512_IMPLICIT_REJECTION_HASH_INPUT_SIZE =
  libcrux_kyber_constants_SHARED_SECRET_SIZE
  + libcrux_kyber_kyber512_CPA_PKE_CIPHERTEXT_SIZE_512;

void
libcrux_kyber_hash_functions_XOFx4___2size_t(uint8_t input[2U][34U], uint8_t ret[2U][840U])
{
  uint8_t out[2U][840U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    out[i][0U] = 0U;
    out[i][1U] = 0U;
    out[i][2U] = 0U;
    out[i][3U] = 0U;
    out[i][4U] = 0U;
    out[i][5U] = 0U;
    out[i][6U] = 0U;
    out[i][7U] = 0U;
    out[i][8U] = 0U;
    out[i][9U] = 0U;
    out[i][10U] = 0U;
    out[i][11U] = 0U;
    out[i][12U] = 0U;
    out[i][13U] = 0U;
    out[i][14U] = 0U;
    out[i][15U] = 0U;
    out[i][16U] = 0U;
    out[i][17U] = 0U;
    out[i][18U] = 0U;
    out[i][19U] = 0U;
    out[i][20U] = 0U;
    out[i][21U] = 0U;
    out[i][22U] = 0U;
    out[i][23U] = 0U;
    out[i][24U] = 0U;
    out[i][25U] = 0U;
    out[i][26U] = 0U;
    out[i][27U] = 0U;
    out[i][28U] = 0U;
    out[i][29U] = 0U;
    out[i][30U] = 0U;
    out[i][31U] = 0U;
    out[i][32U] = 0U;
    out[i][33U] = 0U;
    out[i][34U] = 0U;
    out[i][35U] = 0U;
    out[i][36U] = 0U;
    out[i][37U] = 0U;
    out[i][38U] = 0U;
    out[i][39U] = 0U;
    out[i][40U] = 0U;
    out[i][41U] = 0U;
    out[i][42U] = 0U;
    out[i][43U] = 0U;
    out[i][44U] = 0U;
    out[i][45U] = 0U;
    out[i][46U] = 0U;
    out[i][47U] = 0U;
    out[i][48U] = 0U;
    out[i][49U] = 0U;
    out[i][50U] = 0U;
    out[i][51U] = 0U;
    out[i][52U] = 0U;
    out[i][53U] = 0U;
    out[i][54U] = 0U;
    out[i][55U] = 0U;
    out[i][56U] = 0U;
    out[i][57U] = 0U;
    out[i][58U] = 0U;
    out[i][59U] = 0U;
    out[i][60U] = 0U;
    out[i][61U] = 0U;
    out[i][62U] = 0U;
    out[i][63U] = 0U;
    out[i][64U] = 0U;
    out[i][65U] = 0U;
    out[i][66U] = 0U;
    out[i][67U] = 0U;
    out[i][68U] = 0U;
    out[i][69U] = 0U;
    out[i][70U] = 0U;
    out[i][71U] = 0U;
    out[i][72U] = 0U;
    out[i][73U] = 0U;
    out[i][74U] = 0U;
    out[i][75U] = 0U;
    out[i][76U] = 0U;
    out[i][77U] = 0U;
    out[i][78U] = 0U;
    out[i][79U] = 0U;
    out[i][80U] = 0U;
    out[i][81U] = 0U;
    out[i][82U] = 0U;
    out[i][83U] = 0U;
    out[i][84U] = 0U;
    out[i][85U] = 0U;
    out[i][86U] = 0U;
    out[i][87U] = 0U;
    out[i][88U] = 0U;
    out[i][89U] = 0U;
    out[i][90U] = 0U;
    out[i][91U] = 0U;
    out[i][92U] = 0U;
    out[i][93U] = 0U;
    out[i][94U] = 0U;
    out[i][95U] = 0U;
    out[i][96U] = 0U;
    out[i][97U] = 0U;
    out[i][98U] = 0U;
    out[i][99U] = 0U;
    out[i][100U] = 0U;
    out[i][101U] = 0U;
    out[i][102U] = 0U;
    out[i][103U] = 0U;
    out[i][104U] = 0U;
    out[i][105U] = 0U;
    out[i][106U] = 0U;
    out[i][107U] = 0U;
    out[i][108U] = 0U;
    out[i][109U] = 0U;
    out[i][110U] = 0U;
    out[i][111U] = 0U;
    out[i][112U] = 0U;
    out[i][113U] = 0U;
    out[i][114U] = 0U;
    out[i][115U] = 0U;
    out[i][116U] = 0U;
    out[i][117U] = 0U;
    out[i][118U] = 0U;
    out[i][119U] = 0U;
    out[i][120U] = 0U;
    out[i][121U] = 0U;
    out[i][122U] = 0U;
    out[i][123U] = 0U;
    out[i][124U] = 0U;
    out[i][125U] = 0U;
    out[i][126U] = 0U;
    out[i][127U] = 0U;
    out[i][128U] = 0U;
    out[i][129U] = 0U;
    out[i][130U] = 0U;
    out[i][131U] = 0U;
    out[i][132U] = 0U;
    out[i][133U] = 0U;
    out[i][134U] = 0U;
    out[i][135U] = 0U;
    out[i][136U] = 0U;
    out[i][137U] = 0U;
    out[i][138U] = 0U;
    out[i][139U] = 0U;
    out[i][140U] = 0U;
    out[i][141U] = 0U;
    out[i][142U] = 0U;
    out[i][143U] = 0U;
    out[i][144U] = 0U;
    out[i][145U] = 0U;
    out[i][146U] = 0U;
    out[i][147U] = 0U;
    out[i][148U] = 0U;
    out[i][149U] = 0U;
    out[i][150U] = 0U;
    out[i][151U] = 0U;
    out[i][152U] = 0U;
    out[i][153U] = 0U;
    out[i][154U] = 0U;
    out[i][155U] = 0U;
    out[i][156U] = 0U;
    out[i][157U] = 0U;
    out[i][158U] = 0U;
    out[i][159U] = 0U;
    out[i][160U] = 0U;
    out[i][161U] = 0U;
    out[i][162U] = 0U;
    out[i][163U] = 0U;
    out[i][164U] = 0U;
    out[i][165U] = 0U;
    out[i][166U] = 0U;
    out[i][167U] = 0U;
    out[i][168U] = 0U;
    out[i][169U] = 0U;
    out[i][170U] = 0U;
    out[i][171U] = 0U;
    out[i][172U] = 0U;
    out[i][173U] = 0U;
    out[i][174U] = 0U;
    out[i][175U] = 0U;
    out[i][176U] = 0U;
    out[i][177U] = 0U;
    out[i][178U] = 0U;
    out[i][179U] = 0U;
    out[i][180U] = 0U;
    out[i][181U] = 0U;
    out[i][182U] = 0U;
    out[i][183U] = 0U;
    out[i][184U] = 0U;
    out[i][185U] = 0U;
    out[i][186U] = 0U;
    out[i][187U] = 0U;
    out[i][188U] = 0U;
    out[i][189U] = 0U;
    out[i][190U] = 0U;
    out[i][191U] = 0U;
    out[i][192U] = 0U;
    out[i][193U] = 0U;
    out[i][194U] = 0U;
    out[i][195U] = 0U;
    out[i][196U] = 0U;
    out[i][197U] = 0U;
    out[i][198U] = 0U;
    out[i][199U] = 0U;
    out[i][200U] = 0U;
    out[i][201U] = 0U;
    out[i][202U] = 0U;
    out[i][203U] = 0U;
    out[i][204U] = 0U;
    out[i][205U] = 0U;
    out[i][206U] = 0U;
    out[i][207U] = 0U;
    out[i][208U] = 0U;
    out[i][209U] = 0U;
    out[i][210U] = 0U;
    out[i][211U] = 0U;
    out[i][212U] = 0U;
    out[i][213U] = 0U;
    out[i][214U] = 0U;
    out[i][215U] = 0U;
    out[i][216U] = 0U;
    out[i][217U] = 0U;
    out[i][218U] = 0U;
    out[i][219U] = 0U;
    out[i][220U] = 0U;
    out[i][221U] = 0U;
    out[i][222U] = 0U;
    out[i][223U] = 0U;
    out[i][224U] = 0U;
    out[i][225U] = 0U;
    out[i][226U] = 0U;
    out[i][227U] = 0U;
    out[i][228U] = 0U;
    out[i][229U] = 0U;
    out[i][230U] = 0U;
    out[i][231U] = 0U;
    out[i][232U] = 0U;
    out[i][233U] = 0U;
    out[i][234U] = 0U;
    out[i][235U] = 0U;
    out[i][236U] = 0U;
    out[i][237U] = 0U;
    out[i][238U] = 0U;
    out[i][239U] = 0U;
    out[i][240U] = 0U;
    out[i][241U] = 0U;
    out[i][242U] = 0U;
    out[i][243U] = 0U;
    out[i][244U] = 0U;
    out[i][245U] = 0U;
    out[i][246U] = 0U;
    out[i][247U] = 0U;
    out[i][248U] = 0U;
    out[i][249U] = 0U;
    out[i][250U] = 0U;
    out[i][251U] = 0U;
    out[i][252U] = 0U;
    out[i][253U] = 0U;
    out[i][254U] = 0U;
    out[i][255U] = 0U;
    out[i][256U] = 0U;
    out[i][257U] = 0U;
    out[i][258U] = 0U;
    out[i][259U] = 0U;
    out[i][260U] = 0U;
    out[i][261U] = 0U;
    out[i][262U] = 0U;
    out[i][263U] = 0U;
    out[i][264U] = 0U;
    out[i][265U] = 0U;
    out[i][266U] = 0U;
    out[i][267U] = 0U;
    out[i][268U] = 0U;
    out[i][269U] = 0U;
    out[i][270U] = 0U;
    out[i][271U] = 0U;
    out[i][272U] = 0U;
    out[i][273U] = 0U;
    out[i][274U] = 0U;
    out[i][275U] = 0U;
    out[i][276U] = 0U;
    out[i][277U] = 0U;
    out[i][278U] = 0U;
    out[i][279U] = 0U;
    out[i][280U] = 0U;
    out[i][281U] = 0U;
    out[i][282U] = 0U;
    out[i][283U] = 0U;
    out[i][284U] = 0U;
    out[i][285U] = 0U;
    out[i][286U] = 0U;
    out[i][287U] = 0U;
    out[i][288U] = 0U;
    out[i][289U] = 0U;
    out[i][290U] = 0U;
    out[i][291U] = 0U;
    out[i][292U] = 0U;
    out[i][293U] = 0U;
    out[i][294U] = 0U;
    out[i][295U] = 0U;
    out[i][296U] = 0U;
    out[i][297U] = 0U;
    out[i][298U] = 0U;
    out[i][299U] = 0U;
    out[i][300U] = 0U;
    out[i][301U] = 0U;
    out[i][302U] = 0U;
    out[i][303U] = 0U;
    out[i][304U] = 0U;
    out[i][305U] = 0U;
    out[i][306U] = 0U;
    out[i][307U] = 0U;
    out[i][308U] = 0U;
    out[i][309U] = 0U;
    out[i][310U] = 0U;
    out[i][311U] = 0U;
    out[i][312U] = 0U;
    out[i][313U] = 0U;
    out[i][314U] = 0U;
    out[i][315U] = 0U;
    out[i][316U] = 0U;
    out[i][317U] = 0U;
    out[i][318U] = 0U;
    out[i][319U] = 0U;
    out[i][320U] = 0U;
    out[i][321U] = 0U;
    out[i][322U] = 0U;
    out[i][323U] = 0U;
    out[i][324U] = 0U;
    out[i][325U] = 0U;
    out[i][326U] = 0U;
    out[i][327U] = 0U;
    out[i][328U] = 0U;
    out[i][329U] = 0U;
    out[i][330U] = 0U;
    out[i][331U] = 0U;
    out[i][332U] = 0U;
    out[i][333U] = 0U;
    out[i][334U] = 0U;
    out[i][335U] = 0U;
    out[i][336U] = 0U;
    out[i][337U] = 0U;
    out[i][338U] = 0U;
    out[i][339U] = 0U;
    out[i][340U] = 0U;
    out[i][341U] = 0U;
    out[i][342U] = 0U;
    out[i][343U] = 0U;
    out[i][344U] = 0U;
    out[i][345U] = 0U;
    out[i][346U] = 0U;
    out[i][347U] = 0U;
    out[i][348U] = 0U;
    out[i][349U] = 0U;
    out[i][350U] = 0U;
    out[i][351U] = 0U;
    out[i][352U] = 0U;
    out[i][353U] = 0U;
    out[i][354U] = 0U;
    out[i][355U] = 0U;
    out[i][356U] = 0U;
    out[i][357U] = 0U;
    out[i][358U] = 0U;
    out[i][359U] = 0U;
    out[i][360U] = 0U;
    out[i][361U] = 0U;
    out[i][362U] = 0U;
    out[i][363U] = 0U;
    out[i][364U] = 0U;
    out[i][365U] = 0U;
    out[i][366U] = 0U;
    out[i][367U] = 0U;
    out[i][368U] = 0U;
    out[i][369U] = 0U;
    out[i][370U] = 0U;
    out[i][371U] = 0U;
    out[i][372U] = 0U;
    out[i][373U] = 0U;
    out[i][374U] = 0U;
    out[i][375U] = 0U;
    out[i][376U] = 0U;
    out[i][377U] = 0U;
    out[i][378U] = 0U;
    out[i][379U] = 0U;
    out[i][380U] = 0U;
    out[i][381U] = 0U;
    out[i][382U] = 0U;
    out[i][383U] = 0U;
    out[i][384U] = 0U;
    out[i][385U] = 0U;
    out[i][386U] = 0U;
    out[i][387U] = 0U;
    out[i][388U] = 0U;
    out[i][389U] = 0U;
    out[i][390U] = 0U;
    out[i][391U] = 0U;
    out[i][392U] = 0U;
    out[i][393U] = 0U;
    out[i][394U] = 0U;
    out[i][395U] = 0U;
    out[i][396U] = 0U;
    out[i][397U] = 0U;
    out[i][398U] = 0U;
    out[i][399U] = 0U;
    out[i][400U] = 0U;
    out[i][401U] = 0U;
    out[i][402U] = 0U;
    out[i][403U] = 0U;
    out[i][404U] = 0U;
    out[i][405U] = 0U;
    out[i][406U] = 0U;
    out[i][407U] = 0U;
    out[i][408U] = 0U;
    out[i][409U] = 0U;
    out[i][410U] = 0U;
    out[i][411U] = 0U;
    out[i][412U] = 0U;
    out[i][413U] = 0U;
    out[i][414U] = 0U;
    out[i][415U] = 0U;
    out[i][416U] = 0U;
    out[i][417U] = 0U;
    out[i][418U] = 0U;
    out[i][419U] = 0U;
    out[i][420U] = 0U;
    out[i][421U] = 0U;
    out[i][422U] = 0U;
    out[i][423U] = 0U;
    out[i][424U] = 0U;
    out[i][425U] = 0U;
    out[i][426U] = 0U;
    out[i][427U] = 0U;
    out[i][428U] = 0U;
    out[i][429U] = 0U;
    out[i][430U] = 0U;
    out[i][431U] = 0U;
    out[i][432U] = 0U;
    out[i][433U] = 0U;
    out[i][434U] = 0U;
    out[i][435U] = 0U;
    out[i][436U] = 0U;
    out[i][437U] = 0U;
    out[i][438U] = 0U;
    out[i][439U] = 0U;
    out[i][440U] = 0U;
    out[i][441U] = 0U;
    out[i][442U] = 0U;
    out[i][443U] = 0U;
    out[i][444U] = 0U;
    out[i][445U] = 0U;
    out[i][446U] = 0U;
    out[i][447U] = 0U;
    out[i][448U] = 0U;
    out[i][449U] = 0U;
    out[i][450U] = 0U;
    out[i][451U] = 0U;
    out[i][452U] = 0U;
    out[i][453U] = 0U;
    out[i][454U] = 0U;
    out[i][455U] = 0U;
    out[i][456U] = 0U;
    out[i][457U] = 0U;
    out[i][458U] = 0U;
    out[i][459U] = 0U;
    out[i][460U] = 0U;
    out[i][461U] = 0U;
    out[i][462U] = 0U;
    out[i][463U] = 0U;
    out[i][464U] = 0U;
    out[i][465U] = 0U;
    out[i][466U] = 0U;
    out[i][467U] = 0U;
    out[i][468U] = 0U;
    out[i][469U] = 0U;
    out[i][470U] = 0U;
    out[i][471U] = 0U;
    out[i][472U] = 0U;
    out[i][473U] = 0U;
    out[i][474U] = 0U;
    out[i][475U] = 0U;
    out[i][476U] = 0U;
    out[i][477U] = 0U;
    out[i][478U] = 0U;
    out[i][479U] = 0U;
    out[i][480U] = 0U;
    out[i][481U] = 0U;
    out[i][482U] = 0U;
    out[i][483U] = 0U;
    out[i][484U] = 0U;
    out[i][485U] = 0U;
    out[i][486U] = 0U;
    out[i][487U] = 0U;
    out[i][488U] = 0U;
    out[i][489U] = 0U;
    out[i][490U] = 0U;
    out[i][491U] = 0U;
    out[i][492U] = 0U;
    out[i][493U] = 0U;
    out[i][494U] = 0U;
    out[i][495U] = 0U;
    out[i][496U] = 0U;
    out[i][497U] = 0U;
    out[i][498U] = 0U;
    out[i][499U] = 0U;
    out[i][500U] = 0U;
    out[i][501U] = 0U;
    out[i][502U] = 0U;
    out[i][503U] = 0U;
    out[i][504U] = 0U;
    out[i][505U] = 0U;
    out[i][506U] = 0U;
    out[i][507U] = 0U;
    out[i][508U] = 0U;
    out[i][509U] = 0U;
    out[i][510U] = 0U;
    out[i][511U] = 0U;
    out[i][512U] = 0U;
    out[i][513U] = 0U;
    out[i][514U] = 0U;
    out[i][515U] = 0U;
    out[i][516U] = 0U;
    out[i][517U] = 0U;
    out[i][518U] = 0U;
    out[i][519U] = 0U;
    out[i][520U] = 0U;
    out[i][521U] = 0U;
    out[i][522U] = 0U;
    out[i][523U] = 0U;
    out[i][524U] = 0U;
    out[i][525U] = 0U;
    out[i][526U] = 0U;
    out[i][527U] = 0U;
    out[i][528U] = 0U;
    out[i][529U] = 0U;
    out[i][530U] = 0U;
    out[i][531U] = 0U;
    out[i][532U] = 0U;
    out[i][533U] = 0U;
    out[i][534U] = 0U;
    out[i][535U] = 0U;
    out[i][536U] = 0U;
    out[i][537U] = 0U;
    out[i][538U] = 0U;
    out[i][539U] = 0U;
    out[i][540U] = 0U;
    out[i][541U] = 0U;
    out[i][542U] = 0U;
    out[i][543U] = 0U;
    out[i][544U] = 0U;
    out[i][545U] = 0U;
    out[i][546U] = 0U;
    out[i][547U] = 0U;
    out[i][548U] = 0U;
    out[i][549U] = 0U;
    out[i][550U] = 0U;
    out[i][551U] = 0U;
    out[i][552U] = 0U;
    out[i][553U] = 0U;
    out[i][554U] = 0U;
    out[i][555U] = 0U;
    out[i][556U] = 0U;
    out[i][557U] = 0U;
    out[i][558U] = 0U;
    out[i][559U] = 0U;
    out[i][560U] = 0U;
    out[i][561U] = 0U;
    out[i][562U] = 0U;
    out[i][563U] = 0U;
    out[i][564U] = 0U;
    out[i][565U] = 0U;
    out[i][566U] = 0U;
    out[i][567U] = 0U;
    out[i][568U] = 0U;
    out[i][569U] = 0U;
    out[i][570U] = 0U;
    out[i][571U] = 0U;
    out[i][572U] = 0U;
    out[i][573U] = 0U;
    out[i][574U] = 0U;
    out[i][575U] = 0U;
    out[i][576U] = 0U;
    out[i][577U] = 0U;
    out[i][578U] = 0U;
    out[i][579U] = 0U;
    out[i][580U] = 0U;
    out[i][581U] = 0U;
    out[i][582U] = 0U;
    out[i][583U] = 0U;
    out[i][584U] = 0U;
    out[i][585U] = 0U;
    out[i][586U] = 0U;
    out[i][587U] = 0U;
    out[i][588U] = 0U;
    out[i][589U] = 0U;
    out[i][590U] = 0U;
    out[i][591U] = 0U;
    out[i][592U] = 0U;
    out[i][593U] = 0U;
    out[i][594U] = 0U;
    out[i][595U] = 0U;
    out[i][596U] = 0U;
    out[i][597U] = 0U;
    out[i][598U] = 0U;
    out[i][599U] = 0U;
    out[i][600U] = 0U;
    out[i][601U] = 0U;
    out[i][602U] = 0U;
    out[i][603U] = 0U;
    out[i][604U] = 0U;
    out[i][605U] = 0U;
    out[i][606U] = 0U;
    out[i][607U] = 0U;
    out[i][608U] = 0U;
    out[i][609U] = 0U;
    out[i][610U] = 0U;
    out[i][611U] = 0U;
    out[i][612U] = 0U;
    out[i][613U] = 0U;
    out[i][614U] = 0U;
    out[i][615U] = 0U;
    out[i][616U] = 0U;
    out[i][617U] = 0U;
    out[i][618U] = 0U;
    out[i][619U] = 0U;
    out[i][620U] = 0U;
    out[i][621U] = 0U;
    out[i][622U] = 0U;
    out[i][623U] = 0U;
    out[i][624U] = 0U;
    out[i][625U] = 0U;
    out[i][626U] = 0U;
    out[i][627U] = 0U;
    out[i][628U] = 0U;
    out[i][629U] = 0U;
    out[i][630U] = 0U;
    out[i][631U] = 0U;
    out[i][632U] = 0U;
    out[i][633U] = 0U;
    out[i][634U] = 0U;
    out[i][635U] = 0U;
    out[i][636U] = 0U;
    out[i][637U] = 0U;
    out[i][638U] = 0U;
    out[i][639U] = 0U;
    out[i][640U] = 0U;
    out[i][641U] = 0U;
    out[i][642U] = 0U;
    out[i][643U] = 0U;
    out[i][644U] = 0U;
    out[i][645U] = 0U;
    out[i][646U] = 0U;
    out[i][647U] = 0U;
    out[i][648U] = 0U;
    out[i][649U] = 0U;
    out[i][650U] = 0U;
    out[i][651U] = 0U;
    out[i][652U] = 0U;
    out[i][653U] = 0U;
    out[i][654U] = 0U;
    out[i][655U] = 0U;
    out[i][656U] = 0U;
    out[i][657U] = 0U;
    out[i][658U] = 0U;
    out[i][659U] = 0U;
    out[i][660U] = 0U;
    out[i][661U] = 0U;
    out[i][662U] = 0U;
    out[i][663U] = 0U;
    out[i][664U] = 0U;
    out[i][665U] = 0U;
    out[i][666U] = 0U;
    out[i][667U] = 0U;
    out[i][668U] = 0U;
    out[i][669U] = 0U;
    out[i][670U] = 0U;
    out[i][671U] = 0U;
    out[i][672U] = 0U;
    out[i][673U] = 0U;
    out[i][674U] = 0U;
    out[i][675U] = 0U;
    out[i][676U] = 0U;
    out[i][677U] = 0U;
    out[i][678U] = 0U;
    out[i][679U] = 0U;
    out[i][680U] = 0U;
    out[i][681U] = 0U;
    out[i][682U] = 0U;
    out[i][683U] = 0U;
    out[i][684U] = 0U;
    out[i][685U] = 0U;
    out[i][686U] = 0U;
    out[i][687U] = 0U;
    out[i][688U] = 0U;
    out[i][689U] = 0U;
    out[i][690U] = 0U;
    out[i][691U] = 0U;
    out[i][692U] = 0U;
    out[i][693U] = 0U;
    out[i][694U] = 0U;
    out[i][695U] = 0U;
    out[i][696U] = 0U;
    out[i][697U] = 0U;
    out[i][698U] = 0U;
    out[i][699U] = 0U;
    out[i][700U] = 0U;
    out[i][701U] = 0U;
    out[i][702U] = 0U;
    out[i][703U] = 0U;
    out[i][704U] = 0U;
    out[i][705U] = 0U;
    out[i][706U] = 0U;
    out[i][707U] = 0U;
    out[i][708U] = 0U;
    out[i][709U] = 0U;
    out[i][710U] = 0U;
    out[i][711U] = 0U;
    out[i][712U] = 0U;
    out[i][713U] = 0U;
    out[i][714U] = 0U;
    out[i][715U] = 0U;
    out[i][716U] = 0U;
    out[i][717U] = 0U;
    out[i][718U] = 0U;
    out[i][719U] = 0U;
    out[i][720U] = 0U;
    out[i][721U] = 0U;
    out[i][722U] = 0U;
    out[i][723U] = 0U;
    out[i][724U] = 0U;
    out[i][725U] = 0U;
    out[i][726U] = 0U;
    out[i][727U] = 0U;
    out[i][728U] = 0U;
    out[i][729U] = 0U;
    out[i][730U] = 0U;
    out[i][731U] = 0U;
    out[i][732U] = 0U;
    out[i][733U] = 0U;
    out[i][734U] = 0U;
    out[i][735U] = 0U;
    out[i][736U] = 0U;
    out[i][737U] = 0U;
    out[i][738U] = 0U;
    out[i][739U] = 0U;
    out[i][740U] = 0U;
    out[i][741U] = 0U;
    out[i][742U] = 0U;
    out[i][743U] = 0U;
    out[i][744U] = 0U;
    out[i][745U] = 0U;
    out[i][746U] = 0U;
    out[i][747U] = 0U;
    out[i][748U] = 0U;
    out[i][749U] = 0U;
    out[i][750U] = 0U;
    out[i][751U] = 0U;
    out[i][752U] = 0U;
    out[i][753U] = 0U;
    out[i][754U] = 0U;
    out[i][755U] = 0U;
    out[i][756U] = 0U;
    out[i][757U] = 0U;
    out[i][758U] = 0U;
    out[i][759U] = 0U;
    out[i][760U] = 0U;
    out[i][761U] = 0U;
    out[i][762U] = 0U;
    out[i][763U] = 0U;
    out[i][764U] = 0U;
    out[i][765U] = 0U;
    out[i][766U] = 0U;
    out[i][767U] = 0U;
    out[i][768U] = 0U;
    out[i][769U] = 0U;
    out[i][770U] = 0U;
    out[i][771U] = 0U;
    out[i][772U] = 0U;
    out[i][773U] = 0U;
    out[i][774U] = 0U;
    out[i][775U] = 0U;
    out[i][776U] = 0U;
    out[i][777U] = 0U;
    out[i][778U] = 0U;
    out[i][779U] = 0U;
    out[i][780U] = 0U;
    out[i][781U] = 0U;
    out[i][782U] = 0U;
    out[i][783U] = 0U;
    out[i][784U] = 0U;
    out[i][785U] = 0U;
    out[i][786U] = 0U;
    out[i][787U] = 0U;
    out[i][788U] = 0U;
    out[i][789U] = 0U;
    out[i][790U] = 0U;
    out[i][791U] = 0U;
    out[i][792U] = 0U;
    out[i][793U] = 0U;
    out[i][794U] = 0U;
    out[i][795U] = 0U;
    out[i][796U] = 0U;
    out[i][797U] = 0U;
    out[i][798U] = 0U;
    out[i][799U] = 0U;
    out[i][800U] = 0U;
    out[i][801U] = 0U;
    out[i][802U] = 0U;
    out[i][803U] = 0U;
    out[i][804U] = 0U;
    out[i][805U] = 0U;
    out[i][806U] = 0U;
    out[i][807U] = 0U;
    out[i][808U] = 0U;
    out[i][809U] = 0U;
    out[i][810U] = 0U;
    out[i][811U] = 0U;
    out[i][812U] = 0U;
    out[i][813U] = 0U;
    out[i][814U] = 0U;
    out[i][815U] = 0U;
    out[i][816U] = 0U;
    out[i][817U] = 0U;
    out[i][818U] = 0U;
    out[i][819U] = 0U;
    out[i][820U] = 0U;
    out[i][821U] = 0U;
    out[i][822U] = 0U;
    out[i][823U] = 0U;
    out[i][824U] = 0U;
    out[i][825U] = 0U;
    out[i][826U] = 0U;
    out[i][827U] = 0U;
    out[i][828U] = 0U;
    out[i][829U] = 0U;
    out[i][830U] = 0U;
    out[i][831U] = 0U;
    out[i][832U] = 0U;
    out[i][833U] = 0U;
    out[i][834U] = 0U;
    out[i][835U] = 0U;
    out[i][836U] = 0U;
    out[i][837U] = 0U;
    out[i][838U] = 0U;
    out[i][839U] = 0U;
  }
  bool uu____0;
  if (!libcrux_platform_simd256_support())
    uu____0 = true;
  else
    uu____0 = !false;
  if (uu____0)
  {
    core_ops_range_Range__size_t lit;
    lit.start = (size_t)0U;
    lit.end = (size_t)2U;
    core_ops_range_Range__size_t
    iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
    while (true)
    {
      core_option_Option__size_t
      uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
      if (!(uu____1.tag == core_option_None))
      {
        if (uu____1.tag == core_option_Some)
        {
          size_t i = uu____1.f0;
          uint8_t uu____2[840U];
          libcrux_digest_shake128((size_t)840U,
            Eurydice_array_to_slice((size_t)34U, input[i], uint8_t),
            uu____2);
          memcpy(out[i], uu____2, (size_t)840U * sizeof (uint8_t));
        }
        else
        {
          KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
          KRML_HOST_EXIT(255U);
        }
      }
    }
  }
  else
  {
    Eurydice_slice uu____3 = Eurydice_array_to_slice((size_t)34U, input[0U], uint8_t);
    Eurydice_slice uu____4 = Eurydice_array_to_slice((size_t)34U, input[1U], uint8_t);
    Eurydice_slice uu____5 = Eurydice_array_to_slice((size_t)34U, input[0U], uint8_t);
    __uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t_
    uu____6 =
      libcrux_digest_shake128x4((size_t)840U,
        uu____3,
        uu____4,
        uu____5,
        Eurydice_array_to_slice((size_t)34U, input[1U], uint8_t));
    uint8_t d0[840U];
    memcpy(d0, uu____6.fst, (size_t)840U * sizeof (uint8_t));
    uint8_t d1[840U];
    memcpy(d1, uu____6.snd, (size_t)840U * sizeof (uint8_t));
    uint8_t uu____7[840U];
    memcpy(uu____7, d0, (size_t)840U * sizeof (uint8_t));
    memcpy(out[0U], uu____7, (size_t)840U * sizeof (uint8_t));
    uint8_t uu____8[840U];
    memcpy(uu____8, d1, (size_t)840U * sizeof (uint8_t));
    memcpy(out[1U], uu____8, (size_t)840U * sizeof (uint8_t));
  }
  uint8_t uu____9[2U][840U];
  memcpy(uu____9, out, (size_t)2U * sizeof (uint8_t [840U]));
  memcpy(ret, uu____9, (size_t)2U * sizeof (uint8_t [840U]));
}

K___libcrux_kyber_arithmetic_PolynomialRingElement_2size_t__2size_t__core_option_Option__libcrux_kyber_types_Error
libcrux_kyber_matrix_sample_matrix_A___2size_t(uint8_t seed[34U], bool transpose)
{
  int32_t A_transpose[2U][2U][256U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
    memcpy(A_transpose[i][0U],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  core_option_Option__libcrux_kyber_types_Error sampling_A_error;
  sampling_A_error.tag = core_option_None;
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = (size_t)2U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i0 = uu____0.f0;
        uint8_t uu____1[34U];
        memcpy(uu____1, seed, (size_t)34U * sizeof (uint8_t));
        uint8_t seeds[2U][34U];
        for (size_t i = (size_t)0U; i < (size_t)2U; i++)
          memcpy(seeds[i], uu____1, (size_t)34U * sizeof (uint8_t));
        core_ops_range_Range__size_t lit0;
        lit0.start = (size_t)0U;
        lit0.end = (size_t)2U;
        core_ops_range_Range__size_t
        iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____2 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
          if (uu____2.tag == core_option_None)
            break;
          else if (uu____2.tag == core_option_Some)
          {
            size_t j = uu____2.f0;
            seeds[j][32U] = (uint8_t)i0;
            seeds[j][33U] = (uint8_t)j;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        uint8_t uu____3[2U][34U];
        memcpy(uu____3, seeds, (size_t)2U * sizeof (uint8_t [34U]));
        uint8_t xof_bytes[2U][840U];
        libcrux_kyber_hash_functions_XOFx4___2size_t(uu____3, xof_bytes);
        core_ops_range_Range__size_t lit;
        lit.start = (size_t)0U;
        lit.end = (size_t)2U;
        core_ops_range_Range__size_t
        iter0 = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____4 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
          if (uu____4.tag == core_option_None)
            break;
          else if (uu____4.tag == core_option_Some)
          {
            size_t j = uu____4.f0;
            uint8_t uu____5[840U];
            memcpy(uu____5, xof_bytes[j], (size_t)840U * sizeof (uint8_t));
            K___libcrux_kyber_arithmetic_PolynomialRingElement_core_option_Option_libcrux_kyber_types_Error
            uu____6 = libcrux_kyber_sampling_sample_from_uniform_distribution___840size_t(uu____5);
            int32_t sampled[256U];
            memcpy(sampled, uu____6.fst, (size_t)256U * sizeof (int32_t));
            core_option_Option__libcrux_kyber_types_Error error = uu____6.snd;
            if (core_option__core__option__Option_T___is_some(&error, libcrux_kyber_types_Error))
              sampling_A_error = error;
            if (transpose)
              memcpy(A_transpose[j][i0], sampled, (size_t)256U * sizeof (int32_t));
            else
              memcpy(A_transpose[i0][j], sampled, (size_t)256U * sizeof (int32_t));
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____7[2U][2U][256U];
    memcpy(uu____7, A_transpose, (size_t)2U * sizeof (int32_t [2U][256U]));
    K___libcrux_kyber_arithmetic_PolynomialRingElement_2size_t__2size_t__core_option_Option__libcrux_kyber_types_Error
    lit;
    memcpy(lit.fst, uu____7, (size_t)2U * sizeof (int32_t [2U][256U]));
    lit.snd = sampling_A_error;
    return lit;
  }
}

void libcrux_kyber_hash_functions_PRF___192size_t(Eurydice_slice input, uint8_t ret[192U])
{
  uint8_t ret0[192U];
  libcrux_digest_shake256((size_t)192U, input, ret0);
  memcpy(ret, ret0, (size_t)192U * sizeof (uint8_t));
}

void
libcrux_kyber_sampling_sample_from_binomial_distribution___3size_t(
  Eurydice_slice randomness,
  int32_t ret[256U]
)
{
  int32_t uu____0[256U];
  libcrux_kyber_sampling_sample_from_binomial_distribution_3(randomness, uu____0);
  memcpy(ret, uu____0, (size_t)256U * sizeof (int32_t));
}

K___libcrux_kyber_arithmetic_PolynomialRingElement_2size_t__uint8_t
libcrux_kyber_ind_cpa_sample_vector_cbd_then_ntt___2size_t_3size_t_192size_t(
  uint8_t prf_input[33U],
  uint8_t domain_separator
)
{
  int32_t re_as_ntt[2U][256U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
    memcpy(re_as_ntt[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = (size_t)2U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        prf_input[32U] = domain_separator;
        domain_separator = (uint32_t)domain_separator + 1U;
        uint8_t prf_output[192U];
        libcrux_kyber_hash_functions_PRF___192size_t(Eurydice_array_to_slice((size_t)33U,
            prf_input,
            uint8_t),
          prf_output);
        int32_t r[256U];
        libcrux_kyber_sampling_sample_from_binomial_distribution___3size_t(Eurydice_array_to_slice((size_t)192U,
            prf_output,
            uint8_t),
          r);
        int32_t uu____1[256U];
        libcrux_kyber_ntt_ntt_binomially_sampled_ring_element(r, uu____1);
        memcpy(re_as_ntt[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[2U][256U];
    memcpy(uu____2, re_as_ntt, (size_t)2U * sizeof (int32_t [256U]));
    K___libcrux_kyber_arithmetic_PolynomialRingElement_2size_t__uint8_t lit;
    memcpy(lit.fst, uu____2, (size_t)2U * sizeof (int32_t [256U]));
    lit.snd = domain_separator;
    return lit;
  }
}

void
libcrux_kyber_arithmetic_add_to_ring_element___2size_t(
  int32_t lhs[256U],
  int32_t (*rhs)[256U],
  int32_t ret[256U]
)
{
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, lhs, int32_t),
      int32_t);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        size_t uu____1 = i;
        lhs[uu____1] = lhs[uu____1] + rhs[0U][i];
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, lhs, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_matrix_compute_As_plus_e___2size_t(
  int32_t (*matrix_A)[2U][256U],
  int32_t (*s_as_ntt)[256U],
  int32_t (*error_as_ntt)[256U],
  int32_t ret[2U][256U]
)
{
  int32_t result[2U][256U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
    memcpy(result[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)2U,
        matrix_A,
        Eurydice_error_t_cg_array),
      int32_t [2U][256U]);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        core_ops_range_Range__size_t lit;
        lit.start = (size_t)0U;
        lit.end =
          core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)2U,
              matrix_A[i],
              int32_t [256U]),
            int32_t [256U]);
        core_ops_range_Range__size_t
        iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
          if (uu____1.tag == core_option_None)
            break;
          else if (uu____1.tag == core_option_Some)
          {
            size_t j = uu____1.f0;
            int32_t product[256U];
            libcrux_kyber_ntt_ntt_multiply(&matrix_A[i][j], &s_as_ntt[j], product);
            int32_t uu____2[256U];
            libcrux_kyber_arithmetic_add_to_ring_element___2size_t(result[i], &product, uu____2);
            memcpy(result[i], uu____2, (size_t)256U * sizeof (int32_t));
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        core_ops_range_Range__size_t lit0;
        lit0.start = (size_t)0U;
        lit0.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
        core_ops_range_Range__size_t
        iter0 = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____3 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
          if (uu____3.tag == core_option_None)
            break;
          else if (uu____3.tag == core_option_Some)
          {
            size_t j = uu____3.f0;
            int32_t
            coefficient_normal_form = libcrux_kyber_arithmetic_to_standard_domain(result[i][j]);
            int32_t
            uu____4 =
              libcrux_kyber_arithmetic_barrett_reduce(coefficient_normal_form + error_as_ntt[i][j]);
            result[i][j] = uu____4;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____5[2U][256U];
    memcpy(uu____5, result, (size_t)2U * sizeof (int32_t [256U]));
    memcpy(ret, uu____5, (size_t)2U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_ind_cpa_serialize_secret_key___2size_t_768size_t(
  int32_t key[2U][256U],
  uint8_t ret[768U]
)
{
  uint8_t out[768U];
  for (size_t i = (size_t)0U; i < (size_t)768U; i++)
    out[i] = 0U;
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)2U, key, int32_t [256U]),
      int32_t [256U]);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t re[256U];
        memcpy(re, key[i], (size_t)256U * sizeof (int32_t));
        core_ops_range_Range__size_t lit;
        lit.start = i * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        lit.end = (i + (size_t)1U) * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        Eurydice_slice
        uu____1 =
          Eurydice_array_to_subslice((size_t)768U,
            out,
            lit,
            uint8_t,
            core_ops_range_Range__size_t);
        uint8_t ret[384U];
        libcrux_kyber_serialize_serialize_uncompressed_ring_element(re, ret);
        core_slice___Slice_T___copy_from_slice(uu____1,
          Eurydice_array_to_slice((size_t)384U, ret, uint8_t),
          uint8_t);
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____2[768U];
    memcpy(uu____2, out, (size_t)768U * sizeof (uint8_t));
    memcpy(ret, uu____2, (size_t)768U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_ind_cpa_serialize_public_key___2size_t_768size_t_800size_t(
  int32_t t_as_ntt[2U][256U],
  Eurydice_slice seed_for_a,
  uint8_t ret[800U]
)
{
  uint8_t public_key_serialized[800U];
  for (size_t i = (size_t)0U; i < (size_t)800U; i++)
    public_key_serialized[i] = 0U;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)768U;
  Eurydice_slice
  uu____0 =
    Eurydice_array_to_subslice((size_t)800U,
      public_key_serialized,
      lit,
      uint8_t,
      core_ops_range_Range__size_t);
  int32_t uu____1[2U][256U];
  memcpy(uu____1, t_as_ntt, (size_t)2U * sizeof (int32_t [256U]));
  uint8_t ret0[768U];
  libcrux_kyber_ind_cpa_serialize_secret_key___2size_t_768size_t(uu____1, ret0);
  core_slice___Slice_T___copy_from_slice(uu____0,
    Eurydice_array_to_slice((size_t)768U, ret0, uint8_t),
    uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice_from((size_t)800U,
      public_key_serialized,
      (size_t)768U,
      uint8_t,
      size_t),
    seed_for_a,
    uint8_t);
  uint8_t uu____2[800U];
  memcpy(uu____2, public_key_serialized, (size_t)800U * sizeof (uint8_t));
  memcpy(ret, uu____2, (size_t)800U * sizeof (uint8_t));
}

K___uint8_t_768size_t____uint8_t_800size_t__core_option_Option__libcrux_kyber_types_Error
libcrux_kyber_ind_cpa_generate_keypair___2size_t_768size_t_800size_t_768size_t_3size_t_192size_t(
  Eurydice_slice key_generation_seed
)
{
  uint8_t hashed[64U];
  libcrux_kyber_hash_functions_G(key_generation_seed, hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____0 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U, hashed, uint8_t),
      (size_t)32U,
      uint8_t);
  Eurydice_slice seed_for_A = uu____0.fst;
  Eurydice_slice seed_for_secret_and_error = uu____0.snd;
  uint8_t ret[34U];
  libcrux_kyber_ind_cpa_into_padded_array___34size_t(seed_for_A, ret);
  K___libcrux_kyber_arithmetic_PolynomialRingElement_2size_t__2size_t__core_option_Option__libcrux_kyber_types_Error
  uu____1 = libcrux_kyber_matrix_sample_matrix_A___2size_t(ret, true);
  int32_t A_transpose[2U][2U][256U];
  memcpy(A_transpose, uu____1.fst, (size_t)2U * sizeof (int32_t [2U][256U]));
  core_option_Option__libcrux_kyber_types_Error sampling_A_error = uu____1.snd;
  uint8_t prf_input[33U];
  libcrux_kyber_ind_cpa_into_padded_array___33size_t(seed_for_secret_and_error, prf_input);
  uint8_t uu____2[33U];
  memcpy(uu____2, prf_input, (size_t)33U * sizeof (uint8_t));
  K___libcrux_kyber_arithmetic_PolynomialRingElement_2size_t__uint8_t
  uu____3 =
    libcrux_kyber_ind_cpa_sample_vector_cbd_then_ntt___2size_t_3size_t_192size_t(uu____2,
      0U);
  int32_t secret_as_ntt[2U][256U];
  memcpy(secret_as_ntt, uu____3.fst, (size_t)2U * sizeof (int32_t [256U]));
  uint8_t domain_separator = uu____3.snd;
  uint8_t uu____4[33U];
  memcpy(uu____4, prf_input, (size_t)33U * sizeof (uint8_t));
  int32_t error_as_ntt[2U][256U];
  memcpy(error_as_ntt,
    libcrux_kyber_ind_cpa_sample_vector_cbd_then_ntt___2size_t_3size_t_192size_t(uu____4,
      domain_separator).fst,
    (size_t)2U * sizeof (int32_t [256U]));
  int32_t t_as_ntt[2U][256U];
  libcrux_kyber_matrix_compute_As_plus_e___2size_t(A_transpose,
    secret_as_ntt,
    error_as_ntt,
    t_as_ntt);
  int32_t uu____5[2U][256U];
  memcpy(uu____5, t_as_ntt, (size_t)2U * sizeof (int32_t [256U]));
  uint8_t public_key_serialized[800U];
  libcrux_kyber_ind_cpa_serialize_public_key___2size_t_768size_t_800size_t(uu____5,
    seed_for_A,
    public_key_serialized);
  int32_t uu____6[2U][256U];
  memcpy(uu____6, secret_as_ntt, (size_t)2U * sizeof (int32_t [256U]));
  uint8_t secret_key_serialized[768U];
  libcrux_kyber_ind_cpa_serialize_secret_key___2size_t_768size_t(uu____6, secret_key_serialized);
  uint8_t uu____7[768U];
  memcpy(uu____7, secret_key_serialized, (size_t)768U * sizeof (uint8_t));
  uint8_t uu____8[800U];
  memcpy(uu____8, public_key_serialized, (size_t)800U * sizeof (uint8_t));
  K___uint8_t_768size_t____uint8_t_800size_t__core_option_Option__libcrux_kyber_types_Error lit;
  memcpy(lit.fst.fst, uu____7, (size_t)768U * sizeof (uint8_t));
  memcpy(lit.fst.snd, uu____8, (size_t)800U * sizeof (uint8_t));
  lit.snd = sampling_A_error;
  return lit;
}

void
libcrux_kyber_serialize_kem_secret_key___1632size_t(
  Eurydice_slice private_key,
  Eurydice_slice public_key,
  Eurydice_slice implicit_rejection_value,
  uint8_t ret[1632U]
)
{
  uint8_t out[1632U];
  for (size_t i = (size_t)0U; i < (size_t)1632U; i++)
    out[i] = 0U;
  size_t pointer = (size_t)0U;
  uint8_t *uu____0 = out;
  size_t uu____1 = pointer;
  core_ops_range_Range__size_t lit0;
  lit0.start = pointer;
  lit0.end = uu____1 + core_slice___Slice_T___len(private_key, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)1632U,
      uu____0,
      lit0,
      uint8_t,
      core_ops_range_Range__size_t),
    private_key,
    uint8_t);
  pointer = pointer + core_slice___Slice_T___len(private_key, uint8_t);
  uint8_t *uu____2 = out;
  size_t uu____3 = pointer;
  core_ops_range_Range__size_t lit1;
  lit1.start = pointer;
  lit1.end = uu____3 + core_slice___Slice_T___len(public_key, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)1632U,
      uu____2,
      lit1,
      uint8_t,
      core_ops_range_Range__size_t),
    public_key,
    uint8_t);
  pointer = pointer + core_slice___Slice_T___len(public_key, uint8_t);
  core_ops_range_Range__size_t lit2;
  lit2.start = pointer;
  lit2.end = pointer + libcrux_kyber_constants_H_DIGEST_SIZE;
  Eurydice_slice
  uu____4 =
    Eurydice_array_to_subslice((size_t)1632U,
      out,
      lit2,
      uint8_t,
      core_ops_range_Range__size_t);
  uint8_t ret0[32U];
  libcrux_kyber_hash_functions_H(public_key, ret0);
  core_slice___Slice_T___copy_from_slice(uu____4,
    Eurydice_array_to_slice((size_t)32U, ret0, uint8_t),
    uint8_t);
  pointer = pointer + libcrux_kyber_constants_H_DIGEST_SIZE;
  uint8_t *uu____5 = out;
  size_t uu____6 = pointer;
  core_ops_range_Range__size_t lit;
  lit.start = pointer;
  lit.end = uu____6 + core_slice___Slice_T___len(implicit_rejection_value, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)1632U,
      uu____5,
      lit,
      uint8_t,
      core_ops_range_Range__size_t),
    implicit_rejection_value,
    uint8_t);
  uint8_t uu____7[1632U];
  memcpy(uu____7, out, (size_t)1632U * sizeof (uint8_t));
  memcpy(ret, uu____7, (size_t)1632U * sizeof (uint8_t));
}

void
libcrux_kyber_types__libcrux_kyber__types__KyberPrivateKey_SIZE__8__from___1632size_t(
  uint8_t value[1632U],
  uint8_t ret[1632U]
)
{
  uint8_t uu____0[1632U];
  memcpy(uu____0, value, (size_t)1632U * sizeof (uint8_t));
  memcpy(ret, uu____0, (size_t)1632U * sizeof (uint8_t));
}

libcrux_kyber_types_KyberKeyPair___1632size_t_800size_t
libcrux_kyber_types__libcrux_kyber__types__KyberKeyPair_PRIVATE_KEY_SIZE__PUBLIC_KEY_SIZE___from___1632size_t_800size_t(
  uint8_t sk[1632U],
  uint8_t pk[800U]
)
{
  libcrux_kyber_types_KyberKeyPair___1632size_t_800size_t lit;
  memcpy(lit.sk, sk, (size_t)1632U * sizeof (uint8_t));
  memcpy(lit.pk, pk, (size_t)800U * sizeof (uint8_t));
  return lit;
}

core_result_Result__libcrux_kyber_types_KyberKeyPair__800size_t____1632size_t___libcrux_kyber_types_Error
libcrux_kyber_generate_keypair___2size_t_768size_t_1632size_t_800size_t_768size_t_3size_t_192size_t(
  uint8_t randomness[64U]
)
{
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = libcrux_kyber_constants_CPA_PKE_KEY_GENERATION_SEED_SIZE;
  Eurydice_slice
  ind_cpa_keypair_randomness =
    Eurydice_array_to_subslice((size_t)64U,
      randomness,
      lit0,
      uint8_t,
      core_ops_range_Range__size_t);
  Eurydice_slice
  implicit_rejection_value =
    Eurydice_array_to_subslice_from((size_t)64U,
      randomness,
      libcrux_kyber_constants_CPA_PKE_KEY_GENERATION_SEED_SIZE,
      uint8_t,
      size_t);
  K___uint8_t_768size_t____uint8_t_800size_t__core_option_Option__libcrux_kyber_types_Error
  uu____0 =
    libcrux_kyber_ind_cpa_generate_keypair___2size_t_768size_t_800size_t_768size_t_3size_t_192size_t(ind_cpa_keypair_randomness);
  uint8_t ind_cpa_private_key[768U];
  memcpy(ind_cpa_private_key, uu____0.fst.fst, (size_t)768U * sizeof (uint8_t));
  uint8_t public_key[800U];
  memcpy(public_key, uu____0.fst.snd, (size_t)800U * sizeof (uint8_t));
  core_option_Option__libcrux_kyber_types_Error sampling_a_error = uu____0.snd;
  Eurydice_slice uu____1 = Eurydice_array_to_slice((size_t)768U, ind_cpa_private_key, uint8_t);
  uint8_t secret_key_serialized[1632U];
  libcrux_kyber_serialize_kem_secret_key___1632size_t(uu____1,
    Eurydice_array_to_slice((size_t)800U, public_key, uint8_t),
    implicit_rejection_value,
    secret_key_serialized);
  core_result_Result__libcrux_kyber_types_KyberKeyPair__800size_t____1632size_t___libcrux_kyber_types_Error
  uu____2;
  if (sampling_a_error.tag == core_option_Some)
  {
    libcrux_kyber_types_Error error = sampling_a_error.f0;
    core_result_Result__libcrux_kyber_types_KyberKeyPair__800size_t____1632size_t___libcrux_kyber_types_Error
    lit;
    lit.tag = core_result_Err;
    lit.val.case_Err = error;
    uu____2 = lit;
  }
  else
  {
    uint8_t uu____3[1632U];
    memcpy(uu____3, secret_key_serialized, (size_t)1632U * sizeof (uint8_t));
    uint8_t private_key[1632U];
    libcrux_kyber_types__libcrux_kyber__types__KyberPrivateKey_SIZE__8__from___1632size_t(uu____3,
      private_key);
    uint8_t uu____4[1632U];
    memcpy(uu____4, private_key, (size_t)1632U * sizeof (uint8_t));
    uint8_t uu____5[800U];
    memcpy(uu____5, public_key, (size_t)800U * sizeof (uint8_t));
    core_result_Result__libcrux_kyber_types_KyberKeyPair__800size_t____1632size_t___libcrux_kyber_types_Error
    lit;
    lit.tag = core_result_Ok;
    lit.val.case_Ok =
      libcrux_kyber_types__libcrux_kyber__types__KyberKeyPair_PRIVATE_KEY_SIZE__PUBLIC_KEY_SIZE___from___1632size_t_800size_t(uu____4,
        uu____5);
    uu____2 = lit;
  }
  return uu____2;
}

core_result_Result__libcrux_kyber_types_KyberKeyPair__800size_t____1632size_t___libcrux_kyber_types_Error
libcrux_kyber_kyber512_generate_key_pair_512(uint8_t randomness[64U])
{
  uint8_t uu____0[64U];
  memcpy(uu____0, randomness, (size_t)64U * sizeof (uint8_t));
  return
    libcrux_kyber_generate_keypair___2size_t_768size_t_1632size_t_800size_t_768size_t_3size_t_192size_t(uu____0);
}

uint8_t
*libcrux_kyber_types__libcrux_kyber__types__KyberPublicKey_SIZE__18__as_slice___800size_t(
  uint8_t (*self)[800U]
)
{
  return self[0U];
}

void
libcrux_kyber_ind_cpa_deserialize_public_key___2size_t_768size_t(
  Eurydice_slice public_key,
  int32_t ret[2U][256U]
)
{
  int32_t t_as_ntt[2U][256U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
    memcpy(t_as_ntt[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = (size_t)768U / libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        core_ops_range_Range__size_t lit;
        lit.start = i * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        lit.end = i * (libcrux_kyber_constants_BYTES_PER_RING_ELEMENT + (size_t)1U);
        Eurydice_slice
        t_as_ntt_bytes =
          Eurydice_slice_subslice(public_key,
            lit,
            uint8_t,
            core_ops_range_Range__size_t);
        int32_t uu____1[256U];
        libcrux_kyber_serialize_deserialize_to_uncompressed_ring_element(t_as_ntt_bytes, uu____1);
        memcpy(t_as_ntt[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[2U][256U];
    memcpy(uu____2, t_as_ntt, (size_t)2U * sizeof (int32_t [256U]));
    memcpy(ret, uu____2, (size_t)2U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_ind_cpa_sample_ring_element_cbd___2size_t_128size_t_2size_t(
  uint8_t *prf_input,
  uint8_t *domain_separator,
  int32_t ret[2U][256U]
)
{
  int32_t error_1[2U][256U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
    memcpy(error_1[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)2U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        prf_input[32U] = domain_separator[0U];
        domain_separator[0U] = (uint32_t)domain_separator[0U] + 1U;
        uint8_t prf_output[128U];
        libcrux_kyber_hash_functions_PRF___128size_t(Eurydice_array_to_slice((size_t)33U,
            prf_input,
            uint8_t),
          prf_output);
        int32_t uu____1[256U];
        libcrux_kyber_sampling_sample_from_binomial_distribution___2size_t(Eurydice_array_to_slice((size_t)128U,
            prf_output,
            uint8_t),
          uu____1);
        memcpy(error_1[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[2U][256U];
    memcpy(uu____2, error_1, (size_t)2U * sizeof (int32_t [256U]));
    memcpy(ret, uu____2, (size_t)2U * sizeof (int32_t [256U]));
    return;
  }
}

void libcrux_kyber_ntt_invert_ntt_montgomery___2size_t(int32_t re[256U], int32_t ret[256U])
{
  size_t zeta_i = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT / (size_t)2U;
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)1U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)2U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)3U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)4U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)5U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)6U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)7U, re);
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)8U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t uu____1 = libcrux_kyber_arithmetic_barrett_reduce(re[i]);
        re[i] = uu____1;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, re, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_matrix_compute_vector_u___2size_t(
  int32_t (*a_as_ntt)[2U][256U],
  int32_t (*r_as_ntt)[256U],
  int32_t (*error_1)[256U],
  int32_t ret[2U][256U]
)
{
  int32_t result[2U][256U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
    memcpy(result[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)2U,
        a_as_ntt,
        Eurydice_error_t_cg_array),
      int32_t [2U][256U]);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        core_ops_range_Range__size_t lit;
        lit.start = (size_t)0U;
        lit.end =
          core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)2U,
              a_as_ntt[i],
              int32_t [256U]),
            int32_t [256U]);
        core_ops_range_Range__size_t
        iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
          if (uu____1.tag == core_option_None)
            break;
          else if (uu____1.tag == core_option_Some)
          {
            size_t j = uu____1.f0;
            int32_t product[256U];
            libcrux_kyber_ntt_ntt_multiply(&a_as_ntt[i][j], &r_as_ntt[j], product);
            int32_t uu____2[256U];
            libcrux_kyber_arithmetic_add_to_ring_element___2size_t(result[i], &product, uu____2);
            memcpy(result[i], uu____2, (size_t)256U * sizeof (int32_t));
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        int32_t uu____3[256U];
        libcrux_kyber_ntt_invert_ntt_montgomery___2size_t(result[i], uu____3);
        memcpy(result[i], uu____3, (size_t)256U * sizeof (int32_t));
        core_ops_range_Range__size_t lit0;
        lit0.start = (size_t)0U;
        lit0.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
        core_ops_range_Range__size_t
        iter0 = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____4 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
          if (uu____4.tag == core_option_None)
            break;
          else if (uu____4.tag == core_option_Some)
          {
            size_t j = uu____4.f0;
            int32_t
            coefficient_normal_form =
              libcrux_kyber_arithmetic_montgomery_reduce(result[i][j] * (int32_t)1441);
            int32_t
            uu____5 =
              libcrux_kyber_arithmetic_barrett_reduce(coefficient_normal_form + error_1[i][j]);
            result[i][j] = uu____5;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____6[2U][256U];
    memcpy(uu____6, result, (size_t)2U * sizeof (int32_t [256U]));
    memcpy(ret, uu____6, (size_t)2U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_matrix_compute_ring_element_v___2size_t(
  int32_t (*t_as_ntt)[256U],
  int32_t (*r_as_ntt)[256U],
  int32_t (*error_2)[256U],
  int32_t (*message)[256U],
  int32_t ret[256U]
)
{
  int32_t result[256U];
  memcpy(result,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)2U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (uu____0.tag == core_option_None)
      break;
    else if (uu____0.tag == core_option_Some)
    {
      size_t i = uu____0.f0;
      int32_t product[256U];
      libcrux_kyber_ntt_ntt_multiply(&t_as_ntt[i], &r_as_ntt[i], product);
      libcrux_kyber_arithmetic_add_to_ring_element___2size_t(result, &product, result);
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
      KRML_HOST_EXIT(255U);
    }
  }
  libcrux_kyber_ntt_invert_ntt_montgomery___2size_t(result, result);
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter0 = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
    if (!(uu____1.tag == core_option_None))
    {
      if (uu____1.tag == core_option_Some)
      {
        size_t i = uu____1.f0;
        int32_t
        coefficient_normal_form =
          libcrux_kyber_arithmetic_montgomery_reduce(result[i] * (int32_t)1441);
        int32_t
        uu____2 =
          libcrux_kyber_arithmetic_barrett_reduce(coefficient_normal_form
            + error_2[0U][i]
            + message[0U][i]);
        result[i] = uu____2;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, result, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_serialize_compress_then_serialize_10___320size_t(
  int32_t re[256U],
  uint8_t ret[320U]
)
{
  uint8_t serialized[320U];
  for (size_t i = (size_t)0U; i < (size_t)320U; i++)
    serialized[i] = 0U;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t),
      int32_t)
    / (size_t)4U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t
        coefficient1 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(10U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)4U + (size_t)0U]));
        int32_t
        coefficient2 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(10U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)4U + (size_t)1U]));
        int32_t
        coefficient3 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(10U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)4U + (size_t)2U]));
        int32_t
        coefficient4 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(10U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)4U + (size_t)3U]));
        K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
        uu____1 =
          libcrux_kyber_serialize_compress_coefficients_10(coefficient1,
            coefficient2,
            coefficient3,
            coefficient4);
        uint8_t coef1 = uu____1.fst;
        uint8_t coef2 = uu____1.snd;
        uint8_t coef3 = uu____1.thd;
        uint8_t coef4 = uu____1.f3;
        uint8_t coef5 = uu____1.f4;
        serialized[(size_t)5U * i] = coef1;
        serialized[(size_t)5U * i + (size_t)1U] = coef2;
        serialized[(size_t)5U * i + (size_t)2U] = coef3;
        serialized[(size_t)5U * i + (size_t)3U] = coef4;
        serialized[(size_t)5U * i + (size_t)4U] = coef5;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____2[320U];
    memcpy(uu____2, serialized, (size_t)320U * sizeof (uint8_t));
    memcpy(ret, uu____2, (size_t)320U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_serialize_compress_then_serialize_11___320size_t(
  int32_t re[256U],
  uint8_t ret[320U]
)
{
  uint8_t serialized[320U];
  for (size_t i = (size_t)0U; i < (size_t)320U; i++)
    serialized[i] = 0U;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t),
      int32_t)
    / (size_t)8U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t
        coefficient1 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)0U]));
        int32_t
        coefficient2 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)1U]));
        int32_t
        coefficient3 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)2U]));
        int32_t
        coefficient4 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)3U]));
        int32_t
        coefficient5 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)4U]));
        int32_t
        coefficient6 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)5U]));
        int32_t
        coefficient7 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)6U]));
        int32_t
        coefficient8 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)7U]));
        K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
        uu____1 =
          libcrux_kyber_serialize_compress_coefficients_11(coefficient1,
            coefficient2,
            coefficient3,
            coefficient4,
            coefficient5,
            coefficient6,
            coefficient7,
            coefficient8);
        uint8_t coef1 = uu____1.fst;
        uint8_t coef2 = uu____1.snd;
        uint8_t coef3 = uu____1.thd;
        uint8_t coef4 = uu____1.f3;
        uint8_t coef5 = uu____1.f4;
        uint8_t coef6 = uu____1.f5;
        uint8_t coef7 = uu____1.f6;
        uint8_t coef8 = uu____1.f7;
        uint8_t coef9 = uu____1.f8;
        uint8_t coef10 = uu____1.f9;
        uint8_t coef11 = uu____1.f10;
        serialized[(size_t)11U * i] = coef1;
        serialized[(size_t)11U * i + (size_t)1U] = coef2;
        serialized[(size_t)11U * i + (size_t)2U] = coef3;
        serialized[(size_t)11U * i + (size_t)3U] = coef4;
        serialized[(size_t)11U * i + (size_t)4U] = coef5;
        serialized[(size_t)11U * i + (size_t)5U] = coef6;
        serialized[(size_t)11U * i + (size_t)6U] = coef7;
        serialized[(size_t)11U * i + (size_t)7U] = coef8;
        serialized[(size_t)11U * i + (size_t)8U] = coef9;
        serialized[(size_t)11U * i + (size_t)9U] = coef10;
        serialized[(size_t)11U * i + (size_t)10U] = coef11;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____2[320U];
    memcpy(uu____2, serialized, (size_t)320U * sizeof (uint8_t));
    memcpy(ret, uu____2, (size_t)320U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_serialize_compress_then_serialize_ring_element_u___10size_t_320size_t(
  int32_t re[256U],
  uint8_t ret[320U]
)
{
  uint8_t uu____0[320U];
  libcrux_kyber_serialize_compress_then_serialize_10___320size_t(re, uu____0);
  memcpy(ret, uu____0, (size_t)320U * sizeof (uint8_t));
}

void
libcrux_kyber_ind_cpa_compress_then_serialize_u___2size_t_640size_t_10size_t_320size_t(
  int32_t input[2U][256U],
  uint8_t ret[640U]
)
{
  uint8_t out[640U];
  for (size_t i = (size_t)0U; i < (size_t)640U; i++)
    out[i] = 0U;
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)2U, input, int32_t [256U]),
      int32_t [256U]);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t re[256U];
        memcpy(re, input[i], (size_t)256U * sizeof (int32_t));
        core_ops_range_Range__size_t lit;
        lit.start = i * ((size_t)640U / (size_t)2U);
        lit.end = (i + (size_t)1U) * ((size_t)640U / (size_t)2U);
        Eurydice_slice
        uu____1 =
          Eurydice_array_to_subslice((size_t)640U,
            out,
            lit,
            uint8_t,
            core_ops_range_Range__size_t);
        uint8_t ret[320U];
        libcrux_kyber_serialize_compress_then_serialize_ring_element_u___10size_t_320size_t(re,
          ret);
        core_slice___Slice_T___copy_from_slice(uu____1,
          Eurydice_array_to_slice((size_t)320U, ret, uint8_t),
          uint8_t);
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____2[640U];
    memcpy(uu____2, out, (size_t)640U * sizeof (uint8_t));
    memcpy(ret, uu____2, (size_t)640U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_serialize_compress_then_serialize_4___128size_t(
  int32_t re[256U],
  uint8_t ret[128U]
)
{
  uint8_t serialized[128U];
  for (size_t i = (size_t)0U; i < (size_t)128U; i++)
    serialized[i] = 0U;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t),
      int32_t)
    / (size_t)2U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        uint8_t
        coefficient1 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(4U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)2U + (size_t)0U]));
        uint8_t
        coefficient2 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(4U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)2U + (size_t)1U]));
        serialized[i] = (uint32_t)coefficient2 << 4U | (uint32_t)coefficient1;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____1[128U];
    memcpy(uu____1, serialized, (size_t)128U * sizeof (uint8_t));
    memcpy(ret, uu____1, (size_t)128U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_serialize_compress_then_serialize_5___128size_t(
  int32_t re[256U],
  uint8_t ret[128U]
)
{
  uint8_t serialized[128U];
  for (size_t i = (size_t)0U; i < (size_t)128U; i++)
    serialized[i] = 0U;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t),
      int32_t)
    / (size_t)8U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        uint8_t
        coefficient1 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)0U]));
        uint8_t
        coefficient2 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)1U]));
        uint8_t
        coefficient3 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)2U]));
        uint8_t
        coefficient4 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)3U]));
        uint8_t
        coefficient5 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)4U]));
        uint8_t
        coefficient6 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)5U]));
        uint8_t
        coefficient7 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)6U]));
        uint8_t
        coefficient8 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)7U]));
        K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
        uu____1 =
          libcrux_kyber_serialize_compress_coefficients_5(coefficient2,
            coefficient1,
            coefficient4,
            coefficient3,
            coefficient5,
            coefficient7,
            coefficient6,
            coefficient8);
        uint8_t coef1 = uu____1.fst;
        uint8_t coef2 = uu____1.snd;
        uint8_t coef3 = uu____1.thd;
        uint8_t coef4 = uu____1.f3;
        uint8_t coef5 = uu____1.f4;
        serialized[(size_t)5U * i] = coef1;
        serialized[(size_t)5U * i + (size_t)1U] = coef2;
        serialized[(size_t)5U * i + (size_t)2U] = coef3;
        serialized[(size_t)5U * i + (size_t)3U] = coef4;
        serialized[(size_t)5U * i + (size_t)4U] = coef5;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____2[128U];
    memcpy(uu____2, serialized, (size_t)128U * sizeof (uint8_t));
    memcpy(ret, uu____2, (size_t)128U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_serialize_compress_then_serialize_ring_element_v___4size_t_128size_t(
  int32_t re[256U],
  uint8_t ret[128U]
)
{
  uint8_t uu____0[128U];
  libcrux_kyber_serialize_compress_then_serialize_4___128size_t(re, uu____0);
  memcpy(ret, uu____0, (size_t)128U * sizeof (uint8_t));
}

void
libcrux_kyber_ind_cpa_into_padded_array___768size_t(Eurydice_slice slice, uint8_t ret[768U])
{
  if (false)
    LowStar_Ignore_ignore(core_slice___Slice_T___len(slice, uint8_t), size_t);
  uint8_t out[768U];
  for (size_t i = (size_t)0U; i < (size_t)768U; i++)
    out[i] = 0U;
  uint8_t *uu____0 = out;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(slice, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)768U,
      uu____0,
      lit,
      uint8_t,
      core_ops_range_Range__size_t),
    slice,
    uint8_t);
  uint8_t uu____1[768U];
  memcpy(uu____1, out, (size_t)768U * sizeof (uint8_t));
  memcpy(ret, uu____1, (size_t)768U * sizeof (uint8_t));
}

K___uint8_t_768size_t__core_option_Option__libcrux_kyber_types_Error
libcrux_kyber_ind_cpa_encrypt___2size_t_768size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t(
  Eurydice_slice public_key,
  uint8_t message[32U],
  Eurydice_slice randomness
)
{
  int32_t t_as_ntt[2U][256U];
  libcrux_kyber_ind_cpa_deserialize_public_key___2size_t_768size_t(public_key, t_as_ntt);
  Eurydice_slice seed = Eurydice_slice_subslice_from(public_key, (size_t)768U, uint8_t, size_t);
  uint8_t ret[34U];
  libcrux_kyber_ind_cpa_into_padded_array___34size_t(seed, ret);
  K___libcrux_kyber_arithmetic_PolynomialRingElement_2size_t__2size_t__core_option_Option__libcrux_kyber_types_Error
  uu____0 = libcrux_kyber_matrix_sample_matrix_A___2size_t(ret, false);
  int32_t A_transpose[2U][2U][256U];
  memcpy(A_transpose, uu____0.fst, (size_t)2U * sizeof (int32_t [2U][256U]));
  core_option_Option__libcrux_kyber_types_Error sampling_A_error = uu____0.snd;
  uint8_t prf_input[33U];
  libcrux_kyber_ind_cpa_into_padded_array___33size_t(randomness, prf_input);
  uint8_t uu____1[33U];
  memcpy(uu____1, prf_input, (size_t)33U * sizeof (uint8_t));
  K___libcrux_kyber_arithmetic_PolynomialRingElement_2size_t__uint8_t
  uu____2 =
    libcrux_kyber_ind_cpa_sample_vector_cbd_then_ntt___2size_t_3size_t_192size_t(uu____1,
      0U);
  int32_t r_as_ntt[2U][256U];
  memcpy(r_as_ntt, uu____2.fst, (size_t)2U * sizeof (int32_t [256U]));
  uint8_t domain_separator = uu____2.snd;
  int32_t error_1[2U][256U];
  libcrux_kyber_ind_cpa_sample_ring_element_cbd___2size_t_128size_t_2size_t(prf_input,
    &domain_separator,
    error_1);
  prf_input[32U] = domain_separator;
  uint8_t prf_output[128U];
  libcrux_kyber_hash_functions_PRF___128size_t(Eurydice_array_to_slice((size_t)33U,
      prf_input,
      uint8_t),
    prf_output);
  int32_t error_2[256U];
  libcrux_kyber_sampling_sample_from_binomial_distribution___2size_t(Eurydice_array_to_slice((size_t)128U,
      prf_output,
      uint8_t),
    error_2);
  int32_t u[2U][256U];
  libcrux_kyber_matrix_compute_vector_u___2size_t(A_transpose, r_as_ntt, error_1, u);
  uint8_t uu____3[32U];
  memcpy(uu____3, message, (size_t)32U * sizeof (uint8_t));
  int32_t message_as_ring_element[256U];
  libcrux_kyber_serialize_deserialize_then_decompress_message(uu____3, message_as_ring_element);
  int32_t v[256U];
  libcrux_kyber_matrix_compute_ring_element_v___2size_t(t_as_ntt,
    r_as_ntt,
    &error_2,
    &message_as_ring_element,
    v);
  int32_t uu____4[2U][256U];
  memcpy(uu____4, u, (size_t)2U * sizeof (int32_t [256U]));
  uint8_t c1[640U];
  libcrux_kyber_ind_cpa_compress_then_serialize_u___2size_t_640size_t_10size_t_320size_t(uu____4,
    c1);
  uint8_t c2[128U];
  libcrux_kyber_serialize_compress_then_serialize_ring_element_v___4size_t_128size_t(v, c2);
  uint8_t ciphertext[768U];
  libcrux_kyber_ind_cpa_into_padded_array___768size_t(Eurydice_array_to_slice((size_t)640U,
      c1,
      uint8_t),
    ciphertext);
  Eurydice_slice
  uu____5 =
    Eurydice_array_to_subslice_from((size_t)768U,
      ciphertext,
      (size_t)640U,
      uint8_t,
      size_t);
  core_slice___Slice_T___copy_from_slice(uu____5,
    core_array___Array_T__N__23__as_slice((size_t)128U, c2, uint8_t),
    uint8_t);
  uint8_t uu____6[768U];
  memcpy(uu____6, ciphertext, (size_t)768U * sizeof (uint8_t));
  K___uint8_t_768size_t__core_option_Option__libcrux_kyber_types_Error lit;
  memcpy(lit.fst, uu____6, (size_t)768U * sizeof (uint8_t));
  lit.snd = sampling_A_error;
  return lit;
}

core_result_Result__libcrux_kyber_types_KyberCiphertext___768size_t___uint8_t_32size_t__libcrux_kyber_types_Error
libcrux_kyber_encapsulate___2size_t_768size_t_800size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t(
  uint8_t (*public_key)[800U],
  uint8_t randomness[32U]
)
{
  uint8_t to_hash[64U];
  libcrux_kyber_ind_cpa_into_padded_array___64size_t(Eurydice_array_to_slice((size_t)32U,
      randomness,
      uint8_t),
    to_hash);
  Eurydice_slice
  uu____0 =
    Eurydice_array_to_subslice_from((size_t)64U,
      to_hash,
      libcrux_kyber_constants_H_DIGEST_SIZE,
      uint8_t,
      size_t);
  uint8_t ret[32U];
  libcrux_kyber_hash_functions_H(Eurydice_array_to_slice((size_t)800U,
      libcrux_kyber_types__libcrux_kyber__types__KyberPublicKey_SIZE__18__as_slice___800size_t(public_key),
      uint8_t),
    ret);
  core_slice___Slice_T___copy_from_slice(uu____0,
    Eurydice_array_to_slice((size_t)32U, ret, uint8_t),
    uint8_t);
  uint8_t hashed[64U];
  libcrux_kyber_hash_functions_G(Eurydice_array_to_slice((size_t)64U, to_hash, uint8_t), hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____1 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U, hashed, uint8_t),
      libcrux_kyber_constants_SHARED_SECRET_SIZE,
      uint8_t);
  Eurydice_slice shared_secret = uu____1.fst;
  Eurydice_slice pseudorandomness = uu____1.snd;
  Eurydice_slice
  uu____2 =
    Eurydice_array_to_slice((size_t)800U,
      libcrux_kyber_types__libcrux_kyber__types__KyberPublicKey_SIZE__18__as_slice___800size_t(public_key),
      uint8_t);
  uint8_t uu____3[32U];
  memcpy(uu____3, randomness, (size_t)32U * sizeof (uint8_t));
  K___uint8_t_768size_t__core_option_Option__libcrux_kyber_types_Error
  uu____4 =
    libcrux_kyber_ind_cpa_encrypt___2size_t_768size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t(uu____2,
      uu____3,
      pseudorandomness);
  uint8_t ciphertext[768U];
  memcpy(ciphertext, uu____4.fst, (size_t)768U * sizeof (uint8_t));
  core_option_Option__libcrux_kyber_types_Error sampling_a_error = uu____4.snd;
  core_result_Result__libcrux_kyber_types_KyberCiphertext___768size_t___uint8_t_32size_t__libcrux_kyber_types_Error
  uu____5;
  if (sampling_a_error.tag == core_option_None)
  {
    uint8_t uu____6[768U];
    memcpy(uu____6, ciphertext, (size_t)768U * sizeof (uint8_t));
    uint8_t uu____7[768U];
    memcpy(uu____7, uu____6, (size_t)768U * sizeof (uint8_t));
    core_result_Result__uint8_t_32size_t__core_array_TryFromSliceError
    uu____8 = Eurydice_slice_to_array(shared_secret, Eurydice_slice, uint8_t [32U]);
    if (uu____8.tag == core_result_Ok)
    {
      uint8_t r[32U];
      memcpy(r, uu____8.val.case_Ok, (size_t)32U * sizeof (uint8_t));
      uint8_t uu____9[32U];
      memcpy(uu____9, r, (size_t)32U * sizeof (uint8_t));
      core_result_Result__libcrux_kyber_types_KyberCiphertext___768size_t___uint8_t_32size_t__libcrux_kyber_types_Error
      lit;
      lit.tag = core_result_Ok;
      memcpy(lit.val.case_Ok.fst, uu____7, (size_t)768U * sizeof (uint8_t));
      memcpy(lit.val.case_Ok.snd, uu____9, (size_t)32U * sizeof (uint8_t));
      uu____5 = lit;
    }
    else if (uu____8.tag == core_result_Err)
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
      KRML_HOST_EXIT(255U);
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
      KRML_HOST_EXIT(255U);
    }
  }
  else if (sampling_a_error.tag == core_option_Some)
  {
    libcrux_kyber_types_Error e = sampling_a_error.f0;
    core_result_Result__libcrux_kyber_types_KyberCiphertext___768size_t___uint8_t_32size_t__libcrux_kyber_types_Error
    lit;
    lit.tag = core_result_Err;
    lit.val.case_Err = e;
    uu____5 = lit;
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
    KRML_HOST_EXIT(255U);
  }
  return uu____5;
}

core_result_Result__libcrux_kyber_types_KyberCiphertext___768size_t___uint8_t_32size_t__libcrux_kyber_types_Error
libcrux_kyber_kyber512_encapsulate_512(uint8_t (*public_key)[800U], uint8_t randomness[32U])
{
  uint8_t (*uu____0)[800U] = public_key;
  uint8_t uu____1[32U];
  memcpy(uu____1, randomness, (size_t)32U * sizeof (uint8_t));
  return
    libcrux_kyber_encapsulate___2size_t_768size_t_800size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t(uu____0,
      uu____1);
}

K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
libcrux_kyber_types__libcrux_kyber__types__KyberPrivateKey_SIZE__12__split_at___1632size_t(
  uint8_t (*self)[1632U],
  size_t mid
)
{
  return
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)1632U, self[0U], uint8_t),
      mid,
      uint8_t);
}

void
libcrux_kyber_serialize_deserialize_then_decompress_ring_element_u___10size_t(
  Eurydice_slice serialized,
  int32_t ret[256U]
)
{
  int32_t uu____0[256U];
  libcrux_kyber_serialize_deserialize_then_decompress_10(serialized, uu____0);
  memcpy(ret, uu____0, (size_t)256U * sizeof (int32_t));
}

void libcrux_kyber_ntt_ntt_vector_u___10size_t(int32_t re[256U], int32_t ret[256U])
{
  size_t zeta_i = (size_t)0U;
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)7U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)6U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)5U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)4U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)3U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)2U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)1U, re);
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t uu____1 = libcrux_kyber_arithmetic_barrett_reduce(re[i]);
        re[i] = uu____1;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, re, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_ind_cpa_deserialize_then_decompress_u___2size_t_768size_t_640size_t_10size_t(
  uint8_t *ciphertext,
  int32_t ret[2U][256U]
)
{
  int32_t u_as_ntt[2U][256U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
    memcpy(u_as_ntt[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  size_t
  chunk_size = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT * (size_t)10U / (size_t)8U;
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = (size_t)640U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        core_ops_range_Range__size_t lit;
        lit.start = i * chunk_size;
        lit.end = i * (chunk_size + (size_t)1U);
        Eurydice_slice
        u_bytes =
          Eurydice_array_to_subslice((size_t)768U,
            ciphertext,
            lit,
            uint8_t,
            core_ops_range_Range__size_t);
        int32_t u[256U];
        libcrux_kyber_serialize_deserialize_then_decompress_ring_element_u___10size_t(u_bytes, u);
        int32_t uu____1[256U];
        libcrux_kyber_ntt_ntt_vector_u___10size_t(u, uu____1);
        memcpy(u_as_ntt[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[2U][256U];
    memcpy(uu____2, u_as_ntt, (size_t)2U * sizeof (int32_t [256U]));
    memcpy(ret, uu____2, (size_t)2U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_serialize_deserialize_then_decompress_ring_element_v___4size_t(
  Eurydice_slice serialized,
  int32_t ret[256U]
)
{
  int32_t uu____0[256U];
  libcrux_kyber_serialize_deserialize_then_decompress_4(serialized, uu____0);
  memcpy(ret, uu____0, (size_t)256U * sizeof (int32_t));
}

void
libcrux_kyber_ind_cpa_deserialize_secret_key___2size_t(
  Eurydice_slice secret_key,
  int32_t ret[2U][256U]
)
{
  int32_t secret_as_ntt[2U][256U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
    memcpy(secret_as_ntt[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(secret_key,
      uint8_t)
    / libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t uu____1[256U];
        core_ops_range_Range__size_t lit;
        lit.start = i * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        lit.end =
          i
          * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT
          + libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        libcrux_kyber_serialize_deserialize_to_uncompressed_ring_element(Eurydice_slice_subslice(secret_key,
            lit,
            uint8_t,
            core_ops_range_Range__size_t),
          uu____1);
        memcpy(secret_as_ntt[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[2U][256U];
    memcpy(uu____2, secret_as_ntt, (size_t)2U * sizeof (int32_t [256U]));
    memcpy(ret, uu____2, (size_t)2U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_matrix_compute_message___2size_t(
  int32_t (*v)[256U],
  int32_t (*secret_as_ntt)[256U],
  int32_t (*u_as_ntt)[256U],
  int32_t ret[256U]
)
{
  int32_t result[256U];
  memcpy(result,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)2U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (uu____0.tag == core_option_None)
      break;
    else if (uu____0.tag == core_option_Some)
    {
      size_t i = uu____0.f0;
      int32_t product[256U];
      libcrux_kyber_ntt_ntt_multiply(&secret_as_ntt[i], &u_as_ntt[i], product);
      libcrux_kyber_arithmetic_add_to_ring_element___2size_t(result, &product, result);
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
      KRML_HOST_EXIT(255U);
    }
  }
  libcrux_kyber_ntt_invert_ntt_montgomery___2size_t(result, result);
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter0 = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
    if (!(uu____1.tag == core_option_None))
    {
      if (uu____1.tag == core_option_Some)
      {
        size_t i = uu____1.f0;
        int32_t
        coefficient_normal_form =
          libcrux_kyber_arithmetic_montgomery_reduce(result[i] * (int32_t)1441);
        int32_t
        uu____2 = libcrux_kyber_arithmetic_barrett_reduce(v[0U][i] - coefficient_normal_form);
        result[i] = uu____2;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, result, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_ind_cpa_decrypt___2size_t_768size_t_640size_t_10size_t_4size_t(
  Eurydice_slice secret_key,
  uint8_t *ciphertext,
  uint8_t ret[32U]
)
{
  int32_t u_as_ntt[2U][256U];
  libcrux_kyber_ind_cpa_deserialize_then_decompress_u___2size_t_768size_t_640size_t_10size_t(ciphertext,
    u_as_ntt);
  int32_t v[256U];
  libcrux_kyber_serialize_deserialize_then_decompress_ring_element_v___4size_t(Eurydice_array_to_subslice_from((size_t)768U,
      ciphertext,
      (size_t)640U,
      uint8_t,
      size_t),
    v);
  int32_t secret_as_ntt[2U][256U];
  libcrux_kyber_ind_cpa_deserialize_secret_key___2size_t(secret_key, secret_as_ntt);
  int32_t message[256U];
  libcrux_kyber_matrix_compute_message___2size_t(&v, secret_as_ntt, u_as_ntt, message);
  uint8_t ret0[32U];
  libcrux_kyber_serialize_compress_then_serialize_message(message, ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

void
libcrux_kyber_ind_cpa_into_padded_array___800size_t(Eurydice_slice slice, uint8_t ret[800U])
{
  if (false)
    LowStar_Ignore_ignore(core_slice___Slice_T___len(slice, uint8_t), size_t);
  uint8_t out[800U];
  for (size_t i = (size_t)0U; i < (size_t)800U; i++)
    out[i] = 0U;
  uint8_t *uu____0 = out;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(slice, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)800U,
      uu____0,
      lit,
      uint8_t,
      core_ops_range_Range__size_t),
    slice,
    uint8_t);
  uint8_t uu____1[800U];
  memcpy(uu____1, out, (size_t)800U * sizeof (uint8_t));
  memcpy(ret, uu____1, (size_t)800U * sizeof (uint8_t));
}

Eurydice_slice
libcrux_kyber_types__libcrux_kyber__types__KyberCiphertext_SIZE__1__as_ref___768size_t(
  uint8_t (*self)[768U]
)
{
  return Eurydice_array_to_slice((size_t)768U, self[0U], uint8_t);
}

uint8_t
libcrux_kyber_constant_time_ops_compare_ciphertexts_in_constant_time___768size_t(
  Eurydice_slice lhs,
  Eurydice_slice rhs
)
{
  uint8_t r = 0U;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)768U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        uint8_t uu____1 = Eurydice_slice_index(lhs, i, uint8_t);
        r = (uint32_t)r | ((uint32_t)uu____1 ^ (uint32_t)Eurydice_slice_index(rhs, i, uint8_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    return libcrux_kyber_constant_time_ops_is_non_zero(r);
  }
}

void
libcrux_kyber_decapsulate___2size_t_1632size_t_768size_t_800size_t_768size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t_800size_t(
  uint8_t (*secret_key)[1632U],
  uint8_t (*ciphertext)[768U],
  uint8_t ret[32U]
)
{
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____0 =
    libcrux_kyber_types__libcrux_kyber__types__KyberPrivateKey_SIZE__12__split_at___1632size_t(secret_key,
      (size_t)768U);
  Eurydice_slice ind_cpa_secret_key = uu____0.fst;
  Eurydice_slice secret_key0 = uu____0.snd;
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____1 = core_slice___Slice_T___split_at(secret_key0, (size_t)800U, uint8_t);
  Eurydice_slice ind_cpa_public_key = uu____1.fst;
  Eurydice_slice secret_key1 = uu____1.snd;
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____2 =
    core_slice___Slice_T___split_at(secret_key1,
      libcrux_kyber_constants_H_DIGEST_SIZE,
      uint8_t);
  Eurydice_slice ind_cpa_public_key_hash = uu____2.fst;
  Eurydice_slice implicit_rejection_value = uu____2.snd;
  uint8_t decrypted[32U];
  libcrux_kyber_ind_cpa_decrypt___2size_t_768size_t_640size_t_10size_t_4size_t(ind_cpa_secret_key,
    ciphertext[0U],
    decrypted);
  uint8_t to_hash0[64U];
  libcrux_kyber_ind_cpa_into_padded_array___64size_t(Eurydice_array_to_slice((size_t)32U,
      decrypted,
      uint8_t),
    to_hash0);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice_from((size_t)64U,
      to_hash0,
      libcrux_kyber_constants_SHARED_SECRET_SIZE,
      uint8_t,
      size_t),
    ind_cpa_public_key_hash,
    uint8_t);
  uint8_t hashed[64U];
  libcrux_kyber_hash_functions_G(Eurydice_array_to_slice((size_t)64U, to_hash0, uint8_t),
    hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____3 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U, hashed, uint8_t),
      libcrux_kyber_constants_SHARED_SECRET_SIZE,
      uint8_t);
  Eurydice_slice shared_secret = uu____3.fst;
  Eurydice_slice pseudorandomness = uu____3.snd;
  uint8_t to_hash[800U];
  libcrux_kyber_ind_cpa_into_padded_array___800size_t(implicit_rejection_value, to_hash);
  Eurydice_slice
  uu____4 =
    Eurydice_array_to_subslice_from((size_t)800U,
      to_hash,
      libcrux_kyber_constants_SHARED_SECRET_SIZE,
      uint8_t,
      size_t);
  core_slice___Slice_T___copy_from_slice(uu____4,
    libcrux_kyber_types__libcrux_kyber__types__KyberCiphertext_SIZE__1__as_ref___768size_t(ciphertext),
    uint8_t);
  uint8_t implicit_rejection_shared_secret[32U];
  libcrux_kyber_hash_functions_PRF___32size_t(Eurydice_array_to_slice((size_t)800U,
      to_hash,
      uint8_t),
    implicit_rejection_shared_secret);
  Eurydice_slice uu____5 = ind_cpa_public_key;
  uint8_t uu____6[32U];
  memcpy(uu____6, decrypted, (size_t)32U * sizeof (uint8_t));
  uint8_t expected_ciphertext[768U];
  memcpy(expected_ciphertext,
    libcrux_kyber_ind_cpa_encrypt___2size_t_768size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t(uu____5,
      uu____6,
      pseudorandomness).fst,
    (size_t)768U * sizeof (uint8_t));
  Eurydice_slice
  uu____7 =
    libcrux_kyber_types__libcrux_kyber__types__KyberCiphertext_SIZE__1__as_ref___768size_t(ciphertext);
  uint8_t
  selector =
    libcrux_kyber_constant_time_ops_compare_ciphertexts_in_constant_time___768size_t(uu____7,
      Eurydice_array_to_slice((size_t)768U, expected_ciphertext, uint8_t));
  Eurydice_slice uu____8 = shared_secret;
  uint8_t ret0[32U];
  libcrux_kyber_constant_time_ops_select_shared_secret_in_constant_time(uu____8,
    Eurydice_array_to_slice((size_t)32U, implicit_rejection_shared_secret, uint8_t),
    selector,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

void
libcrux_kyber_kyber512_decapsulate_512(
  uint8_t (*secret_key)[1632U],
  uint8_t (*ciphertext)[768U],
  uint8_t ret[32U]
)
{
  uint8_t ret0[32U];
  libcrux_kyber_decapsulate___2size_t_1632size_t_768size_t_800size_t_768size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t_800size_t(secret_key,
    ciphertext,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

const size_t libcrux_kyber_kyber768_RANK_768 = (size_t)3U;

const
size_t
libcrux_kyber_kyber768_RANKED_BYTES_PER_RING_ELEMENT_768 =
  libcrux_kyber_kyber768_RANK_768
  * libcrux_kyber_constants_BITS_PER_RING_ELEMENT
  / (size_t)8U;

const
size_t
libcrux_kyber_kyber768_T_AS_NTT_ENCODED_SIZE_768 =
  libcrux_kyber_kyber768_RANK_768
  * libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT
  * libcrux_kyber_constants_BITS_PER_COEFFICIENT
  / (size_t)8U;

const size_t libcrux_kyber_kyber768_VECTOR_U_COMPRESSION_FACTOR_768 = (size_t)10U;

const
size_t
libcrux_kyber_kyber768_C1_BLOCK_SIZE_768 =
  libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT
  * libcrux_kyber_kyber768_VECTOR_U_COMPRESSION_FACTOR_768
  / (size_t)8U;

const
size_t
libcrux_kyber_kyber768_C1_SIZE_768 =
  libcrux_kyber_kyber768_C1_BLOCK_SIZE_768
  * libcrux_kyber_kyber768_RANK_768;

const size_t libcrux_kyber_kyber768_VECTOR_V_COMPRESSION_FACTOR_768 = (size_t)4U;

const
size_t
libcrux_kyber_kyber768_C2_SIZE_768 =
  libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT
  * libcrux_kyber_kyber768_VECTOR_V_COMPRESSION_FACTOR_768
  / (size_t)8U;

const
size_t
libcrux_kyber_kyber768_CPA_PKE_SECRET_KEY_SIZE_768 =
  libcrux_kyber_kyber768_RANK_768
  * libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT
  * libcrux_kyber_constants_BITS_PER_COEFFICIENT
  / (size_t)8U;

const
size_t
libcrux_kyber_kyber768_CPA_PKE_PUBLIC_KEY_SIZE_768 =
  libcrux_kyber_kyber768_T_AS_NTT_ENCODED_SIZE_768
  + (size_t)32U;

const
size_t
libcrux_kyber_kyber768_CPA_PKE_CIPHERTEXT_SIZE_768 =
  libcrux_kyber_kyber768_C1_SIZE_768
  + libcrux_kyber_kyber768_C2_SIZE_768;

const
size_t
libcrux_kyber_kyber768_SECRET_KEY_SIZE_768 =
  libcrux_kyber_kyber768_CPA_PKE_SECRET_KEY_SIZE_768
  + libcrux_kyber_kyber768_CPA_PKE_PUBLIC_KEY_SIZE_768
  + libcrux_kyber_constants_H_DIGEST_SIZE
  + libcrux_kyber_constants_SHARED_SECRET_SIZE;

const size_t libcrux_kyber_kyber768_ETA1 = (size_t)2U;

const
size_t
libcrux_kyber_kyber768_ETA1_RANDOMNESS_SIZE = libcrux_kyber_kyber768_ETA1 * (size_t)64U;

const size_t libcrux_kyber_kyber768_ETA2 = (size_t)2U;

const
size_t
libcrux_kyber_kyber768_ETA2_RANDOMNESS_SIZE = libcrux_kyber_kyber768_ETA2 * (size_t)64U;

const
size_t
libcrux_kyber_kyber768_IMPLICIT_REJECTION_HASH_INPUT_SIZE =
  libcrux_kyber_constants_SHARED_SECRET_SIZE
  + libcrux_kyber_kyber768_CPA_PKE_CIPHERTEXT_SIZE_768;

void
libcrux_kyber_hash_functions_XOFx4___3size_t(uint8_t input[3U][34U], uint8_t ret[3U][840U])
{
  uint8_t out[3U][840U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
  {
    out[i][0U] = 0U;
    out[i][1U] = 0U;
    out[i][2U] = 0U;
    out[i][3U] = 0U;
    out[i][4U] = 0U;
    out[i][5U] = 0U;
    out[i][6U] = 0U;
    out[i][7U] = 0U;
    out[i][8U] = 0U;
    out[i][9U] = 0U;
    out[i][10U] = 0U;
    out[i][11U] = 0U;
    out[i][12U] = 0U;
    out[i][13U] = 0U;
    out[i][14U] = 0U;
    out[i][15U] = 0U;
    out[i][16U] = 0U;
    out[i][17U] = 0U;
    out[i][18U] = 0U;
    out[i][19U] = 0U;
    out[i][20U] = 0U;
    out[i][21U] = 0U;
    out[i][22U] = 0U;
    out[i][23U] = 0U;
    out[i][24U] = 0U;
    out[i][25U] = 0U;
    out[i][26U] = 0U;
    out[i][27U] = 0U;
    out[i][28U] = 0U;
    out[i][29U] = 0U;
    out[i][30U] = 0U;
    out[i][31U] = 0U;
    out[i][32U] = 0U;
    out[i][33U] = 0U;
    out[i][34U] = 0U;
    out[i][35U] = 0U;
    out[i][36U] = 0U;
    out[i][37U] = 0U;
    out[i][38U] = 0U;
    out[i][39U] = 0U;
    out[i][40U] = 0U;
    out[i][41U] = 0U;
    out[i][42U] = 0U;
    out[i][43U] = 0U;
    out[i][44U] = 0U;
    out[i][45U] = 0U;
    out[i][46U] = 0U;
    out[i][47U] = 0U;
    out[i][48U] = 0U;
    out[i][49U] = 0U;
    out[i][50U] = 0U;
    out[i][51U] = 0U;
    out[i][52U] = 0U;
    out[i][53U] = 0U;
    out[i][54U] = 0U;
    out[i][55U] = 0U;
    out[i][56U] = 0U;
    out[i][57U] = 0U;
    out[i][58U] = 0U;
    out[i][59U] = 0U;
    out[i][60U] = 0U;
    out[i][61U] = 0U;
    out[i][62U] = 0U;
    out[i][63U] = 0U;
    out[i][64U] = 0U;
    out[i][65U] = 0U;
    out[i][66U] = 0U;
    out[i][67U] = 0U;
    out[i][68U] = 0U;
    out[i][69U] = 0U;
    out[i][70U] = 0U;
    out[i][71U] = 0U;
    out[i][72U] = 0U;
    out[i][73U] = 0U;
    out[i][74U] = 0U;
    out[i][75U] = 0U;
    out[i][76U] = 0U;
    out[i][77U] = 0U;
    out[i][78U] = 0U;
    out[i][79U] = 0U;
    out[i][80U] = 0U;
    out[i][81U] = 0U;
    out[i][82U] = 0U;
    out[i][83U] = 0U;
    out[i][84U] = 0U;
    out[i][85U] = 0U;
    out[i][86U] = 0U;
    out[i][87U] = 0U;
    out[i][88U] = 0U;
    out[i][89U] = 0U;
    out[i][90U] = 0U;
    out[i][91U] = 0U;
    out[i][92U] = 0U;
    out[i][93U] = 0U;
    out[i][94U] = 0U;
    out[i][95U] = 0U;
    out[i][96U] = 0U;
    out[i][97U] = 0U;
    out[i][98U] = 0U;
    out[i][99U] = 0U;
    out[i][100U] = 0U;
    out[i][101U] = 0U;
    out[i][102U] = 0U;
    out[i][103U] = 0U;
    out[i][104U] = 0U;
    out[i][105U] = 0U;
    out[i][106U] = 0U;
    out[i][107U] = 0U;
    out[i][108U] = 0U;
    out[i][109U] = 0U;
    out[i][110U] = 0U;
    out[i][111U] = 0U;
    out[i][112U] = 0U;
    out[i][113U] = 0U;
    out[i][114U] = 0U;
    out[i][115U] = 0U;
    out[i][116U] = 0U;
    out[i][117U] = 0U;
    out[i][118U] = 0U;
    out[i][119U] = 0U;
    out[i][120U] = 0U;
    out[i][121U] = 0U;
    out[i][122U] = 0U;
    out[i][123U] = 0U;
    out[i][124U] = 0U;
    out[i][125U] = 0U;
    out[i][126U] = 0U;
    out[i][127U] = 0U;
    out[i][128U] = 0U;
    out[i][129U] = 0U;
    out[i][130U] = 0U;
    out[i][131U] = 0U;
    out[i][132U] = 0U;
    out[i][133U] = 0U;
    out[i][134U] = 0U;
    out[i][135U] = 0U;
    out[i][136U] = 0U;
    out[i][137U] = 0U;
    out[i][138U] = 0U;
    out[i][139U] = 0U;
    out[i][140U] = 0U;
    out[i][141U] = 0U;
    out[i][142U] = 0U;
    out[i][143U] = 0U;
    out[i][144U] = 0U;
    out[i][145U] = 0U;
    out[i][146U] = 0U;
    out[i][147U] = 0U;
    out[i][148U] = 0U;
    out[i][149U] = 0U;
    out[i][150U] = 0U;
    out[i][151U] = 0U;
    out[i][152U] = 0U;
    out[i][153U] = 0U;
    out[i][154U] = 0U;
    out[i][155U] = 0U;
    out[i][156U] = 0U;
    out[i][157U] = 0U;
    out[i][158U] = 0U;
    out[i][159U] = 0U;
    out[i][160U] = 0U;
    out[i][161U] = 0U;
    out[i][162U] = 0U;
    out[i][163U] = 0U;
    out[i][164U] = 0U;
    out[i][165U] = 0U;
    out[i][166U] = 0U;
    out[i][167U] = 0U;
    out[i][168U] = 0U;
    out[i][169U] = 0U;
    out[i][170U] = 0U;
    out[i][171U] = 0U;
    out[i][172U] = 0U;
    out[i][173U] = 0U;
    out[i][174U] = 0U;
    out[i][175U] = 0U;
    out[i][176U] = 0U;
    out[i][177U] = 0U;
    out[i][178U] = 0U;
    out[i][179U] = 0U;
    out[i][180U] = 0U;
    out[i][181U] = 0U;
    out[i][182U] = 0U;
    out[i][183U] = 0U;
    out[i][184U] = 0U;
    out[i][185U] = 0U;
    out[i][186U] = 0U;
    out[i][187U] = 0U;
    out[i][188U] = 0U;
    out[i][189U] = 0U;
    out[i][190U] = 0U;
    out[i][191U] = 0U;
    out[i][192U] = 0U;
    out[i][193U] = 0U;
    out[i][194U] = 0U;
    out[i][195U] = 0U;
    out[i][196U] = 0U;
    out[i][197U] = 0U;
    out[i][198U] = 0U;
    out[i][199U] = 0U;
    out[i][200U] = 0U;
    out[i][201U] = 0U;
    out[i][202U] = 0U;
    out[i][203U] = 0U;
    out[i][204U] = 0U;
    out[i][205U] = 0U;
    out[i][206U] = 0U;
    out[i][207U] = 0U;
    out[i][208U] = 0U;
    out[i][209U] = 0U;
    out[i][210U] = 0U;
    out[i][211U] = 0U;
    out[i][212U] = 0U;
    out[i][213U] = 0U;
    out[i][214U] = 0U;
    out[i][215U] = 0U;
    out[i][216U] = 0U;
    out[i][217U] = 0U;
    out[i][218U] = 0U;
    out[i][219U] = 0U;
    out[i][220U] = 0U;
    out[i][221U] = 0U;
    out[i][222U] = 0U;
    out[i][223U] = 0U;
    out[i][224U] = 0U;
    out[i][225U] = 0U;
    out[i][226U] = 0U;
    out[i][227U] = 0U;
    out[i][228U] = 0U;
    out[i][229U] = 0U;
    out[i][230U] = 0U;
    out[i][231U] = 0U;
    out[i][232U] = 0U;
    out[i][233U] = 0U;
    out[i][234U] = 0U;
    out[i][235U] = 0U;
    out[i][236U] = 0U;
    out[i][237U] = 0U;
    out[i][238U] = 0U;
    out[i][239U] = 0U;
    out[i][240U] = 0U;
    out[i][241U] = 0U;
    out[i][242U] = 0U;
    out[i][243U] = 0U;
    out[i][244U] = 0U;
    out[i][245U] = 0U;
    out[i][246U] = 0U;
    out[i][247U] = 0U;
    out[i][248U] = 0U;
    out[i][249U] = 0U;
    out[i][250U] = 0U;
    out[i][251U] = 0U;
    out[i][252U] = 0U;
    out[i][253U] = 0U;
    out[i][254U] = 0U;
    out[i][255U] = 0U;
    out[i][256U] = 0U;
    out[i][257U] = 0U;
    out[i][258U] = 0U;
    out[i][259U] = 0U;
    out[i][260U] = 0U;
    out[i][261U] = 0U;
    out[i][262U] = 0U;
    out[i][263U] = 0U;
    out[i][264U] = 0U;
    out[i][265U] = 0U;
    out[i][266U] = 0U;
    out[i][267U] = 0U;
    out[i][268U] = 0U;
    out[i][269U] = 0U;
    out[i][270U] = 0U;
    out[i][271U] = 0U;
    out[i][272U] = 0U;
    out[i][273U] = 0U;
    out[i][274U] = 0U;
    out[i][275U] = 0U;
    out[i][276U] = 0U;
    out[i][277U] = 0U;
    out[i][278U] = 0U;
    out[i][279U] = 0U;
    out[i][280U] = 0U;
    out[i][281U] = 0U;
    out[i][282U] = 0U;
    out[i][283U] = 0U;
    out[i][284U] = 0U;
    out[i][285U] = 0U;
    out[i][286U] = 0U;
    out[i][287U] = 0U;
    out[i][288U] = 0U;
    out[i][289U] = 0U;
    out[i][290U] = 0U;
    out[i][291U] = 0U;
    out[i][292U] = 0U;
    out[i][293U] = 0U;
    out[i][294U] = 0U;
    out[i][295U] = 0U;
    out[i][296U] = 0U;
    out[i][297U] = 0U;
    out[i][298U] = 0U;
    out[i][299U] = 0U;
    out[i][300U] = 0U;
    out[i][301U] = 0U;
    out[i][302U] = 0U;
    out[i][303U] = 0U;
    out[i][304U] = 0U;
    out[i][305U] = 0U;
    out[i][306U] = 0U;
    out[i][307U] = 0U;
    out[i][308U] = 0U;
    out[i][309U] = 0U;
    out[i][310U] = 0U;
    out[i][311U] = 0U;
    out[i][312U] = 0U;
    out[i][313U] = 0U;
    out[i][314U] = 0U;
    out[i][315U] = 0U;
    out[i][316U] = 0U;
    out[i][317U] = 0U;
    out[i][318U] = 0U;
    out[i][319U] = 0U;
    out[i][320U] = 0U;
    out[i][321U] = 0U;
    out[i][322U] = 0U;
    out[i][323U] = 0U;
    out[i][324U] = 0U;
    out[i][325U] = 0U;
    out[i][326U] = 0U;
    out[i][327U] = 0U;
    out[i][328U] = 0U;
    out[i][329U] = 0U;
    out[i][330U] = 0U;
    out[i][331U] = 0U;
    out[i][332U] = 0U;
    out[i][333U] = 0U;
    out[i][334U] = 0U;
    out[i][335U] = 0U;
    out[i][336U] = 0U;
    out[i][337U] = 0U;
    out[i][338U] = 0U;
    out[i][339U] = 0U;
    out[i][340U] = 0U;
    out[i][341U] = 0U;
    out[i][342U] = 0U;
    out[i][343U] = 0U;
    out[i][344U] = 0U;
    out[i][345U] = 0U;
    out[i][346U] = 0U;
    out[i][347U] = 0U;
    out[i][348U] = 0U;
    out[i][349U] = 0U;
    out[i][350U] = 0U;
    out[i][351U] = 0U;
    out[i][352U] = 0U;
    out[i][353U] = 0U;
    out[i][354U] = 0U;
    out[i][355U] = 0U;
    out[i][356U] = 0U;
    out[i][357U] = 0U;
    out[i][358U] = 0U;
    out[i][359U] = 0U;
    out[i][360U] = 0U;
    out[i][361U] = 0U;
    out[i][362U] = 0U;
    out[i][363U] = 0U;
    out[i][364U] = 0U;
    out[i][365U] = 0U;
    out[i][366U] = 0U;
    out[i][367U] = 0U;
    out[i][368U] = 0U;
    out[i][369U] = 0U;
    out[i][370U] = 0U;
    out[i][371U] = 0U;
    out[i][372U] = 0U;
    out[i][373U] = 0U;
    out[i][374U] = 0U;
    out[i][375U] = 0U;
    out[i][376U] = 0U;
    out[i][377U] = 0U;
    out[i][378U] = 0U;
    out[i][379U] = 0U;
    out[i][380U] = 0U;
    out[i][381U] = 0U;
    out[i][382U] = 0U;
    out[i][383U] = 0U;
    out[i][384U] = 0U;
    out[i][385U] = 0U;
    out[i][386U] = 0U;
    out[i][387U] = 0U;
    out[i][388U] = 0U;
    out[i][389U] = 0U;
    out[i][390U] = 0U;
    out[i][391U] = 0U;
    out[i][392U] = 0U;
    out[i][393U] = 0U;
    out[i][394U] = 0U;
    out[i][395U] = 0U;
    out[i][396U] = 0U;
    out[i][397U] = 0U;
    out[i][398U] = 0U;
    out[i][399U] = 0U;
    out[i][400U] = 0U;
    out[i][401U] = 0U;
    out[i][402U] = 0U;
    out[i][403U] = 0U;
    out[i][404U] = 0U;
    out[i][405U] = 0U;
    out[i][406U] = 0U;
    out[i][407U] = 0U;
    out[i][408U] = 0U;
    out[i][409U] = 0U;
    out[i][410U] = 0U;
    out[i][411U] = 0U;
    out[i][412U] = 0U;
    out[i][413U] = 0U;
    out[i][414U] = 0U;
    out[i][415U] = 0U;
    out[i][416U] = 0U;
    out[i][417U] = 0U;
    out[i][418U] = 0U;
    out[i][419U] = 0U;
    out[i][420U] = 0U;
    out[i][421U] = 0U;
    out[i][422U] = 0U;
    out[i][423U] = 0U;
    out[i][424U] = 0U;
    out[i][425U] = 0U;
    out[i][426U] = 0U;
    out[i][427U] = 0U;
    out[i][428U] = 0U;
    out[i][429U] = 0U;
    out[i][430U] = 0U;
    out[i][431U] = 0U;
    out[i][432U] = 0U;
    out[i][433U] = 0U;
    out[i][434U] = 0U;
    out[i][435U] = 0U;
    out[i][436U] = 0U;
    out[i][437U] = 0U;
    out[i][438U] = 0U;
    out[i][439U] = 0U;
    out[i][440U] = 0U;
    out[i][441U] = 0U;
    out[i][442U] = 0U;
    out[i][443U] = 0U;
    out[i][444U] = 0U;
    out[i][445U] = 0U;
    out[i][446U] = 0U;
    out[i][447U] = 0U;
    out[i][448U] = 0U;
    out[i][449U] = 0U;
    out[i][450U] = 0U;
    out[i][451U] = 0U;
    out[i][452U] = 0U;
    out[i][453U] = 0U;
    out[i][454U] = 0U;
    out[i][455U] = 0U;
    out[i][456U] = 0U;
    out[i][457U] = 0U;
    out[i][458U] = 0U;
    out[i][459U] = 0U;
    out[i][460U] = 0U;
    out[i][461U] = 0U;
    out[i][462U] = 0U;
    out[i][463U] = 0U;
    out[i][464U] = 0U;
    out[i][465U] = 0U;
    out[i][466U] = 0U;
    out[i][467U] = 0U;
    out[i][468U] = 0U;
    out[i][469U] = 0U;
    out[i][470U] = 0U;
    out[i][471U] = 0U;
    out[i][472U] = 0U;
    out[i][473U] = 0U;
    out[i][474U] = 0U;
    out[i][475U] = 0U;
    out[i][476U] = 0U;
    out[i][477U] = 0U;
    out[i][478U] = 0U;
    out[i][479U] = 0U;
    out[i][480U] = 0U;
    out[i][481U] = 0U;
    out[i][482U] = 0U;
    out[i][483U] = 0U;
    out[i][484U] = 0U;
    out[i][485U] = 0U;
    out[i][486U] = 0U;
    out[i][487U] = 0U;
    out[i][488U] = 0U;
    out[i][489U] = 0U;
    out[i][490U] = 0U;
    out[i][491U] = 0U;
    out[i][492U] = 0U;
    out[i][493U] = 0U;
    out[i][494U] = 0U;
    out[i][495U] = 0U;
    out[i][496U] = 0U;
    out[i][497U] = 0U;
    out[i][498U] = 0U;
    out[i][499U] = 0U;
    out[i][500U] = 0U;
    out[i][501U] = 0U;
    out[i][502U] = 0U;
    out[i][503U] = 0U;
    out[i][504U] = 0U;
    out[i][505U] = 0U;
    out[i][506U] = 0U;
    out[i][507U] = 0U;
    out[i][508U] = 0U;
    out[i][509U] = 0U;
    out[i][510U] = 0U;
    out[i][511U] = 0U;
    out[i][512U] = 0U;
    out[i][513U] = 0U;
    out[i][514U] = 0U;
    out[i][515U] = 0U;
    out[i][516U] = 0U;
    out[i][517U] = 0U;
    out[i][518U] = 0U;
    out[i][519U] = 0U;
    out[i][520U] = 0U;
    out[i][521U] = 0U;
    out[i][522U] = 0U;
    out[i][523U] = 0U;
    out[i][524U] = 0U;
    out[i][525U] = 0U;
    out[i][526U] = 0U;
    out[i][527U] = 0U;
    out[i][528U] = 0U;
    out[i][529U] = 0U;
    out[i][530U] = 0U;
    out[i][531U] = 0U;
    out[i][532U] = 0U;
    out[i][533U] = 0U;
    out[i][534U] = 0U;
    out[i][535U] = 0U;
    out[i][536U] = 0U;
    out[i][537U] = 0U;
    out[i][538U] = 0U;
    out[i][539U] = 0U;
    out[i][540U] = 0U;
    out[i][541U] = 0U;
    out[i][542U] = 0U;
    out[i][543U] = 0U;
    out[i][544U] = 0U;
    out[i][545U] = 0U;
    out[i][546U] = 0U;
    out[i][547U] = 0U;
    out[i][548U] = 0U;
    out[i][549U] = 0U;
    out[i][550U] = 0U;
    out[i][551U] = 0U;
    out[i][552U] = 0U;
    out[i][553U] = 0U;
    out[i][554U] = 0U;
    out[i][555U] = 0U;
    out[i][556U] = 0U;
    out[i][557U] = 0U;
    out[i][558U] = 0U;
    out[i][559U] = 0U;
    out[i][560U] = 0U;
    out[i][561U] = 0U;
    out[i][562U] = 0U;
    out[i][563U] = 0U;
    out[i][564U] = 0U;
    out[i][565U] = 0U;
    out[i][566U] = 0U;
    out[i][567U] = 0U;
    out[i][568U] = 0U;
    out[i][569U] = 0U;
    out[i][570U] = 0U;
    out[i][571U] = 0U;
    out[i][572U] = 0U;
    out[i][573U] = 0U;
    out[i][574U] = 0U;
    out[i][575U] = 0U;
    out[i][576U] = 0U;
    out[i][577U] = 0U;
    out[i][578U] = 0U;
    out[i][579U] = 0U;
    out[i][580U] = 0U;
    out[i][581U] = 0U;
    out[i][582U] = 0U;
    out[i][583U] = 0U;
    out[i][584U] = 0U;
    out[i][585U] = 0U;
    out[i][586U] = 0U;
    out[i][587U] = 0U;
    out[i][588U] = 0U;
    out[i][589U] = 0U;
    out[i][590U] = 0U;
    out[i][591U] = 0U;
    out[i][592U] = 0U;
    out[i][593U] = 0U;
    out[i][594U] = 0U;
    out[i][595U] = 0U;
    out[i][596U] = 0U;
    out[i][597U] = 0U;
    out[i][598U] = 0U;
    out[i][599U] = 0U;
    out[i][600U] = 0U;
    out[i][601U] = 0U;
    out[i][602U] = 0U;
    out[i][603U] = 0U;
    out[i][604U] = 0U;
    out[i][605U] = 0U;
    out[i][606U] = 0U;
    out[i][607U] = 0U;
    out[i][608U] = 0U;
    out[i][609U] = 0U;
    out[i][610U] = 0U;
    out[i][611U] = 0U;
    out[i][612U] = 0U;
    out[i][613U] = 0U;
    out[i][614U] = 0U;
    out[i][615U] = 0U;
    out[i][616U] = 0U;
    out[i][617U] = 0U;
    out[i][618U] = 0U;
    out[i][619U] = 0U;
    out[i][620U] = 0U;
    out[i][621U] = 0U;
    out[i][622U] = 0U;
    out[i][623U] = 0U;
    out[i][624U] = 0U;
    out[i][625U] = 0U;
    out[i][626U] = 0U;
    out[i][627U] = 0U;
    out[i][628U] = 0U;
    out[i][629U] = 0U;
    out[i][630U] = 0U;
    out[i][631U] = 0U;
    out[i][632U] = 0U;
    out[i][633U] = 0U;
    out[i][634U] = 0U;
    out[i][635U] = 0U;
    out[i][636U] = 0U;
    out[i][637U] = 0U;
    out[i][638U] = 0U;
    out[i][639U] = 0U;
    out[i][640U] = 0U;
    out[i][641U] = 0U;
    out[i][642U] = 0U;
    out[i][643U] = 0U;
    out[i][644U] = 0U;
    out[i][645U] = 0U;
    out[i][646U] = 0U;
    out[i][647U] = 0U;
    out[i][648U] = 0U;
    out[i][649U] = 0U;
    out[i][650U] = 0U;
    out[i][651U] = 0U;
    out[i][652U] = 0U;
    out[i][653U] = 0U;
    out[i][654U] = 0U;
    out[i][655U] = 0U;
    out[i][656U] = 0U;
    out[i][657U] = 0U;
    out[i][658U] = 0U;
    out[i][659U] = 0U;
    out[i][660U] = 0U;
    out[i][661U] = 0U;
    out[i][662U] = 0U;
    out[i][663U] = 0U;
    out[i][664U] = 0U;
    out[i][665U] = 0U;
    out[i][666U] = 0U;
    out[i][667U] = 0U;
    out[i][668U] = 0U;
    out[i][669U] = 0U;
    out[i][670U] = 0U;
    out[i][671U] = 0U;
    out[i][672U] = 0U;
    out[i][673U] = 0U;
    out[i][674U] = 0U;
    out[i][675U] = 0U;
    out[i][676U] = 0U;
    out[i][677U] = 0U;
    out[i][678U] = 0U;
    out[i][679U] = 0U;
    out[i][680U] = 0U;
    out[i][681U] = 0U;
    out[i][682U] = 0U;
    out[i][683U] = 0U;
    out[i][684U] = 0U;
    out[i][685U] = 0U;
    out[i][686U] = 0U;
    out[i][687U] = 0U;
    out[i][688U] = 0U;
    out[i][689U] = 0U;
    out[i][690U] = 0U;
    out[i][691U] = 0U;
    out[i][692U] = 0U;
    out[i][693U] = 0U;
    out[i][694U] = 0U;
    out[i][695U] = 0U;
    out[i][696U] = 0U;
    out[i][697U] = 0U;
    out[i][698U] = 0U;
    out[i][699U] = 0U;
    out[i][700U] = 0U;
    out[i][701U] = 0U;
    out[i][702U] = 0U;
    out[i][703U] = 0U;
    out[i][704U] = 0U;
    out[i][705U] = 0U;
    out[i][706U] = 0U;
    out[i][707U] = 0U;
    out[i][708U] = 0U;
    out[i][709U] = 0U;
    out[i][710U] = 0U;
    out[i][711U] = 0U;
    out[i][712U] = 0U;
    out[i][713U] = 0U;
    out[i][714U] = 0U;
    out[i][715U] = 0U;
    out[i][716U] = 0U;
    out[i][717U] = 0U;
    out[i][718U] = 0U;
    out[i][719U] = 0U;
    out[i][720U] = 0U;
    out[i][721U] = 0U;
    out[i][722U] = 0U;
    out[i][723U] = 0U;
    out[i][724U] = 0U;
    out[i][725U] = 0U;
    out[i][726U] = 0U;
    out[i][727U] = 0U;
    out[i][728U] = 0U;
    out[i][729U] = 0U;
    out[i][730U] = 0U;
    out[i][731U] = 0U;
    out[i][732U] = 0U;
    out[i][733U] = 0U;
    out[i][734U] = 0U;
    out[i][735U] = 0U;
    out[i][736U] = 0U;
    out[i][737U] = 0U;
    out[i][738U] = 0U;
    out[i][739U] = 0U;
    out[i][740U] = 0U;
    out[i][741U] = 0U;
    out[i][742U] = 0U;
    out[i][743U] = 0U;
    out[i][744U] = 0U;
    out[i][745U] = 0U;
    out[i][746U] = 0U;
    out[i][747U] = 0U;
    out[i][748U] = 0U;
    out[i][749U] = 0U;
    out[i][750U] = 0U;
    out[i][751U] = 0U;
    out[i][752U] = 0U;
    out[i][753U] = 0U;
    out[i][754U] = 0U;
    out[i][755U] = 0U;
    out[i][756U] = 0U;
    out[i][757U] = 0U;
    out[i][758U] = 0U;
    out[i][759U] = 0U;
    out[i][760U] = 0U;
    out[i][761U] = 0U;
    out[i][762U] = 0U;
    out[i][763U] = 0U;
    out[i][764U] = 0U;
    out[i][765U] = 0U;
    out[i][766U] = 0U;
    out[i][767U] = 0U;
    out[i][768U] = 0U;
    out[i][769U] = 0U;
    out[i][770U] = 0U;
    out[i][771U] = 0U;
    out[i][772U] = 0U;
    out[i][773U] = 0U;
    out[i][774U] = 0U;
    out[i][775U] = 0U;
    out[i][776U] = 0U;
    out[i][777U] = 0U;
    out[i][778U] = 0U;
    out[i][779U] = 0U;
    out[i][780U] = 0U;
    out[i][781U] = 0U;
    out[i][782U] = 0U;
    out[i][783U] = 0U;
    out[i][784U] = 0U;
    out[i][785U] = 0U;
    out[i][786U] = 0U;
    out[i][787U] = 0U;
    out[i][788U] = 0U;
    out[i][789U] = 0U;
    out[i][790U] = 0U;
    out[i][791U] = 0U;
    out[i][792U] = 0U;
    out[i][793U] = 0U;
    out[i][794U] = 0U;
    out[i][795U] = 0U;
    out[i][796U] = 0U;
    out[i][797U] = 0U;
    out[i][798U] = 0U;
    out[i][799U] = 0U;
    out[i][800U] = 0U;
    out[i][801U] = 0U;
    out[i][802U] = 0U;
    out[i][803U] = 0U;
    out[i][804U] = 0U;
    out[i][805U] = 0U;
    out[i][806U] = 0U;
    out[i][807U] = 0U;
    out[i][808U] = 0U;
    out[i][809U] = 0U;
    out[i][810U] = 0U;
    out[i][811U] = 0U;
    out[i][812U] = 0U;
    out[i][813U] = 0U;
    out[i][814U] = 0U;
    out[i][815U] = 0U;
    out[i][816U] = 0U;
    out[i][817U] = 0U;
    out[i][818U] = 0U;
    out[i][819U] = 0U;
    out[i][820U] = 0U;
    out[i][821U] = 0U;
    out[i][822U] = 0U;
    out[i][823U] = 0U;
    out[i][824U] = 0U;
    out[i][825U] = 0U;
    out[i][826U] = 0U;
    out[i][827U] = 0U;
    out[i][828U] = 0U;
    out[i][829U] = 0U;
    out[i][830U] = 0U;
    out[i][831U] = 0U;
    out[i][832U] = 0U;
    out[i][833U] = 0U;
    out[i][834U] = 0U;
    out[i][835U] = 0U;
    out[i][836U] = 0U;
    out[i][837U] = 0U;
    out[i][838U] = 0U;
    out[i][839U] = 0U;
  }
  bool uu____0;
  if (!libcrux_platform_simd256_support())
    uu____0 = true;
  else
    uu____0 = !false;
  if (uu____0)
  {
    core_ops_range_Range__size_t lit;
    lit.start = (size_t)0U;
    lit.end = (size_t)3U;
    core_ops_range_Range__size_t
    iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
    while (true)
    {
      core_option_Option__size_t
      uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
      if (!(uu____1.tag == core_option_None))
      {
        if (uu____1.tag == core_option_Some)
        {
          size_t i = uu____1.f0;
          uint8_t uu____2[840U];
          libcrux_digest_shake128((size_t)840U,
            Eurydice_array_to_slice((size_t)34U, input[i], uint8_t),
            uu____2);
          memcpy(out[i], uu____2, (size_t)840U * sizeof (uint8_t));
        }
        else
        {
          KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
          KRML_HOST_EXIT(255U);
        }
      }
    }
  }
  else
  {
    Eurydice_slice uu____3 = Eurydice_array_to_slice((size_t)34U, input[0U], uint8_t);
    Eurydice_slice uu____4 = Eurydice_array_to_slice((size_t)34U, input[1U], uint8_t);
    Eurydice_slice uu____5 = Eurydice_array_to_slice((size_t)34U, input[2U], uint8_t);
    __uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t_
    uu____6 =
      libcrux_digest_shake128x4((size_t)840U,
        uu____3,
        uu____4,
        uu____5,
        Eurydice_array_to_slice((size_t)34U, input[0U], uint8_t));
    uint8_t d0[840U];
    memcpy(d0, uu____6.fst, (size_t)840U * sizeof (uint8_t));
    uint8_t d1[840U];
    memcpy(d1, uu____6.snd, (size_t)840U * sizeof (uint8_t));
    uint8_t d2[840U];
    memcpy(d2, uu____6.thd, (size_t)840U * sizeof (uint8_t));
    uint8_t uu____7[840U];
    memcpy(uu____7, d0, (size_t)840U * sizeof (uint8_t));
    memcpy(out[0U], uu____7, (size_t)840U * sizeof (uint8_t));
    uint8_t uu____8[840U];
    memcpy(uu____8, d1, (size_t)840U * sizeof (uint8_t));
    memcpy(out[1U], uu____8, (size_t)840U * sizeof (uint8_t));
    uint8_t uu____9[840U];
    memcpy(uu____9, d2, (size_t)840U * sizeof (uint8_t));
    memcpy(out[2U], uu____9, (size_t)840U * sizeof (uint8_t));
  }
  uint8_t uu____10[3U][840U];
  memcpy(uu____10, out, (size_t)3U * sizeof (uint8_t [840U]));
  memcpy(ret, uu____10, (size_t)3U * sizeof (uint8_t [840U]));
}

K___libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__3size_t__core_option_Option__libcrux_kyber_types_Error
libcrux_kyber_matrix_sample_matrix_A___3size_t(uint8_t seed[34U], bool transpose)
{
  int32_t A_transpose[3U][3U][256U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
    memcpy(A_transpose[i][0U],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  core_option_Option__libcrux_kyber_types_Error sampling_A_error;
  sampling_A_error.tag = core_option_None;
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = (size_t)3U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i0 = uu____0.f0;
        uint8_t uu____1[34U];
        memcpy(uu____1, seed, (size_t)34U * sizeof (uint8_t));
        uint8_t seeds[3U][34U];
        for (size_t i = (size_t)0U; i < (size_t)3U; i++)
          memcpy(seeds[i], uu____1, (size_t)34U * sizeof (uint8_t));
        core_ops_range_Range__size_t lit0;
        lit0.start = (size_t)0U;
        lit0.end = (size_t)3U;
        core_ops_range_Range__size_t
        iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____2 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
          if (uu____2.tag == core_option_None)
            break;
          else if (uu____2.tag == core_option_Some)
          {
            size_t j = uu____2.f0;
            seeds[j][32U] = (uint8_t)i0;
            seeds[j][33U] = (uint8_t)j;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        uint8_t uu____3[3U][34U];
        memcpy(uu____3, seeds, (size_t)3U * sizeof (uint8_t [34U]));
        uint8_t xof_bytes[3U][840U];
        libcrux_kyber_hash_functions_XOFx4___3size_t(uu____3, xof_bytes);
        core_ops_range_Range__size_t lit;
        lit.start = (size_t)0U;
        lit.end = (size_t)3U;
        core_ops_range_Range__size_t
        iter0 = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____4 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
          if (uu____4.tag == core_option_None)
            break;
          else if (uu____4.tag == core_option_Some)
          {
            size_t j = uu____4.f0;
            uint8_t uu____5[840U];
            memcpy(uu____5, xof_bytes[j], (size_t)840U * sizeof (uint8_t));
            K___libcrux_kyber_arithmetic_PolynomialRingElement_core_option_Option_libcrux_kyber_types_Error
            uu____6 = libcrux_kyber_sampling_sample_from_uniform_distribution___840size_t(uu____5);
            int32_t sampled[256U];
            memcpy(sampled, uu____6.fst, (size_t)256U * sizeof (int32_t));
            core_option_Option__libcrux_kyber_types_Error error = uu____6.snd;
            if (core_option__core__option__Option_T___is_some(&error, libcrux_kyber_types_Error))
              sampling_A_error = error;
            if (transpose)
              memcpy(A_transpose[j][i0], sampled, (size_t)256U * sizeof (int32_t));
            else
              memcpy(A_transpose[i0][j], sampled, (size_t)256U * sizeof (int32_t));
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____7[3U][3U][256U];
    memcpy(uu____7, A_transpose, (size_t)3U * sizeof (int32_t [3U][256U]));
    K___libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__3size_t__core_option_Option__libcrux_kyber_types_Error
    lit;
    memcpy(lit.fst, uu____7, (size_t)3U * sizeof (int32_t [3U][256U]));
    lit.snd = sampling_A_error;
    return lit;
  }
}

K___libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__uint8_t
libcrux_kyber_ind_cpa_sample_vector_cbd_then_ntt___3size_t_2size_t_128size_t(
  uint8_t prf_input[33U],
  uint8_t domain_separator
)
{
  int32_t re_as_ntt[3U][256U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
    memcpy(re_as_ntt[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = (size_t)3U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        prf_input[32U] = domain_separator;
        domain_separator = (uint32_t)domain_separator + 1U;
        uint8_t prf_output[128U];
        libcrux_kyber_hash_functions_PRF___128size_t(Eurydice_array_to_slice((size_t)33U,
            prf_input,
            uint8_t),
          prf_output);
        int32_t r[256U];
        libcrux_kyber_sampling_sample_from_binomial_distribution___2size_t(Eurydice_array_to_slice((size_t)128U,
            prf_output,
            uint8_t),
          r);
        int32_t uu____1[256U];
        libcrux_kyber_ntt_ntt_binomially_sampled_ring_element(r, uu____1);
        memcpy(re_as_ntt[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[3U][256U];
    memcpy(uu____2, re_as_ntt, (size_t)3U * sizeof (int32_t [256U]));
    K___libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__uint8_t lit;
    memcpy(lit.fst, uu____2, (size_t)3U * sizeof (int32_t [256U]));
    lit.snd = domain_separator;
    return lit;
  }
}

void
libcrux_kyber_arithmetic_add_to_ring_element___3size_t(
  int32_t lhs[256U],
  int32_t (*rhs)[256U],
  int32_t ret[256U]
)
{
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, lhs, int32_t),
      int32_t);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        size_t uu____1 = i;
        lhs[uu____1] = lhs[uu____1] + rhs[0U][i];
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, lhs, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_matrix_compute_As_plus_e___3size_t(
  int32_t (*matrix_A)[3U][256U],
  int32_t (*s_as_ntt)[256U],
  int32_t (*error_as_ntt)[256U],
  int32_t ret[3U][256U]
)
{
  int32_t result[3U][256U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
    memcpy(result[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)3U,
        matrix_A,
        Eurydice_error_t_cg_array),
      int32_t [3U][256U]);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        core_ops_range_Range__size_t lit;
        lit.start = (size_t)0U;
        lit.end =
          core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)3U,
              matrix_A[i],
              int32_t [256U]),
            int32_t [256U]);
        core_ops_range_Range__size_t
        iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
          if (uu____1.tag == core_option_None)
            break;
          else if (uu____1.tag == core_option_Some)
          {
            size_t j = uu____1.f0;
            int32_t product[256U];
            libcrux_kyber_ntt_ntt_multiply(&matrix_A[i][j], &s_as_ntt[j], product);
            int32_t uu____2[256U];
            libcrux_kyber_arithmetic_add_to_ring_element___3size_t(result[i], &product, uu____2);
            memcpy(result[i], uu____2, (size_t)256U * sizeof (int32_t));
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        core_ops_range_Range__size_t lit0;
        lit0.start = (size_t)0U;
        lit0.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
        core_ops_range_Range__size_t
        iter0 = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____3 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
          if (uu____3.tag == core_option_None)
            break;
          else if (uu____3.tag == core_option_Some)
          {
            size_t j = uu____3.f0;
            int32_t
            coefficient_normal_form = libcrux_kyber_arithmetic_to_standard_domain(result[i][j]);
            int32_t
            uu____4 =
              libcrux_kyber_arithmetic_barrett_reduce(coefficient_normal_form + error_as_ntt[i][j]);
            result[i][j] = uu____4;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____5[3U][256U];
    memcpy(uu____5, result, (size_t)3U * sizeof (int32_t [256U]));
    memcpy(ret, uu____5, (size_t)3U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_ind_cpa_serialize_secret_key___3size_t_1152size_t(
  int32_t key[3U][256U],
  uint8_t ret[1152U]
)
{
  uint8_t out[1152U];
  for (size_t i = (size_t)0U; i < (size_t)1152U; i++)
    out[i] = 0U;
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)3U, key, int32_t [256U]),
      int32_t [256U]);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t re[256U];
        memcpy(re, key[i], (size_t)256U * sizeof (int32_t));
        core_ops_range_Range__size_t lit;
        lit.start = i * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        lit.end = (i + (size_t)1U) * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        Eurydice_slice
        uu____1 =
          Eurydice_array_to_subslice((size_t)1152U,
            out,
            lit,
            uint8_t,
            core_ops_range_Range__size_t);
        uint8_t ret[384U];
        libcrux_kyber_serialize_serialize_uncompressed_ring_element(re, ret);
        core_slice___Slice_T___copy_from_slice(uu____1,
          Eurydice_array_to_slice((size_t)384U, ret, uint8_t),
          uint8_t);
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____2[1152U];
    memcpy(uu____2, out, (size_t)1152U * sizeof (uint8_t));
    memcpy(ret, uu____2, (size_t)1152U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_ind_cpa_serialize_public_key___3size_t_1152size_t_1184size_t(
  int32_t t_as_ntt[3U][256U],
  Eurydice_slice seed_for_a,
  uint8_t ret[1184U]
)
{
  uint8_t public_key_serialized[1184U];
  for (size_t i = (size_t)0U; i < (size_t)1184U; i++)
    public_key_serialized[i] = 0U;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)1152U;
  Eurydice_slice
  uu____0 =
    Eurydice_array_to_subslice((size_t)1184U,
      public_key_serialized,
      lit,
      uint8_t,
      core_ops_range_Range__size_t);
  int32_t uu____1[3U][256U];
  memcpy(uu____1, t_as_ntt, (size_t)3U * sizeof (int32_t [256U]));
  uint8_t ret0[1152U];
  libcrux_kyber_ind_cpa_serialize_secret_key___3size_t_1152size_t(uu____1, ret0);
  core_slice___Slice_T___copy_from_slice(uu____0,
    Eurydice_array_to_slice((size_t)1152U, ret0, uint8_t),
    uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice_from((size_t)1184U,
      public_key_serialized,
      (size_t)1152U,
      uint8_t,
      size_t),
    seed_for_a,
    uint8_t);
  uint8_t uu____2[1184U];
  memcpy(uu____2, public_key_serialized, (size_t)1184U * sizeof (uint8_t));
  memcpy(ret, uu____2, (size_t)1184U * sizeof (uint8_t));
}

K___uint8_t_1152size_t____uint8_t_1184size_t__core_option_Option__libcrux_kyber_types_Error
libcrux_kyber_ind_cpa_generate_keypair___3size_t_1152size_t_1184size_t_1152size_t_2size_t_128size_t(
  Eurydice_slice key_generation_seed
)
{
  uint8_t hashed[64U];
  libcrux_kyber_hash_functions_G(key_generation_seed, hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____0 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U, hashed, uint8_t),
      (size_t)32U,
      uint8_t);
  Eurydice_slice seed_for_A = uu____0.fst;
  Eurydice_slice seed_for_secret_and_error = uu____0.snd;
  uint8_t ret[34U];
  libcrux_kyber_ind_cpa_into_padded_array___34size_t(seed_for_A, ret);
  K___libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__3size_t__core_option_Option__libcrux_kyber_types_Error
  uu____1 = libcrux_kyber_matrix_sample_matrix_A___3size_t(ret, true);
  int32_t A_transpose[3U][3U][256U];
  memcpy(A_transpose, uu____1.fst, (size_t)3U * sizeof (int32_t [3U][256U]));
  core_option_Option__libcrux_kyber_types_Error sampling_A_error = uu____1.snd;
  uint8_t prf_input[33U];
  libcrux_kyber_ind_cpa_into_padded_array___33size_t(seed_for_secret_and_error, prf_input);
  uint8_t uu____2[33U];
  memcpy(uu____2, prf_input, (size_t)33U * sizeof (uint8_t));
  K___libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__uint8_t
  uu____3 =
    libcrux_kyber_ind_cpa_sample_vector_cbd_then_ntt___3size_t_2size_t_128size_t(uu____2,
      0U);
  int32_t secret_as_ntt[3U][256U];
  memcpy(secret_as_ntt, uu____3.fst, (size_t)3U * sizeof (int32_t [256U]));
  uint8_t domain_separator = uu____3.snd;
  uint8_t uu____4[33U];
  memcpy(uu____4, prf_input, (size_t)33U * sizeof (uint8_t));
  int32_t error_as_ntt[3U][256U];
  memcpy(error_as_ntt,
    libcrux_kyber_ind_cpa_sample_vector_cbd_then_ntt___3size_t_2size_t_128size_t(uu____4,
      domain_separator).fst,
    (size_t)3U * sizeof (int32_t [256U]));
  int32_t t_as_ntt[3U][256U];
  libcrux_kyber_matrix_compute_As_plus_e___3size_t(A_transpose,
    secret_as_ntt,
    error_as_ntt,
    t_as_ntt);
  int32_t uu____5[3U][256U];
  memcpy(uu____5, t_as_ntt, (size_t)3U * sizeof (int32_t [256U]));
  uint8_t public_key_serialized[1184U];
  libcrux_kyber_ind_cpa_serialize_public_key___3size_t_1152size_t_1184size_t(uu____5,
    seed_for_A,
    public_key_serialized);
  int32_t uu____6[3U][256U];
  memcpy(uu____6, secret_as_ntt, (size_t)3U * sizeof (int32_t [256U]));
  uint8_t secret_key_serialized[1152U];
  libcrux_kyber_ind_cpa_serialize_secret_key___3size_t_1152size_t(uu____6,
    secret_key_serialized);
  uint8_t uu____7[1152U];
  memcpy(uu____7, secret_key_serialized, (size_t)1152U * sizeof (uint8_t));
  uint8_t uu____8[1184U];
  memcpy(uu____8, public_key_serialized, (size_t)1184U * sizeof (uint8_t));
  K___uint8_t_1152size_t____uint8_t_1184size_t__core_option_Option__libcrux_kyber_types_Error
  lit;
  memcpy(lit.fst.fst, uu____7, (size_t)1152U * sizeof (uint8_t));
  memcpy(lit.fst.snd, uu____8, (size_t)1184U * sizeof (uint8_t));
  lit.snd = sampling_A_error;
  return lit;
}

void
libcrux_kyber_serialize_kem_secret_key___2400size_t(
  Eurydice_slice private_key,
  Eurydice_slice public_key,
  Eurydice_slice implicit_rejection_value,
  uint8_t ret[2400U]
)
{
  uint8_t out[2400U];
  for (size_t i = (size_t)0U; i < (size_t)2400U; i++)
    out[i] = 0U;
  size_t pointer = (size_t)0U;
  uint8_t *uu____0 = out;
  size_t uu____1 = pointer;
  core_ops_range_Range__size_t lit0;
  lit0.start = pointer;
  lit0.end = uu____1 + core_slice___Slice_T___len(private_key, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)2400U,
      uu____0,
      lit0,
      uint8_t,
      core_ops_range_Range__size_t),
    private_key,
    uint8_t);
  pointer = pointer + core_slice___Slice_T___len(private_key, uint8_t);
  uint8_t *uu____2 = out;
  size_t uu____3 = pointer;
  core_ops_range_Range__size_t lit1;
  lit1.start = pointer;
  lit1.end = uu____3 + core_slice___Slice_T___len(public_key, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)2400U,
      uu____2,
      lit1,
      uint8_t,
      core_ops_range_Range__size_t),
    public_key,
    uint8_t);
  pointer = pointer + core_slice___Slice_T___len(public_key, uint8_t);
  core_ops_range_Range__size_t lit2;
  lit2.start = pointer;
  lit2.end = pointer + libcrux_kyber_constants_H_DIGEST_SIZE;
  Eurydice_slice
  uu____4 =
    Eurydice_array_to_subslice((size_t)2400U,
      out,
      lit2,
      uint8_t,
      core_ops_range_Range__size_t);
  uint8_t ret0[32U];
  libcrux_kyber_hash_functions_H(public_key, ret0);
  core_slice___Slice_T___copy_from_slice(uu____4,
    Eurydice_array_to_slice((size_t)32U, ret0, uint8_t),
    uint8_t);
  pointer = pointer + libcrux_kyber_constants_H_DIGEST_SIZE;
  uint8_t *uu____5 = out;
  size_t uu____6 = pointer;
  core_ops_range_Range__size_t lit;
  lit.start = pointer;
  lit.end = uu____6 + core_slice___Slice_T___len(implicit_rejection_value, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)2400U,
      uu____5,
      lit,
      uint8_t,
      core_ops_range_Range__size_t),
    implicit_rejection_value,
    uint8_t);
  uint8_t uu____7[2400U];
  memcpy(uu____7, out, (size_t)2400U * sizeof (uint8_t));
  memcpy(ret, uu____7, (size_t)2400U * sizeof (uint8_t));
}

void
libcrux_kyber_types__libcrux_kyber__types__KyberPrivateKey_SIZE__8__from___2400size_t(
  uint8_t value[2400U],
  uint8_t ret[2400U]
)
{
  uint8_t uu____0[2400U];
  memcpy(uu____0, value, (size_t)2400U * sizeof (uint8_t));
  memcpy(ret, uu____0, (size_t)2400U * sizeof (uint8_t));
}

libcrux_kyber_types_KyberKeyPair___2400size_t_1184size_t
libcrux_kyber_types__libcrux_kyber__types__KyberKeyPair_PRIVATE_KEY_SIZE__PUBLIC_KEY_SIZE___from___2400size_t_1184size_t(
  uint8_t sk[2400U],
  uint8_t pk[1184U]
)
{
  libcrux_kyber_types_KyberKeyPair___2400size_t_1184size_t lit;
  memcpy(lit.sk, sk, (size_t)2400U * sizeof (uint8_t));
  memcpy(lit.pk, pk, (size_t)1184U * sizeof (uint8_t));
  return lit;
}

core_result_Result__libcrux_kyber_types_KyberKeyPair__1184size_t____2400size_t___libcrux_kyber_types_Error
libcrux_kyber_generate_keypair___3size_t_1152size_t_2400size_t_1184size_t_1152size_t_2size_t_128size_t(
  uint8_t randomness[64U]
)
{
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = libcrux_kyber_constants_CPA_PKE_KEY_GENERATION_SEED_SIZE;
  Eurydice_slice
  ind_cpa_keypair_randomness =
    Eurydice_array_to_subslice((size_t)64U,
      randomness,
      lit0,
      uint8_t,
      core_ops_range_Range__size_t);
  Eurydice_slice
  implicit_rejection_value =
    Eurydice_array_to_subslice_from((size_t)64U,
      randomness,
      libcrux_kyber_constants_CPA_PKE_KEY_GENERATION_SEED_SIZE,
      uint8_t,
      size_t);
  K___uint8_t_1152size_t____uint8_t_1184size_t__core_option_Option__libcrux_kyber_types_Error
  uu____0 =
    libcrux_kyber_ind_cpa_generate_keypair___3size_t_1152size_t_1184size_t_1152size_t_2size_t_128size_t(ind_cpa_keypair_randomness);
  uint8_t ind_cpa_private_key[1152U];
  memcpy(ind_cpa_private_key, uu____0.fst.fst, (size_t)1152U * sizeof (uint8_t));
  uint8_t public_key[1184U];
  memcpy(public_key, uu____0.fst.snd, (size_t)1184U * sizeof (uint8_t));
  core_option_Option__libcrux_kyber_types_Error sampling_a_error = uu____0.snd;
  Eurydice_slice uu____1 = Eurydice_array_to_slice((size_t)1152U, ind_cpa_private_key, uint8_t);
  uint8_t secret_key_serialized[2400U];
  libcrux_kyber_serialize_kem_secret_key___2400size_t(uu____1,
    Eurydice_array_to_slice((size_t)1184U, public_key, uint8_t),
    implicit_rejection_value,
    secret_key_serialized);
  core_result_Result__libcrux_kyber_types_KyberKeyPair__1184size_t____2400size_t___libcrux_kyber_types_Error
  uu____2;
  if (sampling_a_error.tag == core_option_Some)
  {
    libcrux_kyber_types_Error error = sampling_a_error.f0;
    core_result_Result__libcrux_kyber_types_KyberKeyPair__1184size_t____2400size_t___libcrux_kyber_types_Error
    lit;
    lit.tag = core_result_Err;
    lit.val.case_Err = error;
    uu____2 = lit;
  }
  else
  {
    uint8_t uu____3[2400U];
    memcpy(uu____3, secret_key_serialized, (size_t)2400U * sizeof (uint8_t));
    uint8_t private_key[2400U];
    libcrux_kyber_types__libcrux_kyber__types__KyberPrivateKey_SIZE__8__from___2400size_t(uu____3,
      private_key);
    uint8_t uu____4[2400U];
    memcpy(uu____4, private_key, (size_t)2400U * sizeof (uint8_t));
    uint8_t uu____5[1184U];
    memcpy(uu____5, public_key, (size_t)1184U * sizeof (uint8_t));
    core_result_Result__libcrux_kyber_types_KyberKeyPair__1184size_t____2400size_t___libcrux_kyber_types_Error
    lit;
    lit.tag = core_result_Ok;
    lit.val.case_Ok =
      libcrux_kyber_types__libcrux_kyber__types__KyberKeyPair_PRIVATE_KEY_SIZE__PUBLIC_KEY_SIZE___from___2400size_t_1184size_t(uu____4,
        uu____5);
    uu____2 = lit;
  }
  return uu____2;
}

core_result_Result__libcrux_kyber_types_KyberKeyPair__1184size_t____2400size_t___libcrux_kyber_types_Error
libcrux_kyber_kyber768_generate_key_pair_768(uint8_t randomness[64U])
{
  uint8_t uu____0[64U];
  memcpy(uu____0, randomness, (size_t)64U * sizeof (uint8_t));
  return
    libcrux_kyber_generate_keypair___3size_t_1152size_t_2400size_t_1184size_t_1152size_t_2size_t_128size_t(uu____0);
}

uint8_t
*libcrux_kyber_types__libcrux_kyber__types__KyberPublicKey_SIZE__18__as_slice___1184size_t(
  uint8_t (*self)[1184U]
)
{
  return self[0U];
}

void
libcrux_kyber_ind_cpa_deserialize_public_key___3size_t_1152size_t(
  Eurydice_slice public_key,
  int32_t ret[3U][256U]
)
{
  int32_t t_as_ntt[3U][256U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
    memcpy(t_as_ntt[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = (size_t)1152U / libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        core_ops_range_Range__size_t lit;
        lit.start = i * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        lit.end = i * (libcrux_kyber_constants_BYTES_PER_RING_ELEMENT + (size_t)1U);
        Eurydice_slice
        t_as_ntt_bytes =
          Eurydice_slice_subslice(public_key,
            lit,
            uint8_t,
            core_ops_range_Range__size_t);
        int32_t uu____1[256U];
        libcrux_kyber_serialize_deserialize_to_uncompressed_ring_element(t_as_ntt_bytes, uu____1);
        memcpy(t_as_ntt[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[3U][256U];
    memcpy(uu____2, t_as_ntt, (size_t)3U * sizeof (int32_t [256U]));
    memcpy(ret, uu____2, (size_t)3U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_ind_cpa_sample_ring_element_cbd___3size_t_128size_t_2size_t(
  uint8_t *prf_input,
  uint8_t *domain_separator,
  int32_t ret[3U][256U]
)
{
  int32_t error_1[3U][256U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
    memcpy(error_1[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)3U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        prf_input[32U] = domain_separator[0U];
        domain_separator[0U] = (uint32_t)domain_separator[0U] + 1U;
        uint8_t prf_output[128U];
        libcrux_kyber_hash_functions_PRF___128size_t(Eurydice_array_to_slice((size_t)33U,
            prf_input,
            uint8_t),
          prf_output);
        int32_t uu____1[256U];
        libcrux_kyber_sampling_sample_from_binomial_distribution___2size_t(Eurydice_array_to_slice((size_t)128U,
            prf_output,
            uint8_t),
          uu____1);
        memcpy(error_1[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[3U][256U];
    memcpy(uu____2, error_1, (size_t)3U * sizeof (int32_t [256U]));
    memcpy(ret, uu____2, (size_t)3U * sizeof (int32_t [256U]));
    return;
  }
}

void libcrux_kyber_ntt_invert_ntt_montgomery___3size_t(int32_t re[256U], int32_t ret[256U])
{
  size_t zeta_i = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT / (size_t)2U;
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)1U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)2U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)3U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)4U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)5U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)6U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)7U, re);
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)8U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t uu____1 = libcrux_kyber_arithmetic_barrett_reduce(re[i]);
        re[i] = uu____1;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, re, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_matrix_compute_vector_u___3size_t(
  int32_t (*a_as_ntt)[3U][256U],
  int32_t (*r_as_ntt)[256U],
  int32_t (*error_1)[256U],
  int32_t ret[3U][256U]
)
{
  int32_t result[3U][256U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
    memcpy(result[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)3U,
        a_as_ntt,
        Eurydice_error_t_cg_array),
      int32_t [3U][256U]);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        core_ops_range_Range__size_t lit;
        lit.start = (size_t)0U;
        lit.end =
          core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)3U,
              a_as_ntt[i],
              int32_t [256U]),
            int32_t [256U]);
        core_ops_range_Range__size_t
        iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
          if (uu____1.tag == core_option_None)
            break;
          else if (uu____1.tag == core_option_Some)
          {
            size_t j = uu____1.f0;
            int32_t product[256U];
            libcrux_kyber_ntt_ntt_multiply(&a_as_ntt[i][j], &r_as_ntt[j], product);
            int32_t uu____2[256U];
            libcrux_kyber_arithmetic_add_to_ring_element___3size_t(result[i], &product, uu____2);
            memcpy(result[i], uu____2, (size_t)256U * sizeof (int32_t));
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        int32_t uu____3[256U];
        libcrux_kyber_ntt_invert_ntt_montgomery___3size_t(result[i], uu____3);
        memcpy(result[i], uu____3, (size_t)256U * sizeof (int32_t));
        core_ops_range_Range__size_t lit0;
        lit0.start = (size_t)0U;
        lit0.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
        core_ops_range_Range__size_t
        iter0 = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____4 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
          if (uu____4.tag == core_option_None)
            break;
          else if (uu____4.tag == core_option_Some)
          {
            size_t j = uu____4.f0;
            int32_t
            coefficient_normal_form =
              libcrux_kyber_arithmetic_montgomery_reduce(result[i][j] * (int32_t)1441);
            int32_t
            uu____5 =
              libcrux_kyber_arithmetic_barrett_reduce(coefficient_normal_form + error_1[i][j]);
            result[i][j] = uu____5;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____6[3U][256U];
    memcpy(uu____6, result, (size_t)3U * sizeof (int32_t [256U]));
    memcpy(ret, uu____6, (size_t)3U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_matrix_compute_ring_element_v___3size_t(
  int32_t (*t_as_ntt)[256U],
  int32_t (*r_as_ntt)[256U],
  int32_t (*error_2)[256U],
  int32_t (*message)[256U],
  int32_t ret[256U]
)
{
  int32_t result[256U];
  memcpy(result,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)3U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (uu____0.tag == core_option_None)
      break;
    else if (uu____0.tag == core_option_Some)
    {
      size_t i = uu____0.f0;
      int32_t product[256U];
      libcrux_kyber_ntt_ntt_multiply(&t_as_ntt[i], &r_as_ntt[i], product);
      libcrux_kyber_arithmetic_add_to_ring_element___3size_t(result, &product, result);
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
      KRML_HOST_EXIT(255U);
    }
  }
  libcrux_kyber_ntt_invert_ntt_montgomery___3size_t(result, result);
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter0 = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
    if (!(uu____1.tag == core_option_None))
    {
      if (uu____1.tag == core_option_Some)
      {
        size_t i = uu____1.f0;
        int32_t
        coefficient_normal_form =
          libcrux_kyber_arithmetic_montgomery_reduce(result[i] * (int32_t)1441);
        int32_t
        uu____2 =
          libcrux_kyber_arithmetic_barrett_reduce(coefficient_normal_form
            + error_2[0U][i]
            + message[0U][i]);
        result[i] = uu____2;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, result, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_ind_cpa_compress_then_serialize_u___3size_t_960size_t_10size_t_320size_t(
  int32_t input[3U][256U],
  uint8_t ret[960U]
)
{
  uint8_t out[960U];
  for (size_t i = (size_t)0U; i < (size_t)960U; i++)
    out[i] = 0U;
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)3U, input, int32_t [256U]),
      int32_t [256U]);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t re[256U];
        memcpy(re, input[i], (size_t)256U * sizeof (int32_t));
        core_ops_range_Range__size_t lit;
        lit.start = i * ((size_t)960U / (size_t)3U);
        lit.end = (i + (size_t)1U) * ((size_t)960U / (size_t)3U);
        Eurydice_slice
        uu____1 =
          Eurydice_array_to_subslice((size_t)960U,
            out,
            lit,
            uint8_t,
            core_ops_range_Range__size_t);
        uint8_t ret[320U];
        libcrux_kyber_serialize_compress_then_serialize_ring_element_u___10size_t_320size_t(re,
          ret);
        core_slice___Slice_T___copy_from_slice(uu____1,
          Eurydice_array_to_slice((size_t)320U, ret, uint8_t),
          uint8_t);
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____2[960U];
    memcpy(uu____2, out, (size_t)960U * sizeof (uint8_t));
    memcpy(ret, uu____2, (size_t)960U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_ind_cpa_into_padded_array___1088size_t(Eurydice_slice slice, uint8_t ret[1088U])
{
  if (false)
    LowStar_Ignore_ignore(core_slice___Slice_T___len(slice, uint8_t), size_t);
  uint8_t out[1088U];
  for (size_t i = (size_t)0U; i < (size_t)1088U; i++)
    out[i] = 0U;
  uint8_t *uu____0 = out;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(slice, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)1088U,
      uu____0,
      lit,
      uint8_t,
      core_ops_range_Range__size_t),
    slice,
    uint8_t);
  uint8_t uu____1[1088U];
  memcpy(uu____1, out, (size_t)1088U * sizeof (uint8_t));
  memcpy(ret, uu____1, (size_t)1088U * sizeof (uint8_t));
}

K___uint8_t_1088size_t__core_option_Option__libcrux_kyber_types_Error
libcrux_kyber_ind_cpa_encrypt___3size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(
  Eurydice_slice public_key,
  uint8_t message[32U],
  Eurydice_slice randomness
)
{
  int32_t t_as_ntt[3U][256U];
  libcrux_kyber_ind_cpa_deserialize_public_key___3size_t_1152size_t(public_key, t_as_ntt);
  Eurydice_slice seed = Eurydice_slice_subslice_from(public_key, (size_t)1152U, uint8_t, size_t);
  uint8_t ret[34U];
  libcrux_kyber_ind_cpa_into_padded_array___34size_t(seed, ret);
  K___libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__3size_t__core_option_Option__libcrux_kyber_types_Error
  uu____0 = libcrux_kyber_matrix_sample_matrix_A___3size_t(ret, false);
  int32_t A_transpose[3U][3U][256U];
  memcpy(A_transpose, uu____0.fst, (size_t)3U * sizeof (int32_t [3U][256U]));
  core_option_Option__libcrux_kyber_types_Error sampling_A_error = uu____0.snd;
  uint8_t prf_input[33U];
  libcrux_kyber_ind_cpa_into_padded_array___33size_t(randomness, prf_input);
  uint8_t uu____1[33U];
  memcpy(uu____1, prf_input, (size_t)33U * sizeof (uint8_t));
  K___libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__uint8_t
  uu____2 =
    libcrux_kyber_ind_cpa_sample_vector_cbd_then_ntt___3size_t_2size_t_128size_t(uu____1,
      0U);
  int32_t r_as_ntt[3U][256U];
  memcpy(r_as_ntt, uu____2.fst, (size_t)3U * sizeof (int32_t [256U]));
  uint8_t domain_separator = uu____2.snd;
  int32_t error_1[3U][256U];
  libcrux_kyber_ind_cpa_sample_ring_element_cbd___3size_t_128size_t_2size_t(prf_input,
    &domain_separator,
    error_1);
  prf_input[32U] = domain_separator;
  uint8_t prf_output[128U];
  libcrux_kyber_hash_functions_PRF___128size_t(Eurydice_array_to_slice((size_t)33U,
      prf_input,
      uint8_t),
    prf_output);
  int32_t error_2[256U];
  libcrux_kyber_sampling_sample_from_binomial_distribution___2size_t(Eurydice_array_to_slice((size_t)128U,
      prf_output,
      uint8_t),
    error_2);
  int32_t u[3U][256U];
  libcrux_kyber_matrix_compute_vector_u___3size_t(A_transpose, r_as_ntt, error_1, u);
  uint8_t uu____3[32U];
  memcpy(uu____3, message, (size_t)32U * sizeof (uint8_t));
  int32_t message_as_ring_element[256U];
  libcrux_kyber_serialize_deserialize_then_decompress_message(uu____3, message_as_ring_element);
  int32_t v[256U];
  libcrux_kyber_matrix_compute_ring_element_v___3size_t(t_as_ntt,
    r_as_ntt,
    &error_2,
    &message_as_ring_element,
    v);
  int32_t uu____4[3U][256U];
  memcpy(uu____4, u, (size_t)3U * sizeof (int32_t [256U]));
  uint8_t c1[960U];
  libcrux_kyber_ind_cpa_compress_then_serialize_u___3size_t_960size_t_10size_t_320size_t(uu____4,
    c1);
  uint8_t c2[128U];
  libcrux_kyber_serialize_compress_then_serialize_ring_element_v___4size_t_128size_t(v, c2);
  uint8_t ciphertext[1088U];
  libcrux_kyber_ind_cpa_into_padded_array___1088size_t(Eurydice_array_to_slice((size_t)960U,
      c1,
      uint8_t),
    ciphertext);
  Eurydice_slice
  uu____5 =
    Eurydice_array_to_subslice_from((size_t)1088U,
      ciphertext,
      (size_t)960U,
      uint8_t,
      size_t);
  core_slice___Slice_T___copy_from_slice(uu____5,
    core_array___Array_T__N__23__as_slice((size_t)128U, c2, uint8_t),
    uint8_t);
  uint8_t uu____6[1088U];
  memcpy(uu____6, ciphertext, (size_t)1088U * sizeof (uint8_t));
  K___uint8_t_1088size_t__core_option_Option__libcrux_kyber_types_Error lit;
  memcpy(lit.fst, uu____6, (size_t)1088U * sizeof (uint8_t));
  lit.snd = sampling_A_error;
  return lit;
}

core_result_Result__libcrux_kyber_types_KyberCiphertext___1088size_t___uint8_t_32size_t__libcrux_kyber_types_Error
libcrux_kyber_encapsulate___3size_t_1088size_t_1184size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(
  uint8_t (*public_key)[1184U],
  uint8_t randomness[32U]
)
{
  uint8_t to_hash[64U];
  libcrux_kyber_ind_cpa_into_padded_array___64size_t(Eurydice_array_to_slice((size_t)32U,
      randomness,
      uint8_t),
    to_hash);
  Eurydice_slice
  uu____0 =
    Eurydice_array_to_subslice_from((size_t)64U,
      to_hash,
      libcrux_kyber_constants_H_DIGEST_SIZE,
      uint8_t,
      size_t);
  uint8_t ret[32U];
  libcrux_kyber_hash_functions_H(Eurydice_array_to_slice((size_t)1184U,
      libcrux_kyber_types__libcrux_kyber__types__KyberPublicKey_SIZE__18__as_slice___1184size_t(public_key),
      uint8_t),
    ret);
  core_slice___Slice_T___copy_from_slice(uu____0,
    Eurydice_array_to_slice((size_t)32U, ret, uint8_t),
    uint8_t);
  uint8_t hashed[64U];
  libcrux_kyber_hash_functions_G(Eurydice_array_to_slice((size_t)64U, to_hash, uint8_t), hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____1 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U, hashed, uint8_t),
      libcrux_kyber_constants_SHARED_SECRET_SIZE,
      uint8_t);
  Eurydice_slice shared_secret = uu____1.fst;
  Eurydice_slice pseudorandomness = uu____1.snd;
  Eurydice_slice
  uu____2 =
    Eurydice_array_to_slice((size_t)1184U,
      libcrux_kyber_types__libcrux_kyber__types__KyberPublicKey_SIZE__18__as_slice___1184size_t(public_key),
      uint8_t);
  uint8_t uu____3[32U];
  memcpy(uu____3, randomness, (size_t)32U * sizeof (uint8_t));
  K___uint8_t_1088size_t__core_option_Option__libcrux_kyber_types_Error
  uu____4 =
    libcrux_kyber_ind_cpa_encrypt___3size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(uu____2,
      uu____3,
      pseudorandomness);
  uint8_t ciphertext[1088U];
  memcpy(ciphertext, uu____4.fst, (size_t)1088U * sizeof (uint8_t));
  core_option_Option__libcrux_kyber_types_Error sampling_a_error = uu____4.snd;
  core_result_Result__libcrux_kyber_types_KyberCiphertext___1088size_t___uint8_t_32size_t__libcrux_kyber_types_Error
  uu____5;
  if (sampling_a_error.tag == core_option_None)
  {
    uint8_t uu____6[1088U];
    memcpy(uu____6, ciphertext, (size_t)1088U * sizeof (uint8_t));
    uint8_t uu____7[1088U];
    memcpy(uu____7, uu____6, (size_t)1088U * sizeof (uint8_t));
    core_result_Result__uint8_t_32size_t__core_array_TryFromSliceError
    uu____8 = Eurydice_slice_to_array(shared_secret, Eurydice_slice, uint8_t [32U]);
    if (uu____8.tag == core_result_Ok)
    {
      uint8_t r[32U];
      memcpy(r, uu____8.val.case_Ok, (size_t)32U * sizeof (uint8_t));
      uint8_t uu____9[32U];
      memcpy(uu____9, r, (size_t)32U * sizeof (uint8_t));
      core_result_Result__libcrux_kyber_types_KyberCiphertext___1088size_t___uint8_t_32size_t__libcrux_kyber_types_Error
      lit;
      lit.tag = core_result_Ok;
      memcpy(lit.val.case_Ok.fst, uu____7, (size_t)1088U * sizeof (uint8_t));
      memcpy(lit.val.case_Ok.snd, uu____9, (size_t)32U * sizeof (uint8_t));
      uu____5 = lit;
    }
    else if (uu____8.tag == core_result_Err)
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
      KRML_HOST_EXIT(255U);
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
      KRML_HOST_EXIT(255U);
    }
  }
  else if (sampling_a_error.tag == core_option_Some)
  {
    libcrux_kyber_types_Error e = sampling_a_error.f0;
    core_result_Result__libcrux_kyber_types_KyberCiphertext___1088size_t___uint8_t_32size_t__libcrux_kyber_types_Error
    lit;
    lit.tag = core_result_Err;
    lit.val.case_Err = e;
    uu____5 = lit;
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
    KRML_HOST_EXIT(255U);
  }
  return uu____5;
}

core_result_Result__libcrux_kyber_types_KyberCiphertext___1088size_t___uint8_t_32size_t__libcrux_kyber_types_Error
libcrux_kyber_kyber768_encapsulate_768(uint8_t (*public_key)[1184U], uint8_t randomness[32U])
{
  uint8_t (*uu____0)[1184U] = public_key;
  uint8_t uu____1[32U];
  memcpy(uu____1, randomness, (size_t)32U * sizeof (uint8_t));
  return
    libcrux_kyber_encapsulate___3size_t_1088size_t_1184size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(uu____0,
      uu____1);
}

K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
libcrux_kyber_types__libcrux_kyber__types__KyberPrivateKey_SIZE__12__split_at___2400size_t(
  uint8_t (*self)[2400U],
  size_t mid
)
{
  return
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)2400U, self[0U], uint8_t),
      mid,
      uint8_t);
}

void
libcrux_kyber_ind_cpa_deserialize_then_decompress_u___3size_t_1088size_t_960size_t_10size_t(
  uint8_t *ciphertext,
  int32_t ret[3U][256U]
)
{
  int32_t u_as_ntt[3U][256U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
    memcpy(u_as_ntt[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  size_t
  chunk_size = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT * (size_t)10U / (size_t)8U;
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = (size_t)960U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        core_ops_range_Range__size_t lit;
        lit.start = i * chunk_size;
        lit.end = i * (chunk_size + (size_t)1U);
        Eurydice_slice
        u_bytes =
          Eurydice_array_to_subslice((size_t)1088U,
            ciphertext,
            lit,
            uint8_t,
            core_ops_range_Range__size_t);
        int32_t u[256U];
        libcrux_kyber_serialize_deserialize_then_decompress_ring_element_u___10size_t(u_bytes, u);
        int32_t uu____1[256U];
        libcrux_kyber_ntt_ntt_vector_u___10size_t(u, uu____1);
        memcpy(u_as_ntt[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[3U][256U];
    memcpy(uu____2, u_as_ntt, (size_t)3U * sizeof (int32_t [256U]));
    memcpy(ret, uu____2, (size_t)3U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_ind_cpa_deserialize_secret_key___3size_t(
  Eurydice_slice secret_key,
  int32_t ret[3U][256U]
)
{
  int32_t secret_as_ntt[3U][256U];
  for (size_t i = (size_t)0U; i < (size_t)3U; i++)
    memcpy(secret_as_ntt[i],
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(secret_key,
      uint8_t)
    / libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t uu____1[256U];
        core_ops_range_Range__size_t lit;
        lit.start = i * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        lit.end =
          i
          * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT
          + libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        libcrux_kyber_serialize_deserialize_to_uncompressed_ring_element(Eurydice_slice_subslice(secret_key,
            lit,
            uint8_t,
            core_ops_range_Range__size_t),
          uu____1);
        memcpy(secret_as_ntt[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[3U][256U];
    memcpy(uu____2, secret_as_ntt, (size_t)3U * sizeof (int32_t [256U]));
    memcpy(ret, uu____2, (size_t)3U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_matrix_compute_message___3size_t(
  int32_t (*v)[256U],
  int32_t (*secret_as_ntt)[256U],
  int32_t (*u_as_ntt)[256U],
  int32_t ret[256U]
)
{
  int32_t result[256U];
  memcpy(result,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)3U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (uu____0.tag == core_option_None)
      break;
    else if (uu____0.tag == core_option_Some)
    {
      size_t i = uu____0.f0;
      int32_t product[256U];
      libcrux_kyber_ntt_ntt_multiply(&secret_as_ntt[i], &u_as_ntt[i], product);
      libcrux_kyber_arithmetic_add_to_ring_element___3size_t(result, &product, result);
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
      KRML_HOST_EXIT(255U);
    }
  }
  libcrux_kyber_ntt_invert_ntt_montgomery___3size_t(result, result);
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter0 = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
    if (!(uu____1.tag == core_option_None))
    {
      if (uu____1.tag == core_option_Some)
      {
        size_t i = uu____1.f0;
        int32_t
        coefficient_normal_form =
          libcrux_kyber_arithmetic_montgomery_reduce(result[i] * (int32_t)1441);
        int32_t
        uu____2 = libcrux_kyber_arithmetic_barrett_reduce(v[0U][i] - coefficient_normal_form);
        result[i] = uu____2;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, result, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_ind_cpa_decrypt___3size_t_1088size_t_960size_t_10size_t_4size_t(
  Eurydice_slice secret_key,
  uint8_t *ciphertext,
  uint8_t ret[32U]
)
{
  int32_t u_as_ntt[3U][256U];
  libcrux_kyber_ind_cpa_deserialize_then_decompress_u___3size_t_1088size_t_960size_t_10size_t(ciphertext,
    u_as_ntt);
  int32_t v[256U];
  libcrux_kyber_serialize_deserialize_then_decompress_ring_element_v___4size_t(Eurydice_array_to_subslice_from((size_t)1088U,
      ciphertext,
      (size_t)960U,
      uint8_t,
      size_t),
    v);
  int32_t secret_as_ntt[3U][256U];
  libcrux_kyber_ind_cpa_deserialize_secret_key___3size_t(secret_key, secret_as_ntt);
  int32_t message[256U];
  libcrux_kyber_matrix_compute_message___3size_t(&v, secret_as_ntt, u_as_ntt, message);
  uint8_t ret0[32U];
  libcrux_kyber_serialize_compress_then_serialize_message(message, ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

void
libcrux_kyber_ind_cpa_into_padded_array___1120size_t(Eurydice_slice slice, uint8_t ret[1120U])
{
  if (false)
    LowStar_Ignore_ignore(core_slice___Slice_T___len(slice, uint8_t), size_t);
  uint8_t out[1120U];
  for (size_t i = (size_t)0U; i < (size_t)1120U; i++)
    out[i] = 0U;
  uint8_t *uu____0 = out;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(slice, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)1120U,
      uu____0,
      lit,
      uint8_t,
      core_ops_range_Range__size_t),
    slice,
    uint8_t);
  uint8_t uu____1[1120U];
  memcpy(uu____1, out, (size_t)1120U * sizeof (uint8_t));
  memcpy(ret, uu____1, (size_t)1120U * sizeof (uint8_t));
}

Eurydice_slice
libcrux_kyber_types__libcrux_kyber__types__KyberCiphertext_SIZE__1__as_ref___1088size_t(
  uint8_t (*self)[1088U]
)
{
  return Eurydice_array_to_slice((size_t)1088U, self[0U], uint8_t);
}

uint8_t
libcrux_kyber_constant_time_ops_compare_ciphertexts_in_constant_time___1088size_t(
  Eurydice_slice lhs,
  Eurydice_slice rhs
)
{
  uint8_t r = 0U;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)1088U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        uint8_t uu____1 = Eurydice_slice_index(lhs, i, uint8_t);
        r = (uint32_t)r | ((uint32_t)uu____1 ^ (uint32_t)Eurydice_slice_index(rhs, i, uint8_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    return libcrux_kyber_constant_time_ops_is_non_zero(r);
  }
}

void
libcrux_kyber_decapsulate___3size_t_2400size_t_1152size_t_1184size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t_1120size_t(
  uint8_t (*secret_key)[2400U],
  uint8_t (*ciphertext)[1088U],
  uint8_t ret[32U]
)
{
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____0 =
    libcrux_kyber_types__libcrux_kyber__types__KyberPrivateKey_SIZE__12__split_at___2400size_t(secret_key,
      (size_t)1152U);
  Eurydice_slice ind_cpa_secret_key = uu____0.fst;
  Eurydice_slice secret_key0 = uu____0.snd;
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____1 = core_slice___Slice_T___split_at(secret_key0, (size_t)1184U, uint8_t);
  Eurydice_slice ind_cpa_public_key = uu____1.fst;
  Eurydice_slice secret_key1 = uu____1.snd;
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____2 =
    core_slice___Slice_T___split_at(secret_key1,
      libcrux_kyber_constants_H_DIGEST_SIZE,
      uint8_t);
  Eurydice_slice ind_cpa_public_key_hash = uu____2.fst;
  Eurydice_slice implicit_rejection_value = uu____2.snd;
  uint8_t decrypted[32U];
  libcrux_kyber_ind_cpa_decrypt___3size_t_1088size_t_960size_t_10size_t_4size_t(ind_cpa_secret_key,
    ciphertext[0U],
    decrypted);
  uint8_t to_hash0[64U];
  libcrux_kyber_ind_cpa_into_padded_array___64size_t(Eurydice_array_to_slice((size_t)32U,
      decrypted,
      uint8_t),
    to_hash0);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice_from((size_t)64U,
      to_hash0,
      libcrux_kyber_constants_SHARED_SECRET_SIZE,
      uint8_t,
      size_t),
    ind_cpa_public_key_hash,
    uint8_t);
  uint8_t hashed[64U];
  libcrux_kyber_hash_functions_G(Eurydice_array_to_slice((size_t)64U, to_hash0, uint8_t),
    hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____3 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U, hashed, uint8_t),
      libcrux_kyber_constants_SHARED_SECRET_SIZE,
      uint8_t);
  Eurydice_slice shared_secret = uu____3.fst;
  Eurydice_slice pseudorandomness = uu____3.snd;
  uint8_t to_hash[1120U];
  libcrux_kyber_ind_cpa_into_padded_array___1120size_t(implicit_rejection_value, to_hash);
  Eurydice_slice
  uu____4 =
    Eurydice_array_to_subslice_from((size_t)1120U,
      to_hash,
      libcrux_kyber_constants_SHARED_SECRET_SIZE,
      uint8_t,
      size_t);
  core_slice___Slice_T___copy_from_slice(uu____4,
    libcrux_kyber_types__libcrux_kyber__types__KyberCiphertext_SIZE__1__as_ref___1088size_t(ciphertext),
    uint8_t);
  uint8_t implicit_rejection_shared_secret[32U];
  libcrux_kyber_hash_functions_PRF___32size_t(Eurydice_array_to_slice((size_t)1120U,
      to_hash,
      uint8_t),
    implicit_rejection_shared_secret);
  Eurydice_slice uu____5 = ind_cpa_public_key;
  uint8_t uu____6[32U];
  memcpy(uu____6, decrypted, (size_t)32U * sizeof (uint8_t));
  uint8_t expected_ciphertext[1088U];
  memcpy(expected_ciphertext,
    libcrux_kyber_ind_cpa_encrypt___3size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(uu____5,
      uu____6,
      pseudorandomness).fst,
    (size_t)1088U * sizeof (uint8_t));
  Eurydice_slice
  uu____7 =
    libcrux_kyber_types__libcrux_kyber__types__KyberCiphertext_SIZE__1__as_ref___1088size_t(ciphertext);
  uint8_t
  selector =
    libcrux_kyber_constant_time_ops_compare_ciphertexts_in_constant_time___1088size_t(uu____7,
      Eurydice_array_to_slice((size_t)1088U, expected_ciphertext, uint8_t));
  Eurydice_slice uu____8 = shared_secret;
  uint8_t ret0[32U];
  libcrux_kyber_constant_time_ops_select_shared_secret_in_constant_time(uu____8,
    Eurydice_array_to_slice((size_t)32U, implicit_rejection_shared_secret, uint8_t),
    selector,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

void
libcrux_kyber_kyber768_decapsulate_768(
  uint8_t (*secret_key)[2400U],
  uint8_t (*ciphertext)[1088U],
  uint8_t ret[32U]
)
{
  uint8_t ret0[32U];
  libcrux_kyber_decapsulate___3size_t_2400size_t_1152size_t_1184size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t_1120size_t(secret_key,
    ciphertext,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

const
size_t
libcrux_kyber_KEY_GENERATION_SEED_SIZE =
  libcrux_kyber_constants_CPA_PKE_KEY_GENERATION_SEED_SIZE
  + libcrux_kyber_constants_SHARED_SECRET_SIZE;

