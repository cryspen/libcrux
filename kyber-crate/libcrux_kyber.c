/* 
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>
  KaRaMeL invocation: eurydice libcrux_kyber.llbc --log Phase3 --debug backtraces
  F* version: 71f2d632
  KaRaMeL version: 416d59a1
 */

#include "libcrux_kyber.h"

const int32_t libcrux_kyber_constants_FIELD_MODULUS = (int32_t)3329;

const size_t libcrux_kyber_constants_BITS_PER_COEFFICIENT = (size_t)12U;

const size_t libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT = (size_t)256U;

const
size_t
libcrux_kyber_constants_BITS_PER_RING_ELEMENT =
  libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT
  * (size_t)12U;

const
size_t
libcrux_kyber_constants_BYTES_PER_RING_ELEMENT =
  libcrux_kyber_constants_BITS_PER_RING_ELEMENT
  / (size_t)8U;

const size_t libcrux_kyber_constants_REJECTION_SAMPLING_SEED_SIZE = (size_t)168U * (size_t)5U;

const size_t libcrux_kyber_constants_SHARED_SECRET_SIZE = (size_t)32U;

const size_t libcrux_kyber_constants_CPA_PKE_KEY_GENERATION_SEED_SIZE = (size_t)32U;

const
size_t
libcrux_kyber_constants_H_DIGEST_SIZE = libcrux_digest_digest_size(libcrux_digest_Sha3_256);

const uint8_t libcrux_kyber_arithmetic_MONTGOMERY_SHIFT = 16U;

const
int32_t
libcrux_kyber_arithmetic_MONTGOMERY_R =
  (int32_t)1
  << (uint32_t)libcrux_kyber_arithmetic_MONTGOMERY_SHIFT;

uint32_t libcrux_kyber_arithmetic_get_n_least_significant_bits(uint8_t n, uint32_t value)
{
  return value & ((1U << (uint32_t)n) - 1U);
}

const int64_t libcrux_kyber_arithmetic_BARRETT_SHIFT = (int64_t)26;

const
int64_t
libcrux_kyber_arithmetic_BARRETT_R =
  (int64_t)1
  << (uint32_t)libcrux_kyber_arithmetic_BARRETT_SHIFT;

const int64_t libcrux_kyber_arithmetic_BARRETT_MULTIPLIER = (int64_t)20159;

int32_t libcrux_kyber_arithmetic_barrett_reduce(int32_t value)
{
  int64_t
  t =
    core_convert_num__i64_59__from(value)
    * libcrux_kyber_arithmetic_BARRETT_MULTIPLIER
    + (libcrux_kyber_arithmetic_BARRETT_R >> 1U);
  int32_t quotient = (int32_t)(t >> (uint32_t)libcrux_kyber_arithmetic_BARRETT_SHIFT);
  return value - quotient * libcrux_kyber_constants_FIELD_MODULUS;
}

const uint32_t libcrux_kyber_arithmetic_INVERSE_OF_MODULUS_MOD_R = 62209U;

int32_t libcrux_kyber_arithmetic_montgomery_reduce(int32_t value)
{
  uint32_t
  t =
    libcrux_kyber_arithmetic_get_n_least_significant_bits(libcrux_kyber_arithmetic_MONTGOMERY_SHIFT,
      (uint32_t)value)
    * libcrux_kyber_arithmetic_INVERSE_OF_MODULUS_MOD_R;
  int16_t
  k =
    (int16_t)libcrux_kyber_arithmetic_get_n_least_significant_bits(libcrux_kyber_arithmetic_MONTGOMERY_SHIFT,
      t);
  int32_t k_times_modulus = (int32_t)k * libcrux_kyber_constants_FIELD_MODULUS;
  int32_t c = k_times_modulus >> (uint32_t)libcrux_kyber_arithmetic_MONTGOMERY_SHIFT;
  int32_t value_high = value >> (uint32_t)libcrux_kyber_arithmetic_MONTGOMERY_SHIFT;
  return value_high - c;
}

int32_t libcrux_kyber_arithmetic_montgomery_multiply_sfe_by_fer(int32_t fe, int32_t fer)
{
  return libcrux_kyber_arithmetic_montgomery_reduce(fe * fer);
}

const int32_t libcrux_kyber_arithmetic_MONTGOMERY_R_SQUARED_MOD_FIELD_MODULUS = (int32_t)1353;

int32_t libcrux_kyber_arithmetic_to_standard_domain(int32_t mfe)
{
  return
    libcrux_kyber_arithmetic_montgomery_reduce(mfe
      * libcrux_kyber_arithmetic_MONTGOMERY_R_SQUARED_MOD_FIELD_MODULUS);
}

uint16_t libcrux_kyber_arithmetic_to_unsigned_representative(int32_t fe)
{
  return (uint16_t)(fe + (libcrux_kyber_constants_FIELD_MODULUS & fe >> 31U));
}

void
libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement_1__clone(
  int32_t (*self)[256U],
  int32_t ret[256U]
)
{
  memcpy(ret, self[0U], (size_t)256U * sizeof (int32_t));
}

bool
libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement_4__eq(
  int32_t (*self)[256U],
  int32_t (*other)[256U]
)
{
  return
    core_array_equality___Array_A__N___eq((size_t)256U,
      self[0U],
      other[0U],
      int32_t,
      int32_t);
}

void
libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement_6__assert_receiver_is_total_eq(
  int32_t (*self)[256U]
)
{

}

const
int32_t
libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO[256U] = { 0U };

uint8_t libcrux_kyber_compress_compress_message_coefficient(uint16_t fe)
{
  int16_t shifted = (int16_t)1664 - (int16_t)fe;
  int16_t mask = shifted >> 15U;
  int16_t shifted_to_positive = mask ^ shifted;
  int16_t shifted_positive_in_range = shifted_to_positive - (int16_t)832;
  return (uint8_t)(shifted_positive_in_range >> 15U & (int16_t)1);
}

int32_t
libcrux_kyber_compress_compress_ciphertext_coefficient(uint8_t coefficient_bits, uint16_t fe)
{
  uint32_t compressed = (uint32_t)fe << (uint32_t)((uint32_t)coefficient_bits + 1U);
  compressed = compressed + (uint32_t)libcrux_kyber_constants_FIELD_MODULUS;
  compressed = compressed / (uint32_t)(libcrux_kyber_constants_FIELD_MODULUS << 1U);
  return
    (int32_t)libcrux_kyber_arithmetic_get_n_least_significant_bits(coefficient_bits, compressed);
}

int32_t libcrux_kyber_compress_decompress_message_coefficient(int32_t fe)
{
  return -fe & (libcrux_kyber_constants_FIELD_MODULUS + (int32_t)1) / (int32_t)2;
}

int32_t
libcrux_kyber_compress_decompress_ciphertext_coefficient(uint8_t coefficient_bits, int32_t fe)
{
  uint32_t decompressed = (uint32_t)fe * (uint32_t)libcrux_kyber_constants_FIELD_MODULUS;
  decompressed = (decompressed << 1U) + (1U << (uint32_t)coefficient_bits);
  decompressed = decompressed >> (uint32_t)((uint32_t)coefficient_bits + 1U);
  return (int32_t)decompressed;
}

uint8_t libcrux_kyber_constant_time_ops_is_non_zero(uint8_t value)
{
  uint16_t value0 = (uint16_t)value;
  uint16_t uu____0 = value0;
  uint16_t
  result =
    (((uint32_t)uu____0 | (uint32_t)core_num__u16_7__wrapping_add(~value0, 1U)) & 0xFFFFU)
    >> 8U
    & 1U;
  return (uint8_t)result;
}

void
libcrux_kyber_constant_time_ops_select_shared_secret_in_constant_time(
  Eurydice_slice lhs,
  Eurydice_slice rhs,
  uint8_t selector,
  uint8_t ret[32U]
)
{
  uint8_t
  mask = core_num__u8_6__wrapping_sub(libcrux_kyber_constant_time_ops_is_non_zero(selector), 1U);
  uint8_t out[32U];
  uint8_t buf[32U] = { 0U };
  memcpy(out, buf, (size_t)32U * sizeof (uint8_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = libcrux_kyber_constants_SHARED_SECRET_SIZE;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        uint8_t uu____1 = (uint32_t)Eurydice_slice_index(lhs, i, uint8_t) & (uint32_t)mask;
        uint8_t *uu____2 = &Eurydice_slice_index(rhs, i, uint8_t);
        size_t uu____3 = i;
        out[uu____3] =
          (uint32_t)out[uu____3]
          | ((uint32_t)uu____1 | ((uint32_t)uu____2[0U] & (uint32_t)~mask));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____4[32U];
    memcpy(uu____4, out, (size_t)32U * sizeof (uint8_t));
    memcpy(ret, uu____4, (size_t)32U * sizeof (uint8_t));
    return;
  }
}

void libcrux_kyber_hash_functions_G(Eurydice_slice input, uint8_t ret[64U])
{
  uint8_t ret0[64U];
  libcrux_digest_sha3_512(input, ret0);
  memcpy(ret, ret0, (size_t)64U * sizeof (uint8_t));
}

void libcrux_kyber_hash_functions_H(Eurydice_slice input, uint8_t ret[32U])
{
  uint8_t ret0[32U];
  libcrux_digest_sha3_256(input, ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

K___uint8_t_uint8_t_uint8_t
libcrux_kyber_serialize_compress_coefficients_3(uint16_t coefficient1, uint16_t coefficient2)
{
  uint8_t coef1 = (uint8_t)((uint32_t)coefficient1 & 255U);
  uint8_t coef2 = (uint8_t)((uint32_t)coefficient1 >> 8U | ((uint32_t)coefficient2 & 15U) << 4U);
  uint8_t coef3 = (uint8_t)((uint32_t)coefficient2 >> 4U & 255U);
  K___uint8_t_uint8_t_uint8_t lit;
  lit.fst = coef1;
  lit.snd = coef2;
  lit.thd = coef3;
  return lit;
}

void
libcrux_kyber_serialize_serialize_uncompressed_ring_element(
  int32_t re[256U],
  uint8_t ret[384U]
)
{
  uint8_t serialized[384U];
  uint8_t buf[384U] = { 0U };
  memcpy(serialized, buf, (size_t)384U * sizeof (uint8_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t),
      int32_t)
    / (size_t)2U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        uint16_t
        coefficient1 =
          libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)2U + (size_t)0U]);
        uint16_t
        coefficient2 =
          libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)2U + (size_t)1U]);
        K___uint8_t_uint8_t_uint8_t
        uu____1 = libcrux_kyber_serialize_compress_coefficients_3(coefficient1, coefficient2);
        uint8_t coef1 = uu____1.fst;
        uint8_t coef2 = uu____1.snd;
        uint8_t coef3 = uu____1.thd;
        serialized[(size_t)3U * i] = coef1;
        serialized[(size_t)3U * i + (size_t)1U] = coef2;
        serialized[(size_t)3U * i + (size_t)2U] = coef3;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____2[384U];
    memcpy(uu____2, serialized, (size_t)384U * sizeof (uint8_t));
    memcpy(ret, uu____2, (size_t)384U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_serialize_deserialize_to_uncompressed_ring_element(
  Eurydice_slice serialized,
  int32_t ret[256U]
)
{
  int32_t re[256U];
  memcpy(re,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(serialized, uint8_t) / (size_t)3U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t
        byte1 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)3U + (size_t)0U, uint8_t);
        int32_t
        byte2 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)3U + (size_t)1U, uint8_t);
        int32_t
        byte3 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)3U + (size_t)2U, uint8_t);
        re[(size_t)2U * i] = (byte2 & (int32_t)15) << 8U | (byte1 & (int32_t)255);
        re[(size_t)2U * i + (size_t)1U] = byte3 << 4U | (byte2 >> 4U & (int32_t)15);
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, re, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_sampling_sample_from_binomial_distribution_2(
  Eurydice_slice randomness,
  int32_t ret[256U]
)
{
  int32_t sampled[256U];
  memcpy(sampled,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = core_slice___Slice_T___len(randomness, uint8_t) / (size_t)4U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        uint32_t
        uu____1 = (uint32_t)Eurydice_slice_index(randomness, i * (size_t)4U + (size_t)0U, uint8_t);
        uint32_t
        uu____2 =
          uu____1
          | (uint32_t)Eurydice_slice_index(randomness, i * (size_t)4U + (size_t)1U, uint8_t) << 8U;
        uint32_t
        uu____3 =
          uu____2
          | (uint32_t)Eurydice_slice_index(randomness, i * (size_t)4U + (size_t)2U, uint8_t) << 16U;
        uint32_t
        random_bits_as_u32 =
          uu____3
          | (uint32_t)Eurydice_slice_index(randomness, i * (size_t)4U + (size_t)3U, uint8_t) << 24U;
        uint32_t even_bits = random_bits_as_u32 & 1431655765U;
        uint32_t odd_bits = random_bits_as_u32 >> 1U & 1431655765U;
        uint32_t coin_toss_outcomes = even_bits + odd_bits;
        core_ops_range_Range__uint32_t lit;
        lit.start = 0U;
        lit.end = core_num__u32_8__BITS / 4U;
        core_ops_range_Range__uint32_t
        iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__uint32_t);
        while (true)
        {
          core_option_Option__uint32_t
          uu____4 = core_iter_range__core__ops__range__Range_A__3__next(&iter, uint32_t);
          if (uu____4.tag == core_option_None)
            break;
          else if (uu____4.tag == core_option_Some)
          {
            uint32_t outcome_set_ = uu____4.f0;
            uint32_t outcome_set = outcome_set_ * 4U;
            int32_t outcome_1 = (int32_t)(coin_toss_outcomes >> (uint32_t)outcome_set & 3U);
            int32_t outcome_2 = (int32_t)(coin_toss_outcomes >> (uint32_t)(outcome_set + 2U) & 3U);
            size_t offset = (size_t)(outcome_set >> 2U);
            sampled[(size_t)8U * i + offset] = outcome_1 - outcome_2;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, sampled, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_sampling_sample_from_binomial_distribution_3(
  Eurydice_slice randomness,
  int32_t ret[256U]
)
{
  int32_t sampled[256U];
  memcpy(sampled,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = core_slice___Slice_T___len(randomness, uint8_t) / (size_t)3U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        uint32_t
        uu____1 = (uint32_t)Eurydice_slice_index(randomness, i * (size_t)3U + (size_t)0U, uint8_t);
        uint32_t
        uu____2 =
          uu____1
          | (uint32_t)Eurydice_slice_index(randomness, i * (size_t)3U + (size_t)1U, uint8_t) << 8U;
        uint32_t
        random_bits_as_u24 =
          uu____2
          | (uint32_t)Eurydice_slice_index(randomness, i * (size_t)3U + (size_t)2U, uint8_t) << 16U;
        uint32_t first_bits = random_bits_as_u24 & 2396745U;
        uint32_t second_bits = random_bits_as_u24 >> 1U & 2396745U;
        uint32_t third_bits = random_bits_as_u24 >> 2U & 2396745U;
        uint32_t coin_toss_outcomes = first_bits + second_bits + third_bits;
        core_ops_range_Range__int32_t lit;
        lit.start = (int32_t)0;
        lit.end = (int32_t)24 / (int32_t)6;
        core_ops_range_Range__int32_t
        iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__int32_t);
        while (true)
        {
          core_option_Option__int32_t
          uu____3 = core_iter_range__core__ops__range__Range_A__3__next(&iter, int32_t);
          if (uu____3.tag == core_option_None)
            break;
          else if (uu____3.tag == core_option_Some)
          {
            int32_t outcome_set_ = uu____3.f0;
            int32_t outcome_set = outcome_set_ * (int32_t)6;
            int32_t outcome_1 = (int32_t)(coin_toss_outcomes >> (uint32_t)outcome_set & 7U);
            int32_t
            outcome_2 = (int32_t)(coin_toss_outcomes >> (uint32_t)(outcome_set + (int32_t)3) & 7U);
            size_t offset = (size_t)(outcome_set / (int32_t)6);
            sampled[(size_t)4U * i + offset] = outcome_1 - outcome_2;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, sampled, (size_t)256U * sizeof (int32_t));
    return;
  }
}

const
int32_t
libcrux_kyber_ntt_ZETAS_TIMES_MONTGOMERY_R[128U] =
  {
    (int32_t)-1044, (int32_t)-758, (int32_t)-359, (int32_t)-1517, (int32_t)1493, (int32_t)1422,
    (int32_t)287, (int32_t)202, (int32_t)-171, (int32_t)622, (int32_t)1577, (int32_t)182,
    (int32_t)962, (int32_t)-1202, (int32_t)-1474, (int32_t)1468, (int32_t)573, (int32_t)-1325,
    (int32_t)264, (int32_t)383, (int32_t)-829, (int32_t)1458, (int32_t)-1602, (int32_t)-130,
    (int32_t)-681, (int32_t)1017, (int32_t)732, (int32_t)608, (int32_t)-1542, (int32_t)411,
    (int32_t)-205, (int32_t)-1571, (int32_t)1223, (int32_t)652, (int32_t)-552, (int32_t)1015,
    (int32_t)-1293, (int32_t)1491, (int32_t)-282, (int32_t)-1544, (int32_t)516, (int32_t)-8,
    (int32_t)-320, (int32_t)-666, (int32_t)-1618, (int32_t)-1162, (int32_t)126, (int32_t)1469,
    (int32_t)-853, (int32_t)-90, (int32_t)-271, (int32_t)830, (int32_t)107, (int32_t)-1421,
    (int32_t)-247, (int32_t)-951, (int32_t)-398, (int32_t)961, (int32_t)-1508, (int32_t)-725,
    (int32_t)448, (int32_t)-1065, (int32_t)677, (int32_t)-1275, (int32_t)-1103, (int32_t)430,
    (int32_t)555, (int32_t)843, (int32_t)-1251, (int32_t)871, (int32_t)1550, (int32_t)105,
    (int32_t)422, (int32_t)587, (int32_t)177, (int32_t)-235, (int32_t)-291, (int32_t)-460,
    (int32_t)1574, (int32_t)1653, (int32_t)-246, (int32_t)778, (int32_t)1159, (int32_t)-147,
    (int32_t)-777, (int32_t)1483, (int32_t)-602, (int32_t)1119, (int32_t)-1590, (int32_t)644,
    (int32_t)-872, (int32_t)349, (int32_t)418, (int32_t)329, (int32_t)-156, (int32_t)-75,
    (int32_t)817, (int32_t)1097, (int32_t)603, (int32_t)610, (int32_t)1322, (int32_t)-1285,
    (int32_t)-1465, (int32_t)384, (int32_t)-1215, (int32_t)-136, (int32_t)1218, (int32_t)-1335,
    (int32_t)-874, (int32_t)220, (int32_t)-1187, (int32_t)-1659, (int32_t)-1185, (int32_t)-1530,
    (int32_t)-1278, (int32_t)794, (int32_t)-1510, (int32_t)-854, (int32_t)-870, (int32_t)478,
    (int32_t)-108, (int32_t)-308, (int32_t)996, (int32_t)991, (int32_t)958, (int32_t)-1460,
    (int32_t)1522, (int32_t)1628
  };

void
libcrux_kyber_ntt_ntt_at_layer(
  size_t *zeta_i,
  int32_t re[256U],
  size_t layer,
  size_t initial_coefficient_bound,
  int32_t ret[256U]
)
{
  size_t step = (size_t)1U << (uint32_t)layer;
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = (size_t)128U / step;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t round = uu____0.f0;
        zeta_i[0U] = zeta_i[0U] + (size_t)1U;
        size_t offset = round * step * (size_t)2U;
        core_ops_range_Range__size_t lit;
        lit.start = offset;
        lit.end = offset + step;
        core_ops_range_Range__size_t
        iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
          if (uu____1.tag == core_option_None)
            break;
          else if (uu____1.tag == core_option_Some)
          {
            size_t j = uu____1.f0;
            int32_t
            t =
              libcrux_kyber_arithmetic_montgomery_multiply_sfe_by_fer(re[j + step],
                libcrux_kyber_ntt_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
            re[j + step] = re[j] - t;
            re[j] = re[j] + t;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, re, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_ntt_ntt_at_layer_3(
  size_t *zeta_i,
  int32_t re[256U],
  size_t layer,
  int32_t ret[256U]
)
{
  int32_t ret0[256U];
  libcrux_kyber_ntt_ntt_at_layer(zeta_i, re, layer, (size_t)3U, ret0);
  memcpy(ret, ret0, (size_t)256U * sizeof (int32_t));
}

void libcrux_kyber_ntt_ntt_binomially_sampled_ring_element(int32_t re[256U], int32_t ret[256U])
{
  size_t zeta_i = (size_t)1U;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)128U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (uu____0.tag == core_option_None)
      break;
    else if (uu____0.tag == core_option_Some)
    {
      size_t j = uu____0.f0;
      int32_t t = re[j + (size_t)128U] * (int32_t)-1600;
      re[j + (size_t)128U] = re[j] - t;
      re[j] = re[j] + t;
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
      KRML_HOST_EXIT(255U);
    }
  }
  libcrux_kyber_ntt_ntt_at_layer_3(&zeta_i, re, (size_t)6U, re);
  libcrux_kyber_ntt_ntt_at_layer_3(&zeta_i, re, (size_t)5U, re);
  libcrux_kyber_ntt_ntt_at_layer_3(&zeta_i, re, (size_t)4U, re);
  libcrux_kyber_ntt_ntt_at_layer_3(&zeta_i, re, (size_t)3U, re);
  libcrux_kyber_ntt_ntt_at_layer_3(&zeta_i, re, (size_t)2U, re);
  libcrux_kyber_ntt_ntt_at_layer_3(&zeta_i, re, (size_t)1U, re);
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter0 = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
    if (!(uu____1.tag == core_option_None))
    {
      if (uu____1.tag == core_option_Some)
      {
        size_t i = uu____1.f0;
        int32_t uu____2 = libcrux_kyber_arithmetic_barrett_reduce(re[i]);
        re[i] = uu____2;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, re, (size_t)256U * sizeof (int32_t));
    return;
  }
}

K___int32_t_int32_t
libcrux_kyber_ntt_ntt_multiply_binomials(
  K___int32_t_int32_t _,
  K___int32_t_int32_t _0,
  int32_t zeta
)
{
  int32_t a0 = _.fst;
  int32_t a1 = _.snd;
  int32_t b0 = _0.fst;
  int32_t b1 = _0.snd;
  int32_t uu____0 = a0 * b0;
  K___int32_t_int32_t lit;
  lit.fst =
    libcrux_kyber_arithmetic_montgomery_reduce(uu____0
      + libcrux_kyber_arithmetic_montgomery_reduce(a1 * b1) * zeta);
  lit.snd = libcrux_kyber_arithmetic_montgomery_reduce(a0 * b1 + a1 * b0);
  return lit;
}

void
libcrux_kyber_ntt_ntt_multiply(int32_t (*lhs)[256U], int32_t (*rhs)[256U], int32_t ret[256U])
{
  int32_t out[256U];
  memcpy(out,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT / (size_t)4U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        K___int32_t_int32_t lit0;
        lit0.fst = lhs[0U][(size_t)4U * i];
        lit0.snd = lhs[0U][(size_t)4U * i + (size_t)1U];
        K___int32_t_int32_t lit1;
        lit1.fst = rhs[0U][(size_t)4U * i];
        lit1.snd = rhs[0U][(size_t)4U * i + (size_t)1U];
        K___int32_t_int32_t
        product =
          libcrux_kyber_ntt_ntt_multiply_binomials(lit0,
            lit1,
            libcrux_kyber_ntt_ZETAS_TIMES_MONTGOMERY_R[(size_t)64U + i]);
        out[(size_t)4U * i] = product.fst;
        out[(size_t)4U * i + (size_t)1U] = product.snd;
        K___int32_t_int32_t lit2;
        lit2.fst = lhs[0U][(size_t)4U * i + (size_t)2U];
        lit2.snd = lhs[0U][(size_t)4U * i + (size_t)3U];
        K___int32_t_int32_t lit;
        lit.fst = rhs[0U][(size_t)4U * i + (size_t)2U];
        lit.snd = rhs[0U][(size_t)4U * i + (size_t)3U];
        K___int32_t_int32_t
        product0 =
          libcrux_kyber_ntt_ntt_multiply_binomials(lit2,
            lit,
            -libcrux_kyber_ntt_ZETAS_TIMES_MONTGOMERY_R[(size_t)64U + i]);
        out[(size_t)4U * i + (size_t)2U] = product0.fst;
        out[(size_t)4U * i + (size_t)3U] = product0.snd;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, out, (size_t)256U * sizeof (int32_t));
    return;
  }
}

K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
libcrux_kyber_serialize_compress_coefficients_10(
  int32_t coefficient1,
  int32_t coefficient2,
  int32_t coefficient3,
  int32_t coefficient4
)
{
  uint8_t coef1 = (uint8_t)(coefficient1 & (int32_t)255);
  uint8_t
  coef2 =
    (uint32_t)(uint8_t)(coefficient2 & (int32_t)63)
    << 2U
    | (uint32_t)(uint8_t)(coefficient1 >> 8U & (int32_t)3);
  uint8_t
  coef3 =
    (uint32_t)(uint8_t)(coefficient3 & (int32_t)15)
    << 4U
    | (uint32_t)(uint8_t)(coefficient2 >> 6U & (int32_t)15);
  uint8_t
  coef4 =
    (uint32_t)(uint8_t)(coefficient4 & (int32_t)3)
    << 6U
    | (uint32_t)(uint8_t)(coefficient3 >> 4U & (int32_t)63);
  uint8_t coef5 = (uint8_t)(coefficient4 >> 2U & (int32_t)255);
  K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t lit;
  lit.fst = coef1;
  lit.snd = coef2;
  lit.thd = coef3;
  lit.f3 = coef4;
  lit.f4 = coef5;
  return lit;
}

K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
libcrux_kyber_serialize_compress_coefficients_11(
  int32_t coefficient1,
  int32_t coefficient2,
  int32_t coefficient3,
  int32_t coefficient4,
  int32_t coefficient5,
  int32_t coefficient6,
  int32_t coefficient7,
  int32_t coefficient8
)
{
  uint8_t coef1 = (uint8_t)coefficient1;
  uint8_t
  coef2 =
    (uint32_t)(uint8_t)(coefficient2 & (int32_t)31)
    << 3U
    | (uint32_t)(uint8_t)(coefficient1 >> 8U);
  uint8_t
  coef3 =
    (uint32_t)(uint8_t)(coefficient3 & (int32_t)3)
    << 6U
    | (uint32_t)(uint8_t)(coefficient2 >> 5U);
  uint8_t coef4 = (uint8_t)(coefficient3 >> 2U & (int32_t)255);
  uint8_t
  coef5 =
    (uint32_t)(uint8_t)(coefficient4 & (int32_t)127)
    << 1U
    | (uint32_t)(uint8_t)(coefficient3 >> 10U);
  uint8_t
  coef6 =
    (uint32_t)(uint8_t)(coefficient5 & (int32_t)15)
    << 4U
    | (uint32_t)(uint8_t)(coefficient4 >> 7U);
  uint8_t
  coef7 =
    (uint32_t)(uint8_t)(coefficient6 & (int32_t)1)
    << 7U
    | (uint32_t)(uint8_t)(coefficient5 >> 4U);
  uint8_t coef8 = (uint8_t)(coefficient6 >> 1U & (int32_t)255);
  uint8_t
  coef9 =
    (uint32_t)(uint8_t)(coefficient7 & (int32_t)63)
    << 2U
    | (uint32_t)(uint8_t)(coefficient6 >> 9U);
  uint8_t
  coef10 =
    (uint32_t)(uint8_t)(coefficient8 & (int32_t)7)
    << 5U
    | (uint32_t)(uint8_t)(coefficient7 >> 6U);
  uint8_t coef11 = (uint8_t)(coefficient8 >> 3U);
  K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
  lit;
  lit.fst = coef1;
  lit.snd = coef2;
  lit.thd = coef3;
  lit.f3 = coef4;
  lit.f4 = coef5;
  lit.f5 = coef6;
  lit.f6 = coef7;
  lit.f7 = coef8;
  lit.f8 = coef9;
  lit.f9 = coef10;
  lit.f10 = coef11;
  return lit;
}

void
libcrux_kyber_ntt_invert_ntt_at_layer(
  size_t *zeta_i,
  int32_t re[256U],
  size_t layer,
  int32_t ret[256U]
)
{
  size_t step = (size_t)1U << (uint32_t)layer;
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = (size_t)128U / step;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t round = uu____0.f0;
        zeta_i[0U] = zeta_i[0U] - (size_t)1U;
        size_t offset = round * step * (size_t)2U;
        core_ops_range_Range__size_t lit;
        lit.start = offset;
        lit.end = offset + step;
        core_ops_range_Range__size_t
        iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
          if (uu____1.tag == core_option_None)
            break;
          else if (uu____1.tag == core_option_Some)
          {
            size_t j = uu____1.f0;
            int32_t a_minus_b = re[j + step] - re[j];
            re[j] = re[j] + re[j + step];
            int32_t
            uu____2 =
              libcrux_kyber_arithmetic_montgomery_reduce(a_minus_b
                * libcrux_kyber_ntt_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
            re[j + step] = uu____2;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, re, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_serialize_deserialize_then_decompress_message(
  uint8_t serialized[32U],
  int32_t ret[256U]
)
{
  int32_t re[256U];
  memcpy(re,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)32U, serialized, uint8_t),
      uint8_t);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        core_ops_range_Range__size_t lit;
        lit.start = (size_t)0U;
        lit.end = (size_t)8U;
        core_ops_range_Range__size_t
        iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
          if (uu____1.tag == core_option_None)
            break;
          else if (uu____1.tag == core_option_Some)
          {
            size_t j = uu____1.f0;
            int32_t coefficient_compressed = (int32_t)((uint32_t)serialized[i] >> (uint32_t)j & 1U);
            int32_t
            uu____2 = libcrux_kyber_compress_decompress_message_coefficient(coefficient_compressed);
            re[(size_t)8U * i + j] = uu____2;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, re, (size_t)256U * sizeof (int32_t));
    return;
  }
}

K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
libcrux_kyber_serialize_compress_coefficients_5(
  uint8_t coefficient2,
  uint8_t coefficient1,
  uint8_t coefficient4,
  uint8_t coefficient3,
  uint8_t coefficient5,
  uint8_t coefficient7,
  uint8_t coefficient6,
  uint8_t coefficient8
)
{
  uint8_t coef1 = ((uint32_t)coefficient2 & 7U) << 5U | (uint32_t)coefficient1;
  uint8_t
  coef2 =
    (((uint32_t)coefficient4 & 1U) << 7U | (uint32_t)coefficient3 << 2U)
    | (uint32_t)coefficient2 >> 3U;
  uint8_t coef3 = ((uint32_t)coefficient5 & 15U) << 4U | (uint32_t)coefficient4 >> 1U;
  uint8_t
  coef4 =
    (((uint32_t)coefficient7 & 3U) << 6U | (uint32_t)coefficient6 << 1U)
    | (uint32_t)coefficient5 >> 4U;
  uint8_t coef5 = (uint32_t)coefficient8 << 3U | (uint32_t)coefficient7 >> 2U;
  K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t lit;
  lit.fst = coef1;
  lit.snd = coef2;
  lit.thd = coef3;
  lit.f3 = coef4;
  lit.f4 = coef5;
  return lit;
}

K___int32_t_int32_t_int32_t_int32_t
libcrux_kyber_serialize_decompress_coefficients_10(
  int32_t byte2,
  int32_t byte1,
  int32_t byte3,
  int32_t byte4,
  int32_t byte5
)
{
  int32_t coefficient1 = (byte2 & (int32_t)3) << 8U | (byte1 & (int32_t)255);
  int32_t coefficient2 = (byte3 & (int32_t)15) << 6U | byte2 >> 2U;
  int32_t coefficient3 = (byte4 & (int32_t)63) << 4U | byte3 >> 4U;
  int32_t coefficient4 = byte5 << 2U | byte4 >> 6U;
  K___int32_t_int32_t_int32_t_int32_t lit;
  lit.fst = coefficient1;
  lit.snd = coefficient2;
  lit.thd = coefficient3;
  lit.f3 = coefficient4;
  return lit;
}

void
libcrux_kyber_serialize_deserialize_then_decompress_10(
  Eurydice_slice serialized,
  int32_t ret[256U]
)
{
  int32_t re[256U];
  memcpy(re,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(serialized, uint8_t) / (size_t)5U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t
        byte1 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)5U + (size_t)0U, uint8_t);
        int32_t
        byte2 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)5U + (size_t)1U, uint8_t);
        int32_t
        byte3 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)5U + (size_t)2U, uint8_t);
        int32_t
        byte4 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)5U + (size_t)3U, uint8_t);
        int32_t
        byte5 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)5U + (size_t)4U, uint8_t);
        K___int32_t_int32_t_int32_t_int32_t
        uu____1 =
          libcrux_kyber_serialize_decompress_coefficients_10(byte2,
            byte1,
            byte3,
            byte4,
            byte5);
        int32_t coefficient1 = uu____1.fst;
        int32_t coefficient2 = uu____1.snd;
        int32_t coefficient3 = uu____1.thd;
        int32_t coefficient4 = uu____1.f3;
        int32_t
        uu____2 = libcrux_kyber_compress_decompress_ciphertext_coefficient(10U, coefficient1);
        re[(size_t)4U * i] = uu____2;
        int32_t
        uu____3 = libcrux_kyber_compress_decompress_ciphertext_coefficient(10U, coefficient2);
        re[(size_t)4U * i + (size_t)1U] = uu____3;
        int32_t
        uu____4 = libcrux_kyber_compress_decompress_ciphertext_coefficient(10U, coefficient3);
        re[(size_t)4U * i + (size_t)2U] = uu____4;
        int32_t
        uu____5 = libcrux_kyber_compress_decompress_ciphertext_coefficient(10U, coefficient4);
        re[(size_t)4U * i + (size_t)3U] = uu____5;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, re, (size_t)256U * sizeof (int32_t));
    return;
  }
}

K___int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t
libcrux_kyber_serialize_decompress_coefficients_11(
  int32_t byte2,
  int32_t byte1,
  int32_t byte3,
  int32_t byte5,
  int32_t byte4,
  int32_t byte6,
  int32_t byte7,
  int32_t byte9,
  int32_t byte8,
  int32_t byte10,
  int32_t byte11
)
{
  int32_t coefficient1 = (byte2 & (int32_t)7) << 8U | byte1;
  int32_t coefficient2 = (byte3 & (int32_t)63) << 5U | byte2 >> 3U;
  int32_t coefficient3 = ((byte5 & (int32_t)1) << 10U | byte4 << 2U) | byte3 >> 6U;
  int32_t coefficient4 = (byte6 & (int32_t)15) << 7U | byte5 >> 1U;
  int32_t coefficient5 = (byte7 & (int32_t)127) << 4U | byte6 >> 4U;
  int32_t coefficient6 = ((byte9 & (int32_t)3) << 9U | byte8 << 1U) | byte7 >> 7U;
  int32_t coefficient7 = (byte10 & (int32_t)31) << 6U | byte9 >> 2U;
  int32_t coefficient8 = byte11 << 3U | byte10 >> 5U;
  K___int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t lit;
  lit.fst = coefficient1;
  lit.snd = coefficient2;
  lit.thd = coefficient3;
  lit.f3 = coefficient4;
  lit.f4 = coefficient5;
  lit.f5 = coefficient6;
  lit.f6 = coefficient7;
  lit.f7 = coefficient8;
  return lit;
}

void
libcrux_kyber_serialize_deserialize_then_decompress_11(
  Eurydice_slice serialized,
  int32_t ret[256U]
)
{
  int32_t re[256U];
  memcpy(re,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(serialized, uint8_t) / (size_t)11U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t
        byte1 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)11U + (size_t)0U, uint8_t);
        int32_t
        byte2 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)11U + (size_t)1U, uint8_t);
        int32_t
        byte3 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)11U + (size_t)2U, uint8_t);
        int32_t
        byte4 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)11U + (size_t)3U, uint8_t);
        int32_t
        byte5 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)11U + (size_t)4U, uint8_t);
        int32_t
        byte6 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)11U + (size_t)5U, uint8_t);
        int32_t
        byte7 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)11U + (size_t)6U, uint8_t);
        int32_t
        byte8 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)11U + (size_t)7U, uint8_t);
        int32_t
        byte9 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)11U + (size_t)8U, uint8_t);
        int32_t
        byte10 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)11U + (size_t)9U, uint8_t);
        int32_t
        byte11 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)11U + (size_t)10U, uint8_t);
        K___int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t
        uu____1 =
          libcrux_kyber_serialize_decompress_coefficients_11(byte2,
            byte1,
            byte3,
            byte5,
            byte4,
            byte6,
            byte7,
            byte9,
            byte8,
            byte10,
            byte11);
        int32_t coefficient1 = uu____1.fst;
        int32_t coefficient2 = uu____1.snd;
        int32_t coefficient3 = uu____1.thd;
        int32_t coefficient4 = uu____1.f3;
        int32_t coefficient5 = uu____1.f4;
        int32_t coefficient6 = uu____1.f5;
        int32_t coefficient7 = uu____1.f6;
        int32_t coefficient8 = uu____1.f7;
        int32_t
        uu____2 = libcrux_kyber_compress_decompress_ciphertext_coefficient(11U, coefficient1);
        re[(size_t)8U * i] = uu____2;
        int32_t
        uu____3 = libcrux_kyber_compress_decompress_ciphertext_coefficient(11U, coefficient2);
        re[(size_t)8U * i + (size_t)1U] = uu____3;
        int32_t
        uu____4 = libcrux_kyber_compress_decompress_ciphertext_coefficient(11U, coefficient3);
        re[(size_t)8U * i + (size_t)2U] = uu____4;
        int32_t
        uu____5 = libcrux_kyber_compress_decompress_ciphertext_coefficient(11U, coefficient4);
        re[(size_t)8U * i + (size_t)3U] = uu____5;
        int32_t
        uu____6 = libcrux_kyber_compress_decompress_ciphertext_coefficient(11U, coefficient5);
        re[(size_t)8U * i + (size_t)4U] = uu____6;
        int32_t
        uu____7 = libcrux_kyber_compress_decompress_ciphertext_coefficient(11U, coefficient6);
        re[(size_t)8U * i + (size_t)5U] = uu____7;
        int32_t
        uu____8 = libcrux_kyber_compress_decompress_ciphertext_coefficient(11U, coefficient7);
        re[(size_t)8U * i + (size_t)6U] = uu____8;
        int32_t
        uu____9 = libcrux_kyber_compress_decompress_ciphertext_coefficient(11U, coefficient8);
        re[(size_t)8U * i + (size_t)7U] = uu____9;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, re, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_ntt_ntt_at_layer_3328(
  size_t *zeta_i,
  int32_t re[256U],
  size_t layer,
  int32_t ret[256U]
)
{
  int32_t ret0[256U];
  libcrux_kyber_ntt_ntt_at_layer(zeta_i, re, layer, (size_t)3328U, ret0);
  memcpy(ret, ret0, (size_t)256U * sizeof (int32_t));
}

K___int32_t_int32_t libcrux_kyber_serialize_decompress_coefficients_4(uint8_t *byte)
{
  int32_t coefficient1 = (int32_t)Eurydice_bitand_pv_u8(byte, 15U);
  int32_t coefficient2 = (int32_t)((uint32_t)Eurydice_shr_pv_u8(byte, (int32_t)4) & 15U);
  K___int32_t_int32_t lit;
  lit.fst = coefficient1;
  lit.snd = coefficient2;
  return lit;
}

void
libcrux_kyber_serialize_deserialize_then_decompress_4(
  Eurydice_slice serialized,
  int32_t ret[256U]
)
{
  int32_t re[256U];
  memcpy(re,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(serialized, uint8_t);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        K___int32_t_int32_t
        uu____1 =
          libcrux_kyber_serialize_decompress_coefficients_4(&Eurydice_slice_index(serialized,
              i,
              uint8_t));
        int32_t coefficient1 = uu____1.fst;
        int32_t coefficient2 = uu____1.snd;
        int32_t
        uu____2 = libcrux_kyber_compress_decompress_ciphertext_coefficient(4U, coefficient1);
        re[(size_t)2U * i] = uu____2;
        int32_t
        uu____3 = libcrux_kyber_compress_decompress_ciphertext_coefficient(4U, coefficient2);
        re[(size_t)2U * i + (size_t)1U] = uu____3;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, re, (size_t)256U * sizeof (int32_t));
    return;
  }
}

K___int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t
libcrux_kyber_serialize_decompress_coefficients_5(
  int32_t byte1,
  int32_t byte2,
  int32_t byte3,
  int32_t byte4,
  int32_t byte5
)
{
  int32_t coefficient1 = byte1 & (int32_t)31;
  int32_t coefficient2 = (byte2 & (int32_t)3) << 3U | byte1 >> 5U;
  int32_t coefficient3 = byte2 >> 2U & (int32_t)31;
  int32_t coefficient4 = (byte3 & (int32_t)15) << 1U | byte2 >> 7U;
  int32_t coefficient5 = (byte4 & (int32_t)1) << 4U | byte3 >> 4U;
  int32_t coefficient6 = byte4 >> 1U & (int32_t)31;
  int32_t coefficient7 = (byte5 & (int32_t)7) << 2U | byte4 >> 6U;
  int32_t coefficient8 = byte5 >> 3U;
  K___int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t lit;
  lit.fst = coefficient1;
  lit.snd = coefficient2;
  lit.thd = coefficient3;
  lit.f3 = coefficient4;
  lit.f4 = coefficient5;
  lit.f5 = coefficient6;
  lit.f6 = coefficient7;
  lit.f7 = coefficient8;
  return lit;
}

void
libcrux_kyber_serialize_deserialize_then_decompress_5(
  Eurydice_slice serialized,
  int32_t ret[256U]
)
{
  int32_t re[256U];
  memcpy(re,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(serialized, uint8_t) / (size_t)5U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t
        byte1 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)5U + (size_t)0U, uint8_t);
        int32_t
        byte2 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)5U + (size_t)1U, uint8_t);
        int32_t
        byte3 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)5U + (size_t)2U, uint8_t);
        int32_t
        byte4 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)5U + (size_t)3U, uint8_t);
        int32_t
        byte5 = (int32_t)Eurydice_slice_index(serialized, i * (size_t)5U + (size_t)4U, uint8_t);
        K___int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t_int32_t
        uu____1 =
          libcrux_kyber_serialize_decompress_coefficients_5(byte1,
            byte2,
            byte3,
            byte4,
            byte5);
        int32_t coefficient1 = uu____1.fst;
        int32_t coefficient2 = uu____1.snd;
        int32_t coefficient3 = uu____1.thd;
        int32_t coefficient4 = uu____1.f3;
        int32_t coefficient5 = uu____1.f4;
        int32_t coefficient6 = uu____1.f5;
        int32_t coefficient7 = uu____1.f6;
        int32_t coefficient8 = uu____1.f7;
        int32_t
        uu____2 = libcrux_kyber_compress_decompress_ciphertext_coefficient(5U, coefficient1);
        re[(size_t)8U * i] = uu____2;
        int32_t
        uu____3 = libcrux_kyber_compress_decompress_ciphertext_coefficient(5U, coefficient2);
        re[(size_t)8U * i + (size_t)1U] = uu____3;
        int32_t
        uu____4 = libcrux_kyber_compress_decompress_ciphertext_coefficient(5U, coefficient3);
        re[(size_t)8U * i + (size_t)2U] = uu____4;
        int32_t
        uu____5 = libcrux_kyber_compress_decompress_ciphertext_coefficient(5U, coefficient4);
        re[(size_t)8U * i + (size_t)3U] = uu____5;
        int32_t
        uu____6 = libcrux_kyber_compress_decompress_ciphertext_coefficient(5U, coefficient5);
        re[(size_t)8U * i + (size_t)4U] = uu____6;
        int32_t
        uu____7 = libcrux_kyber_compress_decompress_ciphertext_coefficient(5U, coefficient6);
        re[(size_t)8U * i + (size_t)5U] = uu____7;
        int32_t
        uu____8 = libcrux_kyber_compress_decompress_ciphertext_coefficient(5U, coefficient7);
        re[(size_t)8U * i + (size_t)6U] = uu____8;
        int32_t
        uu____9 = libcrux_kyber_compress_decompress_ciphertext_coefficient(5U, coefficient8);
        re[(size_t)8U * i + (size_t)7U] = uu____9;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, re, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_serialize_compress_then_serialize_message(int32_t re[256U], uint8_t ret[32U])
{
  uint8_t serialized[32U];
  uint8_t buf[32U] = { 0U };
  memcpy(serialized, buf, (size_t)32U * sizeof (uint8_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t),
      int32_t)
    / (size_t)8U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        core_ops_range_Range__size_t lit;
        lit.start = (size_t)0U;
        lit.end = (size_t)8U;
        core_ops_range_Range__size_t
        iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
          if (uu____1.tag == core_option_None)
            break;
          else if (uu____1.tag == core_option_Some)
          {
            size_t j = uu____1.f0;
            uint16_t
            coefficient =
              libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + j]);
            uint8_t
            coefficient_compressed =
              libcrux_kyber_compress_compress_message_coefficient(coefficient);
            size_t uu____2 = i;
            serialized[uu____2] =
              (uint32_t)serialized[uu____2]
              | (uint32_t)coefficient_compressed << (uint32_t)j;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____3[32U];
    memcpy(uu____3, serialized, (size_t)32U * sizeof (uint8_t));
    memcpy(ret, uu____3, (size_t)32U * sizeof (uint8_t));
    return;
  }
}

libcrux_kyber_types_Error
libcrux_kyber_types__libcrux_kyber__types__Error_19__clone(libcrux_kyber_types_Error *self)
{
  return self[0U];
}

const size_t libcrux_kyber_kyber1024_RANK_1024 = (size_t)4U;

const
size_t
libcrux_kyber_kyber1024_RANKED_BYTES_PER_RING_ELEMENT_1024 =
  libcrux_kyber_kyber1024_RANK_1024
  * libcrux_kyber_constants_BITS_PER_RING_ELEMENT
  / (size_t)8U;

const
size_t
libcrux_kyber_kyber1024_T_AS_NTT_ENCODED_SIZE_1024 =
  libcrux_kyber_kyber1024_RANK_1024
  * libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT
  * libcrux_kyber_constants_BITS_PER_COEFFICIENT
  / (size_t)8U;

const size_t libcrux_kyber_kyber1024_VECTOR_U_COMPRESSION_FACTOR_1024 = (size_t)11U;

const
size_t
libcrux_kyber_kyber1024_C1_BLOCK_SIZE_1024 =
  libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT
  * libcrux_kyber_kyber1024_VECTOR_U_COMPRESSION_FACTOR_1024
  / (size_t)8U;

const
size_t
libcrux_kyber_kyber1024_C1_SIZE_1024 =
  libcrux_kyber_kyber1024_C1_BLOCK_SIZE_1024
  * libcrux_kyber_kyber1024_RANK_1024;

const size_t libcrux_kyber_kyber1024_VECTOR_V_COMPRESSION_FACTOR_1024 = (size_t)5U;

const
size_t
libcrux_kyber_kyber1024_C2_SIZE_1024 =
  libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT
  * libcrux_kyber_kyber1024_VECTOR_V_COMPRESSION_FACTOR_1024
  / (size_t)8U;

const
size_t
libcrux_kyber_kyber1024_CPA_PKE_SECRET_KEY_SIZE_1024 =
  libcrux_kyber_kyber1024_RANK_1024
  * libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT
  * libcrux_kyber_constants_BITS_PER_COEFFICIENT
  / (size_t)8U;

const
size_t
libcrux_kyber_kyber1024_CPA_PKE_PUBLIC_KEY_SIZE_1024 =
  libcrux_kyber_kyber1024_T_AS_NTT_ENCODED_SIZE_1024
  + (size_t)32U;

const
size_t
libcrux_kyber_kyber1024_CPA_PKE_CIPHERTEXT_SIZE_1024 =
  libcrux_kyber_kyber1024_C1_SIZE_1024
  + libcrux_kyber_kyber1024_C2_SIZE_1024;

const
size_t
libcrux_kyber_kyber1024_SECRET_KEY_SIZE_1024 =
  libcrux_kyber_kyber1024_CPA_PKE_SECRET_KEY_SIZE_1024
  + libcrux_kyber_kyber1024_CPA_PKE_PUBLIC_KEY_SIZE_1024
  + libcrux_kyber_constants_H_DIGEST_SIZE
  + libcrux_kyber_constants_SHARED_SECRET_SIZE;

const size_t libcrux_kyber_kyber1024_ETA1 = (size_t)2U;

const
size_t
libcrux_kyber_kyber1024_ETA1_RANDOMNESS_SIZE = libcrux_kyber_kyber1024_ETA1 * (size_t)64U;

const size_t libcrux_kyber_kyber1024_ETA2 = (size_t)2U;

const
size_t
libcrux_kyber_kyber1024_ETA2_RANDOMNESS_SIZE = libcrux_kyber_kyber1024_ETA2 * (size_t)64U;

const
size_t
libcrux_kyber_kyber1024_IMPLICIT_REJECTION_HASH_INPUT_SIZE =
  libcrux_kyber_constants_SHARED_SECRET_SIZE
  + libcrux_kyber_kyber1024_CPA_PKE_CIPHERTEXT_SIZE_1024;

typedef struct __uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t__s
{
  uint8_t fst[840U];
  uint8_t snd[840U];
  uint8_t thd[840U];
  uint8_t f3[840U];
}
__uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t_;

void
libcrux_kyber_hash_functions_XOFx4___4size_t(uint8_t input[4U][34U], uint8_t ret[4U][840U])
{
  uint8_t out[4U][840U];
  uint8_t buf0[840U] = { 0U };
  uint8_t buf1[840U] = { 0U };
  uint8_t buf2[840U] = { 0U };
  uint8_t buf[840U] = { 0U };
  uint8_t buf3[4U][840U] = { buf0, buf1, buf2, buf };
  memcpy(out, buf3, (size_t)4U * sizeof (uint8_t [840U]));
  bool uu____0;
  if (!libcrux_platform_simd256_support())
    uu____0 = true;
  else
    uu____0 = !false;
  if (uu____0)
  {
    core_ops_range_Range__size_t lit;
    lit.start = (size_t)0U;
    lit.end = (size_t)4U;
    core_ops_range_Range__size_t
    iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
    while (true)
    {
      core_option_Option__size_t
      uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
      if (!(uu____1.tag == core_option_None))
      {
        if (uu____1.tag == core_option_Some)
        {
          size_t i = uu____1.f0;
          uint8_t uu____2[840U];
          libcrux_digest_shake128((size_t)840U,
            Eurydice_array_to_slice((size_t)34U, input[i], uint8_t),
            uu____2);
          out[i] = uu____2;
        }
        else
        {
          KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
          KRML_HOST_EXIT(255U);
        }
      }
    }
  }
  else if ((size_t)4U == (size_t)2U)
  {
    Eurydice_slice uu____3 = Eurydice_array_to_slice((size_t)34U, input[0U], uint8_t);
    Eurydice_slice uu____4 = Eurydice_array_to_slice((size_t)34U, input[1U], uint8_t);
    Eurydice_slice uu____5 = Eurydice_array_to_slice((size_t)34U, input[0U], uint8_t);
    __uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t_
    uu____6 =
      libcrux_digest_shake128x4((size_t)840U,
        uu____3,
        uu____4,
        uu____5,
        Eurydice_array_to_slice((size_t)34U, input[1U], uint8_t));
    uint8_t d0[840U];
    uint8_t uu____7[840U];
    memcpy(uu____7, uu____6.fst, (size_t)840U * sizeof (uint8_t));
    memcpy(d0, uu____7, (size_t)840U * sizeof (uint8_t));
    uint8_t d1[840U];
    uint8_t uu____8[840U];
    memcpy(uu____8, uu____6.snd, (size_t)840U * sizeof (uint8_t));
    memcpy(d1, uu____8, (size_t)840U * sizeof (uint8_t));
    uint8_t uu____9[840U];
    memcpy(uu____9, d0, (size_t)840U * sizeof (uint8_t));
    out[0U] = uu____9;
    uint8_t uu____10[840U];
    memcpy(uu____10, d1, (size_t)840U * sizeof (uint8_t));
    out[1U] = uu____10;
  }
  else if ((size_t)4U == (size_t)3U)
  {
    Eurydice_slice uu____11 = Eurydice_array_to_slice((size_t)34U, input[0U], uint8_t);
    Eurydice_slice uu____12 = Eurydice_array_to_slice((size_t)34U, input[1U], uint8_t);
    Eurydice_slice uu____13 = Eurydice_array_to_slice((size_t)34U, input[2U], uint8_t);
    __uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t_
    uu____14 =
      libcrux_digest_shake128x4((size_t)840U,
        uu____11,
        uu____12,
        uu____13,
        Eurydice_array_to_slice((size_t)34U, input[0U], uint8_t));
    uint8_t d0[840U];
    uint8_t uu____15[840U];
    memcpy(uu____15, uu____14.fst, (size_t)840U * sizeof (uint8_t));
    memcpy(d0, uu____15, (size_t)840U * sizeof (uint8_t));
    uint8_t d1[840U];
    uint8_t uu____16[840U];
    memcpy(uu____16, uu____14.snd, (size_t)840U * sizeof (uint8_t));
    memcpy(d1, uu____16, (size_t)840U * sizeof (uint8_t));
    uint8_t d2[840U];
    uint8_t uu____17[840U];
    memcpy(uu____17, uu____14.thd, (size_t)840U * sizeof (uint8_t));
    memcpy(d2, uu____17, (size_t)840U * sizeof (uint8_t));
    uint8_t uu____18[840U];
    memcpy(uu____18, d0, (size_t)840U * sizeof (uint8_t));
    out[0U] = uu____18;
    uint8_t uu____19[840U];
    memcpy(uu____19, d1, (size_t)840U * sizeof (uint8_t));
    out[1U] = uu____19;
    uint8_t uu____20[840U];
    memcpy(uu____20, d2, (size_t)840U * sizeof (uint8_t));
    out[2U] = uu____20;
  }
  else if ((size_t)4U == (size_t)4U)
  {
    Eurydice_slice uu____21 = Eurydice_array_to_slice((size_t)34U, input[0U], uint8_t);
    Eurydice_slice uu____22 = Eurydice_array_to_slice((size_t)34U, input[1U], uint8_t);
    Eurydice_slice uu____23 = Eurydice_array_to_slice((size_t)34U, input[2U], uint8_t);
    __uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t_
    uu____24 =
      libcrux_digest_shake128x4((size_t)840U,
        uu____21,
        uu____22,
        uu____23,
        Eurydice_array_to_slice((size_t)34U, input[3U], uint8_t));
    uint8_t d0[840U];
    uint8_t uu____25[840U];
    memcpy(uu____25, uu____24.fst, (size_t)840U * sizeof (uint8_t));
    memcpy(d0, uu____25, (size_t)840U * sizeof (uint8_t));
    uint8_t d1[840U];
    uint8_t uu____26[840U];
    memcpy(uu____26, uu____24.snd, (size_t)840U * sizeof (uint8_t));
    memcpy(d1, uu____26, (size_t)840U * sizeof (uint8_t));
    uint8_t d2[840U];
    uint8_t uu____27[840U];
    memcpy(uu____27, uu____24.thd, (size_t)840U * sizeof (uint8_t));
    memcpy(d2, uu____27, (size_t)840U * sizeof (uint8_t));
    uint8_t d3[840U];
    uint8_t uu____28[840U];
    memcpy(uu____28, uu____24.f3, (size_t)840U * sizeof (uint8_t));
    memcpy(d3, uu____28, (size_t)840U * sizeof (uint8_t));
    uint8_t uu____29[840U];
    memcpy(uu____29, d0, (size_t)840U * sizeof (uint8_t));
    out[0U] = uu____29;
    uint8_t uu____30[840U];
    memcpy(uu____30, d1, (size_t)840U * sizeof (uint8_t));
    out[1U] = uu____30;
    uint8_t uu____31[840U];
    memcpy(uu____31, d2, (size_t)840U * sizeof (uint8_t));
    out[2U] = uu____31;
    uint8_t uu____32[840U];
    memcpy(uu____32, d3, (size_t)840U * sizeof (uint8_t));
    out[3U] = uu____32;
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
    KRML_HOST_EXIT(255U);
  }
  uint8_t uu____33[4U][840U];
  memcpy(uu____33, out, (size_t)4U * sizeof (uint8_t [840U]));
  memcpy(ret, uu____33, (size_t)4U * sizeof (uint8_t [840U]));
}

K___libcrux_kyber_arithmetic_PolynomialRingElement_core_option_Option_libcrux_kyber_types_Error
libcrux_kyber_sampling_sample_from_uniform_distribution___840size_t(uint8_t randomness[840U])
{
  size_t sampled_coefficients = (size_t)0U;
  int32_t out[256U];
  memcpy(out,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  bool done = false;
  core_slice_iter_Chunks
  iter =
    core_iter_traits_collect__I__into_iter(core_slice___Slice_T___chunks(Eurydice_array_to_slice((size_t)840U,
          randomness,
          uint8_t),
        (size_t)3U,
        uint8_t),
      core_slice_iter_Chunks);
  while (true)
  {
    core_option_Option__Eurydice_slice_uint8_t
    uu____0 = core_slice_iter__core__slice__iter__Chunks__a__T__70__next(&iter, uint8_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        Eurydice_slice bytes = uu____0.f0;
        if (!done)
        {
          int32_t b1 = (int32_t)Eurydice_slice_index(bytes, (size_t)0U, uint8_t);
          int32_t b2 = (int32_t)Eurydice_slice_index(bytes, (size_t)1U, uint8_t);
          int32_t b3 = (int32_t)Eurydice_slice_index(bytes, (size_t)2U, uint8_t);
          int32_t d1 = (b2 & (int32_t)15) << 8U | b1;
          int32_t d2 = b3 << 4U | b2 >> 4U;
          bool uu____1;
          int32_t uu____2;
          size_t uu____3;
          bool uu____4;
          bool uu____5;
          int32_t uu____6;
          bool uu____7;
          size_t uu____8;
          int32_t uu____9;
          size_t uu____10;
          bool uu____11;
          size_t uu____12;
          int32_t uu____13;
          size_t uu____14;
          size_t uu____15;
          if (d1 < libcrux_kyber_constants_FIELD_MODULUS)
          {
            uu____1 = sampled_coefficients < libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
            if (uu____1)
            {
              uu____2 = d1;
              uu____3 = sampled_coefficients;
              out[uu____3] = uu____2;
              sampled_coefficients++;
              uu____6 = d2;
              uu____13 = libcrux_kyber_constants_FIELD_MODULUS;
              uu____5 = uu____6 < uu____13;
              if (uu____5)
              {
                uu____8 = sampled_coefficients;
                uu____14 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                uu____7 = uu____8 < uu____14;
                uu____4 = uu____7;
                if (uu____4)
                {
                  uu____9 = d2;
                  uu____10 = sampled_coefficients;
                  out[uu____10] = uu____9;
                  sampled_coefficients++;
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
                else
                {
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
              }
              else
              {
                uu____4 = false;
                if (uu____4)
                {
                  uu____9 = d2;
                  uu____10 = sampled_coefficients;
                  out[uu____10] = uu____9;
                  sampled_coefficients++;
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
                else
                {
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
              }
            }
            else
            {
              uu____6 = d2;
              uu____13 = libcrux_kyber_constants_FIELD_MODULUS;
              uu____5 = uu____6 < uu____13;
              if (uu____5)
              {
                uu____8 = sampled_coefficients;
                uu____14 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                uu____7 = uu____8 < uu____14;
                uu____4 = uu____7;
                if (uu____4)
                {
                  uu____9 = d2;
                  uu____10 = sampled_coefficients;
                  out[uu____10] = uu____9;
                  sampled_coefficients++;
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
                else
                {
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
              }
              else
              {
                uu____4 = false;
                if (uu____4)
                {
                  uu____9 = d2;
                  uu____10 = sampled_coefficients;
                  out[uu____10] = uu____9;
                  sampled_coefficients++;
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
                else
                {
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
              }
            }
          }
          else
          {
            uu____1 = false;
            if (uu____1)
            {
              uu____2 = d1;
              uu____3 = sampled_coefficients;
              out[uu____3] = uu____2;
              sampled_coefficients++;
              uu____6 = d2;
              uu____13 = libcrux_kyber_constants_FIELD_MODULUS;
              uu____5 = uu____6 < uu____13;
              if (uu____5)
              {
                uu____8 = sampled_coefficients;
                uu____14 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                uu____7 = uu____8 < uu____14;
                uu____4 = uu____7;
                if (uu____4)
                {
                  uu____9 = d2;
                  uu____10 = sampled_coefficients;
                  out[uu____10] = uu____9;
                  sampled_coefficients++;
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
                else
                {
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
              }
              else
              {
                uu____4 = false;
                if (uu____4)
                {
                  uu____9 = d2;
                  uu____10 = sampled_coefficients;
                  out[uu____10] = uu____9;
                  sampled_coefficients++;
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
                else
                {
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
              }
            }
            else
            {
              uu____6 = d2;
              uu____13 = libcrux_kyber_constants_FIELD_MODULUS;
              uu____5 = uu____6 < uu____13;
              if (uu____5)
              {
                uu____8 = sampled_coefficients;
                uu____14 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                uu____7 = uu____8 < uu____14;
                uu____4 = uu____7;
                if (uu____4)
                {
                  uu____9 = d2;
                  uu____10 = sampled_coefficients;
                  out[uu____10] = uu____9;
                  sampled_coefficients++;
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
                else
                {
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
              }
              else
              {
                uu____4 = false;
                if (uu____4)
                {
                  uu____9 = d2;
                  uu____10 = sampled_coefficients;
                  out[uu____10] = uu____9;
                  sampled_coefficients++;
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
                else
                {
                  uu____12 = sampled_coefficients;
                  uu____15 = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
                  uu____11 = uu____12 == uu____15;
                  if (uu____11)
                    done = true;
                }
              }
            }
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    K___libcrux_kyber_arithmetic_PolynomialRingElement_core_option_Option_libcrux_kyber_types_Error
    uu____16;
    if (done)
    {
      K___libcrux_kyber_arithmetic_PolynomialRingElement_core_option_Option_libcrux_kyber_types_Error
      lit;
      memcpy(lit.fst, out, (size_t)256U * sizeof (int32_t));
      lit.snd.tag = core_option_None;
      uu____16 = lit;
    }
    else
    {
      K___libcrux_kyber_arithmetic_PolynomialRingElement_core_option_Option_libcrux_kyber_types_Error
      lit;
      memcpy(lit.fst, out, (size_t)256U * sizeof (int32_t));
      lit.snd.tag = core_option_Some;
      lit.snd.f0 = libcrux_kyber_types_RejectionSampling;
      uu____16 = lit;
    }
    return uu____16;
  }
}

K___libcrux_kyber_arithmetic_PolynomialRingElement_4size_t__4size_t__core_option_Option__libcrux_kyber_types_Error
libcrux_kyber_matrix_sample_matrix_A___4size_t(uint8_t seed[34U], bool transpose)
{
  int32_t A_transpose[4U][4U][256U];
  int32_t
  buf0[4U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  int32_t
  buf1[4U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  int32_t
  buf2[4U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  int32_t
  buf3[4U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  int32_t buf4[4U][4U][256U] = { buf0, buf1, buf2, buf3 };
  memcpy(A_transpose, buf4, (size_t)4U * sizeof (int32_t [4U][256U]));
  core_option_Option__libcrux_kyber_types_Error sampling_A_error;
  sampling_A_error.tag = core_option_None;
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = (size_t)4U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        uint8_t uu____1[34U];
        memcpy(uu____1, seed, (size_t)34U * sizeof (uint8_t));
        uint8_t seeds[4U][34U];
        uint8_t buf[4U][34U] = { uu____1, uu____1, uu____1, uu____1 };
        memcpy(seeds, buf, (size_t)4U * sizeof (uint8_t [34U]));
        core_ops_range_Range__size_t lit0;
        lit0.start = (size_t)0U;
        lit0.end = (size_t)4U;
        core_ops_range_Range__size_t
        iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____2 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
          if (uu____2.tag == core_option_None)
            break;
          else if (uu____2.tag == core_option_Some)
          {
            size_t j = uu____2.f0;
            seeds[j][32U] = (uint8_t)i;
            seeds[j][33U] = (uint8_t)j;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        uint8_t uu____3[4U][34U];
        memcpy(uu____3, seeds, (size_t)4U * sizeof (uint8_t [34U]));
        uint8_t xof_bytes[4U][840U];
        libcrux_kyber_hash_functions_XOFx4___4size_t(uu____3, xof_bytes);
        core_ops_range_Range__size_t lit;
        lit.start = (size_t)0U;
        lit.end = (size_t)4U;
        core_ops_range_Range__size_t
        iter0 = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____4 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
          if (uu____4.tag == core_option_None)
            break;
          else if (uu____4.tag == core_option_Some)
          {
            size_t j = uu____4.f0;
            uint8_t uu____5[840U];
            memcpy(uu____5, xof_bytes[j], (size_t)840U * sizeof (uint8_t));
            K___libcrux_kyber_arithmetic_PolynomialRingElement_core_option_Option_libcrux_kyber_types_Error
            uu____6 = libcrux_kyber_sampling_sample_from_uniform_distribution___840size_t(uu____5);
            int32_t sampled[256U];
            memcpy(sampled, uu____6.fst, (size_t)256U * sizeof (int32_t));
            core_option_Option__libcrux_kyber_types_Error error = uu____6.snd;
            if (core_option__core__option__Option_T___is_some(&error, libcrux_kyber_types_Error))
              sampling_A_error = error;
            if (transpose)
              memcpy(A_transpose[j][i], sampled, (size_t)256U * sizeof (int32_t));
            else
              memcpy(A_transpose[i][j], sampled, (size_t)256U * sizeof (int32_t));
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____7[4U][4U][256U];
    memcpy(uu____7, A_transpose, (size_t)4U * sizeof (int32_t [4U][256U]));
    K___libcrux_kyber_arithmetic_PolynomialRingElement_4size_t__4size_t__core_option_Option__libcrux_kyber_types_Error
    lit;
    memcpy(lit.fst, uu____7, (size_t)4U * sizeof (int32_t [4U][256U]));
    lit.snd = sampling_A_error;
    return lit;
  }
}

void libcrux_kyber_ind_cpa_into_padded_array___34size_t(Eurydice_slice slice, uint8_t ret[34U])
{
  if (false)
    LowStar_Ignore_ignore(core_slice___Slice_T___len(slice, uint8_t), size_t);
  uint8_t out[34U];
  uint8_t buf[34U] = { 0U };
  memcpy(out, buf, (size_t)34U * sizeof (uint8_t));
  uint8_t *uu____0 = out;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(slice, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)34U,
      uu____0,
      lit,
      uint8_t,
      core_ops_range_Range__size_t),
    slice,
    uint8_t);
  uint8_t uu____1[34U];
  memcpy(uu____1, out, (size_t)34U * sizeof (uint8_t));
  memcpy(ret, uu____1, (size_t)34U * sizeof (uint8_t));
}

void libcrux_kyber_ind_cpa_into_padded_array___33size_t(Eurydice_slice slice, uint8_t ret[33U])
{
  if (false)
    LowStar_Ignore_ignore(core_slice___Slice_T___len(slice, uint8_t), size_t);
  uint8_t out[33U];
  uint8_t buf[33U] = { 0U };
  memcpy(out, buf, (size_t)33U * sizeof (uint8_t));
  uint8_t *uu____0 = out;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(slice, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)33U,
      uu____0,
      lit,
      uint8_t,
      core_ops_range_Range__size_t),
    slice,
    uint8_t);
  uint8_t uu____1[33U];
  memcpy(uu____1, out, (size_t)33U * sizeof (uint8_t));
  memcpy(ret, uu____1, (size_t)33U * sizeof (uint8_t));
}

void libcrux_kyber_hash_functions_PRF___128size_t(Eurydice_slice input, uint8_t ret[128U])
{
  uint8_t ret0[128U];
  libcrux_digest_shake256((size_t)128U, input, ret0);
  memcpy(ret, ret0, (size_t)128U * sizeof (uint8_t));
}

void
libcrux_kyber_sampling_sample_from_binomial_distribution___2size_t(
  Eurydice_slice randomness,
  int32_t ret[256U]
)
{
  int32_t uu____0[256U];
  if ((size_t)2U == (size_t)2U)
    libcrux_kyber_sampling_sample_from_binomial_distribution_2(randomness, uu____0);
  else if ((size_t)2U == (size_t)3U)
    libcrux_kyber_sampling_sample_from_binomial_distribution_3(randomness, uu____0);
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
    KRML_HOST_EXIT(255U);
  }
  memcpy(ret, uu____0, (size_t)256U * sizeof (int32_t));
}

K___libcrux_kyber_arithmetic_PolynomialRingElement_4size_t__uint8_t
libcrux_kyber_ind_cpa_sample_vector_cbd_then_ntt___4size_t_2size_t_128size_t(
  uint8_t prf_input[33U],
  uint8_t domain_separator
)
{
  int32_t re_as_ntt[4U][256U];
  int32_t
  buf[4U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  memcpy(re_as_ntt, buf, (size_t)4U * sizeof (int32_t [256U]));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = (size_t)4U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        prf_input[32U] = domain_separator;
        domain_separator = (uint32_t)domain_separator + 1U;
        uint8_t prf_output[128U];
        libcrux_kyber_hash_functions_PRF___128size_t(Eurydice_array_to_slice((size_t)33U,
            prf_input,
            uint8_t),
          prf_output);
        int32_t r[256U];
        libcrux_kyber_sampling_sample_from_binomial_distribution___2size_t(Eurydice_array_to_slice((size_t)128U,
            prf_output,
            uint8_t),
          r);
        int32_t uu____1[256U];
        libcrux_kyber_ntt_ntt_binomially_sampled_ring_element(r, uu____1);
        memcpy(re_as_ntt[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[4U][256U];
    memcpy(uu____2, re_as_ntt, (size_t)4U * sizeof (int32_t [256U]));
    K___libcrux_kyber_arithmetic_PolynomialRingElement_4size_t__uint8_t lit;
    memcpy(lit.fst, uu____2, (size_t)4U * sizeof (int32_t [256U]));
    lit.snd = domain_separator;
    return lit;
  }
}

void
libcrux_kyber_arithmetic_add_to_ring_element___4size_t(
  int32_t lhs[256U],
  int32_t (*rhs)[256U],
  int32_t ret[256U]
)
{
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, lhs, int32_t),
      int32_t);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        size_t uu____1 = i;
        lhs[uu____1] = lhs[uu____1] + rhs[0U][i];
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, lhs, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_matrix_compute_As_plus_e___4size_t(
  int32_t (*matrix_A)[4U][256U],
  int32_t (*s_as_ntt)[256U],
  int32_t (*error_as_ntt)[256U],
  int32_t ret[4U][256U]
)
{
  int32_t result[4U][256U];
  int32_t
  buf[4U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  memcpy(result, buf, (size_t)4U * sizeof (int32_t [256U]));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)4U,
        matrix_A,
        Eurydice_error_t_cg_array),
      int32_t [4U][256U]);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        core_ops_range_Range__size_t lit;
        lit.start = (size_t)0U;
        lit.end =
          core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)4U,
              matrix_A[i],
              int32_t [256U]),
            int32_t [256U]);
        core_ops_range_Range__size_t
        iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
          if (uu____1.tag == core_option_None)
            break;
          else if (uu____1.tag == core_option_Some)
          {
            size_t j = uu____1.f0;
            int32_t product[256U];
            libcrux_kyber_ntt_ntt_multiply(&matrix_A[i][j], &s_as_ntt[j], product);
            int32_t uu____2[256U];
            libcrux_kyber_arithmetic_add_to_ring_element___4size_t(result[i], &product, uu____2);
            memcpy(result[i], uu____2, (size_t)256U * sizeof (int32_t));
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        core_ops_range_Range__size_t lit0;
        lit0.start = (size_t)0U;
        lit0.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
        core_ops_range_Range__size_t
        iter0 = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____3 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
          if (uu____3.tag == core_option_None)
            break;
          else if (uu____3.tag == core_option_Some)
          {
            size_t j = uu____3.f0;
            int32_t
            coefficient_normal_form = libcrux_kyber_arithmetic_to_standard_domain(result[i][j]);
            int32_t
            uu____4 =
              libcrux_kyber_arithmetic_barrett_reduce(coefficient_normal_form + error_as_ntt[i][j]);
            result[i][j] = uu____4;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____5[4U][256U];
    memcpy(uu____5, result, (size_t)4U * sizeof (int32_t [256U]));
    memcpy(ret, uu____5, (size_t)4U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_ind_cpa_serialize_secret_key___4size_t_1536size_t(
  int32_t key[4U][256U],
  uint8_t ret[1536U]
)
{
  uint8_t out[1536U];
  uint8_t buf[1536U] = { 0U };
  memcpy(out, buf, (size_t)1536U * sizeof (uint8_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)4U, key, int32_t [256U]),
      int32_t [256U]);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t re[256U];
        memcpy(re, key[i], (size_t)256U * sizeof (int32_t));
        core_ops_range_Range__size_t lit;
        lit.start = i * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        lit.end = (i + (size_t)1U) * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        Eurydice_slice
        uu____1 =
          Eurydice_array_to_subslice((size_t)1536U,
            out,
            lit,
            uint8_t,
            core_ops_range_Range__size_t);
        uint8_t ret[384U];
        libcrux_kyber_serialize_serialize_uncompressed_ring_element(re, ret);
        core_slice___Slice_T___copy_from_slice(uu____1,
          Eurydice_array_to_slice((size_t)384U, ret, uint8_t),
          uint8_t);
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____2[1536U];
    memcpy(uu____2, out, (size_t)1536U * sizeof (uint8_t));
    memcpy(ret, uu____2, (size_t)1536U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_ind_cpa_serialize_public_key___4size_t_1536size_t_1568size_t(
  int32_t t_as_ntt[4U][256U],
  Eurydice_slice seed_for_a,
  uint8_t ret[1568U]
)
{
  uint8_t public_key_serialized[1568U];
  uint8_t buf[1568U] = { 0U };
  memcpy(public_key_serialized, buf, (size_t)1568U * sizeof (uint8_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)1536U;
  Eurydice_slice
  uu____0 =
    Eurydice_array_to_subslice((size_t)1568U,
      public_key_serialized,
      lit,
      uint8_t,
      core_ops_range_Range__size_t);
  int32_t uu____1[4U][256U];
  memcpy(uu____1, t_as_ntt, (size_t)4U * sizeof (int32_t [256U]));
  uint8_t ret0[1536U];
  libcrux_kyber_ind_cpa_serialize_secret_key___4size_t_1536size_t(uu____1, ret0);
  core_slice___Slice_T___copy_from_slice(uu____0,
    Eurydice_array_to_slice((size_t)1536U, ret0, uint8_t),
    uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice_from((size_t)1568U,
      public_key_serialized,
      (size_t)1536U,
      uint8_t,
      size_t),
    seed_for_a,
    uint8_t);
  uint8_t uu____2[1568U];
  memcpy(uu____2, public_key_serialized, (size_t)1568U * sizeof (uint8_t));
  memcpy(ret, uu____2, (size_t)1568U * sizeof (uint8_t));
}

K___uint8_t_1536size_t____uint8_t_1568size_t__core_option_Option__libcrux_kyber_types_Error
libcrux_kyber_ind_cpa_generate_keypair___4size_t_1536size_t_1568size_t_1536size_t_2size_t_128size_t(
  Eurydice_slice key_generation_seed
)
{
  uint8_t hashed[64U];
  libcrux_kyber_hash_functions_G(key_generation_seed, hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____0 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U, hashed, uint8_t),
      (size_t)32U,
      uint8_t);
  Eurydice_slice seed_for_A = uu____0.fst;
  Eurydice_slice seed_for_secret_and_error = uu____0.snd;
  uint8_t ret[34U];
  libcrux_kyber_ind_cpa_into_padded_array___34size_t(seed_for_A, ret);
  K___libcrux_kyber_arithmetic_PolynomialRingElement_4size_t__4size_t__core_option_Option__libcrux_kyber_types_Error
  uu____1 = libcrux_kyber_matrix_sample_matrix_A___4size_t(ret, true);
  int32_t A_transpose[4U][4U][256U];
  int32_t uu____2[4U][4U][256U];
  memcpy(uu____2, uu____1.fst, (size_t)4U * sizeof (int32_t [4U][256U]));
  memcpy(A_transpose, uu____2, (size_t)4U * sizeof (int32_t [4U][256U]));
  core_option_Option__libcrux_kyber_types_Error sampling_A_error = uu____1.snd;
  uint8_t prf_input[33U];
  libcrux_kyber_ind_cpa_into_padded_array___33size_t(seed_for_secret_and_error, prf_input);
  uint8_t uu____3[33U];
  memcpy(uu____3, prf_input, (size_t)33U * sizeof (uint8_t));
  K___libcrux_kyber_arithmetic_PolynomialRingElement_4size_t__uint8_t
  uu____4 =
    libcrux_kyber_ind_cpa_sample_vector_cbd_then_ntt___4size_t_2size_t_128size_t(uu____3,
      0U);
  int32_t secret_as_ntt[4U][256U];
  int32_t uu____5[4U][256U];
  memcpy(uu____5, uu____4.fst, (size_t)4U * sizeof (int32_t [256U]));
  memcpy(secret_as_ntt, uu____5, (size_t)4U * sizeof (int32_t [256U]));
  uint8_t domain_separator = uu____4.snd;
  uint8_t uu____6[33U];
  memcpy(uu____6, prf_input, (size_t)33U * sizeof (uint8_t));
  int32_t error_as_ntt[4U][256U];
  int32_t uu____7[4U][256U];
  memcpy(uu____7,
    libcrux_kyber_ind_cpa_sample_vector_cbd_then_ntt___4size_t_2size_t_128size_t(uu____6,
      domain_separator).fst,
    (size_t)4U * sizeof (int32_t [256U]));
  memcpy(error_as_ntt, uu____7, (size_t)4U * sizeof (int32_t [256U]));
  int32_t t_as_ntt[4U][256U];
  libcrux_kyber_matrix_compute_As_plus_e___4size_t(A_transpose,
    secret_as_ntt,
    error_as_ntt,
    t_as_ntt);
  int32_t uu____8[4U][256U];
  memcpy(uu____8, t_as_ntt, (size_t)4U * sizeof (int32_t [256U]));
  uint8_t public_key_serialized[1568U];
  libcrux_kyber_ind_cpa_serialize_public_key___4size_t_1536size_t_1568size_t(uu____8,
    seed_for_A,
    public_key_serialized);
  int32_t uu____9[4U][256U];
  memcpy(uu____9, secret_as_ntt, (size_t)4U * sizeof (int32_t [256U]));
  uint8_t secret_key_serialized[1536U];
  libcrux_kyber_ind_cpa_serialize_secret_key___4size_t_1536size_t(uu____9,
    secret_key_serialized);
  uint8_t uu____10[1536U];
  memcpy(uu____10, secret_key_serialized, (size_t)1536U * sizeof (uint8_t));
  uint8_t uu____11[1568U];
  memcpy(uu____11, public_key_serialized, (size_t)1568U * sizeof (uint8_t));
  K___uint8_t_1536size_t____uint8_t_1568size_t__core_option_Option__libcrux_kyber_types_Error
  lit;
  memcpy(lit.fst.fst, uu____10, (size_t)1536U * sizeof (uint8_t));
  memcpy(lit.fst.snd, uu____11, (size_t)1568U * sizeof (uint8_t));
  lit.snd = sampling_A_error;
  return lit;
}

void
libcrux_kyber_serialize_kem_secret_key___3168size_t(
  Eurydice_slice private_key,
  Eurydice_slice public_key,
  Eurydice_slice implicit_rejection_value,
  uint8_t ret[3168U]
)
{
  uint8_t out[3168U];
  uint8_t buf[3168U] = { 0U };
  memcpy(out, buf, (size_t)3168U * sizeof (uint8_t));
  size_t pointer = (size_t)0U;
  uint8_t *uu____0 = out;
  size_t uu____1 = pointer;
  core_ops_range_Range__size_t lit0;
  lit0.start = pointer;
  lit0.end = uu____1 + core_slice___Slice_T___len(private_key, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)3168U,
      uu____0,
      lit0,
      uint8_t,
      core_ops_range_Range__size_t),
    private_key,
    uint8_t);
  pointer = pointer + core_slice___Slice_T___len(private_key, uint8_t);
  uint8_t *uu____2 = out;
  size_t uu____3 = pointer;
  core_ops_range_Range__size_t lit1;
  lit1.start = pointer;
  lit1.end = uu____3 + core_slice___Slice_T___len(public_key, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)3168U,
      uu____2,
      lit1,
      uint8_t,
      core_ops_range_Range__size_t),
    public_key,
    uint8_t);
  pointer = pointer + core_slice___Slice_T___len(public_key, uint8_t);
  core_ops_range_Range__size_t lit2;
  lit2.start = pointer;
  lit2.end = pointer + libcrux_kyber_constants_H_DIGEST_SIZE;
  Eurydice_slice
  uu____4 =
    Eurydice_array_to_subslice((size_t)3168U,
      out,
      lit2,
      uint8_t,
      core_ops_range_Range__size_t);
  uint8_t ret0[32U];
  libcrux_kyber_hash_functions_H(public_key, ret0);
  core_slice___Slice_T___copy_from_slice(uu____4,
    Eurydice_array_to_slice((size_t)32U, ret0, uint8_t),
    uint8_t);
  pointer = pointer + libcrux_kyber_constants_H_DIGEST_SIZE;
  uint8_t *uu____5 = out;
  size_t uu____6 = pointer;
  core_ops_range_Range__size_t lit;
  lit.start = pointer;
  lit.end = uu____6 + core_slice___Slice_T___len(implicit_rejection_value, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)3168U,
      uu____5,
      lit,
      uint8_t,
      core_ops_range_Range__size_t),
    implicit_rejection_value,
    uint8_t);
  uint8_t uu____7[3168U];
  memcpy(uu____7, out, (size_t)3168U * sizeof (uint8_t));
  memcpy(ret, uu____7, (size_t)3168U * sizeof (uint8_t));
}

void
libcrux_kyber_types__libcrux_kyber__types__KyberPrivateKey_SIZE__8__from___3168size_t(
  uint8_t value[3168U],
  uint8_t ret[3168U]
)
{
  uint8_t uu____0[3168U];
  memcpy(uu____0, value, (size_t)3168U * sizeof (uint8_t));
  memcpy(ret, uu____0, (size_t)3168U * sizeof (uint8_t));
}

libcrux_kyber_types_KyberKeyPair___3168size_t_1568size_t
libcrux_kyber_types__libcrux_kyber__types__KyberKeyPair_PRIVATE_KEY_SIZE__PUBLIC_KEY_SIZE___from___3168size_t_1568size_t(
  uint8_t sk[3168U],
  uint8_t pk[1568U]
)
{
  libcrux_kyber_types_KyberKeyPair___3168size_t_1568size_t lit;
  memcpy(lit.sk, sk, (size_t)3168U * sizeof (uint8_t));
  memcpy(lit.pk, pk, (size_t)1568U * sizeof (uint8_t));
  return lit;
}

core_result_Result__libcrux_kyber_types_KyberKeyPair__1568size_t____3168size_t___libcrux_kyber_types_Error
libcrux_kyber_generate_keypair___4size_t_1536size_t_3168size_t_1568size_t_1536size_t_2size_t_128size_t(
  uint8_t randomness[64U]
)
{
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = libcrux_kyber_constants_CPA_PKE_KEY_GENERATION_SEED_SIZE;
  Eurydice_slice
  ind_cpa_keypair_randomness =
    Eurydice_array_to_subslice((size_t)64U,
      randomness,
      lit0,
      uint8_t,
      core_ops_range_Range__size_t);
  Eurydice_slice
  implicit_rejection_value =
    Eurydice_array_to_subslice_from((size_t)64U,
      randomness,
      libcrux_kyber_constants_CPA_PKE_KEY_GENERATION_SEED_SIZE,
      uint8_t,
      size_t);
  K___uint8_t_1536size_t____uint8_t_1568size_t__core_option_Option__libcrux_kyber_types_Error
  uu____0 =
    libcrux_kyber_ind_cpa_generate_keypair___4size_t_1536size_t_1568size_t_1536size_t_2size_t_128size_t(ind_cpa_keypair_randomness);
  uint8_t ind_cpa_private_key[1536U];
  uint8_t uu____1[1536U];
  memcpy(uu____1, uu____0.fst.fst, (size_t)1536U * sizeof (uint8_t));
  memcpy(ind_cpa_private_key, uu____1, (size_t)1536U * sizeof (uint8_t));
  uint8_t public_key[1568U];
  uint8_t uu____2[1568U];
  memcpy(uu____2, uu____0.fst.snd, (size_t)1568U * sizeof (uint8_t));
  memcpy(public_key, uu____2, (size_t)1568U * sizeof (uint8_t));
  core_option_Option__libcrux_kyber_types_Error sampling_a_error = uu____0.snd;
  Eurydice_slice uu____3 = Eurydice_array_to_slice((size_t)1536U, ind_cpa_private_key, uint8_t);
  uint8_t secret_key_serialized[3168U];
  libcrux_kyber_serialize_kem_secret_key___3168size_t(uu____3,
    Eurydice_array_to_slice((size_t)1568U, public_key, uint8_t),
    implicit_rejection_value,
    secret_key_serialized);
  core_result_Result__libcrux_kyber_types_KyberKeyPair__1568size_t____3168size_t___libcrux_kyber_types_Error
  uu____4;
  if (sampling_a_error.tag == core_option_Some)
  {
    libcrux_kyber_types_Error error = sampling_a_error.f0;
    core_result_Result__libcrux_kyber_types_KyberKeyPair__1568size_t____3168size_t___libcrux_kyber_types_Error
    lit;
    lit.tag = core_result_Err;
    lit.val.case_Err = error;
    uu____4 = lit;
  }
  else
  {
    uint8_t uu____5[3168U];
    memcpy(uu____5, secret_key_serialized, (size_t)3168U * sizeof (uint8_t));
    uint8_t private_key[3168U];
    libcrux_kyber_types__libcrux_kyber__types__KyberPrivateKey_SIZE__8__from___3168size_t(uu____5,
      private_key);
    uint8_t uu____6[3168U];
    memcpy(uu____6, private_key, (size_t)3168U * sizeof (uint8_t));
    uint8_t uu____7[1568U];
    memcpy(uu____7, public_key, (size_t)1568U * sizeof (uint8_t));
    core_result_Result__libcrux_kyber_types_KyberKeyPair__1568size_t____3168size_t___libcrux_kyber_types_Error
    lit;
    lit.tag = core_result_Ok;
    lit.val.case_Ok =
      libcrux_kyber_types__libcrux_kyber__types__KyberKeyPair_PRIVATE_KEY_SIZE__PUBLIC_KEY_SIZE___from___3168size_t_1568size_t(uu____6,
        uu____7);
    uu____4 = lit;
  }
  return uu____4;
}

core_result_Result__libcrux_kyber_types_KyberKeyPair__1568size_t____3168size_t___libcrux_kyber_types_Error
libcrux_kyber_kyber1024_generate_key_pair_1024(uint8_t randomness[64U])
{
  uint8_t uu____0[64U];
  memcpy(uu____0, randomness, (size_t)64U * sizeof (uint8_t));
  return
    libcrux_kyber_generate_keypair___4size_t_1536size_t_3168size_t_1568size_t_1536size_t_2size_t_128size_t(uu____0);
}

void libcrux_kyber_ind_cpa_into_padded_array___64size_t(Eurydice_slice slice, uint8_t ret[64U])
{
  if (false)
    LowStar_Ignore_ignore(core_slice___Slice_T___len(slice, uint8_t), size_t);
  uint8_t out[64U];
  uint8_t buf[64U] = { 0U };
  memcpy(out, buf, (size_t)64U * sizeof (uint8_t));
  uint8_t *uu____0 = out;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(slice, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)64U,
      uu____0,
      lit,
      uint8_t,
      core_ops_range_Range__size_t),
    slice,
    uint8_t);
  uint8_t uu____1[64U];
  memcpy(uu____1, out, (size_t)64U * sizeof (uint8_t));
  memcpy(ret, uu____1, (size_t)64U * sizeof (uint8_t));
}

uint8_t
*libcrux_kyber_types__libcrux_kyber__types__KyberPublicKey_SIZE__18__as_slice___1568size_t(
  uint8_t (*self)[1568U]
)
{
  return self[0U];
}

void
libcrux_kyber_ind_cpa_deserialize_public_key___4size_t_1536size_t(
  Eurydice_slice public_key,
  int32_t ret[4U][256U]
)
{
  int32_t t_as_ntt[4U][256U];
  int32_t
  buf[4U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  memcpy(t_as_ntt, buf, (size_t)4U * sizeof (int32_t [256U]));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = (size_t)1536U / libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        core_ops_range_Range__size_t lit;
        lit.start = i * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        lit.end = i * (libcrux_kyber_constants_BYTES_PER_RING_ELEMENT + (size_t)1U);
        Eurydice_slice
        t_as_ntt_bytes =
          Eurydice_slice_subslice(public_key,
            lit,
            uint8_t,
            core_ops_range_Range__size_t);
        int32_t uu____1[256U];
        libcrux_kyber_serialize_deserialize_to_uncompressed_ring_element(t_as_ntt_bytes, uu____1);
        memcpy(t_as_ntt[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[4U][256U];
    memcpy(uu____2, t_as_ntt, (size_t)4U * sizeof (int32_t [256U]));
    memcpy(ret, uu____2, (size_t)4U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_ind_cpa_sample_ring_element_cbd___4size_t_128size_t_2size_t(
  uint8_t *prf_input,
  uint8_t *domain_separator,
  int32_t ret[4U][256U]
)
{
  int32_t error_1[4U][256U];
  int32_t
  buf[4U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  memcpy(error_1, buf, (size_t)4U * sizeof (int32_t [256U]));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)4U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        prf_input[32U] = domain_separator[0U];
        domain_separator[0U] = (uint32_t)domain_separator[0U] + 1U;
        uint8_t prf_output[128U];
        libcrux_kyber_hash_functions_PRF___128size_t(Eurydice_array_to_slice((size_t)33U,
            prf_input,
            uint8_t),
          prf_output);
        int32_t uu____1[256U];
        libcrux_kyber_sampling_sample_from_binomial_distribution___2size_t(Eurydice_array_to_slice((size_t)128U,
            prf_output,
            uint8_t),
          uu____1);
        memcpy(error_1[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[4U][256U];
    memcpy(uu____2, error_1, (size_t)4U * sizeof (int32_t [256U]));
    memcpy(ret, uu____2, (size_t)4U * sizeof (int32_t [256U]));
    return;
  }
}

void libcrux_kyber_ntt_invert_ntt_montgomery___4size_t(int32_t re[256U], int32_t ret[256U])
{
  size_t zeta_i = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT / (size_t)2U;
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)1U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)2U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)3U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)4U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)5U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)6U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)7U, re);
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)8U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t uu____1 = libcrux_kyber_arithmetic_barrett_reduce(re[i]);
        re[i] = uu____1;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, re, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_matrix_compute_vector_u___4size_t(
  int32_t (*a_as_ntt)[4U][256U],
  int32_t (*r_as_ntt)[256U],
  int32_t (*error_1)[256U],
  int32_t ret[4U][256U]
)
{
  int32_t result[4U][256U];
  int32_t
  buf[4U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  memcpy(result, buf, (size_t)4U * sizeof (int32_t [256U]));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)4U,
        a_as_ntt,
        Eurydice_error_t_cg_array),
      int32_t [4U][256U]);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        core_ops_range_Range__size_t lit;
        lit.start = (size_t)0U;
        lit.end =
          core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)4U,
              a_as_ntt[i],
              int32_t [256U]),
            int32_t [256U]);
        core_ops_range_Range__size_t
        iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
          if (uu____1.tag == core_option_None)
            break;
          else if (uu____1.tag == core_option_Some)
          {
            size_t j = uu____1.f0;
            int32_t product[256U];
            libcrux_kyber_ntt_ntt_multiply(&a_as_ntt[i][j], &r_as_ntt[j], product);
            int32_t uu____2[256U];
            libcrux_kyber_arithmetic_add_to_ring_element___4size_t(result[i], &product, uu____2);
            memcpy(result[i], uu____2, (size_t)256U * sizeof (int32_t));
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        int32_t uu____3[256U];
        libcrux_kyber_ntt_invert_ntt_montgomery___4size_t(result[i], uu____3);
        memcpy(result[i], uu____3, (size_t)256U * sizeof (int32_t));
        core_ops_range_Range__size_t lit0;
        lit0.start = (size_t)0U;
        lit0.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
        core_ops_range_Range__size_t
        iter0 = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____4 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
          if (uu____4.tag == core_option_None)
            break;
          else if (uu____4.tag == core_option_Some)
          {
            size_t j = uu____4.f0;
            int32_t
            coefficient_normal_form =
              libcrux_kyber_arithmetic_montgomery_reduce(result[i][j] * (int32_t)1441);
            int32_t
            uu____5 =
              libcrux_kyber_arithmetic_barrett_reduce(coefficient_normal_form + error_1[i][j]);
            result[i][j] = uu____5;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____6[4U][256U];
    memcpy(uu____6, result, (size_t)4U * sizeof (int32_t [256U]));
    memcpy(ret, uu____6, (size_t)4U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_matrix_compute_ring_element_v___4size_t(
  int32_t (*t_as_ntt)[256U],
  int32_t (*r_as_ntt)[256U],
  int32_t (*error_2)[256U],
  int32_t (*message)[256U],
  int32_t ret[256U]
)
{
  int32_t result[256U];
  memcpy(result,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)4U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (uu____0.tag == core_option_None)
      break;
    else if (uu____0.tag == core_option_Some)
    {
      size_t i = uu____0.f0;
      int32_t product[256U];
      libcrux_kyber_ntt_ntt_multiply(&t_as_ntt[i], &r_as_ntt[i], product);
      libcrux_kyber_arithmetic_add_to_ring_element___4size_t(result, &product, result);
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
      KRML_HOST_EXIT(255U);
    }
  }
  libcrux_kyber_ntt_invert_ntt_montgomery___4size_t(result, result);
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter0 = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
    if (!(uu____1.tag == core_option_None))
    {
      if (uu____1.tag == core_option_Some)
      {
        size_t i = uu____1.f0;
        int32_t
        coefficient_normal_form =
          libcrux_kyber_arithmetic_montgomery_reduce(result[i] * (int32_t)1441);
        int32_t
        uu____2 =
          libcrux_kyber_arithmetic_barrett_reduce(coefficient_normal_form
            + error_2[0U][i]
            + message[0U][i]);
        result[i] = uu____2;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, result, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_serialize_compress_then_serialize_10___352size_t(
  int32_t re[256U],
  uint8_t ret[352U]
)
{
  uint8_t serialized[352U];
  uint8_t buf[352U] = { 0U };
  memcpy(serialized, buf, (size_t)352U * sizeof (uint8_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t),
      int32_t)
    / (size_t)4U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t
        coefficient1 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(10U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)4U + (size_t)0U]));
        int32_t
        coefficient2 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(10U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)4U + (size_t)1U]));
        int32_t
        coefficient3 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(10U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)4U + (size_t)2U]));
        int32_t
        coefficient4 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(10U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)4U + (size_t)3U]));
        K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
        uu____1 =
          libcrux_kyber_serialize_compress_coefficients_10(coefficient1,
            coefficient2,
            coefficient3,
            coefficient4);
        uint8_t coef1 = uu____1.fst;
        uint8_t coef2 = uu____1.snd;
        uint8_t coef3 = uu____1.thd;
        uint8_t coef4 = uu____1.f3;
        uint8_t coef5 = uu____1.f4;
        serialized[(size_t)5U * i] = coef1;
        serialized[(size_t)5U * i + (size_t)1U] = coef2;
        serialized[(size_t)5U * i + (size_t)2U] = coef3;
        serialized[(size_t)5U * i + (size_t)3U] = coef4;
        serialized[(size_t)5U * i + (size_t)4U] = coef5;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____2[352U];
    memcpy(uu____2, serialized, (size_t)352U * sizeof (uint8_t));
    memcpy(ret, uu____2, (size_t)352U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_serialize_compress_then_serialize_11___352size_t(
  int32_t re[256U],
  uint8_t ret[352U]
)
{
  uint8_t serialized[352U];
  uint8_t buf[352U] = { 0U };
  memcpy(serialized, buf, (size_t)352U * sizeof (uint8_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t),
      int32_t)
    / (size_t)8U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t
        coefficient1 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)0U]));
        int32_t
        coefficient2 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)1U]));
        int32_t
        coefficient3 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)2U]));
        int32_t
        coefficient4 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)3U]));
        int32_t
        coefficient5 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)4U]));
        int32_t
        coefficient6 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)5U]));
        int32_t
        coefficient7 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)6U]));
        int32_t
        coefficient8 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)7U]));
        K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
        uu____1 =
          libcrux_kyber_serialize_compress_coefficients_11(coefficient1,
            coefficient2,
            coefficient3,
            coefficient4,
            coefficient5,
            coefficient6,
            coefficient7,
            coefficient8);
        uint8_t coef1 = uu____1.fst;
        uint8_t coef2 = uu____1.snd;
        uint8_t coef3 = uu____1.thd;
        uint8_t coef4 = uu____1.f3;
        uint8_t coef5 = uu____1.f4;
        uint8_t coef6 = uu____1.f5;
        uint8_t coef7 = uu____1.f6;
        uint8_t coef8 = uu____1.f7;
        uint8_t coef9 = uu____1.f8;
        uint8_t coef10 = uu____1.f9;
        uint8_t coef11 = uu____1.f10;
        serialized[(size_t)11U * i] = coef1;
        serialized[(size_t)11U * i + (size_t)1U] = coef2;
        serialized[(size_t)11U * i + (size_t)2U] = coef3;
        serialized[(size_t)11U * i + (size_t)3U] = coef4;
        serialized[(size_t)11U * i + (size_t)4U] = coef5;
        serialized[(size_t)11U * i + (size_t)5U] = coef6;
        serialized[(size_t)11U * i + (size_t)6U] = coef7;
        serialized[(size_t)11U * i + (size_t)7U] = coef8;
        serialized[(size_t)11U * i + (size_t)8U] = coef9;
        serialized[(size_t)11U * i + (size_t)9U] = coef10;
        serialized[(size_t)11U * i + (size_t)10U] = coef11;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____2[352U];
    memcpy(uu____2, serialized, (size_t)352U * sizeof (uint8_t));
    memcpy(ret, uu____2, (size_t)352U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_serialize_compress_then_serialize_ring_element_u___11size_t_352size_t(
  int32_t re[256U],
  uint8_t ret[352U]
)
{
  uint8_t uu____0[352U];
  if ((size_t)11U == (size_t)10U)
    libcrux_kyber_serialize_compress_then_serialize_10___352size_t(re, uu____0);
  else if ((size_t)11U == (size_t)11U)
    libcrux_kyber_serialize_compress_then_serialize_11___352size_t(re, uu____0);
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
    KRML_HOST_EXIT(255U);
  }
  memcpy(ret, uu____0, (size_t)352U * sizeof (uint8_t));
}

void
libcrux_kyber_ind_cpa_compress_then_serialize_u___4size_t_1408size_t_11size_t_352size_t(
  int32_t input[4U][256U],
  uint8_t ret[1408U]
)
{
  uint8_t out[1408U];
  uint8_t buf[1408U] = { 0U };
  memcpy(out, buf, (size_t)1408U * sizeof (uint8_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)4U, input, int32_t [256U]),
      int32_t [256U]);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t re[256U];
        memcpy(re, input[i], (size_t)256U * sizeof (int32_t));
        core_ops_range_Range__size_t lit;
        lit.start = i * ((size_t)1408U / (size_t)4U);
        lit.end = (i + (size_t)1U) * ((size_t)1408U / (size_t)4U);
        Eurydice_slice
        uu____1 =
          Eurydice_array_to_subslice((size_t)1408U,
            out,
            lit,
            uint8_t,
            core_ops_range_Range__size_t);
        uint8_t ret[352U];
        libcrux_kyber_serialize_compress_then_serialize_ring_element_u___11size_t_352size_t(re,
          ret);
        core_slice___Slice_T___copy_from_slice(uu____1,
          Eurydice_array_to_slice((size_t)352U, ret, uint8_t),
          uint8_t);
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____2[1408U];
    memcpy(uu____2, out, (size_t)1408U * sizeof (uint8_t));
    memcpy(ret, uu____2, (size_t)1408U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_serialize_compress_then_serialize_4___160size_t(
  int32_t re[256U],
  uint8_t ret[160U]
)
{
  uint8_t serialized[160U];
  uint8_t buf[160U] = { 0U };
  memcpy(serialized, buf, (size_t)160U * sizeof (uint8_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t),
      int32_t)
    / (size_t)2U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        uint8_t
        coefficient1 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(4U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)2U + (size_t)0U]));
        uint8_t
        coefficient2 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(4U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)2U + (size_t)1U]));
        serialized[i] = (uint32_t)coefficient2 << 4U | (uint32_t)coefficient1;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____1[160U];
    memcpy(uu____1, serialized, (size_t)160U * sizeof (uint8_t));
    memcpy(ret, uu____1, (size_t)160U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_serialize_compress_then_serialize_5___160size_t(
  int32_t re[256U],
  uint8_t ret[160U]
)
{
  uint8_t serialized[160U];
  uint8_t buf[160U] = { 0U };
  memcpy(serialized, buf, (size_t)160U * sizeof (uint8_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t),
      int32_t)
    / (size_t)8U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        uint8_t
        coefficient1 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)0U]));
        uint8_t
        coefficient2 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)1U]));
        uint8_t
        coefficient3 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)2U]));
        uint8_t
        coefficient4 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)3U]));
        uint8_t
        coefficient5 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)4U]));
        uint8_t
        coefficient6 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)5U]));
        uint8_t
        coefficient7 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)6U]));
        uint8_t
        coefficient8 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)7U]));
        K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
        uu____1 =
          libcrux_kyber_serialize_compress_coefficients_5(coefficient2,
            coefficient1,
            coefficient4,
            coefficient3,
            coefficient5,
            coefficient7,
            coefficient6,
            coefficient8);
        uint8_t coef1 = uu____1.fst;
        uint8_t coef2 = uu____1.snd;
        uint8_t coef3 = uu____1.thd;
        uint8_t coef4 = uu____1.f3;
        uint8_t coef5 = uu____1.f4;
        serialized[(size_t)5U * i] = coef1;
        serialized[(size_t)5U * i + (size_t)1U] = coef2;
        serialized[(size_t)5U * i + (size_t)2U] = coef3;
        serialized[(size_t)5U * i + (size_t)3U] = coef4;
        serialized[(size_t)5U * i + (size_t)4U] = coef5;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____2[160U];
    memcpy(uu____2, serialized, (size_t)160U * sizeof (uint8_t));
    memcpy(ret, uu____2, (size_t)160U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_serialize_compress_then_serialize_ring_element_v___5size_t_160size_t(
  int32_t re[256U],
  uint8_t ret[160U]
)
{
  uint8_t uu____0[160U];
  if ((size_t)5U == (size_t)4U)
    libcrux_kyber_serialize_compress_then_serialize_4___160size_t(re, uu____0);
  else if ((size_t)5U == (size_t)5U)
    libcrux_kyber_serialize_compress_then_serialize_5___160size_t(re, uu____0);
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
    KRML_HOST_EXIT(255U);
  }
  memcpy(ret, uu____0, (size_t)160U * sizeof (uint8_t));
}

void
libcrux_kyber_ind_cpa_into_padded_array___1568size_t(Eurydice_slice slice, uint8_t ret[1568U])
{
  if (false)
    LowStar_Ignore_ignore(core_slice___Slice_T___len(slice, uint8_t), size_t);
  uint8_t out[1568U];
  uint8_t buf[1568U] = { 0U };
  memcpy(out, buf, (size_t)1568U * sizeof (uint8_t));
  uint8_t *uu____0 = out;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(slice, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)1568U,
      uu____0,
      lit,
      uint8_t,
      core_ops_range_Range__size_t),
    slice,
    uint8_t);
  uint8_t uu____1[1568U];
  memcpy(uu____1, out, (size_t)1568U * sizeof (uint8_t));
  memcpy(ret, uu____1, (size_t)1568U * sizeof (uint8_t));
}

K___uint8_t_1568size_t__core_option_Option__libcrux_kyber_types_Error
libcrux_kyber_ind_cpa_encrypt___4size_t_1568size_t_1536size_t_1408size_t_160size_t_11size_t_5size_t_352size_t_2size_t_128size_t_2size_t_128size_t(
  Eurydice_slice public_key,
  uint8_t message[32U],
  Eurydice_slice randomness
)
{
  int32_t t_as_ntt[4U][256U];
  libcrux_kyber_ind_cpa_deserialize_public_key___4size_t_1536size_t(public_key, t_as_ntt);
  Eurydice_slice seed = Eurydice_slice_subslice_from(public_key, (size_t)1536U, uint8_t, size_t);
  uint8_t ret[34U];
  libcrux_kyber_ind_cpa_into_padded_array___34size_t(seed, ret);
  K___libcrux_kyber_arithmetic_PolynomialRingElement_4size_t__4size_t__core_option_Option__libcrux_kyber_types_Error
  uu____0 = libcrux_kyber_matrix_sample_matrix_A___4size_t(ret, false);
  int32_t A_transpose[4U][4U][256U];
  int32_t uu____1[4U][4U][256U];
  memcpy(uu____1, uu____0.fst, (size_t)4U * sizeof (int32_t [4U][256U]));
  memcpy(A_transpose, uu____1, (size_t)4U * sizeof (int32_t [4U][256U]));
  core_option_Option__libcrux_kyber_types_Error sampling_A_error = uu____0.snd;
  uint8_t prf_input[33U];
  libcrux_kyber_ind_cpa_into_padded_array___33size_t(randomness, prf_input);
  uint8_t uu____2[33U];
  memcpy(uu____2, prf_input, (size_t)33U * sizeof (uint8_t));
  K___libcrux_kyber_arithmetic_PolynomialRingElement_4size_t__uint8_t
  uu____3 =
    libcrux_kyber_ind_cpa_sample_vector_cbd_then_ntt___4size_t_2size_t_128size_t(uu____2,
      0U);
  int32_t r_as_ntt[4U][256U];
  int32_t uu____4[4U][256U];
  memcpy(uu____4, uu____3.fst, (size_t)4U * sizeof (int32_t [256U]));
  memcpy(r_as_ntt, uu____4, (size_t)4U * sizeof (int32_t [256U]));
  uint8_t domain_separator = uu____3.snd;
  int32_t error_1[4U][256U];
  libcrux_kyber_ind_cpa_sample_ring_element_cbd___4size_t_128size_t_2size_t(prf_input,
    &domain_separator,
    error_1);
  prf_input[32U] = domain_separator;
  uint8_t prf_output[128U];
  libcrux_kyber_hash_functions_PRF___128size_t(Eurydice_array_to_slice((size_t)33U,
      prf_input,
      uint8_t),
    prf_output);
  int32_t error_2[256U];
  libcrux_kyber_sampling_sample_from_binomial_distribution___2size_t(Eurydice_array_to_slice((size_t)128U,
      prf_output,
      uint8_t),
    error_2);
  int32_t u[4U][256U];
  libcrux_kyber_matrix_compute_vector_u___4size_t(A_transpose, r_as_ntt, error_1, u);
  uint8_t uu____5[32U];
  memcpy(uu____5, message, (size_t)32U * sizeof (uint8_t));
  int32_t message_as_ring_element[256U];
  libcrux_kyber_serialize_deserialize_then_decompress_message(uu____5, message_as_ring_element);
  int32_t v[256U];
  libcrux_kyber_matrix_compute_ring_element_v___4size_t(t_as_ntt,
    r_as_ntt,
    &error_2,
    &message_as_ring_element,
    v);
  int32_t uu____6[4U][256U];
  memcpy(uu____6, u, (size_t)4U * sizeof (int32_t [256U]));
  uint8_t c1[1408U];
  libcrux_kyber_ind_cpa_compress_then_serialize_u___4size_t_1408size_t_11size_t_352size_t(uu____6,
    c1);
  uint8_t c2[160U];
  libcrux_kyber_serialize_compress_then_serialize_ring_element_v___5size_t_160size_t(v, c2);
  uint8_t ciphertext[1568U];
  libcrux_kyber_ind_cpa_into_padded_array___1568size_t(Eurydice_array_to_slice((size_t)1408U,
      c1,
      uint8_t),
    ciphertext);
  Eurydice_slice
  uu____7 =
    Eurydice_array_to_subslice_from((size_t)1568U,
      ciphertext,
      (size_t)1408U,
      uint8_t,
      size_t);
  core_slice___Slice_T___copy_from_slice(uu____7,
    core_array___Array_T__N__23__as_slice((size_t)160U, c2, uint8_t),
    uint8_t);
  uint8_t uu____8[1568U];
  memcpy(uu____8, ciphertext, (size_t)1568U * sizeof (uint8_t));
  K___uint8_t_1568size_t__core_option_Option__libcrux_kyber_types_Error lit;
  memcpy(lit.fst, uu____8, (size_t)1568U * sizeof (uint8_t));
  lit.snd = sampling_A_error;
  return lit;
}

core_result_Result__libcrux_kyber_types_KyberCiphertext___1568size_t___uint8_t_32size_t__libcrux_kyber_types_Error
libcrux_kyber_encapsulate___4size_t_1568size_t_1568size_t_1536size_t_1408size_t_160size_t_11size_t_5size_t_352size_t_2size_t_128size_t_2size_t_128size_t(
  uint8_t (*public_key)[1568U],
  uint8_t randomness[32U]
)
{
  uint8_t to_hash[64U];
  libcrux_kyber_ind_cpa_into_padded_array___64size_t(Eurydice_array_to_slice((size_t)32U,
      randomness,
      uint8_t),
    to_hash);
  Eurydice_slice
  uu____0 =
    Eurydice_array_to_subslice_from((size_t)64U,
      to_hash,
      libcrux_kyber_constants_H_DIGEST_SIZE,
      uint8_t,
      size_t);
  uint8_t ret[32U];
  libcrux_kyber_hash_functions_H(Eurydice_array_to_slice((size_t)1568U,
      libcrux_kyber_types__libcrux_kyber__types__KyberPublicKey_SIZE__18__as_slice___1568size_t(public_key),
      uint8_t),
    ret);
  core_slice___Slice_T___copy_from_slice(uu____0,
    Eurydice_array_to_slice((size_t)32U, ret, uint8_t),
    uint8_t);
  uint8_t hashed[64U];
  libcrux_kyber_hash_functions_G(Eurydice_array_to_slice((size_t)64U, to_hash, uint8_t), hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____1 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U, hashed, uint8_t),
      libcrux_kyber_constants_SHARED_SECRET_SIZE,
      uint8_t);
  Eurydice_slice shared_secret = uu____1.fst;
  Eurydice_slice pseudorandomness = uu____1.snd;
  Eurydice_slice
  uu____2 =
    Eurydice_array_to_slice((size_t)1568U,
      libcrux_kyber_types__libcrux_kyber__types__KyberPublicKey_SIZE__18__as_slice___1568size_t(public_key),
      uint8_t);
  uint8_t uu____3[32U];
  memcpy(uu____3, randomness, (size_t)32U * sizeof (uint8_t));
  K___uint8_t_1568size_t__core_option_Option__libcrux_kyber_types_Error
  uu____4 =
    libcrux_kyber_ind_cpa_encrypt___4size_t_1568size_t_1536size_t_1408size_t_160size_t_11size_t_5size_t_352size_t_2size_t_128size_t_2size_t_128size_t(uu____2,
      uu____3,
      pseudorandomness);
  uint8_t ciphertext[1568U];
  uint8_t uu____5[1568U];
  memcpy(uu____5, uu____4.fst, (size_t)1568U * sizeof (uint8_t));
  memcpy(ciphertext, uu____5, (size_t)1568U * sizeof (uint8_t));
  core_option_Option__libcrux_kyber_types_Error sampling_a_error = uu____4.snd;
  core_result_Result__libcrux_kyber_types_KyberCiphertext___1568size_t___uint8_t_32size_t__libcrux_kyber_types_Error
  uu____6;
  if (sampling_a_error.tag == core_option_None)
  {
    uint8_t uu____7[1568U];
    memcpy(uu____7, ciphertext, (size_t)1568U * sizeof (uint8_t));
    uint8_t uu____8[1568U];
    memcpy(uu____8, uu____7, (size_t)1568U * sizeof (uint8_t));
    core_result_Result__uint8_t_32size_t__core_array_TryFromSliceError
    uu____9 = Eurydice_slice_to_array(shared_secret, Eurydice_slice, uint8_t [32U]);
    if (uu____9.tag == core_result_Ok)
    {
      uint8_t r[32U];
      uint8_t f0[32U];
      memcpy(f0, uu____9.val.case_Ok, (size_t)32U * sizeof (uint8_t));
      memcpy(r, f0, (size_t)32U * sizeof (uint8_t));
      uint8_t uu____10[32U];
      memcpy(uu____10, r, (size_t)32U * sizeof (uint8_t));
      core_result_Result__libcrux_kyber_types_KyberCiphertext___1568size_t___uint8_t_32size_t__libcrux_kyber_types_Error
      lit;
      lit.tag = core_result_Ok;
      memcpy(lit.val.case_Ok.fst, uu____8, (size_t)1568U * sizeof (uint8_t));
      memcpy(lit.val.case_Ok.snd, uu____10, (size_t)32U * sizeof (uint8_t));
      uu____6 = lit;
    }
    else if (uu____9.tag == core_result_Err)
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
      KRML_HOST_EXIT(255U);
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
      KRML_HOST_EXIT(255U);
    }
  }
  else if (sampling_a_error.tag == core_option_Some)
  {
    libcrux_kyber_types_Error e = sampling_a_error.f0;
    core_result_Result__libcrux_kyber_types_KyberCiphertext___1568size_t___uint8_t_32size_t__libcrux_kyber_types_Error
    lit;
    lit.tag = core_result_Err;
    lit.val.case_Err = e;
    uu____6 = lit;
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
    KRML_HOST_EXIT(255U);
  }
  return uu____6;
}

core_result_Result__libcrux_kyber_types_KyberCiphertext___1568size_t___uint8_t_32size_t__libcrux_kyber_types_Error
libcrux_kyber_kyber1024_encapsulate_1024(uint8_t (*public_key)[1568U], uint8_t randomness[32U])
{
  uint8_t (*uu____0)[1568U] = public_key;
  uint8_t uu____1[32U];
  memcpy(uu____1, randomness, (size_t)32U * sizeof (uint8_t));
  return
    libcrux_kyber_encapsulate___4size_t_1568size_t_1568size_t_1536size_t_1408size_t_160size_t_11size_t_5size_t_352size_t_2size_t_128size_t_2size_t_128size_t(uu____0,
      uu____1);
}

K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
libcrux_kyber_types__libcrux_kyber__types__KyberPrivateKey_SIZE__12__split_at___3168size_t(
  uint8_t (*self)[3168U],
  size_t mid
)
{
  return
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)3168U, self[0U], uint8_t),
      mid,
      uint8_t);
}

void
libcrux_kyber_serialize_deserialize_then_decompress_ring_element_u___11size_t(
  Eurydice_slice serialized,
  int32_t ret[256U]
)
{
  int32_t uu____0[256U];
  if ((size_t)11U == (size_t)10U)
    libcrux_kyber_serialize_deserialize_then_decompress_10(serialized, uu____0);
  else if ((size_t)11U == (size_t)11U)
    libcrux_kyber_serialize_deserialize_then_decompress_11(serialized, uu____0);
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
    KRML_HOST_EXIT(255U);
  }
  memcpy(ret, uu____0, (size_t)256U * sizeof (int32_t));
}

void libcrux_kyber_ntt_ntt_vector_u___11size_t(int32_t re[256U], int32_t ret[256U])
{
  size_t zeta_i = (size_t)0U;
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)7U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)6U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)5U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)4U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)3U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)2U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)1U, re);
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t uu____1 = libcrux_kyber_arithmetic_barrett_reduce(re[i]);
        re[i] = uu____1;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, re, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_ind_cpa_deserialize_then_decompress_u___4size_t_1568size_t_1408size_t_11size_t(
  uint8_t *ciphertext,
  int32_t ret[4U][256U]
)
{
  int32_t u_as_ntt[4U][256U];
  int32_t
  buf[4U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  memcpy(u_as_ntt, buf, (size_t)4U * sizeof (int32_t [256U]));
  size_t
  chunk_size = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT * (size_t)11U / (size_t)8U;
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = (size_t)1408U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        core_ops_range_Range__size_t lit;
        lit.start = i * chunk_size;
        lit.end = i * (chunk_size + (size_t)1U);
        Eurydice_slice
        u_bytes =
          Eurydice_array_to_subslice((size_t)1568U,
            ciphertext,
            lit,
            uint8_t,
            core_ops_range_Range__size_t);
        int32_t u[256U];
        libcrux_kyber_serialize_deserialize_then_decompress_ring_element_u___11size_t(u_bytes, u);
        int32_t uu____1[256U];
        libcrux_kyber_ntt_ntt_vector_u___11size_t(u, uu____1);
        memcpy(u_as_ntt[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[4U][256U];
    memcpy(uu____2, u_as_ntt, (size_t)4U * sizeof (int32_t [256U]));
    memcpy(ret, uu____2, (size_t)4U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_serialize_deserialize_then_decompress_ring_element_v___5size_t(
  Eurydice_slice serialized,
  int32_t ret[256U]
)
{
  int32_t uu____0[256U];
  if ((size_t)5U == (size_t)4U)
    libcrux_kyber_serialize_deserialize_then_decompress_4(serialized, uu____0);
  else if ((size_t)5U == (size_t)5U)
    libcrux_kyber_serialize_deserialize_then_decompress_5(serialized, uu____0);
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
    KRML_HOST_EXIT(255U);
  }
  memcpy(ret, uu____0, (size_t)256U * sizeof (int32_t));
}

void
libcrux_kyber_ind_cpa_deserialize_secret_key___4size_t(
  Eurydice_slice secret_key,
  int32_t ret[4U][256U]
)
{
  int32_t secret_as_ntt[4U][256U];
  int32_t
  buf[4U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  memcpy(secret_as_ntt, buf, (size_t)4U * sizeof (int32_t [256U]));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(secret_key,
      uint8_t)
    / libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t uu____1[256U];
        core_ops_range_Range__size_t lit;
        lit.start = i * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        lit.end =
          i
          * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT
          + libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        libcrux_kyber_serialize_deserialize_to_uncompressed_ring_element(Eurydice_slice_subslice(secret_key,
            lit,
            uint8_t,
            core_ops_range_Range__size_t),
          uu____1);
        memcpy(secret_as_ntt[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[4U][256U];
    memcpy(uu____2, secret_as_ntt, (size_t)4U * sizeof (int32_t [256U]));
    memcpy(ret, uu____2, (size_t)4U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_matrix_compute_message___4size_t(
  int32_t (*v)[256U],
  int32_t (*secret_as_ntt)[256U],
  int32_t (*u_as_ntt)[256U],
  int32_t ret[256U]
)
{
  int32_t result[256U];
  memcpy(result,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)4U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (uu____0.tag == core_option_None)
      break;
    else if (uu____0.tag == core_option_Some)
    {
      size_t i = uu____0.f0;
      int32_t product[256U];
      libcrux_kyber_ntt_ntt_multiply(&secret_as_ntt[i], &u_as_ntt[i], product);
      libcrux_kyber_arithmetic_add_to_ring_element___4size_t(result, &product, result);
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
      KRML_HOST_EXIT(255U);
    }
  }
  libcrux_kyber_ntt_invert_ntt_montgomery___4size_t(result, result);
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter0 = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
    if (!(uu____1.tag == core_option_None))
    {
      if (uu____1.tag == core_option_Some)
      {
        size_t i = uu____1.f0;
        int32_t
        coefficient_normal_form =
          libcrux_kyber_arithmetic_montgomery_reduce(result[i] * (int32_t)1441);
        int32_t
        uu____2 = libcrux_kyber_arithmetic_barrett_reduce(v[0U][i] - coefficient_normal_form);
        result[i] = uu____2;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, result, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_ind_cpa_decrypt___4size_t_1568size_t_1408size_t_11size_t_5size_t(
  Eurydice_slice secret_key,
  uint8_t *ciphertext,
  uint8_t ret[32U]
)
{
  int32_t u_as_ntt[4U][256U];
  libcrux_kyber_ind_cpa_deserialize_then_decompress_u___4size_t_1568size_t_1408size_t_11size_t(ciphertext,
    u_as_ntt);
  int32_t v[256U];
  libcrux_kyber_serialize_deserialize_then_decompress_ring_element_v___5size_t(Eurydice_array_to_subslice_from((size_t)1568U,
      ciphertext,
      (size_t)1408U,
      uint8_t,
      size_t),
    v);
  int32_t secret_as_ntt[4U][256U];
  libcrux_kyber_ind_cpa_deserialize_secret_key___4size_t(secret_key, secret_as_ntt);
  int32_t message[256U];
  libcrux_kyber_matrix_compute_message___4size_t(&v, secret_as_ntt, u_as_ntt, message);
  uint8_t ret0[32U];
  libcrux_kyber_serialize_compress_then_serialize_message(message, ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

void
libcrux_kyber_ind_cpa_into_padded_array___1600size_t(Eurydice_slice slice, uint8_t ret[1600U])
{
  if (false)
    LowStar_Ignore_ignore(core_slice___Slice_T___len(slice, uint8_t), size_t);
  uint8_t out[1600U];
  uint8_t buf[1600U] = { 0U };
  memcpy(out, buf, (size_t)1600U * sizeof (uint8_t));
  uint8_t *uu____0 = out;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(slice, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)1600U,
      uu____0,
      lit,
      uint8_t,
      core_ops_range_Range__size_t),
    slice,
    uint8_t);
  uint8_t uu____1[1600U];
  memcpy(uu____1, out, (size_t)1600U * sizeof (uint8_t));
  memcpy(ret, uu____1, (size_t)1600U * sizeof (uint8_t));
}

Eurydice_slice
libcrux_kyber_types__libcrux_kyber__types__KyberCiphertext_SIZE__1__as_ref___1568size_t(
  uint8_t (*self)[1568U]
)
{
  return Eurydice_array_to_slice((size_t)1568U, self[0U], uint8_t);
}

void libcrux_kyber_hash_functions_PRF___32size_t(Eurydice_slice input, uint8_t ret[32U])
{
  uint8_t ret0[32U];
  libcrux_digest_shake256((size_t)32U, input, ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

uint8_t
libcrux_kyber_constant_time_ops_compare_ciphertexts_in_constant_time___1568size_t(
  Eurydice_slice lhs,
  Eurydice_slice rhs
)
{
  uint8_t r = 0U;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)1568U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        uint8_t uu____1 = Eurydice_slice_index(lhs, i, uint8_t);
        r = (uint32_t)r | ((uint32_t)uu____1 ^ (uint32_t)Eurydice_slice_index(rhs, i, uint8_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    return libcrux_kyber_constant_time_ops_is_non_zero(r);
  }
}

void
libcrux_kyber_decapsulate___4size_t_3168size_t_1536size_t_1568size_t_1568size_t_1536size_t_1408size_t_160size_t_11size_t_5size_t_352size_t_2size_t_128size_t_2size_t_128size_t_1600size_t(
  uint8_t (*secret_key)[3168U],
  uint8_t (*ciphertext)[1568U],
  uint8_t ret[32U]
)
{
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____0 =
    libcrux_kyber_types__libcrux_kyber__types__KyberPrivateKey_SIZE__12__split_at___3168size_t(secret_key,
      (size_t)1536U);
  Eurydice_slice ind_cpa_secret_key = uu____0.fst;
  Eurydice_slice secret_key0 = uu____0.snd;
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____1 = core_slice___Slice_T___split_at(secret_key0, (size_t)1568U, uint8_t);
  Eurydice_slice ind_cpa_public_key = uu____1.fst;
  Eurydice_slice secret_key1 = uu____1.snd;
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____2 =
    core_slice___Slice_T___split_at(secret_key1,
      libcrux_kyber_constants_H_DIGEST_SIZE,
      uint8_t);
  Eurydice_slice ind_cpa_public_key_hash = uu____2.fst;
  Eurydice_slice implicit_rejection_value = uu____2.snd;
  uint8_t decrypted[32U];
  libcrux_kyber_ind_cpa_decrypt___4size_t_1568size_t_1408size_t_11size_t_5size_t(ind_cpa_secret_key,
    ciphertext[0U],
    decrypted);
  uint8_t to_hash0[64U];
  libcrux_kyber_ind_cpa_into_padded_array___64size_t(Eurydice_array_to_slice((size_t)32U,
      decrypted,
      uint8_t),
    to_hash0);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice_from((size_t)64U,
      to_hash0,
      libcrux_kyber_constants_SHARED_SECRET_SIZE,
      uint8_t,
      size_t),
    ind_cpa_public_key_hash,
    uint8_t);
  uint8_t hashed[64U];
  libcrux_kyber_hash_functions_G(Eurydice_array_to_slice((size_t)64U, to_hash0, uint8_t),
    hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____3 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U, hashed, uint8_t),
      libcrux_kyber_constants_SHARED_SECRET_SIZE,
      uint8_t);
  Eurydice_slice shared_secret = uu____3.fst;
  Eurydice_slice pseudorandomness = uu____3.snd;
  uint8_t to_hash[1600U];
  libcrux_kyber_ind_cpa_into_padded_array___1600size_t(implicit_rejection_value, to_hash);
  Eurydice_slice
  uu____4 =
    Eurydice_array_to_subslice_from((size_t)1600U,
      to_hash,
      libcrux_kyber_constants_SHARED_SECRET_SIZE,
      uint8_t,
      size_t);
  core_slice___Slice_T___copy_from_slice(uu____4,
    libcrux_kyber_types__libcrux_kyber__types__KyberCiphertext_SIZE__1__as_ref___1568size_t(ciphertext),
    uint8_t);
  uint8_t implicit_rejection_shared_secret[32U];
  libcrux_kyber_hash_functions_PRF___32size_t(Eurydice_array_to_slice((size_t)1600U,
      to_hash,
      uint8_t),
    implicit_rejection_shared_secret);
  Eurydice_slice uu____5 = ind_cpa_public_key;
  uint8_t uu____6[32U];
  memcpy(uu____6, decrypted, (size_t)32U * sizeof (uint8_t));
  uint8_t expected_ciphertext[1568U];
  uint8_t uu____7[1568U];
  memcpy(uu____7,
    libcrux_kyber_ind_cpa_encrypt___4size_t_1568size_t_1536size_t_1408size_t_160size_t_11size_t_5size_t_352size_t_2size_t_128size_t_2size_t_128size_t(uu____5,
      uu____6,
      pseudorandomness).fst,
    (size_t)1568U * sizeof (uint8_t));
  memcpy(expected_ciphertext, uu____7, (size_t)1568U * sizeof (uint8_t));
  Eurydice_slice
  uu____8 =
    libcrux_kyber_types__libcrux_kyber__types__KyberCiphertext_SIZE__1__as_ref___1568size_t(ciphertext);
  uint8_t
  selector =
    libcrux_kyber_constant_time_ops_compare_ciphertexts_in_constant_time___1568size_t(uu____8,
      Eurydice_array_to_slice((size_t)1568U, expected_ciphertext, uint8_t));
  Eurydice_slice uu____9 = shared_secret;
  uint8_t ret0[32U];
  libcrux_kyber_constant_time_ops_select_shared_secret_in_constant_time(uu____9,
    Eurydice_array_to_slice((size_t)32U, implicit_rejection_shared_secret, uint8_t),
    selector,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

void
libcrux_kyber_kyber1024_decapsulate_1024(
  uint8_t (*secret_key)[3168U],
  uint8_t (*ciphertext)[1568U],
  uint8_t ret[32U]
)
{
  uint8_t ret0[32U];
  libcrux_kyber_decapsulate___4size_t_3168size_t_1536size_t_1568size_t_1568size_t_1536size_t_1408size_t_160size_t_11size_t_5size_t_352size_t_2size_t_128size_t_2size_t_128size_t_1600size_t(secret_key,
    ciphertext,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

const size_t libcrux_kyber_kyber512_RANK_512 = (size_t)2U;

const
size_t
libcrux_kyber_kyber512_RANKED_BYTES_PER_RING_ELEMENT_512 =
  libcrux_kyber_kyber512_RANK_512
  * libcrux_kyber_constants_BITS_PER_RING_ELEMENT
  / (size_t)8U;

const
size_t
libcrux_kyber_kyber512_T_AS_NTT_ENCODED_SIZE_512 =
  libcrux_kyber_kyber512_RANK_512
  * libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT
  * libcrux_kyber_constants_BITS_PER_COEFFICIENT
  / (size_t)8U;

const size_t libcrux_kyber_kyber512_VECTOR_U_COMPRESSION_FACTOR_512 = (size_t)10U;

const
size_t
libcrux_kyber_kyber512_C1_BLOCK_SIZE_512 =
  libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT
  * libcrux_kyber_kyber512_VECTOR_U_COMPRESSION_FACTOR_512
  / (size_t)8U;

const
size_t
libcrux_kyber_kyber512_C1_SIZE_512 =
  libcrux_kyber_kyber512_C1_BLOCK_SIZE_512
  * libcrux_kyber_kyber512_RANK_512;

const size_t libcrux_kyber_kyber512_VECTOR_V_COMPRESSION_FACTOR_512 = (size_t)4U;

const
size_t
libcrux_kyber_kyber512_C2_SIZE_512 =
  libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT
  * libcrux_kyber_kyber512_VECTOR_V_COMPRESSION_FACTOR_512
  / (size_t)8U;

const
size_t
libcrux_kyber_kyber512_CPA_PKE_SECRET_KEY_SIZE_512 =
  libcrux_kyber_kyber512_RANK_512
  * libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT
  * libcrux_kyber_constants_BITS_PER_COEFFICIENT
  / (size_t)8U;

const
size_t
libcrux_kyber_kyber512_CPA_PKE_PUBLIC_KEY_SIZE_512 =
  libcrux_kyber_kyber512_T_AS_NTT_ENCODED_SIZE_512
  + (size_t)32U;

const
size_t
libcrux_kyber_kyber512_CPA_PKE_CIPHERTEXT_SIZE_512 =
  libcrux_kyber_kyber512_C1_SIZE_512
  + libcrux_kyber_kyber512_C2_SIZE_512;

const
size_t
libcrux_kyber_kyber512_SECRET_KEY_SIZE_512 =
  libcrux_kyber_kyber512_CPA_PKE_SECRET_KEY_SIZE_512
  + libcrux_kyber_kyber512_CPA_PKE_PUBLIC_KEY_SIZE_512
  + libcrux_kyber_constants_H_DIGEST_SIZE
  + libcrux_kyber_constants_SHARED_SECRET_SIZE;

const size_t libcrux_kyber_kyber512_ETA1 = (size_t)3U;

const
size_t
libcrux_kyber_kyber512_ETA1_RANDOMNESS_SIZE = libcrux_kyber_kyber512_ETA1 * (size_t)64U;

const size_t libcrux_kyber_kyber512_ETA2 = (size_t)2U;

const
size_t
libcrux_kyber_kyber512_ETA2_RANDOMNESS_SIZE = libcrux_kyber_kyber512_ETA2 * (size_t)64U;

const
size_t
libcrux_kyber_kyber512_IMPLICIT_REJECTION_HASH_INPUT_SIZE =
  libcrux_kyber_constants_SHARED_SECRET_SIZE
  + libcrux_kyber_kyber512_CPA_PKE_CIPHERTEXT_SIZE_512;

void
libcrux_kyber_hash_functions_XOFx4___2size_t(uint8_t input[2U][34U], uint8_t ret[2U][840U])
{
  uint8_t out[2U][840U];
  uint8_t buf0[840U] = { 0U };
  uint8_t buf[840U] = { 0U };
  uint8_t buf1[2U][840U] = { buf0, buf };
  memcpy(out, buf1, (size_t)2U * sizeof (uint8_t [840U]));
  bool uu____0;
  if (!libcrux_platform_simd256_support())
    uu____0 = true;
  else
    uu____0 = !false;
  if (uu____0)
  {
    core_ops_range_Range__size_t lit;
    lit.start = (size_t)0U;
    lit.end = (size_t)2U;
    core_ops_range_Range__size_t
    iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
    while (true)
    {
      core_option_Option__size_t
      uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
      if (!(uu____1.tag == core_option_None))
      {
        if (uu____1.tag == core_option_Some)
        {
          size_t i = uu____1.f0;
          uint8_t uu____2[840U];
          libcrux_digest_shake128((size_t)840U,
            Eurydice_array_to_slice((size_t)34U, input[i], uint8_t),
            uu____2);
          out[i] = uu____2;
        }
        else
        {
          KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
          KRML_HOST_EXIT(255U);
        }
      }
    }
  }
  else if ((size_t)2U == (size_t)2U)
  {
    Eurydice_slice uu____3 = Eurydice_array_to_slice((size_t)34U, input[0U], uint8_t);
    Eurydice_slice uu____4 = Eurydice_array_to_slice((size_t)34U, input[1U], uint8_t);
    Eurydice_slice uu____5 = Eurydice_array_to_slice((size_t)34U, input[0U], uint8_t);
    __uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t_
    uu____6 =
      libcrux_digest_shake128x4((size_t)840U,
        uu____3,
        uu____4,
        uu____5,
        Eurydice_array_to_slice((size_t)34U, input[1U], uint8_t));
    uint8_t d0[840U];
    uint8_t uu____7[840U];
    memcpy(uu____7, uu____6.fst, (size_t)840U * sizeof (uint8_t));
    memcpy(d0, uu____7, (size_t)840U * sizeof (uint8_t));
    uint8_t d1[840U];
    uint8_t uu____8[840U];
    memcpy(uu____8, uu____6.snd, (size_t)840U * sizeof (uint8_t));
    memcpy(d1, uu____8, (size_t)840U * sizeof (uint8_t));
    uint8_t uu____9[840U];
    memcpy(uu____9, d0, (size_t)840U * sizeof (uint8_t));
    out[0U] = uu____9;
    uint8_t uu____10[840U];
    memcpy(uu____10, d1, (size_t)840U * sizeof (uint8_t));
    out[1U] = uu____10;
  }
  else if ((size_t)2U == (size_t)3U)
  {
    Eurydice_slice uu____11 = Eurydice_array_to_slice((size_t)34U, input[0U], uint8_t);
    Eurydice_slice uu____12 = Eurydice_array_to_slice((size_t)34U, input[1U], uint8_t);
    Eurydice_slice uu____13 = Eurydice_array_to_slice((size_t)34U, input[2U], uint8_t);
    __uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t_
    uu____14 =
      libcrux_digest_shake128x4((size_t)840U,
        uu____11,
        uu____12,
        uu____13,
        Eurydice_array_to_slice((size_t)34U, input[0U], uint8_t));
    uint8_t d0[840U];
    uint8_t uu____15[840U];
    memcpy(uu____15, uu____14.fst, (size_t)840U * sizeof (uint8_t));
    memcpy(d0, uu____15, (size_t)840U * sizeof (uint8_t));
    uint8_t d1[840U];
    uint8_t uu____16[840U];
    memcpy(uu____16, uu____14.snd, (size_t)840U * sizeof (uint8_t));
    memcpy(d1, uu____16, (size_t)840U * sizeof (uint8_t));
    uint8_t d2[840U];
    uint8_t uu____17[840U];
    memcpy(uu____17, uu____14.thd, (size_t)840U * sizeof (uint8_t));
    memcpy(d2, uu____17, (size_t)840U * sizeof (uint8_t));
    uint8_t uu____18[840U];
    memcpy(uu____18, d0, (size_t)840U * sizeof (uint8_t));
    out[0U] = uu____18;
    uint8_t uu____19[840U];
    memcpy(uu____19, d1, (size_t)840U * sizeof (uint8_t));
    out[1U] = uu____19;
    uint8_t uu____20[840U];
    memcpy(uu____20, d2, (size_t)840U * sizeof (uint8_t));
    out[2U] = uu____20;
  }
  else if ((size_t)2U == (size_t)4U)
  {
    Eurydice_slice uu____21 = Eurydice_array_to_slice((size_t)34U, input[0U], uint8_t);
    Eurydice_slice uu____22 = Eurydice_array_to_slice((size_t)34U, input[1U], uint8_t);
    Eurydice_slice uu____23 = Eurydice_array_to_slice((size_t)34U, input[2U], uint8_t);
    __uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t_
    uu____24 =
      libcrux_digest_shake128x4((size_t)840U,
        uu____21,
        uu____22,
        uu____23,
        Eurydice_array_to_slice((size_t)34U, input[3U], uint8_t));
    uint8_t d0[840U];
    uint8_t uu____25[840U];
    memcpy(uu____25, uu____24.fst, (size_t)840U * sizeof (uint8_t));
    memcpy(d0, uu____25, (size_t)840U * sizeof (uint8_t));
    uint8_t d1[840U];
    uint8_t uu____26[840U];
    memcpy(uu____26, uu____24.snd, (size_t)840U * sizeof (uint8_t));
    memcpy(d1, uu____26, (size_t)840U * sizeof (uint8_t));
    uint8_t d2[840U];
    uint8_t uu____27[840U];
    memcpy(uu____27, uu____24.thd, (size_t)840U * sizeof (uint8_t));
    memcpy(d2, uu____27, (size_t)840U * sizeof (uint8_t));
    uint8_t d3[840U];
    uint8_t uu____28[840U];
    memcpy(uu____28, uu____24.f3, (size_t)840U * sizeof (uint8_t));
    memcpy(d3, uu____28, (size_t)840U * sizeof (uint8_t));
    uint8_t uu____29[840U];
    memcpy(uu____29, d0, (size_t)840U * sizeof (uint8_t));
    out[0U] = uu____29;
    uint8_t uu____30[840U];
    memcpy(uu____30, d1, (size_t)840U * sizeof (uint8_t));
    out[1U] = uu____30;
    uint8_t uu____31[840U];
    memcpy(uu____31, d2, (size_t)840U * sizeof (uint8_t));
    out[2U] = uu____31;
    uint8_t uu____32[840U];
    memcpy(uu____32, d3, (size_t)840U * sizeof (uint8_t));
    out[3U] = uu____32;
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
    KRML_HOST_EXIT(255U);
  }
  uint8_t uu____33[2U][840U];
  memcpy(uu____33, out, (size_t)2U * sizeof (uint8_t [840U]));
  memcpy(ret, uu____33, (size_t)2U * sizeof (uint8_t [840U]));
}

K___libcrux_kyber_arithmetic_PolynomialRingElement_2size_t__2size_t__core_option_Option__libcrux_kyber_types_Error
libcrux_kyber_matrix_sample_matrix_A___2size_t(uint8_t seed[34U], bool transpose)
{
  int32_t A_transpose[2U][2U][256U];
  int32_t
  buf0[2U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  int32_t
  buf1[2U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  int32_t buf2[2U][2U][256U] = { buf0, buf1 };
  memcpy(A_transpose, buf2, (size_t)2U * sizeof (int32_t [2U][256U]));
  core_option_Option__libcrux_kyber_types_Error sampling_A_error;
  sampling_A_error.tag = core_option_None;
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = (size_t)2U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        uint8_t uu____1[34U];
        memcpy(uu____1, seed, (size_t)34U * sizeof (uint8_t));
        uint8_t seeds[2U][34U];
        uint8_t buf[2U][34U] = { uu____1, uu____1 };
        memcpy(seeds, buf, (size_t)2U * sizeof (uint8_t [34U]));
        core_ops_range_Range__size_t lit0;
        lit0.start = (size_t)0U;
        lit0.end = (size_t)2U;
        core_ops_range_Range__size_t
        iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____2 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
          if (uu____2.tag == core_option_None)
            break;
          else if (uu____2.tag == core_option_Some)
          {
            size_t j = uu____2.f0;
            seeds[j][32U] = (uint8_t)i;
            seeds[j][33U] = (uint8_t)j;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        uint8_t uu____3[2U][34U];
        memcpy(uu____3, seeds, (size_t)2U * sizeof (uint8_t [34U]));
        uint8_t xof_bytes[2U][840U];
        libcrux_kyber_hash_functions_XOFx4___2size_t(uu____3, xof_bytes);
        core_ops_range_Range__size_t lit;
        lit.start = (size_t)0U;
        lit.end = (size_t)2U;
        core_ops_range_Range__size_t
        iter0 = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____4 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
          if (uu____4.tag == core_option_None)
            break;
          else if (uu____4.tag == core_option_Some)
          {
            size_t j = uu____4.f0;
            uint8_t uu____5[840U];
            memcpy(uu____5, xof_bytes[j], (size_t)840U * sizeof (uint8_t));
            K___libcrux_kyber_arithmetic_PolynomialRingElement_core_option_Option_libcrux_kyber_types_Error
            uu____6 = libcrux_kyber_sampling_sample_from_uniform_distribution___840size_t(uu____5);
            int32_t sampled[256U];
            memcpy(sampled, uu____6.fst, (size_t)256U * sizeof (int32_t));
            core_option_Option__libcrux_kyber_types_Error error = uu____6.snd;
            if (core_option__core__option__Option_T___is_some(&error, libcrux_kyber_types_Error))
              sampling_A_error = error;
            if (transpose)
              memcpy(A_transpose[j][i], sampled, (size_t)256U * sizeof (int32_t));
            else
              memcpy(A_transpose[i][j], sampled, (size_t)256U * sizeof (int32_t));
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____7[2U][2U][256U];
    memcpy(uu____7, A_transpose, (size_t)2U * sizeof (int32_t [2U][256U]));
    K___libcrux_kyber_arithmetic_PolynomialRingElement_2size_t__2size_t__core_option_Option__libcrux_kyber_types_Error
    lit;
    memcpy(lit.fst, uu____7, (size_t)2U * sizeof (int32_t [2U][256U]));
    lit.snd = sampling_A_error;
    return lit;
  }
}

void libcrux_kyber_hash_functions_PRF___192size_t(Eurydice_slice input, uint8_t ret[192U])
{
  uint8_t ret0[192U];
  libcrux_digest_shake256((size_t)192U, input, ret0);
  memcpy(ret, ret0, (size_t)192U * sizeof (uint8_t));
}

void
libcrux_kyber_sampling_sample_from_binomial_distribution___3size_t(
  Eurydice_slice randomness,
  int32_t ret[256U]
)
{
  int32_t uu____0[256U];
  if ((size_t)3U == (size_t)2U)
    libcrux_kyber_sampling_sample_from_binomial_distribution_2(randomness, uu____0);
  else if ((size_t)3U == (size_t)3U)
    libcrux_kyber_sampling_sample_from_binomial_distribution_3(randomness, uu____0);
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
    KRML_HOST_EXIT(255U);
  }
  memcpy(ret, uu____0, (size_t)256U * sizeof (int32_t));
}

K___libcrux_kyber_arithmetic_PolynomialRingElement_2size_t__uint8_t
libcrux_kyber_ind_cpa_sample_vector_cbd_then_ntt___2size_t_3size_t_192size_t(
  uint8_t prf_input[33U],
  uint8_t domain_separator
)
{
  int32_t re_as_ntt[2U][256U];
  int32_t
  buf[2U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  memcpy(re_as_ntt, buf, (size_t)2U * sizeof (int32_t [256U]));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = (size_t)2U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        prf_input[32U] = domain_separator;
        domain_separator = (uint32_t)domain_separator + 1U;
        uint8_t prf_output[192U];
        libcrux_kyber_hash_functions_PRF___192size_t(Eurydice_array_to_slice((size_t)33U,
            prf_input,
            uint8_t),
          prf_output);
        int32_t r[256U];
        libcrux_kyber_sampling_sample_from_binomial_distribution___3size_t(Eurydice_array_to_slice((size_t)192U,
            prf_output,
            uint8_t),
          r);
        int32_t uu____1[256U];
        libcrux_kyber_ntt_ntt_binomially_sampled_ring_element(r, uu____1);
        memcpy(re_as_ntt[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[2U][256U];
    memcpy(uu____2, re_as_ntt, (size_t)2U * sizeof (int32_t [256U]));
    K___libcrux_kyber_arithmetic_PolynomialRingElement_2size_t__uint8_t lit;
    memcpy(lit.fst, uu____2, (size_t)2U * sizeof (int32_t [256U]));
    lit.snd = domain_separator;
    return lit;
  }
}

void
libcrux_kyber_arithmetic_add_to_ring_element___2size_t(
  int32_t lhs[256U],
  int32_t (*rhs)[256U],
  int32_t ret[256U]
)
{
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, lhs, int32_t),
      int32_t);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        size_t uu____1 = i;
        lhs[uu____1] = lhs[uu____1] + rhs[0U][i];
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, lhs, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_matrix_compute_As_plus_e___2size_t(
  int32_t (*matrix_A)[2U][256U],
  int32_t (*s_as_ntt)[256U],
  int32_t (*error_as_ntt)[256U],
  int32_t ret[2U][256U]
)
{
  int32_t result[2U][256U];
  int32_t
  buf[2U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  memcpy(result, buf, (size_t)2U * sizeof (int32_t [256U]));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)2U,
        matrix_A,
        Eurydice_error_t_cg_array),
      int32_t [2U][256U]);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        core_ops_range_Range__size_t lit;
        lit.start = (size_t)0U;
        lit.end =
          core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)2U,
              matrix_A[i],
              int32_t [256U]),
            int32_t [256U]);
        core_ops_range_Range__size_t
        iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
          if (uu____1.tag == core_option_None)
            break;
          else if (uu____1.tag == core_option_Some)
          {
            size_t j = uu____1.f0;
            int32_t product[256U];
            libcrux_kyber_ntt_ntt_multiply(&matrix_A[i][j], &s_as_ntt[j], product);
            int32_t uu____2[256U];
            libcrux_kyber_arithmetic_add_to_ring_element___2size_t(result[i], &product, uu____2);
            memcpy(result[i], uu____2, (size_t)256U * sizeof (int32_t));
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        core_ops_range_Range__size_t lit0;
        lit0.start = (size_t)0U;
        lit0.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
        core_ops_range_Range__size_t
        iter0 = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____3 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
          if (uu____3.tag == core_option_None)
            break;
          else if (uu____3.tag == core_option_Some)
          {
            size_t j = uu____3.f0;
            int32_t
            coefficient_normal_form = libcrux_kyber_arithmetic_to_standard_domain(result[i][j]);
            int32_t
            uu____4 =
              libcrux_kyber_arithmetic_barrett_reduce(coefficient_normal_form + error_as_ntt[i][j]);
            result[i][j] = uu____4;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____5[2U][256U];
    memcpy(uu____5, result, (size_t)2U * sizeof (int32_t [256U]));
    memcpy(ret, uu____5, (size_t)2U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_ind_cpa_serialize_secret_key___2size_t_768size_t(
  int32_t key[2U][256U],
  uint8_t ret[768U]
)
{
  uint8_t out[768U];
  uint8_t buf[768U] = { 0U };
  memcpy(out, buf, (size_t)768U * sizeof (uint8_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)2U, key, int32_t [256U]),
      int32_t [256U]);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t re[256U];
        memcpy(re, key[i], (size_t)256U * sizeof (int32_t));
        core_ops_range_Range__size_t lit;
        lit.start = i * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        lit.end = (i + (size_t)1U) * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        Eurydice_slice
        uu____1 =
          Eurydice_array_to_subslice((size_t)768U,
            out,
            lit,
            uint8_t,
            core_ops_range_Range__size_t);
        uint8_t ret[384U];
        libcrux_kyber_serialize_serialize_uncompressed_ring_element(re, ret);
        core_slice___Slice_T___copy_from_slice(uu____1,
          Eurydice_array_to_slice((size_t)384U, ret, uint8_t),
          uint8_t);
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____2[768U];
    memcpy(uu____2, out, (size_t)768U * sizeof (uint8_t));
    memcpy(ret, uu____2, (size_t)768U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_ind_cpa_serialize_public_key___2size_t_768size_t_800size_t(
  int32_t t_as_ntt[2U][256U],
  Eurydice_slice seed_for_a,
  uint8_t ret[800U]
)
{
  uint8_t public_key_serialized[800U];
  uint8_t buf[800U] = { 0U };
  memcpy(public_key_serialized, buf, (size_t)800U * sizeof (uint8_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)768U;
  Eurydice_slice
  uu____0 =
    Eurydice_array_to_subslice((size_t)800U,
      public_key_serialized,
      lit,
      uint8_t,
      core_ops_range_Range__size_t);
  int32_t uu____1[2U][256U];
  memcpy(uu____1, t_as_ntt, (size_t)2U * sizeof (int32_t [256U]));
  uint8_t ret0[768U];
  libcrux_kyber_ind_cpa_serialize_secret_key___2size_t_768size_t(uu____1, ret0);
  core_slice___Slice_T___copy_from_slice(uu____0,
    Eurydice_array_to_slice((size_t)768U, ret0, uint8_t),
    uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice_from((size_t)800U,
      public_key_serialized,
      (size_t)768U,
      uint8_t,
      size_t),
    seed_for_a,
    uint8_t);
  uint8_t uu____2[800U];
  memcpy(uu____2, public_key_serialized, (size_t)800U * sizeof (uint8_t));
  memcpy(ret, uu____2, (size_t)800U * sizeof (uint8_t));
}

K___uint8_t_768size_t____uint8_t_800size_t__core_option_Option__libcrux_kyber_types_Error
libcrux_kyber_ind_cpa_generate_keypair___2size_t_768size_t_800size_t_768size_t_3size_t_192size_t(
  Eurydice_slice key_generation_seed
)
{
  uint8_t hashed[64U];
  libcrux_kyber_hash_functions_G(key_generation_seed, hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____0 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U, hashed, uint8_t),
      (size_t)32U,
      uint8_t);
  Eurydice_slice seed_for_A = uu____0.fst;
  Eurydice_slice seed_for_secret_and_error = uu____0.snd;
  uint8_t ret[34U];
  libcrux_kyber_ind_cpa_into_padded_array___34size_t(seed_for_A, ret);
  K___libcrux_kyber_arithmetic_PolynomialRingElement_2size_t__2size_t__core_option_Option__libcrux_kyber_types_Error
  uu____1 = libcrux_kyber_matrix_sample_matrix_A___2size_t(ret, true);
  int32_t A_transpose[2U][2U][256U];
  int32_t uu____2[2U][2U][256U];
  memcpy(uu____2, uu____1.fst, (size_t)2U * sizeof (int32_t [2U][256U]));
  memcpy(A_transpose, uu____2, (size_t)2U * sizeof (int32_t [2U][256U]));
  core_option_Option__libcrux_kyber_types_Error sampling_A_error = uu____1.snd;
  uint8_t prf_input[33U];
  libcrux_kyber_ind_cpa_into_padded_array___33size_t(seed_for_secret_and_error, prf_input);
  uint8_t uu____3[33U];
  memcpy(uu____3, prf_input, (size_t)33U * sizeof (uint8_t));
  K___libcrux_kyber_arithmetic_PolynomialRingElement_2size_t__uint8_t
  uu____4 =
    libcrux_kyber_ind_cpa_sample_vector_cbd_then_ntt___2size_t_3size_t_192size_t(uu____3,
      0U);
  int32_t secret_as_ntt[2U][256U];
  int32_t uu____5[2U][256U];
  memcpy(uu____5, uu____4.fst, (size_t)2U * sizeof (int32_t [256U]));
  memcpy(secret_as_ntt, uu____5, (size_t)2U * sizeof (int32_t [256U]));
  uint8_t domain_separator = uu____4.snd;
  uint8_t uu____6[33U];
  memcpy(uu____6, prf_input, (size_t)33U * sizeof (uint8_t));
  int32_t error_as_ntt[2U][256U];
  int32_t uu____7[2U][256U];
  memcpy(uu____7,
    libcrux_kyber_ind_cpa_sample_vector_cbd_then_ntt___2size_t_3size_t_192size_t(uu____6,
      domain_separator).fst,
    (size_t)2U * sizeof (int32_t [256U]));
  memcpy(error_as_ntt, uu____7, (size_t)2U * sizeof (int32_t [256U]));
  int32_t t_as_ntt[2U][256U];
  libcrux_kyber_matrix_compute_As_plus_e___2size_t(A_transpose,
    secret_as_ntt,
    error_as_ntt,
    t_as_ntt);
  int32_t uu____8[2U][256U];
  memcpy(uu____8, t_as_ntt, (size_t)2U * sizeof (int32_t [256U]));
  uint8_t public_key_serialized[800U];
  libcrux_kyber_ind_cpa_serialize_public_key___2size_t_768size_t_800size_t(uu____8,
    seed_for_A,
    public_key_serialized);
  int32_t uu____9[2U][256U];
  memcpy(uu____9, secret_as_ntt, (size_t)2U * sizeof (int32_t [256U]));
  uint8_t secret_key_serialized[768U];
  libcrux_kyber_ind_cpa_serialize_secret_key___2size_t_768size_t(uu____9, secret_key_serialized);
  uint8_t uu____10[768U];
  memcpy(uu____10, secret_key_serialized, (size_t)768U * sizeof (uint8_t));
  uint8_t uu____11[800U];
  memcpy(uu____11, public_key_serialized, (size_t)800U * sizeof (uint8_t));
  K___uint8_t_768size_t____uint8_t_800size_t__core_option_Option__libcrux_kyber_types_Error lit;
  memcpy(lit.fst.fst, uu____10, (size_t)768U * sizeof (uint8_t));
  memcpy(lit.fst.snd, uu____11, (size_t)800U * sizeof (uint8_t));
  lit.snd = sampling_A_error;
  return lit;
}

void
libcrux_kyber_serialize_kem_secret_key___1632size_t(
  Eurydice_slice private_key,
  Eurydice_slice public_key,
  Eurydice_slice implicit_rejection_value,
  uint8_t ret[1632U]
)
{
  uint8_t out[1632U];
  uint8_t buf[1632U] = { 0U };
  memcpy(out, buf, (size_t)1632U * sizeof (uint8_t));
  size_t pointer = (size_t)0U;
  uint8_t *uu____0 = out;
  size_t uu____1 = pointer;
  core_ops_range_Range__size_t lit0;
  lit0.start = pointer;
  lit0.end = uu____1 + core_slice___Slice_T___len(private_key, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)1632U,
      uu____0,
      lit0,
      uint8_t,
      core_ops_range_Range__size_t),
    private_key,
    uint8_t);
  pointer = pointer + core_slice___Slice_T___len(private_key, uint8_t);
  uint8_t *uu____2 = out;
  size_t uu____3 = pointer;
  core_ops_range_Range__size_t lit1;
  lit1.start = pointer;
  lit1.end = uu____3 + core_slice___Slice_T___len(public_key, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)1632U,
      uu____2,
      lit1,
      uint8_t,
      core_ops_range_Range__size_t),
    public_key,
    uint8_t);
  pointer = pointer + core_slice___Slice_T___len(public_key, uint8_t);
  core_ops_range_Range__size_t lit2;
  lit2.start = pointer;
  lit2.end = pointer + libcrux_kyber_constants_H_DIGEST_SIZE;
  Eurydice_slice
  uu____4 =
    Eurydice_array_to_subslice((size_t)1632U,
      out,
      lit2,
      uint8_t,
      core_ops_range_Range__size_t);
  uint8_t ret0[32U];
  libcrux_kyber_hash_functions_H(public_key, ret0);
  core_slice___Slice_T___copy_from_slice(uu____4,
    Eurydice_array_to_slice((size_t)32U, ret0, uint8_t),
    uint8_t);
  pointer = pointer + libcrux_kyber_constants_H_DIGEST_SIZE;
  uint8_t *uu____5 = out;
  size_t uu____6 = pointer;
  core_ops_range_Range__size_t lit;
  lit.start = pointer;
  lit.end = uu____6 + core_slice___Slice_T___len(implicit_rejection_value, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)1632U,
      uu____5,
      lit,
      uint8_t,
      core_ops_range_Range__size_t),
    implicit_rejection_value,
    uint8_t);
  uint8_t uu____7[1632U];
  memcpy(uu____7, out, (size_t)1632U * sizeof (uint8_t));
  memcpy(ret, uu____7, (size_t)1632U * sizeof (uint8_t));
}

void
libcrux_kyber_types__libcrux_kyber__types__KyberPrivateKey_SIZE__8__from___1632size_t(
  uint8_t value[1632U],
  uint8_t ret[1632U]
)
{
  uint8_t uu____0[1632U];
  memcpy(uu____0, value, (size_t)1632U * sizeof (uint8_t));
  memcpy(ret, uu____0, (size_t)1632U * sizeof (uint8_t));
}

libcrux_kyber_types_KyberKeyPair___1632size_t_800size_t
libcrux_kyber_types__libcrux_kyber__types__KyberKeyPair_PRIVATE_KEY_SIZE__PUBLIC_KEY_SIZE___from___1632size_t_800size_t(
  uint8_t sk[1632U],
  uint8_t pk[800U]
)
{
  libcrux_kyber_types_KyberKeyPair___1632size_t_800size_t lit;
  memcpy(lit.sk, sk, (size_t)1632U * sizeof (uint8_t));
  memcpy(lit.pk, pk, (size_t)800U * sizeof (uint8_t));
  return lit;
}

core_result_Result__libcrux_kyber_types_KyberKeyPair__800size_t____1632size_t___libcrux_kyber_types_Error
libcrux_kyber_generate_keypair___2size_t_768size_t_1632size_t_800size_t_768size_t_3size_t_192size_t(
  uint8_t randomness[64U]
)
{
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = libcrux_kyber_constants_CPA_PKE_KEY_GENERATION_SEED_SIZE;
  Eurydice_slice
  ind_cpa_keypair_randomness =
    Eurydice_array_to_subslice((size_t)64U,
      randomness,
      lit0,
      uint8_t,
      core_ops_range_Range__size_t);
  Eurydice_slice
  implicit_rejection_value =
    Eurydice_array_to_subslice_from((size_t)64U,
      randomness,
      libcrux_kyber_constants_CPA_PKE_KEY_GENERATION_SEED_SIZE,
      uint8_t,
      size_t);
  K___uint8_t_768size_t____uint8_t_800size_t__core_option_Option__libcrux_kyber_types_Error
  uu____0 =
    libcrux_kyber_ind_cpa_generate_keypair___2size_t_768size_t_800size_t_768size_t_3size_t_192size_t(ind_cpa_keypair_randomness);
  uint8_t ind_cpa_private_key[768U];
  uint8_t uu____1[768U];
  memcpy(uu____1, uu____0.fst.fst, (size_t)768U * sizeof (uint8_t));
  memcpy(ind_cpa_private_key, uu____1, (size_t)768U * sizeof (uint8_t));
  uint8_t public_key[800U];
  uint8_t uu____2[800U];
  memcpy(uu____2, uu____0.fst.snd, (size_t)800U * sizeof (uint8_t));
  memcpy(public_key, uu____2, (size_t)800U * sizeof (uint8_t));
  core_option_Option__libcrux_kyber_types_Error sampling_a_error = uu____0.snd;
  Eurydice_slice uu____3 = Eurydice_array_to_slice((size_t)768U, ind_cpa_private_key, uint8_t);
  uint8_t secret_key_serialized[1632U];
  libcrux_kyber_serialize_kem_secret_key___1632size_t(uu____3,
    Eurydice_array_to_slice((size_t)800U, public_key, uint8_t),
    implicit_rejection_value,
    secret_key_serialized);
  core_result_Result__libcrux_kyber_types_KyberKeyPair__800size_t____1632size_t___libcrux_kyber_types_Error
  uu____4;
  if (sampling_a_error.tag == core_option_Some)
  {
    libcrux_kyber_types_Error error = sampling_a_error.f0;
    core_result_Result__libcrux_kyber_types_KyberKeyPair__800size_t____1632size_t___libcrux_kyber_types_Error
    lit;
    lit.tag = core_result_Err;
    lit.val.case_Err = error;
    uu____4 = lit;
  }
  else
  {
    uint8_t uu____5[1632U];
    memcpy(uu____5, secret_key_serialized, (size_t)1632U * sizeof (uint8_t));
    uint8_t private_key[1632U];
    libcrux_kyber_types__libcrux_kyber__types__KyberPrivateKey_SIZE__8__from___1632size_t(uu____5,
      private_key);
    uint8_t uu____6[1632U];
    memcpy(uu____6, private_key, (size_t)1632U * sizeof (uint8_t));
    uint8_t uu____7[800U];
    memcpy(uu____7, public_key, (size_t)800U * sizeof (uint8_t));
    core_result_Result__libcrux_kyber_types_KyberKeyPair__800size_t____1632size_t___libcrux_kyber_types_Error
    lit;
    lit.tag = core_result_Ok;
    lit.val.case_Ok =
      libcrux_kyber_types__libcrux_kyber__types__KyberKeyPair_PRIVATE_KEY_SIZE__PUBLIC_KEY_SIZE___from___1632size_t_800size_t(uu____6,
        uu____7);
    uu____4 = lit;
  }
  return uu____4;
}

core_result_Result__libcrux_kyber_types_KyberKeyPair__800size_t____1632size_t___libcrux_kyber_types_Error
libcrux_kyber_kyber512_generate_key_pair_512(uint8_t randomness[64U])
{
  uint8_t uu____0[64U];
  memcpy(uu____0, randomness, (size_t)64U * sizeof (uint8_t));
  return
    libcrux_kyber_generate_keypair___2size_t_768size_t_1632size_t_800size_t_768size_t_3size_t_192size_t(uu____0);
}

uint8_t
*libcrux_kyber_types__libcrux_kyber__types__KyberPublicKey_SIZE__18__as_slice___800size_t(
  uint8_t (*self)[800U]
)
{
  return self[0U];
}

void
libcrux_kyber_ind_cpa_deserialize_public_key___2size_t_768size_t(
  Eurydice_slice public_key,
  int32_t ret[2U][256U]
)
{
  int32_t t_as_ntt[2U][256U];
  int32_t
  buf[2U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  memcpy(t_as_ntt, buf, (size_t)2U * sizeof (int32_t [256U]));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = (size_t)768U / libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        core_ops_range_Range__size_t lit;
        lit.start = i * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        lit.end = i * (libcrux_kyber_constants_BYTES_PER_RING_ELEMENT + (size_t)1U);
        Eurydice_slice
        t_as_ntt_bytes =
          Eurydice_slice_subslice(public_key,
            lit,
            uint8_t,
            core_ops_range_Range__size_t);
        int32_t uu____1[256U];
        libcrux_kyber_serialize_deserialize_to_uncompressed_ring_element(t_as_ntt_bytes, uu____1);
        memcpy(t_as_ntt[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[2U][256U];
    memcpy(uu____2, t_as_ntt, (size_t)2U * sizeof (int32_t [256U]));
    memcpy(ret, uu____2, (size_t)2U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_ind_cpa_sample_ring_element_cbd___2size_t_128size_t_2size_t(
  uint8_t *prf_input,
  uint8_t *domain_separator,
  int32_t ret[2U][256U]
)
{
  int32_t error_1[2U][256U];
  int32_t
  buf[2U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  memcpy(error_1, buf, (size_t)2U * sizeof (int32_t [256U]));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)2U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        prf_input[32U] = domain_separator[0U];
        domain_separator[0U] = (uint32_t)domain_separator[0U] + 1U;
        uint8_t prf_output[128U];
        libcrux_kyber_hash_functions_PRF___128size_t(Eurydice_array_to_slice((size_t)33U,
            prf_input,
            uint8_t),
          prf_output);
        int32_t uu____1[256U];
        libcrux_kyber_sampling_sample_from_binomial_distribution___2size_t(Eurydice_array_to_slice((size_t)128U,
            prf_output,
            uint8_t),
          uu____1);
        memcpy(error_1[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[2U][256U];
    memcpy(uu____2, error_1, (size_t)2U * sizeof (int32_t [256U]));
    memcpy(ret, uu____2, (size_t)2U * sizeof (int32_t [256U]));
    return;
  }
}

void libcrux_kyber_ntt_invert_ntt_montgomery___2size_t(int32_t re[256U], int32_t ret[256U])
{
  size_t zeta_i = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT / (size_t)2U;
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)1U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)2U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)3U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)4U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)5U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)6U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)7U, re);
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)8U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t uu____1 = libcrux_kyber_arithmetic_barrett_reduce(re[i]);
        re[i] = uu____1;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, re, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_matrix_compute_vector_u___2size_t(
  int32_t (*a_as_ntt)[2U][256U],
  int32_t (*r_as_ntt)[256U],
  int32_t (*error_1)[256U],
  int32_t ret[2U][256U]
)
{
  int32_t result[2U][256U];
  int32_t
  buf[2U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  memcpy(result, buf, (size_t)2U * sizeof (int32_t [256U]));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)2U,
        a_as_ntt,
        Eurydice_error_t_cg_array),
      int32_t [2U][256U]);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        core_ops_range_Range__size_t lit;
        lit.start = (size_t)0U;
        lit.end =
          core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)2U,
              a_as_ntt[i],
              int32_t [256U]),
            int32_t [256U]);
        core_ops_range_Range__size_t
        iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
          if (uu____1.tag == core_option_None)
            break;
          else if (uu____1.tag == core_option_Some)
          {
            size_t j = uu____1.f0;
            int32_t product[256U];
            libcrux_kyber_ntt_ntt_multiply(&a_as_ntt[i][j], &r_as_ntt[j], product);
            int32_t uu____2[256U];
            libcrux_kyber_arithmetic_add_to_ring_element___2size_t(result[i], &product, uu____2);
            memcpy(result[i], uu____2, (size_t)256U * sizeof (int32_t));
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        int32_t uu____3[256U];
        libcrux_kyber_ntt_invert_ntt_montgomery___2size_t(result[i], uu____3);
        memcpy(result[i], uu____3, (size_t)256U * sizeof (int32_t));
        core_ops_range_Range__size_t lit0;
        lit0.start = (size_t)0U;
        lit0.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
        core_ops_range_Range__size_t
        iter0 = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____4 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
          if (uu____4.tag == core_option_None)
            break;
          else if (uu____4.tag == core_option_Some)
          {
            size_t j = uu____4.f0;
            int32_t
            coefficient_normal_form =
              libcrux_kyber_arithmetic_montgomery_reduce(result[i][j] * (int32_t)1441);
            int32_t
            uu____5 =
              libcrux_kyber_arithmetic_barrett_reduce(coefficient_normal_form + error_1[i][j]);
            result[i][j] = uu____5;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____6[2U][256U];
    memcpy(uu____6, result, (size_t)2U * sizeof (int32_t [256U]));
    memcpy(ret, uu____6, (size_t)2U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_matrix_compute_ring_element_v___2size_t(
  int32_t (*t_as_ntt)[256U],
  int32_t (*r_as_ntt)[256U],
  int32_t (*error_2)[256U],
  int32_t (*message)[256U],
  int32_t ret[256U]
)
{
  int32_t result[256U];
  memcpy(result,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)2U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (uu____0.tag == core_option_None)
      break;
    else if (uu____0.tag == core_option_Some)
    {
      size_t i = uu____0.f0;
      int32_t product[256U];
      libcrux_kyber_ntt_ntt_multiply(&t_as_ntt[i], &r_as_ntt[i], product);
      libcrux_kyber_arithmetic_add_to_ring_element___2size_t(result, &product, result);
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
      KRML_HOST_EXIT(255U);
    }
  }
  libcrux_kyber_ntt_invert_ntt_montgomery___2size_t(result, result);
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter0 = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
    if (!(uu____1.tag == core_option_None))
    {
      if (uu____1.tag == core_option_Some)
      {
        size_t i = uu____1.f0;
        int32_t
        coefficient_normal_form =
          libcrux_kyber_arithmetic_montgomery_reduce(result[i] * (int32_t)1441);
        int32_t
        uu____2 =
          libcrux_kyber_arithmetic_barrett_reduce(coefficient_normal_form
            + error_2[0U][i]
            + message[0U][i]);
        result[i] = uu____2;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, result, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_serialize_compress_then_serialize_10___320size_t(
  int32_t re[256U],
  uint8_t ret[320U]
)
{
  uint8_t serialized[320U];
  uint8_t buf[320U] = { 0U };
  memcpy(serialized, buf, (size_t)320U * sizeof (uint8_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t),
      int32_t)
    / (size_t)4U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t
        coefficient1 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(10U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)4U + (size_t)0U]));
        int32_t
        coefficient2 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(10U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)4U + (size_t)1U]));
        int32_t
        coefficient3 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(10U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)4U + (size_t)2U]));
        int32_t
        coefficient4 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(10U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)4U + (size_t)3U]));
        K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
        uu____1 =
          libcrux_kyber_serialize_compress_coefficients_10(coefficient1,
            coefficient2,
            coefficient3,
            coefficient4);
        uint8_t coef1 = uu____1.fst;
        uint8_t coef2 = uu____1.snd;
        uint8_t coef3 = uu____1.thd;
        uint8_t coef4 = uu____1.f3;
        uint8_t coef5 = uu____1.f4;
        serialized[(size_t)5U * i] = coef1;
        serialized[(size_t)5U * i + (size_t)1U] = coef2;
        serialized[(size_t)5U * i + (size_t)2U] = coef3;
        serialized[(size_t)5U * i + (size_t)3U] = coef4;
        serialized[(size_t)5U * i + (size_t)4U] = coef5;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____2[320U];
    memcpy(uu____2, serialized, (size_t)320U * sizeof (uint8_t));
    memcpy(ret, uu____2, (size_t)320U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_serialize_compress_then_serialize_11___320size_t(
  int32_t re[256U],
  uint8_t ret[320U]
)
{
  uint8_t serialized[320U];
  uint8_t buf[320U] = { 0U };
  memcpy(serialized, buf, (size_t)320U * sizeof (uint8_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t),
      int32_t)
    / (size_t)8U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t
        coefficient1 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)0U]));
        int32_t
        coefficient2 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)1U]));
        int32_t
        coefficient3 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)2U]));
        int32_t
        coefficient4 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)3U]));
        int32_t
        coefficient5 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)4U]));
        int32_t
        coefficient6 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)5U]));
        int32_t
        coefficient7 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)6U]));
        int32_t
        coefficient8 =
          libcrux_kyber_compress_compress_ciphertext_coefficient(11U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)7U]));
        K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
        uu____1 =
          libcrux_kyber_serialize_compress_coefficients_11(coefficient1,
            coefficient2,
            coefficient3,
            coefficient4,
            coefficient5,
            coefficient6,
            coefficient7,
            coefficient8);
        uint8_t coef1 = uu____1.fst;
        uint8_t coef2 = uu____1.snd;
        uint8_t coef3 = uu____1.thd;
        uint8_t coef4 = uu____1.f3;
        uint8_t coef5 = uu____1.f4;
        uint8_t coef6 = uu____1.f5;
        uint8_t coef7 = uu____1.f6;
        uint8_t coef8 = uu____1.f7;
        uint8_t coef9 = uu____1.f8;
        uint8_t coef10 = uu____1.f9;
        uint8_t coef11 = uu____1.f10;
        serialized[(size_t)11U * i] = coef1;
        serialized[(size_t)11U * i + (size_t)1U] = coef2;
        serialized[(size_t)11U * i + (size_t)2U] = coef3;
        serialized[(size_t)11U * i + (size_t)3U] = coef4;
        serialized[(size_t)11U * i + (size_t)4U] = coef5;
        serialized[(size_t)11U * i + (size_t)5U] = coef6;
        serialized[(size_t)11U * i + (size_t)6U] = coef7;
        serialized[(size_t)11U * i + (size_t)7U] = coef8;
        serialized[(size_t)11U * i + (size_t)8U] = coef9;
        serialized[(size_t)11U * i + (size_t)9U] = coef10;
        serialized[(size_t)11U * i + (size_t)10U] = coef11;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____2[320U];
    memcpy(uu____2, serialized, (size_t)320U * sizeof (uint8_t));
    memcpy(ret, uu____2, (size_t)320U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_serialize_compress_then_serialize_ring_element_u___10size_t_320size_t(
  int32_t re[256U],
  uint8_t ret[320U]
)
{
  uint8_t uu____0[320U];
  if ((size_t)10U == (size_t)10U)
    libcrux_kyber_serialize_compress_then_serialize_10___320size_t(re, uu____0);
  else if ((size_t)10U == (size_t)11U)
    libcrux_kyber_serialize_compress_then_serialize_11___320size_t(re, uu____0);
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
    KRML_HOST_EXIT(255U);
  }
  memcpy(ret, uu____0, (size_t)320U * sizeof (uint8_t));
}

void
libcrux_kyber_ind_cpa_compress_then_serialize_u___2size_t_640size_t_10size_t_320size_t(
  int32_t input[2U][256U],
  uint8_t ret[640U]
)
{
  uint8_t out[640U];
  uint8_t buf[640U] = { 0U };
  memcpy(out, buf, (size_t)640U * sizeof (uint8_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)2U, input, int32_t [256U]),
      int32_t [256U]);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t re[256U];
        memcpy(re, input[i], (size_t)256U * sizeof (int32_t));
        core_ops_range_Range__size_t lit;
        lit.start = i * ((size_t)640U / (size_t)2U);
        lit.end = (i + (size_t)1U) * ((size_t)640U / (size_t)2U);
        Eurydice_slice
        uu____1 =
          Eurydice_array_to_subslice((size_t)640U,
            out,
            lit,
            uint8_t,
            core_ops_range_Range__size_t);
        uint8_t ret[320U];
        libcrux_kyber_serialize_compress_then_serialize_ring_element_u___10size_t_320size_t(re,
          ret);
        core_slice___Slice_T___copy_from_slice(uu____1,
          Eurydice_array_to_slice((size_t)320U, ret, uint8_t),
          uint8_t);
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____2[640U];
    memcpy(uu____2, out, (size_t)640U * sizeof (uint8_t));
    memcpy(ret, uu____2, (size_t)640U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_serialize_compress_then_serialize_4___128size_t(
  int32_t re[256U],
  uint8_t ret[128U]
)
{
  uint8_t serialized[128U];
  uint8_t buf[128U] = { 0U };
  memcpy(serialized, buf, (size_t)128U * sizeof (uint8_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t),
      int32_t)
    / (size_t)2U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        uint8_t
        coefficient1 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(4U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)2U + (size_t)0U]));
        uint8_t
        coefficient2 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(4U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)2U + (size_t)1U]));
        serialized[i] = (uint32_t)coefficient2 << 4U | (uint32_t)coefficient1;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____1[128U];
    memcpy(uu____1, serialized, (size_t)128U * sizeof (uint8_t));
    memcpy(ret, uu____1, (size_t)128U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_serialize_compress_then_serialize_5___128size_t(
  int32_t re[256U],
  uint8_t ret[128U]
)
{
  uint8_t serialized[128U];
  uint8_t buf[128U] = { 0U };
  memcpy(serialized, buf, (size_t)128U * sizeof (uint8_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, re, int32_t),
      int32_t)
    / (size_t)8U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        uint8_t
        coefficient1 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)0U]));
        uint8_t
        coefficient2 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)1U]));
        uint8_t
        coefficient3 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)2U]));
        uint8_t
        coefficient4 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)3U]));
        uint8_t
        coefficient5 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)4U]));
        uint8_t
        coefficient6 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)5U]));
        uint8_t
        coefficient7 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)6U]));
        uint8_t
        coefficient8 =
          (uint8_t)libcrux_kyber_compress_compress_ciphertext_coefficient(5U,
            libcrux_kyber_arithmetic_to_unsigned_representative(re[i * (size_t)8U + (size_t)7U]));
        K___uint8_t_uint8_t_uint8_t_uint8_t_uint8_t
        uu____1 =
          libcrux_kyber_serialize_compress_coefficients_5(coefficient2,
            coefficient1,
            coefficient4,
            coefficient3,
            coefficient5,
            coefficient7,
            coefficient6,
            coefficient8);
        uint8_t coef1 = uu____1.fst;
        uint8_t coef2 = uu____1.snd;
        uint8_t coef3 = uu____1.thd;
        uint8_t coef4 = uu____1.f3;
        uint8_t coef5 = uu____1.f4;
        serialized[(size_t)5U * i] = coef1;
        serialized[(size_t)5U * i + (size_t)1U] = coef2;
        serialized[(size_t)5U * i + (size_t)2U] = coef3;
        serialized[(size_t)5U * i + (size_t)3U] = coef4;
        serialized[(size_t)5U * i + (size_t)4U] = coef5;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____2[128U];
    memcpy(uu____2, serialized, (size_t)128U * sizeof (uint8_t));
    memcpy(ret, uu____2, (size_t)128U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_serialize_compress_then_serialize_ring_element_v___4size_t_128size_t(
  int32_t re[256U],
  uint8_t ret[128U]
)
{
  uint8_t uu____0[128U];
  if ((size_t)4U == (size_t)4U)
    libcrux_kyber_serialize_compress_then_serialize_4___128size_t(re, uu____0);
  else if ((size_t)4U == (size_t)5U)
    libcrux_kyber_serialize_compress_then_serialize_5___128size_t(re, uu____0);
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
    KRML_HOST_EXIT(255U);
  }
  memcpy(ret, uu____0, (size_t)128U * sizeof (uint8_t));
}

void
libcrux_kyber_ind_cpa_into_padded_array___768size_t(Eurydice_slice slice, uint8_t ret[768U])
{
  if (false)
    LowStar_Ignore_ignore(core_slice___Slice_T___len(slice, uint8_t), size_t);
  uint8_t out[768U];
  uint8_t buf[768U] = { 0U };
  memcpy(out, buf, (size_t)768U * sizeof (uint8_t));
  uint8_t *uu____0 = out;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(slice, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)768U,
      uu____0,
      lit,
      uint8_t,
      core_ops_range_Range__size_t),
    slice,
    uint8_t);
  uint8_t uu____1[768U];
  memcpy(uu____1, out, (size_t)768U * sizeof (uint8_t));
  memcpy(ret, uu____1, (size_t)768U * sizeof (uint8_t));
}

K___uint8_t_768size_t__core_option_Option__libcrux_kyber_types_Error
libcrux_kyber_ind_cpa_encrypt___2size_t_768size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t(
  Eurydice_slice public_key,
  uint8_t message[32U],
  Eurydice_slice randomness
)
{
  int32_t t_as_ntt[2U][256U];
  libcrux_kyber_ind_cpa_deserialize_public_key___2size_t_768size_t(public_key, t_as_ntt);
  Eurydice_slice seed = Eurydice_slice_subslice_from(public_key, (size_t)768U, uint8_t, size_t);
  uint8_t ret[34U];
  libcrux_kyber_ind_cpa_into_padded_array___34size_t(seed, ret);
  K___libcrux_kyber_arithmetic_PolynomialRingElement_2size_t__2size_t__core_option_Option__libcrux_kyber_types_Error
  uu____0 = libcrux_kyber_matrix_sample_matrix_A___2size_t(ret, false);
  int32_t A_transpose[2U][2U][256U];
  int32_t uu____1[2U][2U][256U];
  memcpy(uu____1, uu____0.fst, (size_t)2U * sizeof (int32_t [2U][256U]));
  memcpy(A_transpose, uu____1, (size_t)2U * sizeof (int32_t [2U][256U]));
  core_option_Option__libcrux_kyber_types_Error sampling_A_error = uu____0.snd;
  uint8_t prf_input[33U];
  libcrux_kyber_ind_cpa_into_padded_array___33size_t(randomness, prf_input);
  uint8_t uu____2[33U];
  memcpy(uu____2, prf_input, (size_t)33U * sizeof (uint8_t));
  K___libcrux_kyber_arithmetic_PolynomialRingElement_2size_t__uint8_t
  uu____3 =
    libcrux_kyber_ind_cpa_sample_vector_cbd_then_ntt___2size_t_3size_t_192size_t(uu____2,
      0U);
  int32_t r_as_ntt[2U][256U];
  int32_t uu____4[2U][256U];
  memcpy(uu____4, uu____3.fst, (size_t)2U * sizeof (int32_t [256U]));
  memcpy(r_as_ntt, uu____4, (size_t)2U * sizeof (int32_t [256U]));
  uint8_t domain_separator = uu____3.snd;
  int32_t error_1[2U][256U];
  libcrux_kyber_ind_cpa_sample_ring_element_cbd___2size_t_128size_t_2size_t(prf_input,
    &domain_separator,
    error_1);
  prf_input[32U] = domain_separator;
  uint8_t prf_output[128U];
  libcrux_kyber_hash_functions_PRF___128size_t(Eurydice_array_to_slice((size_t)33U,
      prf_input,
      uint8_t),
    prf_output);
  int32_t error_2[256U];
  libcrux_kyber_sampling_sample_from_binomial_distribution___2size_t(Eurydice_array_to_slice((size_t)128U,
      prf_output,
      uint8_t),
    error_2);
  int32_t u[2U][256U];
  libcrux_kyber_matrix_compute_vector_u___2size_t(A_transpose, r_as_ntt, error_1, u);
  uint8_t uu____5[32U];
  memcpy(uu____5, message, (size_t)32U * sizeof (uint8_t));
  int32_t message_as_ring_element[256U];
  libcrux_kyber_serialize_deserialize_then_decompress_message(uu____5, message_as_ring_element);
  int32_t v[256U];
  libcrux_kyber_matrix_compute_ring_element_v___2size_t(t_as_ntt,
    r_as_ntt,
    &error_2,
    &message_as_ring_element,
    v);
  int32_t uu____6[2U][256U];
  memcpy(uu____6, u, (size_t)2U * sizeof (int32_t [256U]));
  uint8_t c1[640U];
  libcrux_kyber_ind_cpa_compress_then_serialize_u___2size_t_640size_t_10size_t_320size_t(uu____6,
    c1);
  uint8_t c2[128U];
  libcrux_kyber_serialize_compress_then_serialize_ring_element_v___4size_t_128size_t(v, c2);
  uint8_t ciphertext[768U];
  libcrux_kyber_ind_cpa_into_padded_array___768size_t(Eurydice_array_to_slice((size_t)640U,
      c1,
      uint8_t),
    ciphertext);
  Eurydice_slice
  uu____7 =
    Eurydice_array_to_subslice_from((size_t)768U,
      ciphertext,
      (size_t)640U,
      uint8_t,
      size_t);
  core_slice___Slice_T___copy_from_slice(uu____7,
    core_array___Array_T__N__23__as_slice((size_t)128U, c2, uint8_t),
    uint8_t);
  uint8_t uu____8[768U];
  memcpy(uu____8, ciphertext, (size_t)768U * sizeof (uint8_t));
  K___uint8_t_768size_t__core_option_Option__libcrux_kyber_types_Error lit;
  memcpy(lit.fst, uu____8, (size_t)768U * sizeof (uint8_t));
  lit.snd = sampling_A_error;
  return lit;
}

core_result_Result__libcrux_kyber_types_KyberCiphertext___768size_t___uint8_t_32size_t__libcrux_kyber_types_Error
libcrux_kyber_encapsulate___2size_t_768size_t_800size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t(
  uint8_t (*public_key)[800U],
  uint8_t randomness[32U]
)
{
  uint8_t to_hash[64U];
  libcrux_kyber_ind_cpa_into_padded_array___64size_t(Eurydice_array_to_slice((size_t)32U,
      randomness,
      uint8_t),
    to_hash);
  Eurydice_slice
  uu____0 =
    Eurydice_array_to_subslice_from((size_t)64U,
      to_hash,
      libcrux_kyber_constants_H_DIGEST_SIZE,
      uint8_t,
      size_t);
  uint8_t ret[32U];
  libcrux_kyber_hash_functions_H(Eurydice_array_to_slice((size_t)800U,
      libcrux_kyber_types__libcrux_kyber__types__KyberPublicKey_SIZE__18__as_slice___800size_t(public_key),
      uint8_t),
    ret);
  core_slice___Slice_T___copy_from_slice(uu____0,
    Eurydice_array_to_slice((size_t)32U, ret, uint8_t),
    uint8_t);
  uint8_t hashed[64U];
  libcrux_kyber_hash_functions_G(Eurydice_array_to_slice((size_t)64U, to_hash, uint8_t), hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____1 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U, hashed, uint8_t),
      libcrux_kyber_constants_SHARED_SECRET_SIZE,
      uint8_t);
  Eurydice_slice shared_secret = uu____1.fst;
  Eurydice_slice pseudorandomness = uu____1.snd;
  Eurydice_slice
  uu____2 =
    Eurydice_array_to_slice((size_t)800U,
      libcrux_kyber_types__libcrux_kyber__types__KyberPublicKey_SIZE__18__as_slice___800size_t(public_key),
      uint8_t);
  uint8_t uu____3[32U];
  memcpy(uu____3, randomness, (size_t)32U * sizeof (uint8_t));
  K___uint8_t_768size_t__core_option_Option__libcrux_kyber_types_Error
  uu____4 =
    libcrux_kyber_ind_cpa_encrypt___2size_t_768size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t(uu____2,
      uu____3,
      pseudorandomness);
  uint8_t ciphertext[768U];
  uint8_t uu____5[768U];
  memcpy(uu____5, uu____4.fst, (size_t)768U * sizeof (uint8_t));
  memcpy(ciphertext, uu____5, (size_t)768U * sizeof (uint8_t));
  core_option_Option__libcrux_kyber_types_Error sampling_a_error = uu____4.snd;
  core_result_Result__libcrux_kyber_types_KyberCiphertext___768size_t___uint8_t_32size_t__libcrux_kyber_types_Error
  uu____6;
  if (sampling_a_error.tag == core_option_None)
  {
    uint8_t uu____7[768U];
    memcpy(uu____7, ciphertext, (size_t)768U * sizeof (uint8_t));
    uint8_t uu____8[768U];
    memcpy(uu____8, uu____7, (size_t)768U * sizeof (uint8_t));
    core_result_Result__uint8_t_32size_t__core_array_TryFromSliceError
    uu____9 = Eurydice_slice_to_array(shared_secret, Eurydice_slice, uint8_t [32U]);
    if (uu____9.tag == core_result_Ok)
    {
      uint8_t r[32U];
      uint8_t f0[32U];
      memcpy(f0, uu____9.val.case_Ok, (size_t)32U * sizeof (uint8_t));
      memcpy(r, f0, (size_t)32U * sizeof (uint8_t));
      uint8_t uu____10[32U];
      memcpy(uu____10, r, (size_t)32U * sizeof (uint8_t));
      core_result_Result__libcrux_kyber_types_KyberCiphertext___768size_t___uint8_t_32size_t__libcrux_kyber_types_Error
      lit;
      lit.tag = core_result_Ok;
      memcpy(lit.val.case_Ok.fst, uu____8, (size_t)768U * sizeof (uint8_t));
      memcpy(lit.val.case_Ok.snd, uu____10, (size_t)32U * sizeof (uint8_t));
      uu____6 = lit;
    }
    else if (uu____9.tag == core_result_Err)
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
      KRML_HOST_EXIT(255U);
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
      KRML_HOST_EXIT(255U);
    }
  }
  else if (sampling_a_error.tag == core_option_Some)
  {
    libcrux_kyber_types_Error e = sampling_a_error.f0;
    core_result_Result__libcrux_kyber_types_KyberCiphertext___768size_t___uint8_t_32size_t__libcrux_kyber_types_Error
    lit;
    lit.tag = core_result_Err;
    lit.val.case_Err = e;
    uu____6 = lit;
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
    KRML_HOST_EXIT(255U);
  }
  return uu____6;
}

core_result_Result__libcrux_kyber_types_KyberCiphertext___768size_t___uint8_t_32size_t__libcrux_kyber_types_Error
libcrux_kyber_kyber512_encapsulate_512(uint8_t (*public_key)[800U], uint8_t randomness[32U])
{
  uint8_t (*uu____0)[800U] = public_key;
  uint8_t uu____1[32U];
  memcpy(uu____1, randomness, (size_t)32U * sizeof (uint8_t));
  return
    libcrux_kyber_encapsulate___2size_t_768size_t_800size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t(uu____0,
      uu____1);
}

K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
libcrux_kyber_types__libcrux_kyber__types__KyberPrivateKey_SIZE__12__split_at___1632size_t(
  uint8_t (*self)[1632U],
  size_t mid
)
{
  return
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)1632U, self[0U], uint8_t),
      mid,
      uint8_t);
}

void
libcrux_kyber_serialize_deserialize_then_decompress_ring_element_u___10size_t(
  Eurydice_slice serialized,
  int32_t ret[256U]
)
{
  int32_t uu____0[256U];
  if ((size_t)10U == (size_t)10U)
    libcrux_kyber_serialize_deserialize_then_decompress_10(serialized, uu____0);
  else if ((size_t)10U == (size_t)11U)
    libcrux_kyber_serialize_deserialize_then_decompress_11(serialized, uu____0);
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
    KRML_HOST_EXIT(255U);
  }
  memcpy(ret, uu____0, (size_t)256U * sizeof (int32_t));
}

void libcrux_kyber_ntt_ntt_vector_u___10size_t(int32_t re[256U], int32_t ret[256U])
{
  size_t zeta_i = (size_t)0U;
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)7U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)6U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)5U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)4U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)3U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)2U, re);
  libcrux_kyber_ntt_ntt_at_layer_3328(&zeta_i, re, (size_t)1U, re);
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t uu____1 = libcrux_kyber_arithmetic_barrett_reduce(re[i]);
        re[i] = uu____1;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, re, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_ind_cpa_deserialize_then_decompress_u___2size_t_768size_t_640size_t_10size_t(
  uint8_t *ciphertext,
  int32_t ret[2U][256U]
)
{
  int32_t u_as_ntt[2U][256U];
  int32_t
  buf[2U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  memcpy(u_as_ntt, buf, (size_t)2U * sizeof (int32_t [256U]));
  size_t
  chunk_size = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT * (size_t)10U / (size_t)8U;
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = (size_t)640U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        core_ops_range_Range__size_t lit;
        lit.start = i * chunk_size;
        lit.end = i * (chunk_size + (size_t)1U);
        Eurydice_slice
        u_bytes =
          Eurydice_array_to_subslice((size_t)768U,
            ciphertext,
            lit,
            uint8_t,
            core_ops_range_Range__size_t);
        int32_t u[256U];
        libcrux_kyber_serialize_deserialize_then_decompress_ring_element_u___10size_t(u_bytes, u);
        int32_t uu____1[256U];
        libcrux_kyber_ntt_ntt_vector_u___10size_t(u, uu____1);
        memcpy(u_as_ntt[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[2U][256U];
    memcpy(uu____2, u_as_ntt, (size_t)2U * sizeof (int32_t [256U]));
    memcpy(ret, uu____2, (size_t)2U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_serialize_deserialize_then_decompress_ring_element_v___4size_t(
  Eurydice_slice serialized,
  int32_t ret[256U]
)
{
  int32_t uu____0[256U];
  if ((size_t)4U == (size_t)4U)
    libcrux_kyber_serialize_deserialize_then_decompress_4(serialized, uu____0);
  else if ((size_t)4U == (size_t)5U)
    libcrux_kyber_serialize_deserialize_then_decompress_5(serialized, uu____0);
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
    KRML_HOST_EXIT(255U);
  }
  memcpy(ret, uu____0, (size_t)256U * sizeof (int32_t));
}

void
libcrux_kyber_ind_cpa_deserialize_secret_key___2size_t(
  Eurydice_slice secret_key,
  int32_t ret[2U][256U]
)
{
  int32_t secret_as_ntt[2U][256U];
  int32_t
  buf[2U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  memcpy(secret_as_ntt, buf, (size_t)2U * sizeof (int32_t [256U]));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(secret_key,
      uint8_t)
    / libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t uu____1[256U];
        core_ops_range_Range__size_t lit;
        lit.start = i * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        lit.end =
          i
          * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT
          + libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        libcrux_kyber_serialize_deserialize_to_uncompressed_ring_element(Eurydice_slice_subslice(secret_key,
            lit,
            uint8_t,
            core_ops_range_Range__size_t),
          uu____1);
        memcpy(secret_as_ntt[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[2U][256U];
    memcpy(uu____2, secret_as_ntt, (size_t)2U * sizeof (int32_t [256U]));
    memcpy(ret, uu____2, (size_t)2U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_matrix_compute_message___2size_t(
  int32_t (*v)[256U],
  int32_t (*secret_as_ntt)[256U],
  int32_t (*u_as_ntt)[256U],
  int32_t ret[256U]
)
{
  int32_t result[256U];
  memcpy(result,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)2U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (uu____0.tag == core_option_None)
      break;
    else if (uu____0.tag == core_option_Some)
    {
      size_t i = uu____0.f0;
      int32_t product[256U];
      libcrux_kyber_ntt_ntt_multiply(&secret_as_ntt[i], &u_as_ntt[i], product);
      libcrux_kyber_arithmetic_add_to_ring_element___2size_t(result, &product, result);
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
      KRML_HOST_EXIT(255U);
    }
  }
  libcrux_kyber_ntt_invert_ntt_montgomery___2size_t(result, result);
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter0 = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
    if (!(uu____1.tag == core_option_None))
    {
      if (uu____1.tag == core_option_Some)
      {
        size_t i = uu____1.f0;
        int32_t
        coefficient_normal_form =
          libcrux_kyber_arithmetic_montgomery_reduce(result[i] * (int32_t)1441);
        int32_t
        uu____2 = libcrux_kyber_arithmetic_barrett_reduce(v[0U][i] - coefficient_normal_form);
        result[i] = uu____2;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, result, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_ind_cpa_decrypt___2size_t_768size_t_640size_t_10size_t_4size_t(
  Eurydice_slice secret_key,
  uint8_t *ciphertext,
  uint8_t ret[32U]
)
{
  int32_t u_as_ntt[2U][256U];
  libcrux_kyber_ind_cpa_deserialize_then_decompress_u___2size_t_768size_t_640size_t_10size_t(ciphertext,
    u_as_ntt);
  int32_t v[256U];
  libcrux_kyber_serialize_deserialize_then_decompress_ring_element_v___4size_t(Eurydice_array_to_subslice_from((size_t)768U,
      ciphertext,
      (size_t)640U,
      uint8_t,
      size_t),
    v);
  int32_t secret_as_ntt[2U][256U];
  libcrux_kyber_ind_cpa_deserialize_secret_key___2size_t(secret_key, secret_as_ntt);
  int32_t message[256U];
  libcrux_kyber_matrix_compute_message___2size_t(&v, secret_as_ntt, u_as_ntt, message);
  uint8_t ret0[32U];
  libcrux_kyber_serialize_compress_then_serialize_message(message, ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

void
libcrux_kyber_ind_cpa_into_padded_array___800size_t(Eurydice_slice slice, uint8_t ret[800U])
{
  if (false)
    LowStar_Ignore_ignore(core_slice___Slice_T___len(slice, uint8_t), size_t);
  uint8_t out[800U];
  uint8_t buf[800U] = { 0U };
  memcpy(out, buf, (size_t)800U * sizeof (uint8_t));
  uint8_t *uu____0 = out;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(slice, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)800U,
      uu____0,
      lit,
      uint8_t,
      core_ops_range_Range__size_t),
    slice,
    uint8_t);
  uint8_t uu____1[800U];
  memcpy(uu____1, out, (size_t)800U * sizeof (uint8_t));
  memcpy(ret, uu____1, (size_t)800U * sizeof (uint8_t));
}

Eurydice_slice
libcrux_kyber_types__libcrux_kyber__types__KyberCiphertext_SIZE__1__as_ref___768size_t(
  uint8_t (*self)[768U]
)
{
  return Eurydice_array_to_slice((size_t)768U, self[0U], uint8_t);
}

uint8_t
libcrux_kyber_constant_time_ops_compare_ciphertexts_in_constant_time___768size_t(
  Eurydice_slice lhs,
  Eurydice_slice rhs
)
{
  uint8_t r = 0U;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)768U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        uint8_t uu____1 = Eurydice_slice_index(lhs, i, uint8_t);
        r = (uint32_t)r | ((uint32_t)uu____1 ^ (uint32_t)Eurydice_slice_index(rhs, i, uint8_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    return libcrux_kyber_constant_time_ops_is_non_zero(r);
  }
}

void
libcrux_kyber_decapsulate___2size_t_1632size_t_768size_t_800size_t_768size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t_800size_t(
  uint8_t (*secret_key)[1632U],
  uint8_t (*ciphertext)[768U],
  uint8_t ret[32U]
)
{
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____0 =
    libcrux_kyber_types__libcrux_kyber__types__KyberPrivateKey_SIZE__12__split_at___1632size_t(secret_key,
      (size_t)768U);
  Eurydice_slice ind_cpa_secret_key = uu____0.fst;
  Eurydice_slice secret_key0 = uu____0.snd;
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____1 = core_slice___Slice_T___split_at(secret_key0, (size_t)800U, uint8_t);
  Eurydice_slice ind_cpa_public_key = uu____1.fst;
  Eurydice_slice secret_key1 = uu____1.snd;
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____2 =
    core_slice___Slice_T___split_at(secret_key1,
      libcrux_kyber_constants_H_DIGEST_SIZE,
      uint8_t);
  Eurydice_slice ind_cpa_public_key_hash = uu____2.fst;
  Eurydice_slice implicit_rejection_value = uu____2.snd;
  uint8_t decrypted[32U];
  libcrux_kyber_ind_cpa_decrypt___2size_t_768size_t_640size_t_10size_t_4size_t(ind_cpa_secret_key,
    ciphertext[0U],
    decrypted);
  uint8_t to_hash0[64U];
  libcrux_kyber_ind_cpa_into_padded_array___64size_t(Eurydice_array_to_slice((size_t)32U,
      decrypted,
      uint8_t),
    to_hash0);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice_from((size_t)64U,
      to_hash0,
      libcrux_kyber_constants_SHARED_SECRET_SIZE,
      uint8_t,
      size_t),
    ind_cpa_public_key_hash,
    uint8_t);
  uint8_t hashed[64U];
  libcrux_kyber_hash_functions_G(Eurydice_array_to_slice((size_t)64U, to_hash0, uint8_t),
    hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____3 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U, hashed, uint8_t),
      libcrux_kyber_constants_SHARED_SECRET_SIZE,
      uint8_t);
  Eurydice_slice shared_secret = uu____3.fst;
  Eurydice_slice pseudorandomness = uu____3.snd;
  uint8_t to_hash[800U];
  libcrux_kyber_ind_cpa_into_padded_array___800size_t(implicit_rejection_value, to_hash);
  Eurydice_slice
  uu____4 =
    Eurydice_array_to_subslice_from((size_t)800U,
      to_hash,
      libcrux_kyber_constants_SHARED_SECRET_SIZE,
      uint8_t,
      size_t);
  core_slice___Slice_T___copy_from_slice(uu____4,
    libcrux_kyber_types__libcrux_kyber__types__KyberCiphertext_SIZE__1__as_ref___768size_t(ciphertext),
    uint8_t);
  uint8_t implicit_rejection_shared_secret[32U];
  libcrux_kyber_hash_functions_PRF___32size_t(Eurydice_array_to_slice((size_t)800U,
      to_hash,
      uint8_t),
    implicit_rejection_shared_secret);
  Eurydice_slice uu____5 = ind_cpa_public_key;
  uint8_t uu____6[32U];
  memcpy(uu____6, decrypted, (size_t)32U * sizeof (uint8_t));
  uint8_t expected_ciphertext[768U];
  uint8_t uu____7[768U];
  memcpy(uu____7,
    libcrux_kyber_ind_cpa_encrypt___2size_t_768size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t(uu____5,
      uu____6,
      pseudorandomness).fst,
    (size_t)768U * sizeof (uint8_t));
  memcpy(expected_ciphertext, uu____7, (size_t)768U * sizeof (uint8_t));
  Eurydice_slice
  uu____8 =
    libcrux_kyber_types__libcrux_kyber__types__KyberCiphertext_SIZE__1__as_ref___768size_t(ciphertext);
  uint8_t
  selector =
    libcrux_kyber_constant_time_ops_compare_ciphertexts_in_constant_time___768size_t(uu____8,
      Eurydice_array_to_slice((size_t)768U, expected_ciphertext, uint8_t));
  Eurydice_slice uu____9 = shared_secret;
  uint8_t ret0[32U];
  libcrux_kyber_constant_time_ops_select_shared_secret_in_constant_time(uu____9,
    Eurydice_array_to_slice((size_t)32U, implicit_rejection_shared_secret, uint8_t),
    selector,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

void
libcrux_kyber_kyber512_decapsulate_512(
  uint8_t (*secret_key)[1632U],
  uint8_t (*ciphertext)[768U],
  uint8_t ret[32U]
)
{
  uint8_t ret0[32U];
  libcrux_kyber_decapsulate___2size_t_1632size_t_768size_t_800size_t_768size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t_800size_t(secret_key,
    ciphertext,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

const size_t libcrux_kyber_kyber768_RANK_768 = (size_t)3U;

const
size_t
libcrux_kyber_kyber768_RANKED_BYTES_PER_RING_ELEMENT_768 =
  libcrux_kyber_kyber768_RANK_768
  * libcrux_kyber_constants_BITS_PER_RING_ELEMENT
  / (size_t)8U;

const
size_t
libcrux_kyber_kyber768_T_AS_NTT_ENCODED_SIZE_768 =
  libcrux_kyber_kyber768_RANK_768
  * libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT
  * libcrux_kyber_constants_BITS_PER_COEFFICIENT
  / (size_t)8U;

const size_t libcrux_kyber_kyber768_VECTOR_U_COMPRESSION_FACTOR_768 = (size_t)10U;

const
size_t
libcrux_kyber_kyber768_C1_BLOCK_SIZE_768 =
  libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT
  * libcrux_kyber_kyber768_VECTOR_U_COMPRESSION_FACTOR_768
  / (size_t)8U;

const
size_t
libcrux_kyber_kyber768_C1_SIZE_768 =
  libcrux_kyber_kyber768_C1_BLOCK_SIZE_768
  * libcrux_kyber_kyber768_RANK_768;

const size_t libcrux_kyber_kyber768_VECTOR_V_COMPRESSION_FACTOR_768 = (size_t)4U;

const
size_t
libcrux_kyber_kyber768_C2_SIZE_768 =
  libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT
  * libcrux_kyber_kyber768_VECTOR_V_COMPRESSION_FACTOR_768
  / (size_t)8U;

const
size_t
libcrux_kyber_kyber768_CPA_PKE_SECRET_KEY_SIZE_768 =
  libcrux_kyber_kyber768_RANK_768
  * libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT
  * libcrux_kyber_constants_BITS_PER_COEFFICIENT
  / (size_t)8U;

const
size_t
libcrux_kyber_kyber768_CPA_PKE_PUBLIC_KEY_SIZE_768 =
  libcrux_kyber_kyber768_T_AS_NTT_ENCODED_SIZE_768
  + (size_t)32U;

const
size_t
libcrux_kyber_kyber768_CPA_PKE_CIPHERTEXT_SIZE_768 =
  libcrux_kyber_kyber768_C1_SIZE_768
  + libcrux_kyber_kyber768_C2_SIZE_768;

const
size_t
libcrux_kyber_kyber768_SECRET_KEY_SIZE_768 =
  libcrux_kyber_kyber768_CPA_PKE_SECRET_KEY_SIZE_768
  + libcrux_kyber_kyber768_CPA_PKE_PUBLIC_KEY_SIZE_768
  + libcrux_kyber_constants_H_DIGEST_SIZE
  + libcrux_kyber_constants_SHARED_SECRET_SIZE;

const size_t libcrux_kyber_kyber768_ETA1 = (size_t)2U;

const
size_t
libcrux_kyber_kyber768_ETA1_RANDOMNESS_SIZE = libcrux_kyber_kyber768_ETA1 * (size_t)64U;

const size_t libcrux_kyber_kyber768_ETA2 = (size_t)2U;

const
size_t
libcrux_kyber_kyber768_ETA2_RANDOMNESS_SIZE = libcrux_kyber_kyber768_ETA2 * (size_t)64U;

const
size_t
libcrux_kyber_kyber768_IMPLICIT_REJECTION_HASH_INPUT_SIZE =
  libcrux_kyber_constants_SHARED_SECRET_SIZE
  + libcrux_kyber_kyber768_CPA_PKE_CIPHERTEXT_SIZE_768;

void
libcrux_kyber_hash_functions_XOFx4___3size_t(uint8_t input[3U][34U], uint8_t ret[3U][840U])
{
  uint8_t out[3U][840U];
  uint8_t buf0[840U] = { 0U };
  uint8_t buf1[840U] = { 0U };
  uint8_t buf[840U] = { 0U };
  uint8_t buf2[3U][840U] = { buf0, buf1, buf };
  memcpy(out, buf2, (size_t)3U * sizeof (uint8_t [840U]));
  bool uu____0;
  if (!libcrux_platform_simd256_support())
    uu____0 = true;
  else
    uu____0 = !false;
  if (uu____0)
  {
    core_ops_range_Range__size_t lit;
    lit.start = (size_t)0U;
    lit.end = (size_t)3U;
    core_ops_range_Range__size_t
    iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
    while (true)
    {
      core_option_Option__size_t
      uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
      if (!(uu____1.tag == core_option_None))
      {
        if (uu____1.tag == core_option_Some)
        {
          size_t i = uu____1.f0;
          uint8_t uu____2[840U];
          libcrux_digest_shake128((size_t)840U,
            Eurydice_array_to_slice((size_t)34U, input[i], uint8_t),
            uu____2);
          out[i] = uu____2;
        }
        else
        {
          KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
          KRML_HOST_EXIT(255U);
        }
      }
    }
  }
  else if ((size_t)3U == (size_t)2U)
  {
    Eurydice_slice uu____3 = Eurydice_array_to_slice((size_t)34U, input[0U], uint8_t);
    Eurydice_slice uu____4 = Eurydice_array_to_slice((size_t)34U, input[1U], uint8_t);
    Eurydice_slice uu____5 = Eurydice_array_to_slice((size_t)34U, input[0U], uint8_t);
    __uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t_
    uu____6 =
      libcrux_digest_shake128x4((size_t)840U,
        uu____3,
        uu____4,
        uu____5,
        Eurydice_array_to_slice((size_t)34U, input[1U], uint8_t));
    uint8_t d0[840U];
    uint8_t uu____7[840U];
    memcpy(uu____7, uu____6.fst, (size_t)840U * sizeof (uint8_t));
    memcpy(d0, uu____7, (size_t)840U * sizeof (uint8_t));
    uint8_t d1[840U];
    uint8_t uu____8[840U];
    memcpy(uu____8, uu____6.snd, (size_t)840U * sizeof (uint8_t));
    memcpy(d1, uu____8, (size_t)840U * sizeof (uint8_t));
    uint8_t uu____9[840U];
    memcpy(uu____9, d0, (size_t)840U * sizeof (uint8_t));
    out[0U] = uu____9;
    uint8_t uu____10[840U];
    memcpy(uu____10, d1, (size_t)840U * sizeof (uint8_t));
    out[1U] = uu____10;
  }
  else if ((size_t)3U == (size_t)3U)
  {
    Eurydice_slice uu____11 = Eurydice_array_to_slice((size_t)34U, input[0U], uint8_t);
    Eurydice_slice uu____12 = Eurydice_array_to_slice((size_t)34U, input[1U], uint8_t);
    Eurydice_slice uu____13 = Eurydice_array_to_slice((size_t)34U, input[2U], uint8_t);
    __uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t_
    uu____14 =
      libcrux_digest_shake128x4((size_t)840U,
        uu____11,
        uu____12,
        uu____13,
        Eurydice_array_to_slice((size_t)34U, input[0U], uint8_t));
    uint8_t d0[840U];
    uint8_t uu____15[840U];
    memcpy(uu____15, uu____14.fst, (size_t)840U * sizeof (uint8_t));
    memcpy(d0, uu____15, (size_t)840U * sizeof (uint8_t));
    uint8_t d1[840U];
    uint8_t uu____16[840U];
    memcpy(uu____16, uu____14.snd, (size_t)840U * sizeof (uint8_t));
    memcpy(d1, uu____16, (size_t)840U * sizeof (uint8_t));
    uint8_t d2[840U];
    uint8_t uu____17[840U];
    memcpy(uu____17, uu____14.thd, (size_t)840U * sizeof (uint8_t));
    memcpy(d2, uu____17, (size_t)840U * sizeof (uint8_t));
    uint8_t uu____18[840U];
    memcpy(uu____18, d0, (size_t)840U * sizeof (uint8_t));
    out[0U] = uu____18;
    uint8_t uu____19[840U];
    memcpy(uu____19, d1, (size_t)840U * sizeof (uint8_t));
    out[1U] = uu____19;
    uint8_t uu____20[840U];
    memcpy(uu____20, d2, (size_t)840U * sizeof (uint8_t));
    out[2U] = uu____20;
  }
  else if ((size_t)3U == (size_t)4U)
  {
    Eurydice_slice uu____21 = Eurydice_array_to_slice((size_t)34U, input[0U], uint8_t);
    Eurydice_slice uu____22 = Eurydice_array_to_slice((size_t)34U, input[1U], uint8_t);
    Eurydice_slice uu____23 = Eurydice_array_to_slice((size_t)34U, input[2U], uint8_t);
    __uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t__uint8_t_840size_t_
    uu____24 =
      libcrux_digest_shake128x4((size_t)840U,
        uu____21,
        uu____22,
        uu____23,
        Eurydice_array_to_slice((size_t)34U, input[3U], uint8_t));
    uint8_t d0[840U];
    uint8_t uu____25[840U];
    memcpy(uu____25, uu____24.fst, (size_t)840U * sizeof (uint8_t));
    memcpy(d0, uu____25, (size_t)840U * sizeof (uint8_t));
    uint8_t d1[840U];
    uint8_t uu____26[840U];
    memcpy(uu____26, uu____24.snd, (size_t)840U * sizeof (uint8_t));
    memcpy(d1, uu____26, (size_t)840U * sizeof (uint8_t));
    uint8_t d2[840U];
    uint8_t uu____27[840U];
    memcpy(uu____27, uu____24.thd, (size_t)840U * sizeof (uint8_t));
    memcpy(d2, uu____27, (size_t)840U * sizeof (uint8_t));
    uint8_t d3[840U];
    uint8_t uu____28[840U];
    memcpy(uu____28, uu____24.f3, (size_t)840U * sizeof (uint8_t));
    memcpy(d3, uu____28, (size_t)840U * sizeof (uint8_t));
    uint8_t uu____29[840U];
    memcpy(uu____29, d0, (size_t)840U * sizeof (uint8_t));
    out[0U] = uu____29;
    uint8_t uu____30[840U];
    memcpy(uu____30, d1, (size_t)840U * sizeof (uint8_t));
    out[1U] = uu____30;
    uint8_t uu____31[840U];
    memcpy(uu____31, d2, (size_t)840U * sizeof (uint8_t));
    out[2U] = uu____31;
    uint8_t uu____32[840U];
    memcpy(uu____32, d3, (size_t)840U * sizeof (uint8_t));
    out[3U] = uu____32;
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
    KRML_HOST_EXIT(255U);
  }
  uint8_t uu____33[3U][840U];
  memcpy(uu____33, out, (size_t)3U * sizeof (uint8_t [840U]));
  memcpy(ret, uu____33, (size_t)3U * sizeof (uint8_t [840U]));
}

K___libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__3size_t__core_option_Option__libcrux_kyber_types_Error
libcrux_kyber_matrix_sample_matrix_A___3size_t(uint8_t seed[34U], bool transpose)
{
  int32_t A_transpose[3U][3U][256U];
  int32_t
  buf0[3U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  int32_t
  buf1[3U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  int32_t
  buf2[3U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  int32_t buf3[3U][3U][256U] = { buf0, buf1, buf2 };
  memcpy(A_transpose, buf3, (size_t)3U * sizeof (int32_t [3U][256U]));
  core_option_Option__libcrux_kyber_types_Error sampling_A_error;
  sampling_A_error.tag = core_option_None;
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = (size_t)3U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        uint8_t uu____1[34U];
        memcpy(uu____1, seed, (size_t)34U * sizeof (uint8_t));
        uint8_t seeds[3U][34U];
        uint8_t buf[3U][34U] = { uu____1, uu____1, uu____1 };
        memcpy(seeds, buf, (size_t)3U * sizeof (uint8_t [34U]));
        core_ops_range_Range__size_t lit0;
        lit0.start = (size_t)0U;
        lit0.end = (size_t)3U;
        core_ops_range_Range__size_t
        iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____2 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
          if (uu____2.tag == core_option_None)
            break;
          else if (uu____2.tag == core_option_Some)
          {
            size_t j = uu____2.f0;
            seeds[j][32U] = (uint8_t)i;
            seeds[j][33U] = (uint8_t)j;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        uint8_t uu____3[3U][34U];
        memcpy(uu____3, seeds, (size_t)3U * sizeof (uint8_t [34U]));
        uint8_t xof_bytes[3U][840U];
        libcrux_kyber_hash_functions_XOFx4___3size_t(uu____3, xof_bytes);
        core_ops_range_Range__size_t lit;
        lit.start = (size_t)0U;
        lit.end = (size_t)3U;
        core_ops_range_Range__size_t
        iter0 = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____4 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
          if (uu____4.tag == core_option_None)
            break;
          else if (uu____4.tag == core_option_Some)
          {
            size_t j = uu____4.f0;
            uint8_t uu____5[840U];
            memcpy(uu____5, xof_bytes[j], (size_t)840U * sizeof (uint8_t));
            K___libcrux_kyber_arithmetic_PolynomialRingElement_core_option_Option_libcrux_kyber_types_Error
            uu____6 = libcrux_kyber_sampling_sample_from_uniform_distribution___840size_t(uu____5);
            int32_t sampled[256U];
            memcpy(sampled, uu____6.fst, (size_t)256U * sizeof (int32_t));
            core_option_Option__libcrux_kyber_types_Error error = uu____6.snd;
            if (core_option__core__option__Option_T___is_some(&error, libcrux_kyber_types_Error))
              sampling_A_error = error;
            if (transpose)
              memcpy(A_transpose[j][i], sampled, (size_t)256U * sizeof (int32_t));
            else
              memcpy(A_transpose[i][j], sampled, (size_t)256U * sizeof (int32_t));
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____7[3U][3U][256U];
    memcpy(uu____7, A_transpose, (size_t)3U * sizeof (int32_t [3U][256U]));
    K___libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__3size_t__core_option_Option__libcrux_kyber_types_Error
    lit;
    memcpy(lit.fst, uu____7, (size_t)3U * sizeof (int32_t [3U][256U]));
    lit.snd = sampling_A_error;
    return lit;
  }
}

K___libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__uint8_t
libcrux_kyber_ind_cpa_sample_vector_cbd_then_ntt___3size_t_2size_t_128size_t(
  uint8_t prf_input[33U],
  uint8_t domain_separator
)
{
  int32_t re_as_ntt[3U][256U];
  int32_t
  buf[3U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  memcpy(re_as_ntt, buf, (size_t)3U * sizeof (int32_t [256U]));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = (size_t)3U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        prf_input[32U] = domain_separator;
        domain_separator = (uint32_t)domain_separator + 1U;
        uint8_t prf_output[128U];
        libcrux_kyber_hash_functions_PRF___128size_t(Eurydice_array_to_slice((size_t)33U,
            prf_input,
            uint8_t),
          prf_output);
        int32_t r[256U];
        libcrux_kyber_sampling_sample_from_binomial_distribution___2size_t(Eurydice_array_to_slice((size_t)128U,
            prf_output,
            uint8_t),
          r);
        int32_t uu____1[256U];
        libcrux_kyber_ntt_ntt_binomially_sampled_ring_element(r, uu____1);
        memcpy(re_as_ntt[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[3U][256U];
    memcpy(uu____2, re_as_ntt, (size_t)3U * sizeof (int32_t [256U]));
    K___libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__uint8_t lit;
    memcpy(lit.fst, uu____2, (size_t)3U * sizeof (int32_t [256U]));
    lit.snd = domain_separator;
    return lit;
  }
}

void
libcrux_kyber_arithmetic_add_to_ring_element___3size_t(
  int32_t lhs[256U],
  int32_t (*rhs)[256U],
  int32_t ret[256U]
)
{
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)256U, lhs, int32_t),
      int32_t);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        size_t uu____1 = i;
        lhs[uu____1] = lhs[uu____1] + rhs[0U][i];
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, lhs, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_matrix_compute_As_plus_e___3size_t(
  int32_t (*matrix_A)[3U][256U],
  int32_t (*s_as_ntt)[256U],
  int32_t (*error_as_ntt)[256U],
  int32_t ret[3U][256U]
)
{
  int32_t result[3U][256U];
  int32_t
  buf[3U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  memcpy(result, buf, (size_t)3U * sizeof (int32_t [256U]));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)3U,
        matrix_A,
        Eurydice_error_t_cg_array),
      int32_t [3U][256U]);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        core_ops_range_Range__size_t lit;
        lit.start = (size_t)0U;
        lit.end =
          core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)3U,
              matrix_A[i],
              int32_t [256U]),
            int32_t [256U]);
        core_ops_range_Range__size_t
        iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
          if (uu____1.tag == core_option_None)
            break;
          else if (uu____1.tag == core_option_Some)
          {
            size_t j = uu____1.f0;
            int32_t product[256U];
            libcrux_kyber_ntt_ntt_multiply(&matrix_A[i][j], &s_as_ntt[j], product);
            int32_t uu____2[256U];
            libcrux_kyber_arithmetic_add_to_ring_element___3size_t(result[i], &product, uu____2);
            memcpy(result[i], uu____2, (size_t)256U * sizeof (int32_t));
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        core_ops_range_Range__size_t lit0;
        lit0.start = (size_t)0U;
        lit0.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
        core_ops_range_Range__size_t
        iter0 = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____3 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
          if (uu____3.tag == core_option_None)
            break;
          else if (uu____3.tag == core_option_Some)
          {
            size_t j = uu____3.f0;
            int32_t
            coefficient_normal_form = libcrux_kyber_arithmetic_to_standard_domain(result[i][j]);
            int32_t
            uu____4 =
              libcrux_kyber_arithmetic_barrett_reduce(coefficient_normal_form + error_as_ntt[i][j]);
            result[i][j] = uu____4;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____5[3U][256U];
    memcpy(uu____5, result, (size_t)3U * sizeof (int32_t [256U]));
    memcpy(ret, uu____5, (size_t)3U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_ind_cpa_serialize_secret_key___3size_t_1152size_t(
  int32_t key[3U][256U],
  uint8_t ret[1152U]
)
{
  uint8_t out[1152U];
  uint8_t buf[1152U] = { 0U };
  memcpy(out, buf, (size_t)1152U * sizeof (uint8_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)3U, key, int32_t [256U]),
      int32_t [256U]);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t re[256U];
        memcpy(re, key[i], (size_t)256U * sizeof (int32_t));
        core_ops_range_Range__size_t lit;
        lit.start = i * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        lit.end = (i + (size_t)1U) * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        Eurydice_slice
        uu____1 =
          Eurydice_array_to_subslice((size_t)1152U,
            out,
            lit,
            uint8_t,
            core_ops_range_Range__size_t);
        uint8_t ret[384U];
        libcrux_kyber_serialize_serialize_uncompressed_ring_element(re, ret);
        core_slice___Slice_T___copy_from_slice(uu____1,
          Eurydice_array_to_slice((size_t)384U, ret, uint8_t),
          uint8_t);
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____2[1152U];
    memcpy(uu____2, out, (size_t)1152U * sizeof (uint8_t));
    memcpy(ret, uu____2, (size_t)1152U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_ind_cpa_serialize_public_key___3size_t_1152size_t_1184size_t(
  int32_t t_as_ntt[3U][256U],
  Eurydice_slice seed_for_a,
  uint8_t ret[1184U]
)
{
  uint8_t public_key_serialized[1184U];
  uint8_t buf[1184U] = { 0U };
  memcpy(public_key_serialized, buf, (size_t)1184U * sizeof (uint8_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)1152U;
  Eurydice_slice
  uu____0 =
    Eurydice_array_to_subslice((size_t)1184U,
      public_key_serialized,
      lit,
      uint8_t,
      core_ops_range_Range__size_t);
  int32_t uu____1[3U][256U];
  memcpy(uu____1, t_as_ntt, (size_t)3U * sizeof (int32_t [256U]));
  uint8_t ret0[1152U];
  libcrux_kyber_ind_cpa_serialize_secret_key___3size_t_1152size_t(uu____1, ret0);
  core_slice___Slice_T___copy_from_slice(uu____0,
    Eurydice_array_to_slice((size_t)1152U, ret0, uint8_t),
    uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice_from((size_t)1184U,
      public_key_serialized,
      (size_t)1152U,
      uint8_t,
      size_t),
    seed_for_a,
    uint8_t);
  uint8_t uu____2[1184U];
  memcpy(uu____2, public_key_serialized, (size_t)1184U * sizeof (uint8_t));
  memcpy(ret, uu____2, (size_t)1184U * sizeof (uint8_t));
}

K___uint8_t_1152size_t____uint8_t_1184size_t__core_option_Option__libcrux_kyber_types_Error
libcrux_kyber_ind_cpa_generate_keypair___3size_t_1152size_t_1184size_t_1152size_t_2size_t_128size_t(
  Eurydice_slice key_generation_seed
)
{
  uint8_t hashed[64U];
  libcrux_kyber_hash_functions_G(key_generation_seed, hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____0 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U, hashed, uint8_t),
      (size_t)32U,
      uint8_t);
  Eurydice_slice seed_for_A = uu____0.fst;
  Eurydice_slice seed_for_secret_and_error = uu____0.snd;
  uint8_t ret[34U];
  libcrux_kyber_ind_cpa_into_padded_array___34size_t(seed_for_A, ret);
  K___libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__3size_t__core_option_Option__libcrux_kyber_types_Error
  uu____1 = libcrux_kyber_matrix_sample_matrix_A___3size_t(ret, true);
  int32_t A_transpose[3U][3U][256U];
  int32_t uu____2[3U][3U][256U];
  memcpy(uu____2, uu____1.fst, (size_t)3U * sizeof (int32_t [3U][256U]));
  memcpy(A_transpose, uu____2, (size_t)3U * sizeof (int32_t [3U][256U]));
  core_option_Option__libcrux_kyber_types_Error sampling_A_error = uu____1.snd;
  uint8_t prf_input[33U];
  libcrux_kyber_ind_cpa_into_padded_array___33size_t(seed_for_secret_and_error, prf_input);
  uint8_t uu____3[33U];
  memcpy(uu____3, prf_input, (size_t)33U * sizeof (uint8_t));
  K___libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__uint8_t
  uu____4 =
    libcrux_kyber_ind_cpa_sample_vector_cbd_then_ntt___3size_t_2size_t_128size_t(uu____3,
      0U);
  int32_t secret_as_ntt[3U][256U];
  int32_t uu____5[3U][256U];
  memcpy(uu____5, uu____4.fst, (size_t)3U * sizeof (int32_t [256U]));
  memcpy(secret_as_ntt, uu____5, (size_t)3U * sizeof (int32_t [256U]));
  uint8_t domain_separator = uu____4.snd;
  uint8_t uu____6[33U];
  memcpy(uu____6, prf_input, (size_t)33U * sizeof (uint8_t));
  int32_t error_as_ntt[3U][256U];
  int32_t uu____7[3U][256U];
  memcpy(uu____7,
    libcrux_kyber_ind_cpa_sample_vector_cbd_then_ntt___3size_t_2size_t_128size_t(uu____6,
      domain_separator).fst,
    (size_t)3U * sizeof (int32_t [256U]));
  memcpy(error_as_ntt, uu____7, (size_t)3U * sizeof (int32_t [256U]));
  int32_t t_as_ntt[3U][256U];
  libcrux_kyber_matrix_compute_As_plus_e___3size_t(A_transpose,
    secret_as_ntt,
    error_as_ntt,
    t_as_ntt);
  int32_t uu____8[3U][256U];
  memcpy(uu____8, t_as_ntt, (size_t)3U * sizeof (int32_t [256U]));
  uint8_t public_key_serialized[1184U];
  libcrux_kyber_ind_cpa_serialize_public_key___3size_t_1152size_t_1184size_t(uu____8,
    seed_for_A,
    public_key_serialized);
  int32_t uu____9[3U][256U];
  memcpy(uu____9, secret_as_ntt, (size_t)3U * sizeof (int32_t [256U]));
  uint8_t secret_key_serialized[1152U];
  libcrux_kyber_ind_cpa_serialize_secret_key___3size_t_1152size_t(uu____9,
    secret_key_serialized);
  uint8_t uu____10[1152U];
  memcpy(uu____10, secret_key_serialized, (size_t)1152U * sizeof (uint8_t));
  uint8_t uu____11[1184U];
  memcpy(uu____11, public_key_serialized, (size_t)1184U * sizeof (uint8_t));
  K___uint8_t_1152size_t____uint8_t_1184size_t__core_option_Option__libcrux_kyber_types_Error
  lit;
  memcpy(lit.fst.fst, uu____10, (size_t)1152U * sizeof (uint8_t));
  memcpy(lit.fst.snd, uu____11, (size_t)1184U * sizeof (uint8_t));
  lit.snd = sampling_A_error;
  return lit;
}

void
libcrux_kyber_serialize_kem_secret_key___2400size_t(
  Eurydice_slice private_key,
  Eurydice_slice public_key,
  Eurydice_slice implicit_rejection_value,
  uint8_t ret[2400U]
)
{
  uint8_t out[2400U];
  uint8_t buf[2400U] = { 0U };
  memcpy(out, buf, (size_t)2400U * sizeof (uint8_t));
  size_t pointer = (size_t)0U;
  uint8_t *uu____0 = out;
  size_t uu____1 = pointer;
  core_ops_range_Range__size_t lit0;
  lit0.start = pointer;
  lit0.end = uu____1 + core_slice___Slice_T___len(private_key, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)2400U,
      uu____0,
      lit0,
      uint8_t,
      core_ops_range_Range__size_t),
    private_key,
    uint8_t);
  pointer = pointer + core_slice___Slice_T___len(private_key, uint8_t);
  uint8_t *uu____2 = out;
  size_t uu____3 = pointer;
  core_ops_range_Range__size_t lit1;
  lit1.start = pointer;
  lit1.end = uu____3 + core_slice___Slice_T___len(public_key, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)2400U,
      uu____2,
      lit1,
      uint8_t,
      core_ops_range_Range__size_t),
    public_key,
    uint8_t);
  pointer = pointer + core_slice___Slice_T___len(public_key, uint8_t);
  core_ops_range_Range__size_t lit2;
  lit2.start = pointer;
  lit2.end = pointer + libcrux_kyber_constants_H_DIGEST_SIZE;
  Eurydice_slice
  uu____4 =
    Eurydice_array_to_subslice((size_t)2400U,
      out,
      lit2,
      uint8_t,
      core_ops_range_Range__size_t);
  uint8_t ret0[32U];
  libcrux_kyber_hash_functions_H(public_key, ret0);
  core_slice___Slice_T___copy_from_slice(uu____4,
    Eurydice_array_to_slice((size_t)32U, ret0, uint8_t),
    uint8_t);
  pointer = pointer + libcrux_kyber_constants_H_DIGEST_SIZE;
  uint8_t *uu____5 = out;
  size_t uu____6 = pointer;
  core_ops_range_Range__size_t lit;
  lit.start = pointer;
  lit.end = uu____6 + core_slice___Slice_T___len(implicit_rejection_value, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)2400U,
      uu____5,
      lit,
      uint8_t,
      core_ops_range_Range__size_t),
    implicit_rejection_value,
    uint8_t);
  uint8_t uu____7[2400U];
  memcpy(uu____7, out, (size_t)2400U * sizeof (uint8_t));
  memcpy(ret, uu____7, (size_t)2400U * sizeof (uint8_t));
}

void
libcrux_kyber_types__libcrux_kyber__types__KyberPrivateKey_SIZE__8__from___2400size_t(
  uint8_t value[2400U],
  uint8_t ret[2400U]
)
{
  uint8_t uu____0[2400U];
  memcpy(uu____0, value, (size_t)2400U * sizeof (uint8_t));
  memcpy(ret, uu____0, (size_t)2400U * sizeof (uint8_t));
}

libcrux_kyber_types_KyberKeyPair___2400size_t_1184size_t
libcrux_kyber_types__libcrux_kyber__types__KyberKeyPair_PRIVATE_KEY_SIZE__PUBLIC_KEY_SIZE___from___2400size_t_1184size_t(
  uint8_t sk[2400U],
  uint8_t pk[1184U]
)
{
  libcrux_kyber_types_KyberKeyPair___2400size_t_1184size_t lit;
  memcpy(lit.sk, sk, (size_t)2400U * sizeof (uint8_t));
  memcpy(lit.pk, pk, (size_t)1184U * sizeof (uint8_t));
  return lit;
}

core_result_Result__libcrux_kyber_types_KyberKeyPair__1184size_t____2400size_t___libcrux_kyber_types_Error
libcrux_kyber_generate_keypair___3size_t_1152size_t_2400size_t_1184size_t_1152size_t_2size_t_128size_t(
  uint8_t randomness[64U]
)
{
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = libcrux_kyber_constants_CPA_PKE_KEY_GENERATION_SEED_SIZE;
  Eurydice_slice
  ind_cpa_keypair_randomness =
    Eurydice_array_to_subslice((size_t)64U,
      randomness,
      lit0,
      uint8_t,
      core_ops_range_Range__size_t);
  Eurydice_slice
  implicit_rejection_value =
    Eurydice_array_to_subslice_from((size_t)64U,
      randomness,
      libcrux_kyber_constants_CPA_PKE_KEY_GENERATION_SEED_SIZE,
      uint8_t,
      size_t);
  K___uint8_t_1152size_t____uint8_t_1184size_t__core_option_Option__libcrux_kyber_types_Error
  uu____0 =
    libcrux_kyber_ind_cpa_generate_keypair___3size_t_1152size_t_1184size_t_1152size_t_2size_t_128size_t(ind_cpa_keypair_randomness);
  uint8_t ind_cpa_private_key[1152U];
  uint8_t uu____1[1152U];
  memcpy(uu____1, uu____0.fst.fst, (size_t)1152U * sizeof (uint8_t));
  memcpy(ind_cpa_private_key, uu____1, (size_t)1152U * sizeof (uint8_t));
  uint8_t public_key[1184U];
  uint8_t uu____2[1184U];
  memcpy(uu____2, uu____0.fst.snd, (size_t)1184U * sizeof (uint8_t));
  memcpy(public_key, uu____2, (size_t)1184U * sizeof (uint8_t));
  core_option_Option__libcrux_kyber_types_Error sampling_a_error = uu____0.snd;
  Eurydice_slice uu____3 = Eurydice_array_to_slice((size_t)1152U, ind_cpa_private_key, uint8_t);
  uint8_t secret_key_serialized[2400U];
  libcrux_kyber_serialize_kem_secret_key___2400size_t(uu____3,
    Eurydice_array_to_slice((size_t)1184U, public_key, uint8_t),
    implicit_rejection_value,
    secret_key_serialized);
  core_result_Result__libcrux_kyber_types_KyberKeyPair__1184size_t____2400size_t___libcrux_kyber_types_Error
  uu____4;
  if (sampling_a_error.tag == core_option_Some)
  {
    libcrux_kyber_types_Error error = sampling_a_error.f0;
    core_result_Result__libcrux_kyber_types_KyberKeyPair__1184size_t____2400size_t___libcrux_kyber_types_Error
    lit;
    lit.tag = core_result_Err;
    lit.val.case_Err = error;
    uu____4 = lit;
  }
  else
  {
    uint8_t uu____5[2400U];
    memcpy(uu____5, secret_key_serialized, (size_t)2400U * sizeof (uint8_t));
    uint8_t private_key[2400U];
    libcrux_kyber_types__libcrux_kyber__types__KyberPrivateKey_SIZE__8__from___2400size_t(uu____5,
      private_key);
    uint8_t uu____6[2400U];
    memcpy(uu____6, private_key, (size_t)2400U * sizeof (uint8_t));
    uint8_t uu____7[1184U];
    memcpy(uu____7, public_key, (size_t)1184U * sizeof (uint8_t));
    core_result_Result__libcrux_kyber_types_KyberKeyPair__1184size_t____2400size_t___libcrux_kyber_types_Error
    lit;
    lit.tag = core_result_Ok;
    lit.val.case_Ok =
      libcrux_kyber_types__libcrux_kyber__types__KyberKeyPair_PRIVATE_KEY_SIZE__PUBLIC_KEY_SIZE___from___2400size_t_1184size_t(uu____6,
        uu____7);
    uu____4 = lit;
  }
  return uu____4;
}

core_result_Result__libcrux_kyber_types_KyberKeyPair__1184size_t____2400size_t___libcrux_kyber_types_Error
libcrux_kyber_kyber768_generate_key_pair_768(uint8_t randomness[64U])
{
  uint8_t uu____0[64U];
  memcpy(uu____0, randomness, (size_t)64U * sizeof (uint8_t));
  return
    libcrux_kyber_generate_keypair___3size_t_1152size_t_2400size_t_1184size_t_1152size_t_2size_t_128size_t(uu____0);
}

uint8_t
*libcrux_kyber_types__libcrux_kyber__types__KyberPublicKey_SIZE__18__as_slice___1184size_t(
  uint8_t (*self)[1184U]
)
{
  return self[0U];
}

void
libcrux_kyber_ind_cpa_deserialize_public_key___3size_t_1152size_t(
  Eurydice_slice public_key,
  int32_t ret[3U][256U]
)
{
  int32_t t_as_ntt[3U][256U];
  int32_t
  buf[3U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  memcpy(t_as_ntt, buf, (size_t)3U * sizeof (int32_t [256U]));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = (size_t)1152U / libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        core_ops_range_Range__size_t lit;
        lit.start = i * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        lit.end = i * (libcrux_kyber_constants_BYTES_PER_RING_ELEMENT + (size_t)1U);
        Eurydice_slice
        t_as_ntt_bytes =
          Eurydice_slice_subslice(public_key,
            lit,
            uint8_t,
            core_ops_range_Range__size_t);
        int32_t uu____1[256U];
        libcrux_kyber_serialize_deserialize_to_uncompressed_ring_element(t_as_ntt_bytes, uu____1);
        memcpy(t_as_ntt[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[3U][256U];
    memcpy(uu____2, t_as_ntt, (size_t)3U * sizeof (int32_t [256U]));
    memcpy(ret, uu____2, (size_t)3U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_ind_cpa_sample_ring_element_cbd___3size_t_128size_t_2size_t(
  uint8_t *prf_input,
  uint8_t *domain_separator,
  int32_t ret[3U][256U]
)
{
  int32_t error_1[3U][256U];
  int32_t
  buf[3U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  memcpy(error_1, buf, (size_t)3U * sizeof (int32_t [256U]));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)3U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        prf_input[32U] = domain_separator[0U];
        domain_separator[0U] = (uint32_t)domain_separator[0U] + 1U;
        uint8_t prf_output[128U];
        libcrux_kyber_hash_functions_PRF___128size_t(Eurydice_array_to_slice((size_t)33U,
            prf_input,
            uint8_t),
          prf_output);
        int32_t uu____1[256U];
        libcrux_kyber_sampling_sample_from_binomial_distribution___2size_t(Eurydice_array_to_slice((size_t)128U,
            prf_output,
            uint8_t),
          uu____1);
        memcpy(error_1[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[3U][256U];
    memcpy(uu____2, error_1, (size_t)3U * sizeof (int32_t [256U]));
    memcpy(ret, uu____2, (size_t)3U * sizeof (int32_t [256U]));
    return;
  }
}

void libcrux_kyber_ntt_invert_ntt_montgomery___3size_t(int32_t re[256U], int32_t ret[256U])
{
  size_t zeta_i = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT / (size_t)2U;
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)1U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)2U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)3U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)4U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)5U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)6U, re);
  libcrux_kyber_ntt_invert_ntt_at_layer(&zeta_i, re, (size_t)7U, re);
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)8U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t uu____1 = libcrux_kyber_arithmetic_barrett_reduce(re[i]);
        re[i] = uu____1;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, re, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_matrix_compute_vector_u___3size_t(
  int32_t (*a_as_ntt)[3U][256U],
  int32_t (*r_as_ntt)[256U],
  int32_t (*error_1)[256U],
  int32_t ret[3U][256U]
)
{
  int32_t result[3U][256U];
  int32_t
  buf[3U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  memcpy(result, buf, (size_t)3U * sizeof (int32_t [256U]));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)3U,
        a_as_ntt,
        Eurydice_error_t_cg_array),
      int32_t [3U][256U]);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        core_ops_range_Range__size_t lit;
        lit.start = (size_t)0U;
        lit.end =
          core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)3U,
              a_as_ntt[i],
              int32_t [256U]),
            int32_t [256U]);
        core_ops_range_Range__size_t
        iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
          if (uu____1.tag == core_option_None)
            break;
          else if (uu____1.tag == core_option_Some)
          {
            size_t j = uu____1.f0;
            int32_t product[256U];
            libcrux_kyber_ntt_ntt_multiply(&a_as_ntt[i][j], &r_as_ntt[j], product);
            int32_t uu____2[256U];
            libcrux_kyber_arithmetic_add_to_ring_element___3size_t(result[i], &product, uu____2);
            memcpy(result[i], uu____2, (size_t)256U * sizeof (int32_t));
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        int32_t uu____3[256U];
        libcrux_kyber_ntt_invert_ntt_montgomery___3size_t(result[i], uu____3);
        memcpy(result[i], uu____3, (size_t)256U * sizeof (int32_t));
        core_ops_range_Range__size_t lit0;
        lit0.start = (size_t)0U;
        lit0.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
        core_ops_range_Range__size_t
        iter0 = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
        while (true)
        {
          core_option_Option__size_t
          uu____4 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
          if (uu____4.tag == core_option_None)
            break;
          else if (uu____4.tag == core_option_Some)
          {
            size_t j = uu____4.f0;
            int32_t
            coefficient_normal_form =
              libcrux_kyber_arithmetic_montgomery_reduce(result[i][j] * (int32_t)1441);
            int32_t
            uu____5 =
              libcrux_kyber_arithmetic_barrett_reduce(coefficient_normal_form + error_1[i][j]);
            result[i][j] = uu____5;
          }
          else
          {
            KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
            KRML_HOST_EXIT(255U);
          }
        }
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____6[3U][256U];
    memcpy(uu____6, result, (size_t)3U * sizeof (int32_t [256U]));
    memcpy(ret, uu____6, (size_t)3U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_matrix_compute_ring_element_v___3size_t(
  int32_t (*t_as_ntt)[256U],
  int32_t (*r_as_ntt)[256U],
  int32_t (*error_2)[256U],
  int32_t (*message)[256U],
  int32_t ret[256U]
)
{
  int32_t result[256U];
  memcpy(result,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)3U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (uu____0.tag == core_option_None)
      break;
    else if (uu____0.tag == core_option_Some)
    {
      size_t i = uu____0.f0;
      int32_t product[256U];
      libcrux_kyber_ntt_ntt_multiply(&t_as_ntt[i], &r_as_ntt[i], product);
      libcrux_kyber_arithmetic_add_to_ring_element___3size_t(result, &product, result);
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
      KRML_HOST_EXIT(255U);
    }
  }
  libcrux_kyber_ntt_invert_ntt_montgomery___3size_t(result, result);
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter0 = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
    if (!(uu____1.tag == core_option_None))
    {
      if (uu____1.tag == core_option_Some)
      {
        size_t i = uu____1.f0;
        int32_t
        coefficient_normal_form =
          libcrux_kyber_arithmetic_montgomery_reduce(result[i] * (int32_t)1441);
        int32_t
        uu____2 =
          libcrux_kyber_arithmetic_barrett_reduce(coefficient_normal_form
            + error_2[0U][i]
            + message[0U][i]);
        result[i] = uu____2;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, result, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_ind_cpa_compress_then_serialize_u___3size_t_960size_t_10size_t_320size_t(
  int32_t input[3U][256U],
  uint8_t ret[960U]
)
{
  uint8_t out[960U];
  uint8_t buf[960U] = { 0U };
  memcpy(out, buf, (size_t)960U * sizeof (uint8_t));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)3U, input, int32_t [256U]),
      int32_t [256U]);
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t re[256U];
        memcpy(re, input[i], (size_t)256U * sizeof (int32_t));
        core_ops_range_Range__size_t lit;
        lit.start = i * ((size_t)960U / (size_t)3U);
        lit.end = (i + (size_t)1U) * ((size_t)960U / (size_t)3U);
        Eurydice_slice
        uu____1 =
          Eurydice_array_to_subslice((size_t)960U,
            out,
            lit,
            uint8_t,
            core_ops_range_Range__size_t);
        uint8_t ret[320U];
        libcrux_kyber_serialize_compress_then_serialize_ring_element_u___10size_t_320size_t(re,
          ret);
        core_slice___Slice_T___copy_from_slice(uu____1,
          Eurydice_array_to_slice((size_t)320U, ret, uint8_t),
          uint8_t);
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    uint8_t uu____2[960U];
    memcpy(uu____2, out, (size_t)960U * sizeof (uint8_t));
    memcpy(ret, uu____2, (size_t)960U * sizeof (uint8_t));
    return;
  }
}

void
libcrux_kyber_ind_cpa_into_padded_array___1088size_t(Eurydice_slice slice, uint8_t ret[1088U])
{
  if (false)
    LowStar_Ignore_ignore(core_slice___Slice_T___len(slice, uint8_t), size_t);
  uint8_t out[1088U];
  uint8_t buf[1088U] = { 0U };
  memcpy(out, buf, (size_t)1088U * sizeof (uint8_t));
  uint8_t *uu____0 = out;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(slice, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)1088U,
      uu____0,
      lit,
      uint8_t,
      core_ops_range_Range__size_t),
    slice,
    uint8_t);
  uint8_t uu____1[1088U];
  memcpy(uu____1, out, (size_t)1088U * sizeof (uint8_t));
  memcpy(ret, uu____1, (size_t)1088U * sizeof (uint8_t));
}

K___uint8_t_1088size_t__core_option_Option__libcrux_kyber_types_Error
libcrux_kyber_ind_cpa_encrypt___3size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(
  Eurydice_slice public_key,
  uint8_t message[32U],
  Eurydice_slice randomness
)
{
  int32_t t_as_ntt[3U][256U];
  libcrux_kyber_ind_cpa_deserialize_public_key___3size_t_1152size_t(public_key, t_as_ntt);
  Eurydice_slice seed = Eurydice_slice_subslice_from(public_key, (size_t)1152U, uint8_t, size_t);
  uint8_t ret[34U];
  libcrux_kyber_ind_cpa_into_padded_array___34size_t(seed, ret);
  K___libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__3size_t__core_option_Option__libcrux_kyber_types_Error
  uu____0 = libcrux_kyber_matrix_sample_matrix_A___3size_t(ret, false);
  int32_t A_transpose[3U][3U][256U];
  int32_t uu____1[3U][3U][256U];
  memcpy(uu____1, uu____0.fst, (size_t)3U * sizeof (int32_t [3U][256U]));
  memcpy(A_transpose, uu____1, (size_t)3U * sizeof (int32_t [3U][256U]));
  core_option_Option__libcrux_kyber_types_Error sampling_A_error = uu____0.snd;
  uint8_t prf_input[33U];
  libcrux_kyber_ind_cpa_into_padded_array___33size_t(randomness, prf_input);
  uint8_t uu____2[33U];
  memcpy(uu____2, prf_input, (size_t)33U * sizeof (uint8_t));
  K___libcrux_kyber_arithmetic_PolynomialRingElement_3size_t__uint8_t
  uu____3 =
    libcrux_kyber_ind_cpa_sample_vector_cbd_then_ntt___3size_t_2size_t_128size_t(uu____2,
      0U);
  int32_t r_as_ntt[3U][256U];
  int32_t uu____4[3U][256U];
  memcpy(uu____4, uu____3.fst, (size_t)3U * sizeof (int32_t [256U]));
  memcpy(r_as_ntt, uu____4, (size_t)3U * sizeof (int32_t [256U]));
  uint8_t domain_separator = uu____3.snd;
  int32_t error_1[3U][256U];
  libcrux_kyber_ind_cpa_sample_ring_element_cbd___3size_t_128size_t_2size_t(prf_input,
    &domain_separator,
    error_1);
  prf_input[32U] = domain_separator;
  uint8_t prf_output[128U];
  libcrux_kyber_hash_functions_PRF___128size_t(Eurydice_array_to_slice((size_t)33U,
      prf_input,
      uint8_t),
    prf_output);
  int32_t error_2[256U];
  libcrux_kyber_sampling_sample_from_binomial_distribution___2size_t(Eurydice_array_to_slice((size_t)128U,
      prf_output,
      uint8_t),
    error_2);
  int32_t u[3U][256U];
  libcrux_kyber_matrix_compute_vector_u___3size_t(A_transpose, r_as_ntt, error_1, u);
  uint8_t uu____5[32U];
  memcpy(uu____5, message, (size_t)32U * sizeof (uint8_t));
  int32_t message_as_ring_element[256U];
  libcrux_kyber_serialize_deserialize_then_decompress_message(uu____5, message_as_ring_element);
  int32_t v[256U];
  libcrux_kyber_matrix_compute_ring_element_v___3size_t(t_as_ntt,
    r_as_ntt,
    &error_2,
    &message_as_ring_element,
    v);
  int32_t uu____6[3U][256U];
  memcpy(uu____6, u, (size_t)3U * sizeof (int32_t [256U]));
  uint8_t c1[960U];
  libcrux_kyber_ind_cpa_compress_then_serialize_u___3size_t_960size_t_10size_t_320size_t(uu____6,
    c1);
  uint8_t c2[128U];
  libcrux_kyber_serialize_compress_then_serialize_ring_element_v___4size_t_128size_t(v, c2);
  uint8_t ciphertext[1088U];
  libcrux_kyber_ind_cpa_into_padded_array___1088size_t(Eurydice_array_to_slice((size_t)960U,
      c1,
      uint8_t),
    ciphertext);
  Eurydice_slice
  uu____7 =
    Eurydice_array_to_subslice_from((size_t)1088U,
      ciphertext,
      (size_t)960U,
      uint8_t,
      size_t);
  core_slice___Slice_T___copy_from_slice(uu____7,
    core_array___Array_T__N__23__as_slice((size_t)128U, c2, uint8_t),
    uint8_t);
  uint8_t uu____8[1088U];
  memcpy(uu____8, ciphertext, (size_t)1088U * sizeof (uint8_t));
  K___uint8_t_1088size_t__core_option_Option__libcrux_kyber_types_Error lit;
  memcpy(lit.fst, uu____8, (size_t)1088U * sizeof (uint8_t));
  lit.snd = sampling_A_error;
  return lit;
}

core_result_Result__libcrux_kyber_types_KyberCiphertext___1088size_t___uint8_t_32size_t__libcrux_kyber_types_Error
libcrux_kyber_encapsulate___3size_t_1088size_t_1184size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(
  uint8_t (*public_key)[1184U],
  uint8_t randomness[32U]
)
{
  uint8_t to_hash[64U];
  libcrux_kyber_ind_cpa_into_padded_array___64size_t(Eurydice_array_to_slice((size_t)32U,
      randomness,
      uint8_t),
    to_hash);
  Eurydice_slice
  uu____0 =
    Eurydice_array_to_subslice_from((size_t)64U,
      to_hash,
      libcrux_kyber_constants_H_DIGEST_SIZE,
      uint8_t,
      size_t);
  uint8_t ret[32U];
  libcrux_kyber_hash_functions_H(Eurydice_array_to_slice((size_t)1184U,
      libcrux_kyber_types__libcrux_kyber__types__KyberPublicKey_SIZE__18__as_slice___1184size_t(public_key),
      uint8_t),
    ret);
  core_slice___Slice_T___copy_from_slice(uu____0,
    Eurydice_array_to_slice((size_t)32U, ret, uint8_t),
    uint8_t);
  uint8_t hashed[64U];
  libcrux_kyber_hash_functions_G(Eurydice_array_to_slice((size_t)64U, to_hash, uint8_t), hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____1 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U, hashed, uint8_t),
      libcrux_kyber_constants_SHARED_SECRET_SIZE,
      uint8_t);
  Eurydice_slice shared_secret = uu____1.fst;
  Eurydice_slice pseudorandomness = uu____1.snd;
  Eurydice_slice
  uu____2 =
    Eurydice_array_to_slice((size_t)1184U,
      libcrux_kyber_types__libcrux_kyber__types__KyberPublicKey_SIZE__18__as_slice___1184size_t(public_key),
      uint8_t);
  uint8_t uu____3[32U];
  memcpy(uu____3, randomness, (size_t)32U * sizeof (uint8_t));
  K___uint8_t_1088size_t__core_option_Option__libcrux_kyber_types_Error
  uu____4 =
    libcrux_kyber_ind_cpa_encrypt___3size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(uu____2,
      uu____3,
      pseudorandomness);
  uint8_t ciphertext[1088U];
  uint8_t uu____5[1088U];
  memcpy(uu____5, uu____4.fst, (size_t)1088U * sizeof (uint8_t));
  memcpy(ciphertext, uu____5, (size_t)1088U * sizeof (uint8_t));
  core_option_Option__libcrux_kyber_types_Error sampling_a_error = uu____4.snd;
  core_result_Result__libcrux_kyber_types_KyberCiphertext___1088size_t___uint8_t_32size_t__libcrux_kyber_types_Error
  uu____6;
  if (sampling_a_error.tag == core_option_None)
  {
    uint8_t uu____7[1088U];
    memcpy(uu____7, ciphertext, (size_t)1088U * sizeof (uint8_t));
    uint8_t uu____8[1088U];
    memcpy(uu____8, uu____7, (size_t)1088U * sizeof (uint8_t));
    core_result_Result__uint8_t_32size_t__core_array_TryFromSliceError
    uu____9 = Eurydice_slice_to_array(shared_secret, Eurydice_slice, uint8_t [32U]);
    if (uu____9.tag == core_result_Ok)
    {
      uint8_t r[32U];
      uint8_t f0[32U];
      memcpy(f0, uu____9.val.case_Ok, (size_t)32U * sizeof (uint8_t));
      memcpy(r, f0, (size_t)32U * sizeof (uint8_t));
      uint8_t uu____10[32U];
      memcpy(uu____10, r, (size_t)32U * sizeof (uint8_t));
      core_result_Result__libcrux_kyber_types_KyberCiphertext___1088size_t___uint8_t_32size_t__libcrux_kyber_types_Error
      lit;
      lit.tag = core_result_Ok;
      memcpy(lit.val.case_Ok.fst, uu____8, (size_t)1088U * sizeof (uint8_t));
      memcpy(lit.val.case_Ok.snd, uu____10, (size_t)32U * sizeof (uint8_t));
      uu____6 = lit;
    }
    else if (uu____9.tag == core_result_Err)
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
      KRML_HOST_EXIT(255U);
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
      KRML_HOST_EXIT(255U);
    }
  }
  else if (sampling_a_error.tag == core_option_Some)
  {
    libcrux_kyber_types_Error e = sampling_a_error.f0;
    core_result_Result__libcrux_kyber_types_KyberCiphertext___1088size_t___uint8_t_32size_t__libcrux_kyber_types_Error
    lit;
    lit.tag = core_result_Err;
    lit.val.case_Err = e;
    uu____6 = lit;
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
    KRML_HOST_EXIT(255U);
  }
  return uu____6;
}

core_result_Result__libcrux_kyber_types_KyberCiphertext___1088size_t___uint8_t_32size_t__libcrux_kyber_types_Error
libcrux_kyber_kyber768_encapsulate_768(uint8_t (*public_key)[1184U], uint8_t randomness[32U])
{
  uint8_t (*uu____0)[1184U] = public_key;
  uint8_t uu____1[32U];
  memcpy(uu____1, randomness, (size_t)32U * sizeof (uint8_t));
  return
    libcrux_kyber_encapsulate___3size_t_1088size_t_1184size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(uu____0,
      uu____1);
}

K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
libcrux_kyber_types__libcrux_kyber__types__KyberPrivateKey_SIZE__12__split_at___2400size_t(
  uint8_t (*self)[2400U],
  size_t mid
)
{
  return
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)2400U, self[0U], uint8_t),
      mid,
      uint8_t);
}

void
libcrux_kyber_ind_cpa_deserialize_then_decompress_u___3size_t_1088size_t_960size_t_10size_t(
  uint8_t *ciphertext,
  int32_t ret[3U][256U]
)
{
  int32_t u_as_ntt[3U][256U];
  int32_t
  buf[3U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  memcpy(u_as_ntt, buf, (size_t)3U * sizeof (int32_t [256U]));
  size_t
  chunk_size = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT * (size_t)10U / (size_t)8U;
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = (size_t)960U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        core_ops_range_Range__size_t lit;
        lit.start = i * chunk_size;
        lit.end = i * (chunk_size + (size_t)1U);
        Eurydice_slice
        u_bytes =
          Eurydice_array_to_subslice((size_t)1088U,
            ciphertext,
            lit,
            uint8_t,
            core_ops_range_Range__size_t);
        int32_t u[256U];
        libcrux_kyber_serialize_deserialize_then_decompress_ring_element_u___10size_t(u_bytes, u);
        int32_t uu____1[256U];
        libcrux_kyber_ntt_ntt_vector_u___10size_t(u, uu____1);
        memcpy(u_as_ntt[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[3U][256U];
    memcpy(uu____2, u_as_ntt, (size_t)3U * sizeof (int32_t [256U]));
    memcpy(ret, uu____2, (size_t)3U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_ind_cpa_deserialize_secret_key___3size_t(
  Eurydice_slice secret_key,
  int32_t ret[3U][256U]
)
{
  int32_t secret_as_ntt[3U][256U];
  int32_t
  buf[3U][256U] =
    {
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
      libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO
    };
  memcpy(secret_as_ntt, buf, (size_t)3U * sizeof (int32_t [256U]));
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end =
    core_slice___Slice_T___len(secret_key,
      uint8_t)
    / libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        int32_t uu____1[256U];
        core_ops_range_Range__size_t lit;
        lit.start = i * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        lit.end =
          i
          * libcrux_kyber_constants_BYTES_PER_RING_ELEMENT
          + libcrux_kyber_constants_BYTES_PER_RING_ELEMENT;
        libcrux_kyber_serialize_deserialize_to_uncompressed_ring_element(Eurydice_slice_subslice(secret_key,
            lit,
            uint8_t,
            core_ops_range_Range__size_t),
          uu____1);
        memcpy(secret_as_ntt[i], uu____1, (size_t)256U * sizeof (int32_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    int32_t uu____2[3U][256U];
    memcpy(uu____2, secret_as_ntt, (size_t)3U * sizeof (int32_t [256U]));
    memcpy(ret, uu____2, (size_t)3U * sizeof (int32_t [256U]));
    return;
  }
}

void
libcrux_kyber_matrix_compute_message___3size_t(
  int32_t (*v)[256U],
  int32_t (*secret_as_ntt)[256U],
  int32_t (*u_as_ntt)[256U],
  int32_t ret[256U]
)
{
  int32_t result[256U];
  memcpy(result,
    libcrux_kyber_arithmetic__libcrux_kyber__arithmetic__PolynomialRingElement__ZERO,
    (size_t)256U * sizeof (int32_t));
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)3U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (uu____0.tag == core_option_None)
      break;
    else if (uu____0.tag == core_option_Some)
    {
      size_t i = uu____0.f0;
      int32_t product[256U];
      libcrux_kyber_ntt_ntt_multiply(&secret_as_ntt[i], &u_as_ntt[i], product);
      libcrux_kyber_arithmetic_add_to_ring_element___3size_t(result, &product, result);
    }
    else
    {
      KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
      KRML_HOST_EXIT(255U);
    }
  }
  libcrux_kyber_ntt_invert_ntt_montgomery___3size_t(result, result);
  core_ops_range_Range__size_t lit0;
  lit0.start = (size_t)0U;
  lit0.end = libcrux_kyber_constants_COEFFICIENTS_IN_RING_ELEMENT;
  core_ops_range_Range__size_t
  iter0 = core_iter_traits_collect__I__into_iter(lit0, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____1 = core_iter_range__core__ops__range__Range_A__3__next(&iter0, size_t);
    if (!(uu____1.tag == core_option_None))
    {
      if (uu____1.tag == core_option_Some)
      {
        size_t i = uu____1.f0;
        int32_t
        coefficient_normal_form =
          libcrux_kyber_arithmetic_montgomery_reduce(result[i] * (int32_t)1441);
        int32_t
        uu____2 = libcrux_kyber_arithmetic_barrett_reduce(v[0U][i] - coefficient_normal_form);
        result[i] = uu____2;
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    memcpy(ret, result, (size_t)256U * sizeof (int32_t));
    return;
  }
}

void
libcrux_kyber_ind_cpa_decrypt___3size_t_1088size_t_960size_t_10size_t_4size_t(
  Eurydice_slice secret_key,
  uint8_t *ciphertext,
  uint8_t ret[32U]
)
{
  int32_t u_as_ntt[3U][256U];
  libcrux_kyber_ind_cpa_deserialize_then_decompress_u___3size_t_1088size_t_960size_t_10size_t(ciphertext,
    u_as_ntt);
  int32_t v[256U];
  libcrux_kyber_serialize_deserialize_then_decompress_ring_element_v___4size_t(Eurydice_array_to_subslice_from((size_t)1088U,
      ciphertext,
      (size_t)960U,
      uint8_t,
      size_t),
    v);
  int32_t secret_as_ntt[3U][256U];
  libcrux_kyber_ind_cpa_deserialize_secret_key___3size_t(secret_key, secret_as_ntt);
  int32_t message[256U];
  libcrux_kyber_matrix_compute_message___3size_t(&v, secret_as_ntt, u_as_ntt, message);
  uint8_t ret0[32U];
  libcrux_kyber_serialize_compress_then_serialize_message(message, ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

void
libcrux_kyber_ind_cpa_into_padded_array___1120size_t(Eurydice_slice slice, uint8_t ret[1120U])
{
  if (false)
    LowStar_Ignore_ignore(core_slice___Slice_T___len(slice, uint8_t), size_t);
  uint8_t out[1120U];
  uint8_t buf[1120U] = { 0U };
  memcpy(out, buf, (size_t)1120U * sizeof (uint8_t));
  uint8_t *uu____0 = out;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = core_slice___Slice_T___len(slice, uint8_t);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)1120U,
      uu____0,
      lit,
      uint8_t,
      core_ops_range_Range__size_t),
    slice,
    uint8_t);
  uint8_t uu____1[1120U];
  memcpy(uu____1, out, (size_t)1120U * sizeof (uint8_t));
  memcpy(ret, uu____1, (size_t)1120U * sizeof (uint8_t));
}

Eurydice_slice
libcrux_kyber_types__libcrux_kyber__types__KyberCiphertext_SIZE__1__as_ref___1088size_t(
  uint8_t (*self)[1088U]
)
{
  return Eurydice_array_to_slice((size_t)1088U, self[0U], uint8_t);
}

uint8_t
libcrux_kyber_constant_time_ops_compare_ciphertexts_in_constant_time___1088size_t(
  Eurydice_slice lhs,
  Eurydice_slice rhs
)
{
  uint8_t r = 0U;
  core_ops_range_Range__size_t lit;
  lit.start = (size_t)0U;
  lit.end = (size_t)1088U;
  core_ops_range_Range__size_t
  iter = core_iter_traits_collect__I__into_iter(lit, core_ops_range_Range__size_t);
  while (true)
  {
    core_option_Option__size_t
    uu____0 = core_iter_range__core__ops__range__Range_A__3__next(&iter, size_t);
    if (!(uu____0.tag == core_option_None))
    {
      if (uu____0.tag == core_option_Some)
      {
        size_t i = uu____0.f0;
        uint8_t uu____1 = Eurydice_slice_index(lhs, i, uint8_t);
        r = (uint32_t)r | ((uint32_t)uu____1 ^ (uint32_t)Eurydice_slice_index(rhs, i, uint8_t));
        continue;
      }
      else
      {
        KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "panic!");
        KRML_HOST_EXIT(255U);
      }
    }
    return libcrux_kyber_constant_time_ops_is_non_zero(r);
  }
}

void
libcrux_kyber_decapsulate___3size_t_2400size_t_1152size_t_1184size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t_1120size_t(
  uint8_t (*secret_key)[2400U],
  uint8_t (*ciphertext)[1088U],
  uint8_t ret[32U]
)
{
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____0 =
    libcrux_kyber_types__libcrux_kyber__types__KyberPrivateKey_SIZE__12__split_at___2400size_t(secret_key,
      (size_t)1152U);
  Eurydice_slice ind_cpa_secret_key = uu____0.fst;
  Eurydice_slice secret_key0 = uu____0.snd;
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____1 = core_slice___Slice_T___split_at(secret_key0, (size_t)1184U, uint8_t);
  Eurydice_slice ind_cpa_public_key = uu____1.fst;
  Eurydice_slice secret_key1 = uu____1.snd;
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____2 =
    core_slice___Slice_T___split_at(secret_key1,
      libcrux_kyber_constants_H_DIGEST_SIZE,
      uint8_t);
  Eurydice_slice ind_cpa_public_key_hash = uu____2.fst;
  Eurydice_slice implicit_rejection_value = uu____2.snd;
  uint8_t decrypted[32U];
  libcrux_kyber_ind_cpa_decrypt___3size_t_1088size_t_960size_t_10size_t_4size_t(ind_cpa_secret_key,
    ciphertext[0U],
    decrypted);
  uint8_t to_hash0[64U];
  libcrux_kyber_ind_cpa_into_padded_array___64size_t(Eurydice_array_to_slice((size_t)32U,
      decrypted,
      uint8_t),
    to_hash0);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice_from((size_t)64U,
      to_hash0,
      libcrux_kyber_constants_SHARED_SECRET_SIZE,
      uint8_t,
      size_t),
    ind_cpa_public_key_hash,
    uint8_t);
  uint8_t hashed[64U];
  libcrux_kyber_hash_functions_G(Eurydice_array_to_slice((size_t)64U, to_hash0, uint8_t),
    hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____3 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U, hashed, uint8_t),
      libcrux_kyber_constants_SHARED_SECRET_SIZE,
      uint8_t);
  Eurydice_slice shared_secret = uu____3.fst;
  Eurydice_slice pseudorandomness = uu____3.snd;
  uint8_t to_hash[1120U];
  libcrux_kyber_ind_cpa_into_padded_array___1120size_t(implicit_rejection_value, to_hash);
  Eurydice_slice
  uu____4 =
    Eurydice_array_to_subslice_from((size_t)1120U,
      to_hash,
      libcrux_kyber_constants_SHARED_SECRET_SIZE,
      uint8_t,
      size_t);
  core_slice___Slice_T___copy_from_slice(uu____4,
    libcrux_kyber_types__libcrux_kyber__types__KyberCiphertext_SIZE__1__as_ref___1088size_t(ciphertext),
    uint8_t);
  uint8_t implicit_rejection_shared_secret[32U];
  libcrux_kyber_hash_functions_PRF___32size_t(Eurydice_array_to_slice((size_t)1120U,
      to_hash,
      uint8_t),
    implicit_rejection_shared_secret);
  Eurydice_slice uu____5 = ind_cpa_public_key;
  uint8_t uu____6[32U];
  memcpy(uu____6, decrypted, (size_t)32U * sizeof (uint8_t));
  uint8_t expected_ciphertext[1088U];
  uint8_t uu____7[1088U];
  memcpy(uu____7,
    libcrux_kyber_ind_cpa_encrypt___3size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t(uu____5,
      uu____6,
      pseudorandomness).fst,
    (size_t)1088U * sizeof (uint8_t));
  memcpy(expected_ciphertext, uu____7, (size_t)1088U * sizeof (uint8_t));
  Eurydice_slice
  uu____8 =
    libcrux_kyber_types__libcrux_kyber__types__KyberCiphertext_SIZE__1__as_ref___1088size_t(ciphertext);
  uint8_t
  selector =
    libcrux_kyber_constant_time_ops_compare_ciphertexts_in_constant_time___1088size_t(uu____8,
      Eurydice_array_to_slice((size_t)1088U, expected_ciphertext, uint8_t));
  Eurydice_slice uu____9 = shared_secret;
  uint8_t ret0[32U];
  libcrux_kyber_constant_time_ops_select_shared_secret_in_constant_time(uu____9,
    Eurydice_array_to_slice((size_t)32U, implicit_rejection_shared_secret, uint8_t),
    selector,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

void
libcrux_kyber_kyber768_decapsulate_768(
  uint8_t (*secret_key)[2400U],
  uint8_t (*ciphertext)[1088U],
  uint8_t ret[32U]
)
{
  uint8_t ret0[32U];
  libcrux_kyber_decapsulate___3size_t_2400size_t_1152size_t_1184size_t_1088size_t_1152size_t_960size_t_128size_t_10size_t_4size_t_320size_t_2size_t_128size_t_2size_t_128size_t_1120size_t(secret_key,
    ciphertext,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

const
size_t
libcrux_kyber_KEY_GENERATION_SEED_SIZE =
  libcrux_kyber_constants_CPA_PKE_KEY_GENERATION_SEED_SIZE
  + libcrux_kyber_constants_SHARED_SECRET_SIZE;

