/* 
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>
  KaRaMeL invocation: /home/franziskus/eurydice//eurydice --config ../c.yaml ../../libcrux_ml_kem.llbc
  F* version: <unknown>
  KaRaMeL version: 04cb86b9
 */

#include "libcrux_mlkem512.h"

#include "internal/libcrux_polynomial.h"
#include "internal/libcrux_mlkem_avx2.h"
#include "internal/libcrux_mlkem768.h"
#include "internal/libcrux_core.h"

static libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
closure__libcrux_ml_kem_vector_PortableVector_2size_t_768size_t_10size_t(void)
{
  return
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_vector_PortableVector();
}

static inline void
deserialize_then_decompress_u__libcrux_ml_kem_vector_PortableVector_2size_t_768size_t_10size_t(
  uint8_t *ciphertext,
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector ret[2U]
)
{
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  u_as_ntt[2U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    u_as_ntt[i] =
      libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_vector_PortableVector();
  }
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)768U,
          ciphertext,
          uint8_t,
          Eurydice_slice),
        uint8_t,
        size_t)
      / (LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT * (size_t)10U / (size_t)8U);
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    u_bytes =
      Eurydice_array_to_subslice((size_t)768U,
        ciphertext,
        (
          (core_ops_range_Range__size_t){
            .start = i0
            * (LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT * (size_t)10U / (size_t)8U),
            .end = i0
            * (LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT * (size_t)10U / (size_t)8U)
            + LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT * (size_t)10U / (size_t)8U
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
    uu____0 =
      libcrux_ml_kem_serialize_deserialize_then_decompress_ring_element_u__libcrux_ml_kem_vector_PortableVector_10size_t(u_bytes);
    u_as_ntt[i0] = uu____0;
    libcrux_ml_kem_ntt_ntt_vector_u__libcrux_ml_kem_vector_PortableVector_10size_t(&u_as_ntt[i0]);
  }
  memcpy(ret,
    u_as_ntt,
    (size_t)2U
    *
      sizeof (libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector));
}

static libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
closure__libcrux_ml_kem_vector_PortableVector_2size_t(void)
{
  return
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_vector_PortableVector();
}

static inline void
deserialize_secret_key__libcrux_ml_kem_vector_PortableVector_2size_t(
  Eurydice_slice secret_key,
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector ret[2U]
)
{
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  secret_as_ntt[2U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    secret_as_ntt[i] =
      libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_vector_PortableVector();
  }
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(secret_key,
        uint8_t,
        size_t)
      / LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT;
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    secret_bytes =
      Eurydice_slice_subslice(secret_key,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT,
            .end = i0
            * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT
            + LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
    uu____0 =
      libcrux_ml_kem_serialize_deserialize_to_uncompressed_ring_element__libcrux_ml_kem_vector_PortableVector(secret_bytes);
    secret_as_ntt[i0] = uu____0;
  }
  memcpy(ret,
    secret_as_ntt,
    (size_t)2U
    *
      sizeof (libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector));
}

static inline void
invert_ntt_montgomery__libcrux_ml_kem_vector_PortableVector_2size_t(
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector *re
)
{
  size_t zeta_i = LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT / (size_t)2U;
  libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_1__libcrux_ml_kem_vector_PortableVector(&zeta_i,
    re,
    (size_t)1U);
  libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_2__libcrux_ml_kem_vector_PortableVector(&zeta_i,
    re,
    (size_t)2U);
  libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_3__libcrux_ml_kem_vector_PortableVector(&zeta_i,
    re,
    (size_t)3U);
  libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_4_plus__libcrux_ml_kem_vector_PortableVector(&zeta_i,
    re,
    (size_t)4U);
  libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_4_plus__libcrux_ml_kem_vector_PortableVector(&zeta_i,
    re,
    (size_t)5U);
  libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_4_plus__libcrux_ml_kem_vector_PortableVector(&zeta_i,
    re,
    (size_t)6U);
  libcrux_ml_kem_invert_ntt_invert_ntt_at_layer_4_plus__libcrux_ml_kem_vector_PortableVector(&zeta_i,
    re,
    (size_t)7U);
  libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___poly_barrett_reduce__libcrux_ml_kem_vector_PortableVector(re);
}

static inline libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
compute_message__libcrux_ml_kem_vector_PortableVector_2size_t(
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector *v,
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  *secret_as_ntt,
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector *u_as_ntt
)
{
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  result =
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_vector_PortableVector();
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    size_t i0 = i;
    libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
    product =
      libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ntt_multiply__libcrux_ml_kem_vector_PortableVector(&secret_as_ntt[i0],
        &u_as_ntt[i0]);
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_to_ring_element__libcrux_ml_kem_vector_PortableVector_2size_t(&result,
      &product);
  }
  invert_ntt_montgomery__libcrux_ml_kem_vector_PortableVector_2size_t(&result);
  result =
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___subtract_reduce__libcrux_ml_kem_vector_PortableVector(v,
      result);
  return result;
}

static void
decrypt__libcrux_ml_kem_vector_PortableVector_2size_t_768size_t_640size_t_10size_t_4size_t(
  Eurydice_slice secret_key,
  uint8_t *ciphertext,
  uint8_t ret[32U]
)
{
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  u_as_ntt[2U];
  deserialize_then_decompress_u__libcrux_ml_kem_vector_PortableVector_2size_t_768size_t_10size_t(ciphertext,
    u_as_ntt);
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  v =
    libcrux_ml_kem_serialize_deserialize_then_decompress_ring_element_v__libcrux_ml_kem_vector_PortableVector_4size_t(Eurydice_array_to_subslice_from((size_t)768U,
        ciphertext,
        (size_t)640U,
        uint8_t,
        size_t,
        Eurydice_slice));
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  secret_as_ntt[2U];
  deserialize_secret_key__libcrux_ml_kem_vector_PortableVector_2size_t(secret_key,
    secret_as_ntt);
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  message =
    compute_message__libcrux_ml_kem_vector_PortableVector_2size_t(&v,
      secret_as_ntt,
      u_as_ntt);
  uint8_t ret0[32U];
  libcrux_ml_kem_serialize_compress_then_serialize_message__libcrux_ml_kem_vector_PortableVector(message,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

inline void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____G___2size_t(
  Eurydice_slice input,
  uint8_t ret[64U]
)
{
  uint8_t digest[64U] = { 0U };
  libcrux_sha3_portable_sha512(Eurydice_array_to_slice((size_t)64U,
      digest,
      uint8_t,
      Eurydice_slice),
    input);
  memcpy(ret, digest, (size_t)64U * sizeof (uint8_t));
}

inline void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRF___2size_t_32size_t(
  Eurydice_slice input,
  uint8_t ret[32U]
)
{
  uint8_t digest[32U] = { 0U };
  libcrux_sha3_portable_shake256(Eurydice_array_to_slice((size_t)32U,
      digest,
      uint8_t,
      Eurydice_slice),
    input);
  memcpy(ret, digest, (size_t)32U * sizeof (uint8_t));
}

static libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
closure__libcrux_ml_kem_vector_PortableVector_768size_t_2size_t(void)
{
  return
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_vector_PortableVector();
}

static inline void
deserialize_ring_elements_reduced__libcrux_ml_kem_vector_PortableVector_768size_t_2size_t(
  Eurydice_slice public_key,
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector ret[2U]
)
{
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  deserialized_pk[2U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    deserialized_pk[i] =
      libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_vector_PortableVector();
  }
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(public_key,
        uint8_t,
        size_t)
      / LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT;
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    ring_element =
      Eurydice_slice_subslice(public_key,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT,
            .end = i0
            * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT
            + LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
    uu____0 =
      libcrux_ml_kem_serialize_deserialize_to_reduced_ring_element__libcrux_ml_kem_vector_PortableVector(ring_element);
    deserialized_pk[i0] = uu____0;
  }
  memcpy(ret,
    deserialized_pk,
    (size_t)2U
    *
      sizeof (libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector));
}

static libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
closure__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t(
  void
)
{
  return
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_vector_PortableVector();
}

static void
closure__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t0(
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector ret[2U]
)
{
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector ret0[2U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    ret0[i] =
      libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_vector_PortableVector();
  }
  memcpy(ret,
    ret0,
    (size_t)2U
    *
      sizeof (libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector));
}

inline libcrux_ml_kem_hash_functions_portable_PortableHash____2size_t
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____shake128_init_absorb___2size_t(
  uint8_t input[2U][34U]
)
{
  libcrux_sha3_portable_KeccakState1 state[2U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    state[i] = libcrux_sha3_portable_incremental_shake128_init();
  }
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    size_t i0 = i;
    libcrux_sha3_portable_KeccakState1 *uu____0 = &state[i0];
    libcrux_sha3_portable_incremental_shake128_absorb_final(uu____0,
      Eurydice_array_to_slice((size_t)34U, input[i0], uint8_t, Eurydice_slice));
  }
  libcrux_sha3_portable_KeccakState1 uu____1[2U];
  memcpy(uu____1, state, (size_t)2U * sizeof (libcrux_sha3_portable_KeccakState1));
  libcrux_ml_kem_hash_functions_portable_PortableHash____2size_t lit;
  memcpy(lit.shake128_state, uu____1, (size_t)2U * sizeof (libcrux_sha3_portable_KeccakState1));
  return lit;
}

inline void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____shake128_squeeze_three_blocks___2size_t(
  libcrux_ml_kem_hash_functions_portable_PortableHash____2size_t *self,
  uint8_t ret[2U][504U]
)
{
  uint8_t out[2U][504U] = { { 0U } };
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    size_t i0 = i;
    libcrux_sha3_portable_KeccakState1 *uu____0 = &self->shake128_state[i0];
    libcrux_sha3_portable_incremental_shake128_squeeze_first_three_blocks(uu____0,
      Eurydice_array_to_slice((size_t)504U, out[i0], uint8_t, Eurydice_slice));
  }
  memcpy(ret, out, (size_t)2U * sizeof (uint8_t [504U]));
}

static inline bool
sample_from_uniform_distribution_next__libcrux_ml_kem_vector_PortableVector_2size_t_504size_t(
  uint8_t randomness[2U][504U],
  size_t *sampled_coefficients,
  int16_t (*out)[272U]
)
{
  for (size_t i0 = (size_t)0U; i0 < (size_t)2U; i0++)
  {
    size_t i1 = i0;
    for (size_t i = (size_t)0U; i < (size_t)504U / (size_t)24U; i++)
    {
      size_t r = i;
      if (sampled_coefficients[i1] < LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT)
      {
        Eurydice_slice
        uu____0 =
          Eurydice_array_to_subslice((size_t)504U,
            randomness[i1],
            (
              (core_ops_range_Range__size_t){
                .start = r * (size_t)24U,
                .end = r * (size_t)24U + (size_t)24U
              }
            ),
            uint8_t,
            core_ops_range_Range__size_t,
            Eurydice_slice);
        size_t
        sampled =
          libcrux_ml_kem_vector___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__PortableVector___rej_sample(uu____0,
            Eurydice_array_to_subslice((size_t)272U,
              out[i1],
              (
                (core_ops_range_Range__size_t){
                  .start = sampled_coefficients[i1],
                  .end = sampled_coefficients[i1] + (size_t)16U
                }
              ),
              int16_t,
              core_ops_range_Range__size_t,
              Eurydice_slice));
        size_t uu____1 = i1;
        sampled_coefficients[uu____1] = sampled_coefficients[uu____1] + sampled;
      }
    }
  }
  bool done = true;
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    size_t i0 = i;
    if (sampled_coefficients[i0] >= LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT)
    {
      sampled_coefficients[i0] = LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT;
    }
    else
    {
      done = false;
    }
  }
  return done;
}

inline void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____shake128_squeeze_block___2size_t(
  libcrux_ml_kem_hash_functions_portable_PortableHash____2size_t *self,
  uint8_t ret[2U][168U]
)
{
  uint8_t out[2U][168U] = { { 0U } };
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    size_t i0 = i;
    libcrux_sha3_portable_KeccakState1 *uu____0 = &self->shake128_state[i0];
    libcrux_sha3_portable_incremental_shake128_squeeze_next_block(uu____0,
      Eurydice_array_to_slice((size_t)168U, out[i0], uint8_t, Eurydice_slice));
  }
  memcpy(ret, out, (size_t)2U * sizeof (uint8_t [168U]));
}

static inline bool
sample_from_uniform_distribution_next__libcrux_ml_kem_vector_PortableVector_2size_t_168size_t(
  uint8_t randomness[2U][168U],
  size_t *sampled_coefficients,
  int16_t (*out)[272U]
)
{
  for (size_t i0 = (size_t)0U; i0 < (size_t)2U; i0++)
  {
    size_t i1 = i0;
    for (size_t i = (size_t)0U; i < (size_t)168U / (size_t)24U; i++)
    {
      size_t r = i;
      if (sampled_coefficients[i1] < LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT)
      {
        Eurydice_slice
        uu____0 =
          Eurydice_array_to_subslice((size_t)168U,
            randomness[i1],
            (
              (core_ops_range_Range__size_t){
                .start = r * (size_t)24U,
                .end = r * (size_t)24U + (size_t)24U
              }
            ),
            uint8_t,
            core_ops_range_Range__size_t,
            Eurydice_slice);
        size_t
        sampled =
          libcrux_ml_kem_vector___libcrux_ml_kem__vector__traits__Operations_for_libcrux_ml_kem__vector__PortableVector___rej_sample(uu____0,
            Eurydice_array_to_subslice((size_t)272U,
              out[i1],
              (
                (core_ops_range_Range__size_t){
                  .start = sampled_coefficients[i1],
                  .end = sampled_coefficients[i1] + (size_t)16U
                }
              ),
              int16_t,
              core_ops_range_Range__size_t,
              Eurydice_slice));
        size_t uu____1 = i1;
        sampled_coefficients[uu____1] = sampled_coefficients[uu____1] + sampled;
      }
    }
  }
  bool done = true;
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    size_t i0 = i;
    if (sampled_coefficients[i0] >= LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT)
    {
      sampled_coefficients[i0] = LIBCRUX_ML_KEM_CONSTANTS_COEFFICIENTS_IN_RING_ELEMENT;
    }
    else
    {
      done = false;
    }
  }
  return done;
}

static libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
closure__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t1(
  int16_t s[272U]
)
{
  return
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___from_i16_array__libcrux_ml_kem_vector_PortableVector(Eurydice_array_to_subslice((size_t)272U,
        s,
        ((core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)256U }),
        int16_t,
        core_ops_range_Range__size_t,
        Eurydice_slice));
}

static inline void
sample_from_xof__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t(
  uint8_t seeds[2U][34U],
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector ret[2U]
)
{
  size_t sampled_coefficients[2U] = { 0U };
  int16_t out[2U][272U] = { { 0U } };
  uint8_t uu____0[2U][34U];
  memcpy(uu____0, seeds, (size_t)2U * sizeof (uint8_t [34U]));
  libcrux_ml_kem_hash_functions_portable_PortableHash____2size_t
  xof_state =
    libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____shake128_init_absorb___2size_t(uu____0);
  uint8_t randomness0[2U][504U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____shake128_squeeze_three_blocks___2size_t(&xof_state,
    randomness0);
  uint8_t uu____1[2U][504U];
  memcpy(uu____1, randomness0, (size_t)2U * sizeof (uint8_t [504U]));
  bool
  done =
    sample_from_uniform_distribution_next__libcrux_ml_kem_vector_PortableVector_2size_t_504size_t(uu____1,
      sampled_coefficients,
      out);
  while (true)
  {
    if (!!done)
    {
      break;
    }
    uint8_t randomness[2U][168U];
    libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____shake128_squeeze_block___2size_t(&xof_state,
      randomness);
    uint8_t uu____2[2U][168U];
    memcpy(uu____2, randomness, (size_t)2U * sizeof (uint8_t [168U]));
    done =
      sample_from_uniform_distribution_next__libcrux_ml_kem_vector_PortableVector_2size_t_168size_t(uu____2,
        sampled_coefficients,
        out);
  }
  int16_t uu____3[2U][272U];
  memcpy(uu____3, out, (size_t)2U * sizeof (int16_t [272U]));
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector ret0[2U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    ret0[i] =
      closure__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t1(uu____3[i]);
  }
  memcpy(ret,
    ret0,
    (size_t)2U
    *
      sizeof (libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector));
}

static inline void
sample_matrix_A__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t(
  uint8_t seed[34U],
  bool transpose,
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  ret[2U][2U]
)
{
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  A_transpose[2U][2U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    closure__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t0(A_transpose[i]);
  }
  for (size_t i0 = (size_t)0U; i0 < (size_t)2U; i0++)
  {
    size_t i1 = i0;
    uint8_t uu____0[34U];
    memcpy(uu____0, seed, (size_t)34U * sizeof (uint8_t));
    uint8_t seeds[2U][34U];
    for (size_t i = (size_t)0U; i < (size_t)2U; i++)
    {
      memcpy(seeds[i], uu____0, (size_t)34U * sizeof (uint8_t));
    }
    for (size_t i = (size_t)0U; i < (size_t)2U; i++)
    {
      size_t j = i;
      seeds[j][32U] = (uint8_t)i1;
      seeds[j][33U] = (uint8_t)j;
    }
    uint8_t uu____1[2U][34U];
    memcpy(uu____1, seeds, (size_t)2U * sizeof (uint8_t [34U]));
    libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
    sampled[2U];
    sample_from_xof__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t(uu____1,
      sampled);
    for
    (size_t
      i = (size_t)0U;
      i
      <
        core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)2U,
            sampled,
            libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector,
            Eurydice_slice),
          libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector,
          size_t);
      i++)
    {
      size_t j = i;
      libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
      sample = sampled[j];
      if (transpose)
      {
        A_transpose[j][i1] = sample;
      }
      else
      {
        A_transpose[i1][j] = sample;
      }
    }
  }
  memcpy(ret,
    A_transpose,
    (size_t)2U
    *
      sizeof (
        libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector [2U]
      ));
}

static libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
closure__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_3size_t_192size_t(
  void
)
{
  return
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_vector_PortableVector();
}

inline void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRFxN___2size_t_192size_t(
  uint8_t (*input)[33U],
  uint8_t ret[2U][192U]
)
{
  uint8_t out[2U][192U] = { { 0U } };
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    size_t i0 = i;
    Eurydice_slice
    uu____0 = Eurydice_array_to_slice((size_t)192U, out[i0], uint8_t, Eurydice_slice);
    libcrux_sha3_portable_shake256(uu____0,
      Eurydice_array_to_slice((size_t)33U, input[i0], uint8_t, Eurydice_slice));
  }
  memcpy(ret, out, (size_t)2U * sizeof (uint8_t [192U]));
}

static inline libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
sample_from_binomial_distribution__libcrux_ml_kem_vector_PortableVector_3size_t(
  Eurydice_slice randomness
)
{
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector uu____0;
  uu____0 =
    libcrux_ml_kem_sampling_sample_from_binomial_distribution_3__libcrux_ml_kem_vector_PortableVector(randomness);
  return uu____0;
}

static inline K___libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector_2size_t__uint8_t
sample_vector_cbd_then_ntt__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_3size_t_192size_t(
  uint8_t prf_input[33U],
  uint8_t domain_separator
)
{
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  re_as_ntt[2U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    re_as_ntt[i] =
      libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_vector_PortableVector();
  }
  uint8_t uu____0[33U];
  memcpy(uu____0, prf_input, (size_t)33U * sizeof (uint8_t));
  uint8_t prf_inputs[2U][33U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    memcpy(prf_inputs[i], uu____0, (size_t)33U * sizeof (uint8_t));
  }
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    size_t i0 = i;
    prf_inputs[i0][32U] = domain_separator;
    domain_separator = (uint32_t)domain_separator + 1U;
  }
  uint8_t prf_outputs[2U][192U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRFxN___2size_t_192size_t(prf_inputs,
    prf_outputs);
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    size_t i0 = i;
    libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
    uu____1 =
      sample_from_binomial_distribution__libcrux_ml_kem_vector_PortableVector_3size_t(Eurydice_array_to_slice((size_t)192U,
          prf_outputs[i0],
          uint8_t,
          Eurydice_slice));
    re_as_ntt[i0] = uu____1;
    libcrux_ml_kem_ntt_ntt_binomially_sampled_ring_element__libcrux_ml_kem_vector_PortableVector(&re_as_ntt[i0]);
  }
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  uu____2[2U];
  memcpy(uu____2,
    re_as_ntt,
    (size_t)2U
    *
      sizeof (libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector));
  K___libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector_2size_t__uint8_t
  lit;
  memcpy(lit.fst,
    uu____2,
    (size_t)2U
    *
      sizeof (libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector));
  lit.snd = domain_separator;
  return lit;
}

static libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
closure__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_128size_t_2size_t(
  void
)
{
  return
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_vector_PortableVector();
}

inline void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRFxN___2size_t_128size_t(
  uint8_t (*input)[33U],
  uint8_t ret[2U][128U]
)
{
  uint8_t out[2U][128U] = { { 0U } };
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    size_t i0 = i;
    Eurydice_slice
    uu____0 = Eurydice_array_to_slice((size_t)128U, out[i0], uint8_t, Eurydice_slice);
    libcrux_sha3_portable_shake256(uu____0,
      Eurydice_array_to_slice((size_t)33U, input[i0], uint8_t, Eurydice_slice));
  }
  memcpy(ret, out, (size_t)2U * sizeof (uint8_t [128U]));
}

static inline K___libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector_2size_t__uint8_t
sample_ring_element_cbd__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_128size_t_2size_t(
  uint8_t prf_input[33U],
  uint8_t domain_separator
)
{
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  error_1[2U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    error_1[i] =
      libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_vector_PortableVector();
  }
  uint8_t uu____0[33U];
  memcpy(uu____0, prf_input, (size_t)33U * sizeof (uint8_t));
  uint8_t prf_inputs[2U][33U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    memcpy(prf_inputs[i], uu____0, (size_t)33U * sizeof (uint8_t));
  }
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    size_t i0 = i;
    prf_inputs[i0][32U] = domain_separator;
    domain_separator = (uint32_t)domain_separator + 1U;
  }
  uint8_t prf_outputs[2U][128U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRFxN___2size_t_128size_t(prf_inputs,
    prf_outputs);
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    size_t i0 = i;
    libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
    uu____1 =
      libcrux_ml_kem_sampling_sample_from_binomial_distribution__libcrux_ml_kem_vector_PortableVector_2size_t(Eurydice_array_to_slice((size_t)128U,
          prf_outputs[i0],
          uint8_t,
          Eurydice_slice));
    error_1[i0] = uu____1;
  }
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  uu____2[2U];
  memcpy(uu____2,
    error_1,
    (size_t)2U
    *
      sizeof (libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector));
  K___libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector_2size_t__uint8_t
  lit;
  memcpy(lit.fst,
    uu____2,
    (size_t)2U
    *
      sizeof (libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector));
  lit.snd = domain_separator;
  return lit;
}

inline void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRF___2size_t_128size_t(
  Eurydice_slice input,
  uint8_t ret[128U]
)
{
  uint8_t digest[128U] = { 0U };
  libcrux_sha3_portable_shake256(Eurydice_array_to_slice((size_t)128U,
      digest,
      uint8_t,
      Eurydice_slice),
    input);
  memcpy(ret, digest, (size_t)128U * sizeof (uint8_t));
}

static libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
closure__libcrux_ml_kem_vector_PortableVector_2size_t0(void)
{
  return
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_vector_PortableVector();
}

static inline void
compute_vector_u__libcrux_ml_kem_vector_PortableVector_2size_t(
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  (*a_as_ntt)[2U],
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector *r_as_ntt,
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector *error_1,
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector ret[2U]
)
{
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  result[2U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    result[i] =
      libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_vector_PortableVector();
  }
  for
  (size_t
    i0 = (size_t)0U;
    i0
    <
      core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)2U,
          a_as_ntt,
          libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector [2U],
          Eurydice_slice),
        libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector [2U],
        size_t);
    i0++)
  {
    size_t i1 = i0;
    libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
    *row = a_as_ntt[i1];
    for
    (size_t
      i = (size_t)0U;
      i
      <
        core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)2U,
            row,
            libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector,
            Eurydice_slice),
          libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector,
          size_t);
      i++)
    {
      size_t j = i;
      libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
      *a_element = &row[j];
      libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
      product =
        libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ntt_multiply__libcrux_ml_kem_vector_PortableVector(a_element,
          &r_as_ntt[j]);
      libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_to_ring_element__libcrux_ml_kem_vector_PortableVector_2size_t(&result[i1],
        &product);
    }
    invert_ntt_montgomery__libcrux_ml_kem_vector_PortableVector_2size_t(&result[i1]);
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_error_reduce__libcrux_ml_kem_vector_PortableVector(&result[i1],
      &error_1[i1]);
  }
  memcpy(ret,
    result,
    (size_t)2U
    *
      sizeof (libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector));
}

static inline libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
compute_ring_element_v__libcrux_ml_kem_vector_PortableVector_2size_t(
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector *t_as_ntt,
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector *r_as_ntt,
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector *error_2,
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector *message
)
{
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  result =
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_vector_PortableVector();
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    size_t i0 = i;
    libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
    product =
      libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ntt_multiply__libcrux_ml_kem_vector_PortableVector(&t_as_ntt[i0],
        &r_as_ntt[i0]);
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_to_ring_element__libcrux_ml_kem_vector_PortableVector_2size_t(&result,
      &product);
  }
  invert_ntt_montgomery__libcrux_ml_kem_vector_PortableVector_2size_t(&result);
  result =
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_message_error_reduce__libcrux_ml_kem_vector_PortableVector(error_2,
      message,
      result);
  return result;
}

static void
compress_then_serialize_u__libcrux_ml_kem_vector_PortableVector_2size_t_640size_t_10size_t_320size_t(
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector input[2U],
  Eurydice_slice out
)
{
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)2U,
          input,
          libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector,
          Eurydice_slice),
        libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector,
        size_t);
    i++)
  {
    size_t i0 = i;
    libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
    re = input[i0];
    Eurydice_slice
    uu____0 =
      Eurydice_slice_subslice(out,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * ((size_t)640U / (size_t)2U),
            .end = (i0 + (size_t)1U) * ((size_t)640U / (size_t)2U)
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    uint8_t ret[320U];
    libcrux_ml_kem_serialize_compress_then_serialize_ring_element_u__libcrux_ml_kem_vector_PortableVector_10size_t_320size_t(&re,
      ret);
    core_slice___Slice_T___copy_from_slice(uu____0,
      Eurydice_array_to_slice((size_t)320U, ret, uint8_t, Eurydice_slice),
      uint8_t,
      void *);
  }
}

static void
encrypt__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_768size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t(
  Eurydice_slice public_key,
  uint8_t message[32U],
  Eurydice_slice randomness,
  uint8_t ret[768U]
)
{
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  t_as_ntt[2U];
  deserialize_ring_elements_reduced__libcrux_ml_kem_vector_PortableVector_768size_t_2size_t(Eurydice_slice_subslice_to(public_key,
      (size_t)768U,
      uint8_t,
      size_t,
      Eurydice_slice),
    t_as_ntt);
  Eurydice_slice
  seed = Eurydice_slice_subslice_from(public_key, (size_t)768U, uint8_t, size_t, Eurydice_slice);
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  A_transpose[2U][2U];
  uint8_t ret0[34U];
  libcrux_ml_kem_ind_cpa_into_padded_array___34size_t(seed, ret0);
  sample_matrix_A__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t(ret0,
    false,
    A_transpose);
  uint8_t prf_input[33U];
  libcrux_ml_kem_ind_cpa_into_padded_array___33size_t(randomness, prf_input);
  uint8_t uu____0[33U];
  memcpy(uu____0, prf_input, (size_t)33U * sizeof (uint8_t));
  K___libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector_2size_t__uint8_t
  uu____1 =
    sample_vector_cbd_then_ntt__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_3size_t_192size_t(uu____0,
      0U);
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  r_as_ntt[2U];
  memcpy(r_as_ntt,
    uu____1.fst,
    (size_t)2U
    *
      sizeof (libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector));
  uint8_t domain_separator0 = uu____1.snd;
  uint8_t uu____2[33U];
  memcpy(uu____2, prf_input, (size_t)33U * sizeof (uint8_t));
  K___libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector_2size_t__uint8_t
  uu____3 =
    sample_ring_element_cbd__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_128size_t_2size_t(uu____2,
      domain_separator0);
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  error_1[2U];
  memcpy(error_1,
    uu____3.fst,
    (size_t)2U
    *
      sizeof (libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector));
  uint8_t domain_separator = uu____3.snd;
  prf_input[32U] = domain_separator;
  uint8_t prf_output[128U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRF___2size_t_128size_t(Eurydice_array_to_slice((size_t)33U,
      prf_input,
      uint8_t,
      Eurydice_slice),
    prf_output);
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  error_2 =
    libcrux_ml_kem_sampling_sample_from_binomial_distribution__libcrux_ml_kem_vector_PortableVector_2size_t(Eurydice_array_to_slice((size_t)128U,
        prf_output,
        uint8_t,
        Eurydice_slice));
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector u[2U];
  compute_vector_u__libcrux_ml_kem_vector_PortableVector_2size_t(A_transpose,
    r_as_ntt,
    error_1,
    u);
  uint8_t uu____4[32U];
  memcpy(uu____4, message, (size_t)32U * sizeof (uint8_t));
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  message_as_ring_element =
    libcrux_ml_kem_serialize_deserialize_then_decompress_message__libcrux_ml_kem_vector_PortableVector(uu____4);
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  v =
    compute_ring_element_v__libcrux_ml_kem_vector_PortableVector_2size_t(t_as_ntt,
      r_as_ntt,
      &error_2,
      &message_as_ring_element);
  uint8_t ciphertext[768U] = { 0U };
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  uu____5[2U];
  memcpy(uu____5,
    u,
    (size_t)2U
    *
      sizeof (libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector));
  compress_then_serialize_u__libcrux_ml_kem_vector_PortableVector_2size_t_640size_t_10size_t_320size_t(uu____5,
    Eurydice_array_to_subslice((size_t)768U,
      ciphertext,
      ((core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)640U }),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice));
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  uu____6 = v;
  libcrux_ml_kem_serialize_compress_then_serialize_ring_element_v__libcrux_ml_kem_vector_PortableVector_4size_t_128size_t(uu____6,
    Eurydice_array_to_subslice_from((size_t)768U,
      ciphertext,
      (size_t)640U,
      uint8_t,
      size_t,
      Eurydice_slice));
  memcpy(ret, ciphertext, (size_t)768U * sizeof (uint8_t));
}

static void
decapsulate_generic__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_1632size_t_768size_t_800size_t_768size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t_800size_t(
  libcrux_ml_kem_types_MlKemPrivateKey____1632size_t *private_key,
  libcrux_ml_kem_types_MlKemCiphertext____768size_t *ciphertext,
  uint8_t ret[32U]
)
{
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____0 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)1632U,
        private_key->value,
        uint8_t,
        Eurydice_slice),
      (size_t)768U,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice ind_cpa_secret_key = uu____0.fst;
  Eurydice_slice secret_key0 = uu____0.snd;
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____1 =
    core_slice___Slice_T___split_at(secret_key0,
      (size_t)800U,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice ind_cpa_public_key = uu____1.fst;
  Eurydice_slice secret_key = uu____1.snd;
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____2 =
    core_slice___Slice_T___split_at(secret_key,
      LIBCRUX_ML_KEM_CONSTANTS_H_DIGEST_SIZE,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice ind_cpa_public_key_hash = uu____2.fst;
  Eurydice_slice implicit_rejection_value = uu____2.snd;
  uint8_t decrypted[32U];
  decrypt__libcrux_ml_kem_vector_PortableVector_2size_t_768size_t_640size_t_10size_t_4size_t(ind_cpa_secret_key,
    ciphertext->value,
    decrypted);
  uint8_t to_hash0[64U];
  libcrux_ml_kem_ind_cpa_into_padded_array___64size_t(Eurydice_array_to_slice((size_t)32U,
      decrypted,
      uint8_t,
      Eurydice_slice),
    to_hash0);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice_from((size_t)64U,
      to_hash0,
      LIBCRUX_ML_KEM_CONSTANTS_SHARED_SECRET_SIZE,
      uint8_t,
      size_t,
      Eurydice_slice),
    ind_cpa_public_key_hash,
    uint8_t,
    void *);
  uint8_t hashed[64U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____G___2size_t(Eurydice_array_to_slice((size_t)64U,
      to_hash0,
      uint8_t,
      Eurydice_slice),
    hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____3 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U,
        hashed,
        uint8_t,
        Eurydice_slice),
      LIBCRUX_ML_KEM_CONSTANTS_SHARED_SECRET_SIZE,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice shared_secret = uu____3.fst;
  Eurydice_slice pseudorandomness = uu____3.snd;
  uint8_t to_hash[800U];
  libcrux_ml_kem_ind_cpa_into_padded_array___800size_t(implicit_rejection_value, to_hash);
  Eurydice_slice
  uu____4 =
    Eurydice_array_to_subslice_from((size_t)800U,
      to_hash,
      LIBCRUX_ML_KEM_CONSTANTS_SHARED_SECRET_SIZE,
      uint8_t,
      size_t,
      Eurydice_slice);
  core_slice___Slice_T___copy_from_slice(uu____4,
    libcrux_ml_kem_types___core__convert__AsRef__Slice_u8___for_libcrux_ml_kem__types__MlKemCiphertext_SIZE___1__as_ref___768size_t(ciphertext),
    uint8_t,
    void *);
  uint8_t implicit_rejection_shared_secret[32U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____PRF___2size_t_32size_t(Eurydice_array_to_slice((size_t)800U,
      to_hash,
      uint8_t,
      Eurydice_slice),
    implicit_rejection_shared_secret);
  Eurydice_slice uu____5 = ind_cpa_public_key;
  uint8_t uu____6[32U];
  memcpy(uu____6, decrypted, (size_t)32U * sizeof (uint8_t));
  uint8_t expected_ciphertext[768U];
  encrypt__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_768size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t(uu____5,
    uu____6,
    pseudorandomness,
    expected_ciphertext);
  Eurydice_slice
  uu____7 =
    libcrux_ml_kem_types___core__convert__AsRef__Slice_u8___for_libcrux_ml_kem__types__MlKemCiphertext_SIZE___1__as_ref___768size_t(ciphertext);
  uint8_t
  selector =
    libcrux_ml_kem_constant_time_ops_compare_ciphertexts_in_constant_time___768size_t(uu____7,
      Eurydice_array_to_slice((size_t)768U, expected_ciphertext, uint8_t, Eurydice_slice));
  Eurydice_slice uu____8 = shared_secret;
  uint8_t ret0[32U];
  libcrux_ml_kem_constant_time_ops_select_shared_secret_in_constant_time(uu____8,
    Eurydice_array_to_slice((size_t)32U, implicit_rejection_shared_secret, uint8_t, Eurydice_slice),
    selector,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

static void
decapsulate___2size_t_1632size_t_768size_t_800size_t_768size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t_800size_t(
  libcrux_ml_kem_types_MlKemPrivateKey____1632size_t *private_key,
  libcrux_ml_kem_types_MlKemCiphertext____768size_t *ciphertext,
  uint8_t ret[32U]
)
{
  bool uu____0;
  uu____0 = true;
  bool uu____1;
  if (uu____0)
  {
    uu____1 = libcrux_platform_platform_simd256_support();
  }
  else
  {
    uu____1 = false;
  }
  uint8_t uu____2[32U];
  if (uu____1)
  {
    libcrux_ml_kem_ind_cca_decapsulate_generic__libcrux_ml_kem_vector_avx2_SIMD256Vector_libcrux_ml_kem_hash_functions_avx2_Simd256Hash_2size_t_1632size_t_768size_t_800size_t_768size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t_800size_t(private_key,
      ciphertext,
      uu____2);
  }
  else
  {
    decapsulate_generic__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_1632size_t_768size_t_800size_t_768size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t_800size_t(private_key,
      ciphertext,
      uu____2);
    memcpy(ret, uu____2, (size_t)32U * sizeof (uint8_t));
    return;
  }
  memcpy(ret, uu____2, (size_t)32U * sizeof (uint8_t));
}

void
libcrux_ml_kem_mlkem512_decapsulate(
  libcrux_ml_kem_types_MlKemPrivateKey____1632size_t *private_key,
  libcrux_ml_kem_types_MlKemCiphertext____768size_t *ciphertext,
  uint8_t ret[32U]
)
{
  uint8_t ret0[32U];
  decapsulate___2size_t_1632size_t_768size_t_800size_t_768size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t_800size_t(private_key,
    ciphertext,
    ret0);
  memcpy(ret, ret0, (size_t)32U * sizeof (uint8_t));
}

inline void
libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____H___2size_t(
  Eurydice_slice input,
  uint8_t ret[32U]
)
{
  uint8_t digest[32U] = { 0U };
  libcrux_sha3_portable_sha256(Eurydice_array_to_slice((size_t)32U,
      digest,
      uint8_t,
      Eurydice_slice),
    input);
  memcpy(ret, digest, (size_t)32U * sizeof (uint8_t));
}

static K___libcrux_ml_kem_types_MlKemCiphertext___768size_t___uint8_t_32size_t_
encapsulate_generic__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_768size_t_800size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t(
  libcrux_ml_kem_types_MlKemPublicKey____800size_t *public_key,
  uint8_t randomness[32U]
)
{
  uint8_t to_hash[64U];
  libcrux_ml_kem_ind_cpa_into_padded_array___64size_t(Eurydice_array_to_slice((size_t)32U,
      randomness,
      uint8_t,
      Eurydice_slice),
    to_hash);
  Eurydice_slice
  uu____0 =
    Eurydice_array_to_subslice_from((size_t)64U,
      to_hash,
      LIBCRUX_ML_KEM_CONSTANTS_H_DIGEST_SIZE,
      uint8_t,
      size_t,
      Eurydice_slice);
  uint8_t ret[32U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____H___2size_t(Eurydice_array_to_slice((size_t)800U,
      libcrux_ml_kem_types__libcrux_ml_kem__types__MlKemPublicKey_SIZE__18__as_slice___800size_t(public_key),
      uint8_t,
      Eurydice_slice),
    ret);
  core_slice___Slice_T___copy_from_slice(uu____0,
    Eurydice_array_to_slice((size_t)32U, ret, uint8_t, Eurydice_slice),
    uint8_t,
    void *);
  uint8_t hashed[64U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____G___2size_t(Eurydice_array_to_slice((size_t)64U,
      to_hash,
      uint8_t,
      Eurydice_slice),
    hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____1 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U,
        hashed,
        uint8_t,
        Eurydice_slice),
      LIBCRUX_ML_KEM_CONSTANTS_SHARED_SECRET_SIZE,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice shared_secret = uu____1.fst;
  Eurydice_slice pseudorandomness = uu____1.snd;
  Eurydice_slice
  uu____2 =
    Eurydice_array_to_slice((size_t)800U,
      libcrux_ml_kem_types__libcrux_ml_kem__types__MlKemPublicKey_SIZE__18__as_slice___800size_t(public_key),
      uint8_t,
      Eurydice_slice);
  uint8_t uu____3[32U];
  memcpy(uu____3, randomness, (size_t)32U * sizeof (uint8_t));
  uint8_t ciphertext[768U];
  encrypt__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_768size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t(uu____2,
    uu____3,
    pseudorandomness,
    ciphertext);
  uint8_t shared_secret_array[32U] = { 0U };
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_slice((size_t)32U,
      shared_secret_array,
      uint8_t,
      Eurydice_slice),
    shared_secret,
    uint8_t,
    void *);
  uint8_t uu____4[768U];
  memcpy(uu____4, ciphertext, (size_t)768U * sizeof (uint8_t));
  libcrux_ml_kem_types_MlKemCiphertext____768size_t
  uu____5 =
    libcrux_ml_kem_types___core__convert__From__Array_u8__SIZE___for_libcrux_ml_kem__types__MlKemCiphertext_SIZE___2__from___768size_t(uu____4);
  uint8_t uu____6[32U];
  memcpy(uu____6, shared_secret_array, (size_t)32U * sizeof (uint8_t));
  K___libcrux_ml_kem_types_MlKemCiphertext___768size_t___uint8_t_32size_t_ lit;
  lit.fst = uu____5;
  memcpy(lit.snd, uu____6, (size_t)32U * sizeof (uint8_t));
  return lit;
}

static K___libcrux_ml_kem_types_MlKemCiphertext___768size_t___uint8_t_32size_t_
encapsulate___2size_t_768size_t_800size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t(
  libcrux_ml_kem_types_MlKemPublicKey____800size_t *public_key,
  uint8_t randomness[32U]
)
{
  bool uu____0;
  uu____0 = true;
  bool uu____1;
  if (uu____0)
  {
    uu____1 = libcrux_platform_platform_simd256_support();
  }
  else
  {
    uu____1 = false;
  }
  K___libcrux_ml_kem_types_MlKemCiphertext___768size_t___uint8_t_32size_t_ uu____2;
  if (uu____1)
  {
    libcrux_ml_kem_types_MlKemPublicKey____800size_t *uu____3 = public_key;
    uint8_t uu____4[32U];
    memcpy(uu____4, randomness, (size_t)32U * sizeof (uint8_t));
    uu____2 =
      libcrux_ml_kem_ind_cca_encapsulate_generic__libcrux_ml_kem_vector_avx2_SIMD256Vector_libcrux_ml_kem_hash_functions_avx2_Simd256Hash_2size_t_768size_t_800size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t(uu____3,
        uu____4);
  }
  else
  {
    libcrux_ml_kem_types_MlKemPublicKey____800size_t *uu____5 = public_key;
    uint8_t uu____6[32U];
    memcpy(uu____6, randomness, (size_t)32U * sizeof (uint8_t));
    uu____2 =
      encapsulate_generic__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_768size_t_800size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t(uu____5,
        uu____6);
    return uu____2;
  }
  return uu____2;
}

K___libcrux_ml_kem_types_MlKemCiphertext___768size_t___uint8_t_32size_t_
libcrux_ml_kem_mlkem512_encapsulate(
  libcrux_ml_kem_types_MlKemPublicKey____800size_t *public_key,
  uint8_t randomness[32U]
)
{
  libcrux_ml_kem_types_MlKemPublicKey____800size_t *uu____0 = public_key;
  uint8_t uu____1[32U];
  memcpy(uu____1, randomness, (size_t)32U * sizeof (uint8_t));
  return
    encapsulate___2size_t_768size_t_800size_t_768size_t_640size_t_128size_t_10size_t_4size_t_320size_t_3size_t_192size_t_2size_t_128size_t(uu____0,
      uu____1);
}

static libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
closure__libcrux_ml_kem_vector_PortableVector_2size_t1(void)
{
  return
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_vector_PortableVector();
}

static inline void
compute_As_plus_e__libcrux_ml_kem_vector_PortableVector_2size_t(
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  (*matrix_A)[2U],
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector *s_as_ntt,
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  *error_as_ntt,
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector ret[2U]
)
{
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  result[2U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    result[i] =
      libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_vector_PortableVector();
  }
  for
  (size_t
    i0 = (size_t)0U;
    i0
    <
      core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)2U,
          matrix_A,
          libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector [2U],
          Eurydice_slice),
        libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector [2U],
        size_t);
    i0++)
  {
    size_t i1 = i0;
    libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
    *row = matrix_A[i1];
    for
    (size_t
      i = (size_t)0U;
      i
      <
        core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)2U,
            row,
            libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector,
            Eurydice_slice),
          libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector,
          size_t);
      i++)
    {
      size_t j = i;
      libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
      *matrix_element = &row[j];
      libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
      product =
        libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ntt_multiply__libcrux_ml_kem_vector_PortableVector(matrix_element,
          &s_as_ntt[j]);
      libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_to_ring_element__libcrux_ml_kem_vector_PortableVector_2size_t(&result[i1],
        &product);
    }
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___add_standard_error_reduce__libcrux_ml_kem_vector_PortableVector(&result[i1],
      &error_as_ntt[i1]);
  }
  memcpy(ret,
    result,
    (size_t)2U
    *
      sizeof (libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector));
}

static inline void
serialize_secret_key__libcrux_ml_kem_vector_PortableVector_2size_t_768size_t(
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector key[2U],
  uint8_t ret[768U]
)
{
  uint8_t out[768U] = { 0U };
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(Eurydice_array_to_slice((size_t)2U,
          key,
          libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector,
          Eurydice_slice),
        libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector,
        size_t);
    i++)
  {
    size_t i0 = i;
    libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
    re = key[i0];
    Eurydice_slice
    uu____0 =
      Eurydice_array_to_subslice((size_t)768U,
        out,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT,
            .end = (i0 + (size_t)1U) * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    uint8_t ret0[384U];
    libcrux_ml_kem_serialize_serialize_uncompressed_ring_element__libcrux_ml_kem_vector_PortableVector(&re,
      ret0);
    core_slice___Slice_T___copy_from_slice(uu____0,
      Eurydice_array_to_slice((size_t)384U, ret0, uint8_t, Eurydice_slice),
      uint8_t,
      void *);
  }
  memcpy(ret, out, (size_t)768U * sizeof (uint8_t));
}

static inline void
serialize_public_key__libcrux_ml_kem_vector_PortableVector_2size_t_768size_t_800size_t(
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  t_as_ntt[2U],
  Eurydice_slice seed_for_a,
  uint8_t ret[800U]
)
{
  uint8_t public_key_serialized[800U] = { 0U };
  Eurydice_slice
  uu____0 =
    Eurydice_array_to_subslice((size_t)800U,
      public_key_serialized,
      ((core_ops_range_Range__size_t){ .start = (size_t)0U, .end = (size_t)768U }),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice);
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  uu____1[2U];
  memcpy(uu____1,
    t_as_ntt,
    (size_t)2U
    *
      sizeof (libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector));
  uint8_t ret0[768U];
  serialize_secret_key__libcrux_ml_kem_vector_PortableVector_2size_t_768size_t(uu____1, ret0);
  core_slice___Slice_T___copy_from_slice(uu____0,
    Eurydice_array_to_slice((size_t)768U, ret0, uint8_t, Eurydice_slice),
    uint8_t,
    void *);
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice_from((size_t)800U,
      public_key_serialized,
      (size_t)768U,
      uint8_t,
      size_t,
      Eurydice_slice),
    seed_for_a,
    uint8_t,
    void *);
  memcpy(ret, public_key_serialized, (size_t)800U * sizeof (uint8_t));
}

static K___uint8_t_768size_t__uint8_t_800size_t_
generate_keypair__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_768size_t_800size_t_768size_t_3size_t_192size_t(
  Eurydice_slice key_generation_seed
)
{
  uint8_t hashed[64U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____G___2size_t(key_generation_seed,
    hashed);
  K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t
  uu____0 =
    core_slice___Slice_T___split_at(Eurydice_array_to_slice((size_t)64U,
        hashed,
        uint8_t,
        Eurydice_slice),
      (size_t)32U,
      uint8_t,
      K___Eurydice_slice_uint8_t_Eurydice_slice_uint8_t);
  Eurydice_slice seed_for_A = uu____0.fst;
  Eurydice_slice seed_for_secret_and_error = uu____0.snd;
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  A_transpose[2U][2U];
  uint8_t ret[34U];
  libcrux_ml_kem_ind_cpa_into_padded_array___34size_t(seed_for_A, ret);
  sample_matrix_A__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t(ret,
    true,
    A_transpose);
  uint8_t prf_input[33U];
  libcrux_ml_kem_ind_cpa_into_padded_array___33size_t(seed_for_secret_and_error, prf_input);
  uint8_t uu____1[33U];
  memcpy(uu____1, prf_input, (size_t)33U * sizeof (uint8_t));
  K___libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector_2size_t__uint8_t
  uu____2 =
    sample_vector_cbd_then_ntt__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_3size_t_192size_t(uu____1,
      0U);
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  secret_as_ntt[2U];
  memcpy(secret_as_ntt,
    uu____2.fst,
    (size_t)2U
    *
      sizeof (libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector));
  uint8_t domain_separator = uu____2.snd;
  uint8_t uu____3[33U];
  memcpy(uu____3, prf_input, (size_t)33U * sizeof (uint8_t));
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  error_as_ntt[2U];
  memcpy(error_as_ntt,
    sample_vector_cbd_then_ntt__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_3size_t_192size_t(uu____3,
      domain_separator).fst,
    (size_t)2U
    *
      sizeof (libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector));
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  t_as_ntt[2U];
  compute_As_plus_e__libcrux_ml_kem_vector_PortableVector_2size_t(A_transpose,
    secret_as_ntt,
    error_as_ntt,
    t_as_ntt);
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  uu____4[2U];
  memcpy(uu____4,
    t_as_ntt,
    (size_t)2U
    *
      sizeof (libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector));
  uint8_t public_key_serialized[800U];
  serialize_public_key__libcrux_ml_kem_vector_PortableVector_2size_t_768size_t_800size_t(uu____4,
    seed_for_A,
    public_key_serialized);
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  uu____5[2U];
  memcpy(uu____5,
    secret_as_ntt,
    (size_t)2U
    *
      sizeof (libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector));
  uint8_t secret_key_serialized[768U];
  serialize_secret_key__libcrux_ml_kem_vector_PortableVector_2size_t_768size_t(uu____5,
    secret_key_serialized);
  uint8_t uu____6[768U];
  memcpy(uu____6, secret_key_serialized, (size_t)768U * sizeof (uint8_t));
  uint8_t uu____7[800U];
  memcpy(uu____7, public_key_serialized, (size_t)800U * sizeof (uint8_t));
  K___uint8_t_768size_t__uint8_t_800size_t_ lit;
  memcpy(lit.fst, uu____6, (size_t)768U * sizeof (uint8_t));
  memcpy(lit.snd, uu____7, (size_t)800U * sizeof (uint8_t));
  return lit;
}

static inline void
serialize_kem_secret_key__libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_1632size_t(
  Eurydice_slice private_key,
  Eurydice_slice public_key,
  Eurydice_slice implicit_rejection_value,
  uint8_t ret[1632U]
)
{
  uint8_t out[1632U] = { 0U };
  size_t pointer = (size_t)0U;
  uint8_t *uu____0 = out;
  size_t uu____1 = pointer;
  size_t uu____2 = pointer;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)1632U,
      uu____0,
      (
        (core_ops_range_Range__size_t){
          .start = uu____1,
          .end = uu____2 + core_slice___Slice_T___len(private_key, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    private_key,
    uint8_t,
    void *);
  pointer = pointer + core_slice___Slice_T___len(private_key, uint8_t, size_t);
  uint8_t *uu____3 = out;
  size_t uu____4 = pointer;
  size_t uu____5 = pointer;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)1632U,
      uu____3,
      (
        (core_ops_range_Range__size_t){
          .start = uu____4,
          .end = uu____5 + core_slice___Slice_T___len(public_key, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    public_key,
    uint8_t,
    void *);
  pointer = pointer + core_slice___Slice_T___len(public_key, uint8_t, size_t);
  Eurydice_slice
  uu____6 =
    Eurydice_array_to_subslice((size_t)1632U,
      out,
      (
        (core_ops_range_Range__size_t){
          .start = pointer,
          .end = pointer + LIBCRUX_ML_KEM_CONSTANTS_H_DIGEST_SIZE
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice);
  uint8_t ret0[32U];
  libcrux_ml_kem_hash_functions_portable___libcrux_ml_kem__hash_functions__Hash_K__for_libcrux_ml_kem__hash_functions__portable__PortableHash_K____H___2size_t(public_key,
    ret0);
  core_slice___Slice_T___copy_from_slice(uu____6,
    Eurydice_array_to_slice((size_t)32U, ret0, uint8_t, Eurydice_slice),
    uint8_t,
    void *);
  pointer = pointer + LIBCRUX_ML_KEM_CONSTANTS_H_DIGEST_SIZE;
  uint8_t *uu____7 = out;
  size_t uu____8 = pointer;
  size_t uu____9 = pointer;
  core_slice___Slice_T___copy_from_slice(Eurydice_array_to_subslice((size_t)1632U,
      uu____7,
      (
        (core_ops_range_Range__size_t){
          .start = uu____8,
          .end = uu____9 + core_slice___Slice_T___len(implicit_rejection_value, uint8_t, size_t)
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice),
    implicit_rejection_value,
    uint8_t,
    void *);
  memcpy(ret, out, (size_t)1632U * sizeof (uint8_t));
}

static libcrux_ml_kem_types_MlKemKeyPair____1632size_t__800size_t
generate_keypair_generic__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_768size_t_1632size_t_800size_t_768size_t_3size_t_192size_t(
  Eurydice_slice ind_cpa_keypair_randomness,
  Eurydice_slice implicit_rejection_value
)
{
  K___uint8_t_768size_t__uint8_t_800size_t_
  uu____0 =
    generate_keypair__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_768size_t_800size_t_768size_t_3size_t_192size_t(ind_cpa_keypair_randomness);
  uint8_t ind_cpa_private_key[768U];
  memcpy(ind_cpa_private_key, uu____0.fst, (size_t)768U * sizeof (uint8_t));
  uint8_t public_key[800U];
  memcpy(public_key, uu____0.snd, (size_t)800U * sizeof (uint8_t));
  Eurydice_slice
  uu____1 = Eurydice_array_to_slice((size_t)768U, ind_cpa_private_key, uint8_t, Eurydice_slice);
  uint8_t secret_key_serialized[1632U];
  serialize_kem_secret_key__libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_1632size_t(uu____1,
    Eurydice_array_to_slice((size_t)800U, public_key, uint8_t, Eurydice_slice),
    implicit_rejection_value,
    secret_key_serialized);
  uint8_t uu____2[1632U];
  memcpy(uu____2, secret_key_serialized, (size_t)1632U * sizeof (uint8_t));
  libcrux_ml_kem_types_MlKemPrivateKey____1632size_t
  private_key =
    libcrux_ml_kem_types___core__convert__From__Array_u8__SIZE___for_libcrux_ml_kem__types__MlKemPrivateKey_SIZE___8__from___1632size_t(uu____2);
  libcrux_ml_kem_types_MlKemPrivateKey____1632size_t uu____3 = private_key;
  uint8_t uu____4[800U];
  memcpy(uu____4, public_key, (size_t)800U * sizeof (uint8_t));
  return
    libcrux_ml_kem_types__libcrux_ml_kem__types__MlKemKeyPair_PRIVATE_KEY_SIZE__PUBLIC_KEY_SIZE___from___1632size_t_800size_t(uu____3,
      libcrux_ml_kem_types___core__convert__From__Array_u8__SIZE___for_libcrux_ml_kem__types__MlKemPublicKey_SIZE___14__from___800size_t(uu____4));
}

static libcrux_ml_kem_types_MlKemKeyPair____1632size_t__800size_t
generate_keypair___2size_t_768size_t_1632size_t_800size_t_768size_t_3size_t_192size_t(
  uint8_t randomness[64U]
)
{
  Eurydice_slice
  ind_cpa_keypair_randomness =
    Eurydice_array_to_subslice((size_t)64U,
      randomness,
      (
        (core_ops_range_Range__size_t){
          .start = (size_t)0U,
          .end = LIBCRUX_ML_KEM_CONSTANTS_CPA_PKE_KEY_GENERATION_SEED_SIZE
        }
      ),
      uint8_t,
      core_ops_range_Range__size_t,
      Eurydice_slice);
  Eurydice_slice
  implicit_rejection_value =
    Eurydice_array_to_subslice_from((size_t)64U,
      randomness,
      LIBCRUX_ML_KEM_CONSTANTS_CPA_PKE_KEY_GENERATION_SEED_SIZE,
      uint8_t,
      size_t,
      Eurydice_slice);
  bool uu____0;
  uu____0 = true;
  bool uu____1;
  if (uu____0)
  {
    uu____1 = libcrux_platform_platform_simd256_support();
  }
  else
  {
    uu____1 = false;
  }
  libcrux_ml_kem_types_MlKemKeyPair____1632size_t__800size_t uu____2;
  if (uu____1)
  {
    uu____2 =
      libcrux_ml_kem_ind_cca_generate_keypair_generic__libcrux_ml_kem_vector_avx2_SIMD256Vector_libcrux_ml_kem_hash_functions_avx2_Simd256Hash_2size_t_768size_t_1632size_t_800size_t_768size_t_3size_t_192size_t(ind_cpa_keypair_randomness,
        implicit_rejection_value);
  }
  else
  {
    uu____2 =
      generate_keypair_generic__libcrux_ml_kem_vector_PortableVector_libcrux_ml_kem_hash_functions_portable_PortableHash___2size_t___2size_t_768size_t_1632size_t_800size_t_768size_t_3size_t_192size_t(ind_cpa_keypair_randomness,
        implicit_rejection_value);
  }
  return uu____2;
}

libcrux_ml_kem_types_MlKemKeyPair____1632size_t__800size_t
libcrux_ml_kem_mlkem512_generate_key_pair(uint8_t randomness[64U])
{
  uint8_t uu____0[64U];
  memcpy(uu____0, randomness, (size_t)64U * sizeof (uint8_t));
  return
    generate_keypair___2size_t_768size_t_1632size_t_800size_t_768size_t_3size_t_192size_t(uu____0);
}

static libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
closure__libcrux_ml_kem_vector_PortableVector_800size_t_2size_t(void)
{
  return
    libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_vector_PortableVector();
}

static inline void
deserialize_ring_elements_reduced__libcrux_ml_kem_vector_PortableVector_800size_t_2size_t(
  Eurydice_slice public_key,
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector ret[2U]
)
{
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  deserialized_pk[2U];
  for (size_t i = (size_t)0U; i < (size_t)2U; i++)
  {
    deserialized_pk[i] =
      libcrux_ml_kem_polynomial__libcrux_ml_kem__polynomial__PolynomialRingElement_Vector__TraitClause_0___ZERO__libcrux_ml_kem_vector_PortableVector();
  }
  for
  (size_t
    i = (size_t)0U;
    i
    <
      core_slice___Slice_T___len(public_key,
        uint8_t,
        size_t)
      / LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT;
    i++)
  {
    size_t i0 = i;
    Eurydice_slice
    ring_element =
      Eurydice_slice_subslice(public_key,
        (
          (core_ops_range_Range__size_t){
            .start = i0 * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT,
            .end = i0
            * LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT
            + LIBCRUX_ML_KEM_CONSTANTS_BYTES_PER_RING_ELEMENT
          }
        ),
        uint8_t,
        core_ops_range_Range__size_t,
        Eurydice_slice);
    libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
    uu____0 =
      libcrux_ml_kem_serialize_deserialize_to_reduced_ring_element__libcrux_ml_kem_vector_PortableVector(ring_element);
    deserialized_pk[i0] = uu____0;
  }
  memcpy(ret,
    deserialized_pk,
    (size_t)2U
    *
      sizeof (libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector));
}

static bool
validate_public_key_generic__libcrux_ml_kem_vector_PortableVector_2size_t_768size_t_800size_t(
  uint8_t *public_key
)
{
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  deserialized_pk[2U];
  deserialize_ring_elements_reduced__libcrux_ml_kem_vector_PortableVector_800size_t_2size_t(Eurydice_array_to_subslice_to((size_t)800U,
      public_key,
      (size_t)768U,
      uint8_t,
      size_t,
      Eurydice_slice),
    deserialized_pk);
  libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector
  uu____0[2U];
  memcpy(uu____0,
    deserialized_pk,
    (size_t)2U
    *
      sizeof (libcrux_ml_kem_polynomial_PolynomialRingElement__libcrux_ml_kem_vector_PortableVector));
  uint8_t public_key_serialized[800U];
  serialize_public_key__libcrux_ml_kem_vector_PortableVector_2size_t_768size_t_800size_t(uu____0,
    Eurydice_array_to_subslice_from((size_t)800U,
      public_key,
      (size_t)768U,
      uint8_t,
      size_t,
      Eurydice_slice),
    public_key_serialized);
  return
    core_array_equality___core__cmp__PartialEq__Array_B__N___for__Array_A__N____eq((size_t)800U,
      public_key,
      public_key_serialized,
      uint8_t,
      uint8_t,
      bool);
}

static bool validate_public_key___2size_t_768size_t_800size_t(uint8_t *public_key)
{
  bool uu____0;
  uu____0 = true;
  bool uu____1;
  if (uu____0)
  {
    uu____1 = libcrux_platform_platform_simd256_support();
  }
  else
  {
    uu____1 = false;
  }
  bool uu____2;
  if (uu____1)
  {
    uu____2 =
      libcrux_ml_kem_ind_cca_validate_public_key_generic__libcrux_ml_kem_vector_avx2_SIMD256Vector_2size_t_768size_t_800size_t(public_key);
  }
  else
  {
    uu____2 =
      validate_public_key_generic__libcrux_ml_kem_vector_PortableVector_2size_t_768size_t_800size_t(public_key);
  }
  return uu____2;
}

core_option_Option__libcrux_ml_kem_types_MlKemPublicKey___800size_t__
libcrux_ml_kem_mlkem512_validate_public_key(
  libcrux_ml_kem_types_MlKemPublicKey____800size_t public_key
)
{
  core_option_Option__libcrux_ml_kem_types_MlKemPublicKey___800size_t__ uu____0;
  if (validate_public_key___2size_t_768size_t_800size_t(public_key.value))
  {
    uu____0 =
      (
        (core_option_Option__libcrux_ml_kem_types_MlKemPublicKey___800size_t__){
          .tag = core_option_Some,
          .f0 = public_key
        }
      );
  }
  else
  {
    uu____0 =
      (
        (core_option_Option__libcrux_ml_kem_types_MlKemPublicKey___800size_t__){
          .tag = core_option_None
        }
      );
  }
  return uu____0;
}

