(* File automatically generated by Hacspec *)
From Hacspec Require Import Hacspec_Lib MachineIntegers.
From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.

Require Import Super.

Require Import Super.

Require Import Super. (* as add_to_ring_element *)

Require Import Super. (* as barrett_reduce *)

Require Import Super. (* as montgomery_reduce *)

Require Import Super. (* as KyberFieldElement *)

Require Import Super. (* as KyberPolynomialRingElement *)

Require Import Super. (* as COEFFICIENTS_IN_RING_ELEMENT *)

Definition v_ZETAS_MONTGOMERY_DOMAIN : nseq int32 TODO: Int.to_string length :=
  array_from_list [(@repr WORDSIZE32 1044);
    (@repr WORDSIZE32 758);
    (@repr WORDSIZE32 359);
    (@repr WORDSIZE32 1517);
    (@repr WORDSIZE32 1493);
    (@repr WORDSIZE32 1422);
    (@repr WORDSIZE32 287);
    (@repr WORDSIZE32 202);
    (@repr WORDSIZE32 171);
    (@repr WORDSIZE32 622);
    (@repr WORDSIZE32 1577);
    (@repr WORDSIZE32 182);
    (@repr WORDSIZE32 962);
    (@repr WORDSIZE32 1202);
    (@repr WORDSIZE32 1474);
    (@repr WORDSIZE32 1468);
    (@repr WORDSIZE32 573);
    (@repr WORDSIZE32 1325);
    (@repr WORDSIZE32 264);
    (@repr WORDSIZE32 383);
    (@repr WORDSIZE32 829);
    (@repr WORDSIZE32 1458);
    (@repr WORDSIZE32 1602);
    (@repr WORDSIZE32 130);
    (@repr WORDSIZE32 681);
    (@repr WORDSIZE32 1017);
    (@repr WORDSIZE32 732);
    (@repr WORDSIZE32 608);
    (@repr WORDSIZE32 1542);
    (@repr WORDSIZE32 411);
    (@repr WORDSIZE32 205);
    (@repr WORDSIZE32 1571);
    (@repr WORDSIZE32 1223);
    (@repr WORDSIZE32 652);
    (@repr WORDSIZE32 552);
    (@repr WORDSIZE32 1015);
    (@repr WORDSIZE32 1293);
    (@repr WORDSIZE32 1491);
    (@repr WORDSIZE32 282);
    (@repr WORDSIZE32 1544);
    (@repr WORDSIZE32 516);
    (@repr WORDSIZE32 8);
    (@repr WORDSIZE32 320);
    (@repr WORDSIZE32 666);
    (@repr WORDSIZE32 1618);
    (@repr WORDSIZE32 1162);
    (@repr WORDSIZE32 126);
    (@repr WORDSIZE32 1469);
    (@repr WORDSIZE32 853);
    (@repr WORDSIZE32 90);
    (@repr WORDSIZE32 271);
    (@repr WORDSIZE32 830);
    (@repr WORDSIZE32 107);
    (@repr WORDSIZE32 1421);
    (@repr WORDSIZE32 247);
    (@repr WORDSIZE32 951);
    (@repr WORDSIZE32 398);
    (@repr WORDSIZE32 961);
    (@repr WORDSIZE32 1508);
    (@repr WORDSIZE32 725);
    (@repr WORDSIZE32 448);
    (@repr WORDSIZE32 1065);
    (@repr WORDSIZE32 677);
    (@repr WORDSIZE32 1275);
    (@repr WORDSIZE32 1103);
    (@repr WORDSIZE32 430);
    (@repr WORDSIZE32 555);
    (@repr WORDSIZE32 843);
    (@repr WORDSIZE32 1251);
    (@repr WORDSIZE32 871);
    (@repr WORDSIZE32 1550);
    (@repr WORDSIZE32 105);
    (@repr WORDSIZE32 422);
    (@repr WORDSIZE32 587);
    (@repr WORDSIZE32 177);
    (@repr WORDSIZE32 235);
    (@repr WORDSIZE32 291);
    (@repr WORDSIZE32 460);
    (@repr WORDSIZE32 1574);
    (@repr WORDSIZE32 1653);
    (@repr WORDSIZE32 246);
    (@repr WORDSIZE32 778);
    (@repr WORDSIZE32 1159);
    (@repr WORDSIZE32 147);
    (@repr WORDSIZE32 777);
    (@repr WORDSIZE32 1483);
    (@repr WORDSIZE32 602);
    (@repr WORDSIZE32 1119);
    (@repr WORDSIZE32 1590);
    (@repr WORDSIZE32 644);
    (@repr WORDSIZE32 872);
    (@repr WORDSIZE32 349);
    (@repr WORDSIZE32 418);
    (@repr WORDSIZE32 329);
    (@repr WORDSIZE32 156);
    (@repr WORDSIZE32 75);
    (@repr WORDSIZE32 817);
    (@repr WORDSIZE32 1097);
    (@repr WORDSIZE32 603);
    (@repr WORDSIZE32 610);
    (@repr WORDSIZE32 1322);
    (@repr WORDSIZE32 1285);
    (@repr WORDSIZE32 1465);
    (@repr WORDSIZE32 384);
    (@repr WORDSIZE32 1215);
    (@repr WORDSIZE32 136);
    (@repr WORDSIZE32 1218);
    (@repr WORDSIZE32 1335);
    (@repr WORDSIZE32 874);
    (@repr WORDSIZE32 220);
    (@repr WORDSIZE32 1187);
    (@repr WORDSIZE32 1659);
    (@repr WORDSIZE32 1185);
    (@repr WORDSIZE32 1530);
    (@repr WORDSIZE32 1278);
    (@repr WORDSIZE32 794);
    (@repr WORDSIZE32 1510);
    (@repr WORDSIZE32 854);
    (@repr WORDSIZE32 870);
    (@repr WORDSIZE32 478);
    (@repr WORDSIZE32 108);
    (@repr WORDSIZE32 308);
    (@repr WORDSIZE32 996);
    (@repr WORDSIZE32 991);
    (@repr WORDSIZE32 958);
    (@repr WORDSIZE32 1460);
    (@repr WORDSIZE32 1522);
    (@repr WORDSIZE32 1628)].

(*Not implemented yet? todo(item)*)

Definition ntt_multiply_binomials ('(a0,a1) : (int32 × int32)) ('(b0,b1) : (int32 × int32)) (zeta : int32) : (int32 × int32) :=
  (montgomery_reduce ((a0.*b0).+((montgomery_reduce (a1.*b1)).*zeta)),montgomery_reduce ((a0.*b1).+(a1.*b0))).

(*Not implemented yet? todo(item)*)

Definition invert_ntt_montgomery (re : t_KyberPolynomialRingElement_t) : t_KyberPolynomialRingElement_t :=
  let _ := (tt) : unit in
  let zeta_i := (v_COEFFICIENTS_IN_RING_ELEMENT./(@repr WORDSIZE32 2)) : uint_size in
  let step := ((@repr WORDSIZE32 1) shift_left (@repr WORDSIZE32 1)) : uint_size in
  let '(re,zeta_i) := (f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)((@repr WORDSIZE32 128)./step))) (re,zeta_i) (fun '(re,zeta_i) round =>
      let zeta_i := (zeta_i.-(@repr WORDSIZE32 1)) : uint_size in
      let offset := ((round.*step).*(@repr WORDSIZE32 2)) : uint_size in
      let re := (f_fold (f_into_iter (Build_Range offset(offset.+step))) re (fun re j =>
          let a_minus_b := (((f_coefficients re).[(j.+step)]).-((f_coefficients re).[j])) : int32 in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) j (((f_coefficients re).[j]).+((f_coefficients re).[(j.+step)])))) : t_KyberPolynomialRingElement_t in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) (j.+step) (montgomery_reduce (a_minus_b.*(v_ZETAS_MONTGOMERY_DOMAIN.[zeta_i]))))) : t_KyberPolynomialRingElement_t in
          re)) : t_KyberPolynomialRingElement_t in
      (re,zeta_i))) : (t_KyberPolynomialRingElement_t × uint_size) in
  let step := ((@repr WORDSIZE32 1) shift_left (@repr WORDSIZE32 2)) : uint_size in
  let '(re,zeta_i) := (f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)((@repr WORDSIZE32 128)./step))) (re,zeta_i) (fun '(re,zeta_i) round =>
      let zeta_i := (zeta_i.-(@repr WORDSIZE32 1)) : uint_size in
      let offset := ((round.*step).*(@repr WORDSIZE32 2)) : uint_size in
      let re := (f_fold (f_into_iter (Build_Range offset(offset.+step))) re (fun re j =>
          let a_minus_b := (((f_coefficients re).[(j.+step)]).-((f_coefficients re).[j])) : int32 in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) j (((f_coefficients re).[j]).+((f_coefficients re).[(j.+step)])))) : t_KyberPolynomialRingElement_t in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) (j.+step) (montgomery_reduce (a_minus_b.*(v_ZETAS_MONTGOMERY_DOMAIN.[zeta_i]))))) : t_KyberPolynomialRingElement_t in
          re)) : t_KyberPolynomialRingElement_t in
      (re,zeta_i))) : (t_KyberPolynomialRingElement_t × uint_size) in
  let step := ((@repr WORDSIZE32 1) shift_left (@repr WORDSIZE32 3)) : uint_size in
  let '(re,zeta_i) := (f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)((@repr WORDSIZE32 128)./step))) (re,zeta_i) (fun '(re,zeta_i) round =>
      let zeta_i := (zeta_i.-(@repr WORDSIZE32 1)) : uint_size in
      let offset := ((round.*step).*(@repr WORDSIZE32 2)) : uint_size in
      let re := (f_fold (f_into_iter (Build_Range offset(offset.+step))) re (fun re j =>
          let a_minus_b := (((f_coefficients re).[(j.+step)]).-((f_coefficients re).[j])) : int32 in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) j (((f_coefficients re).[j]).+((f_coefficients re).[(j.+step)])))) : t_KyberPolynomialRingElement_t in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) (j.+step) (montgomery_reduce (a_minus_b.*(v_ZETAS_MONTGOMERY_DOMAIN.[zeta_i]))))) : t_KyberPolynomialRingElement_t in
          re)) : t_KyberPolynomialRingElement_t in
      (re,zeta_i))) : (t_KyberPolynomialRingElement_t × uint_size) in
  let step := ((@repr WORDSIZE32 1) shift_left (@repr WORDSIZE32 4)) : uint_size in
  let '(re,zeta_i) := (f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)((@repr WORDSIZE32 128)./step))) (re,zeta_i) (fun '(re,zeta_i) round =>
      let zeta_i := (zeta_i.-(@repr WORDSIZE32 1)) : uint_size in
      let offset := ((round.*step).*(@repr WORDSIZE32 2)) : uint_size in
      let re := (f_fold (f_into_iter (Build_Range offset(offset.+step))) re (fun re j =>
          let a_minus_b := (((f_coefficients re).[(j.+step)]).-((f_coefficients re).[j])) : int32 in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) j (((f_coefficients re).[j]).+((f_coefficients re).[(j.+step)])))) : t_KyberPolynomialRingElement_t in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) (j.+step) (montgomery_reduce (a_minus_b.*(v_ZETAS_MONTGOMERY_DOMAIN.[zeta_i]))))) : t_KyberPolynomialRingElement_t in
          re)) : t_KyberPolynomialRingElement_t in
      (re,zeta_i))) : (t_KyberPolynomialRingElement_t × uint_size) in
  let step := ((@repr WORDSIZE32 1) shift_left (@repr WORDSIZE32 5)) : uint_size in
  let '(re,zeta_i) := (f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)((@repr WORDSIZE32 128)./step))) (re,zeta_i) (fun '(re,zeta_i) round =>
      let zeta_i := (zeta_i.-(@repr WORDSIZE32 1)) : uint_size in
      let offset := ((round.*step).*(@repr WORDSIZE32 2)) : uint_size in
      let re := (f_fold (f_into_iter (Build_Range offset(offset.+step))) re (fun re j =>
          let a_minus_b := (((f_coefficients re).[(j.+step)]).-((f_coefficients re).[j])) : int32 in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) j (((f_coefficients re).[j]).+((f_coefficients re).[(j.+step)])))) : t_KyberPolynomialRingElement_t in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) (j.+step) (montgomery_reduce (a_minus_b.*(v_ZETAS_MONTGOMERY_DOMAIN.[zeta_i]))))) : t_KyberPolynomialRingElement_t in
          re)) : t_KyberPolynomialRingElement_t in
      (re,zeta_i))) : (t_KyberPolynomialRingElement_t × uint_size) in
  let step := ((@repr WORDSIZE32 1) shift_left (@repr WORDSIZE32 6)) : uint_size in
  let '(re,zeta_i) := (f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)((@repr WORDSIZE32 128)./step))) (re,zeta_i) (fun '(re,zeta_i) round =>
      let zeta_i := (zeta_i.-(@repr WORDSIZE32 1)) : uint_size in
      let offset := ((round.*step).*(@repr WORDSIZE32 2)) : uint_size in
      let re := (f_fold (f_into_iter (Build_Range offset(offset.+step))) re (fun re j =>
          let a_minus_b := (((f_coefficients re).[(j.+step)]).-((f_coefficients re).[j])) : int32 in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) j (((f_coefficients re).[j]).+((f_coefficients re).[(j.+step)])))) : t_KyberPolynomialRingElement_t in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) (j.+step) (montgomery_reduce (a_minus_b.*(v_ZETAS_MONTGOMERY_DOMAIN.[zeta_i]))))) : t_KyberPolynomialRingElement_t in
          re)) : t_KyberPolynomialRingElement_t in
      (re,zeta_i))) : (t_KyberPolynomialRingElement_t × uint_size) in
  let step := ((@repr WORDSIZE32 1) shift_left (@repr WORDSIZE32 7)) : uint_size in
  let '(re,zeta_i) := (f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)((@repr WORDSIZE32 128)./step))) (re,zeta_i) (fun '(re,zeta_i) round =>
      let zeta_i := (zeta_i.-(@repr WORDSIZE32 1)) : uint_size in
      let offset := ((round.*step).*(@repr WORDSIZE32 2)) : uint_size in
      let re := (f_fold (f_into_iter (Build_Range offset(offset.+step))) re (fun re j =>
          let a_minus_b := (((f_coefficients re).[(j.+step)]).-((f_coefficients re).[j])) : int32 in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) j (((f_coefficients re).[j]).+((f_coefficients re).[(j.+step)])))) : t_KyberPolynomialRingElement_t in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) (j.+step) (montgomery_reduce (a_minus_b.*(v_ZETAS_MONTGOMERY_DOMAIN.[zeta_i]))))) : t_KyberPolynomialRingElement_t in
          re)) : t_KyberPolynomialRingElement_t in
      (re,zeta_i))) : (t_KyberPolynomialRingElement_t × uint_size) in
  let _ := (tt) : unit in
  let _ := (tt) : unit in
  let re := (f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)(@repr WORDSIZE32 8))) re (fun re i =>
      Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) i (barrett_reduce ((f_coefficients re).[i]))))) : t_KyberPolynomialRingElement_t in
  re.

Definition ntt_binomially_sampled_ring_element (re : t_KyberPolynomialRingElement_t) : t_KyberPolynomialRingElement_t :=
  let _ := (tt) : unit in
  let zeta_i := ((@repr WORDSIZE32 0)) : uint_size in
  let zeta_i := (zeta_i.+(@repr WORDSIZE32 1)) : uint_size in
  let re := (f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)(@repr WORDSIZE32 128))) re (fun re j =>
      let t := (((f_coefficients re).[(j.+(@repr WORDSIZE32 128))]).*(@repr WORDSIZE32 1600)) : int32 in
      let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) (j.+(@repr WORDSIZE32 128)) (((f_coefficients re).[j]).-t))) : t_KyberPolynomialRingElement_t in
      let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) j (((f_coefficients re).[j]).+t))) : t_KyberPolynomialRingElement_t in
      re)) : t_KyberPolynomialRingElement_t in
  let _ := (tt) : unit in
  let step := ((@repr WORDSIZE32 1) shift_left (@repr WORDSIZE32 6)) : uint_size in
  let '(re,zeta_i) := (f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)((@repr WORDSIZE32 128)./step))) (re,zeta_i) (fun '(re,zeta_i) round =>
      let zeta_i := (zeta_i.+(@repr WORDSIZE32 1)) : uint_size in
      let offset := ((round.*step).*(@repr WORDSIZE32 2)) : uint_size in
      let re := (f_fold (f_into_iter (Build_Range offset(offset.+step))) re (fun re j =>
          let t := (montgomery_reduce (((f_coefficients re).[(j.+step)]).*(v_ZETAS_MONTGOMERY_DOMAIN.[zeta_i]))) : int32 in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) (j.+step) (((f_coefficients re).[j]).-t))) : t_KyberPolynomialRingElement_t in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) j (((f_coefficients re).[j]).+t))) : t_KyberPolynomialRingElement_t in
          re)) : t_KyberPolynomialRingElement_t in
      (re,zeta_i))) : (t_KyberPolynomialRingElement_t × uint_size) in
  let _ := (tt) : unit in
  let step := ((@repr WORDSIZE32 1) shift_left (@repr WORDSIZE32 5)) : uint_size in
  let '(re,zeta_i) := (f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)((@repr WORDSIZE32 128)./step))) (re,zeta_i) (fun '(re,zeta_i) round =>
      let zeta_i := (zeta_i.+(@repr WORDSIZE32 1)) : uint_size in
      let offset := ((round.*step).*(@repr WORDSIZE32 2)) : uint_size in
      let re := (f_fold (f_into_iter (Build_Range offset(offset.+step))) re (fun re j =>
          let t := (montgomery_reduce (((f_coefficients re).[(j.+step)]).*(v_ZETAS_MONTGOMERY_DOMAIN.[zeta_i]))) : int32 in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) (j.+step) (((f_coefficients re).[j]).-t))) : t_KyberPolynomialRingElement_t in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) j (((f_coefficients re).[j]).+t))) : t_KyberPolynomialRingElement_t in
          re)) : t_KyberPolynomialRingElement_t in
      (re,zeta_i))) : (t_KyberPolynomialRingElement_t × uint_size) in
  let _ := (tt) : unit in
  let step := ((@repr WORDSIZE32 1) shift_left (@repr WORDSIZE32 4)) : uint_size in
  let '(re,zeta_i) := (f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)((@repr WORDSIZE32 128)./step))) (re,zeta_i) (fun '(re,zeta_i) round =>
      let zeta_i := (zeta_i.+(@repr WORDSIZE32 1)) : uint_size in
      let offset := ((round.*step).*(@repr WORDSIZE32 2)) : uint_size in
      let re := (f_fold (f_into_iter (Build_Range offset(offset.+step))) re (fun re j =>
          let t := (montgomery_reduce (((f_coefficients re).[(j.+step)]).*(v_ZETAS_MONTGOMERY_DOMAIN.[zeta_i]))) : int32 in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) (j.+step) (((f_coefficients re).[j]).-t))) : t_KyberPolynomialRingElement_t in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) j (((f_coefficients re).[j]).+t))) : t_KyberPolynomialRingElement_t in
          re)) : t_KyberPolynomialRingElement_t in
      (re,zeta_i))) : (t_KyberPolynomialRingElement_t × uint_size) in
  let _ := (tt) : unit in
  let step := ((@repr WORDSIZE32 1) shift_left (@repr WORDSIZE32 3)) : uint_size in
  let '(re,zeta_i) := (f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)((@repr WORDSIZE32 128)./step))) (re,zeta_i) (fun '(re,zeta_i) round =>
      let zeta_i := (zeta_i.+(@repr WORDSIZE32 1)) : uint_size in
      let offset := ((round.*step).*(@repr WORDSIZE32 2)) : uint_size in
      let re := (f_fold (f_into_iter (Build_Range offset(offset.+step))) re (fun re j =>
          let t := (montgomery_reduce (((f_coefficients re).[(j.+step)]).*(v_ZETAS_MONTGOMERY_DOMAIN.[zeta_i]))) : int32 in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) (j.+step) (((f_coefficients re).[j]).-t))) : t_KyberPolynomialRingElement_t in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) j (((f_coefficients re).[j]).+t))) : t_KyberPolynomialRingElement_t in
          re)) : t_KyberPolynomialRingElement_t in
      (re,zeta_i))) : (t_KyberPolynomialRingElement_t × uint_size) in
  let _ := (tt) : unit in
  let step := ((@repr WORDSIZE32 1) shift_left (@repr WORDSIZE32 2)) : uint_size in
  let '(re,zeta_i) := (f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)((@repr WORDSIZE32 128)./step))) (re,zeta_i) (fun '(re,zeta_i) round =>
      let zeta_i := (zeta_i.+(@repr WORDSIZE32 1)) : uint_size in
      let offset := ((round.*step).*(@repr WORDSIZE32 2)) : uint_size in
      let re := (f_fold (f_into_iter (Build_Range offset(offset.+step))) re (fun re j =>
          let t := (montgomery_reduce (((f_coefficients re).[(j.+step)]).*(v_ZETAS_MONTGOMERY_DOMAIN.[zeta_i]))) : int32 in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) (j.+step) (((f_coefficients re).[j]).-t))) : t_KyberPolynomialRingElement_t in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) j (((f_coefficients re).[j]).+t))) : t_KyberPolynomialRingElement_t in
          re)) : t_KyberPolynomialRingElement_t in
      (re,zeta_i))) : (t_KyberPolynomialRingElement_t × uint_size) in
  let _ := (tt) : unit in
  let step := ((@repr WORDSIZE32 1) shift_left (@repr WORDSIZE32 1)) : uint_size in
  let '(re,zeta_i) := (f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)((@repr WORDSIZE32 128)./step))) (re,zeta_i) (fun '(re,zeta_i) round =>
      let zeta_i := (zeta_i.+(@repr WORDSIZE32 1)) : uint_size in
      let offset := ((round.*step).*(@repr WORDSIZE32 2)) : uint_size in
      let re := (f_fold (f_into_iter (Build_Range offset(offset.+step))) re (fun re j =>
          let t := (montgomery_reduce (((f_coefficients re).[(j.+step)]).*(v_ZETAS_MONTGOMERY_DOMAIN.[zeta_i]))) : int32 in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) (j.+step) (((f_coefficients re).[j]).-t))) : t_KyberPolynomialRingElement_t in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) j (((f_coefficients re).[j]).+t))) : t_KyberPolynomialRingElement_t in
          re)) : t_KyberPolynomialRingElement_t in
      (re,zeta_i))) : (t_KyberPolynomialRingElement_t × uint_size) in
  let _ := (tt) : unit in
  let re := (Build_t_KyberPolynomialRingElement (impl_23__map (f_coefficients re) barrett_reduce)) : t_KyberPolynomialRingElement_t in
  re.

Definition ntt_multiply (left : t_KyberPolynomialRingElement_t) (right : t_KyberPolynomialRingElement_t) : t_KyberPolynomialRingElement_t :=
  let _ := (tt) : unit in
  let _ := (tt) : unit in
  let out := (impl__KyberPolynomialRingElement__ZERO) : t_KyberPolynomialRingElement_t in
  let out := (f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)(v_COEFFICIENTS_IN_RING_ELEMENT./(@repr WORDSIZE32 4)))) out (fun out i =>
      let product := (ntt_multiply_binomials ((f_coefficients left).[((@repr WORDSIZE32 4).*i)],(f_coefficients left).[(((@repr WORDSIZE32 4).*i).+(@repr WORDSIZE32 1))]) ((f_coefficients right).[((@repr WORDSIZE32 4).*i)],(f_coefficients right).[(((@repr WORDSIZE32 4).*i).+(@repr WORDSIZE32 1))]) (v_ZETAS_MONTGOMERY_DOMAIN.[((@repr WORDSIZE32 64).+i)])) : (int32 × int32) in
      let out := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients out) ((@repr WORDSIZE32 4).*i) failure todo(term))) : t_KyberPolynomialRingElement_t in
      let out := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients out) (((@repr WORDSIZE32 4).*i).+(@repr WORDSIZE32 1)) failure todo(term))) : t_KyberPolynomialRingElement_t in
      let product := (ntt_multiply_binomials ((f_coefficients left).[(((@repr WORDSIZE32 4).*i).+(@repr WORDSIZE32 2))],(f_coefficients left).[(((@repr WORDSIZE32 4).*i).+(@repr WORDSIZE32 3))]) ((f_coefficients right).[(((@repr WORDSIZE32 4).*i).+(@repr WORDSIZE32 2))],(f_coefficients right).[(((@repr WORDSIZE32 4).*i).+(@repr WORDSIZE32 3))]) (neg (v_ZETAS_MONTGOMERY_DOMAIN.[((@repr WORDSIZE32 64).+i)]))) : (int32 × int32) in
      let out := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients out) (((@repr WORDSIZE32 4).*i).+(@repr WORDSIZE32 2)) failure todo(term))) : t_KyberPolynomialRingElement_t in
      let out := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients out) (((@repr WORDSIZE32 4).*i).+(@repr WORDSIZE32 3)) failure todo(term))) : t_KyberPolynomialRingElement_t in
      out)) : t_KyberPolynomialRingElement_t in
  let _ := (tt) : unit in
  out.

Definition compute_As_plus_e (matrix_A : nseq nseq t_KyberPolynomialRingElement_t TODO: Int.to_string length TODO: Int.to_string length) (s_as_ntt : nseq t_KyberPolynomialRingElement_t TODO: Int.to_string length) (error_as_ntt : nseq t_KyberPolynomialRingElement_t TODO: Int.to_string length) : nseq t_KyberPolynomialRingElement_t TODO: Int.to_string length :=
  let result := (repeat impl__KyberPolynomialRingElement__ZERO K) : nseq t_KyberPolynomialRingElement_t TODO: Int.to_string length in
  let result := (f_fold (f_into_iter (f_enumerate (impl__iter (unsize matrix_A)))) result (fun result '(i,row) =>
      let result := (f_fold (f_into_iter (f_enumerate (impl__iter (unsize row)))) result (fun result '(j,matrix_element) =>
          let product := (ntt_multiply matrix_element (s_as_ntt.[j])) : t_KyberPolynomialRingElement_t in
          let result := (update_at result i (add_to_ring_element (result.[i]) product)) : nseq t_KyberPolynomialRingElement_t TODO: Int.to_string length in
          result)) : nseq t_KyberPolynomialRingElement_t TODO: Int.to_string length in
      f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)(impl__len (unsize (f_coefficients (result.[i])))))) result (fun result j =>
        let coefficient_normal_form := (montgomery_reduce (((f_coefficients (result.[i])).[j]).*(@repr WORDSIZE32 1353))) : int32 in
        update_at result i (Build_t_KyberPolynomialRingElement (update_at (f_coefficients (result.[i])) j (barrett_reduce (coefficient_normal_form.+((f_coefficients (error_as_ntt.[i])).[j])))))))) : nseq t_KyberPolynomialRingElement_t TODO: Int.to_string length in
  result.

Definition compute_message (v : t_KyberPolynomialRingElement_t) (secret_as_ntt : nseq t_KyberPolynomialRingElement_t TODO: Int.to_string length) (u_as_ntt : nseq t_KyberPolynomialRingElement_t TODO: Int.to_string length) : t_KyberPolynomialRingElement_t :=
  let result := (impl__KyberPolynomialRingElement__ZERO) : t_KyberPolynomialRingElement_t in
  let result := (f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)K)) result (fun result i =>
      let product := (ntt_multiply (secret_as_ntt.[i]) (u_as_ntt.[i])) : t_KyberPolynomialRingElement_t in
      let result := (add_to_ring_element result product) : t_KyberPolynomialRingElement_t in
      result)) : t_KyberPolynomialRingElement_t in
  let result := (invert_ntt_montgomery result) : t_KyberPolynomialRingElement_t in
  let result := (f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)(impl__len (unsize (f_coefficients result))))) result (fun result i =>
      let coefficient_normal_form := (montgomery_reduce (((f_coefficients result).[i]).*(@repr WORDSIZE32 1441))) : int32 in
      let result := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients result) i (barrett_reduce (((f_coefficients v).[i]).-coefficient_normal_form)))) : t_KyberPolynomialRingElement_t in
      result)) : t_KyberPolynomialRingElement_t in
  result.

Definition compute_ring_element_v (t_as_ntt : nseq t_KyberPolynomialRingElement_t TODO: Int.to_string length) (r_as_ntt : nseq t_KyberPolynomialRingElement_t TODO: Int.to_string length) (error_2 : t_KyberPolynomialRingElement_t) (message : t_KyberPolynomialRingElement_t) : t_KyberPolynomialRingElement_t :=
  let result := (impl__KyberPolynomialRingElement__ZERO) : t_KyberPolynomialRingElement_t in
  let result := (f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)K)) result (fun result i =>
      let product := (ntt_multiply (t_as_ntt.[i]) (r_as_ntt.[i])) : t_KyberPolynomialRingElement_t in
      let result := (add_to_ring_element result product) : t_KyberPolynomialRingElement_t in
      result)) : t_KyberPolynomialRingElement_t in
  let result := (invert_ntt_montgomery result) : t_KyberPolynomialRingElement_t in
  let result := (f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)(impl__len (unsize (f_coefficients result))))) result (fun result i =>
      let coefficient_normal_form := (montgomery_reduce (((f_coefficients result).[i]).*(@repr WORDSIZE32 1441))) : int32 in
      let result := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients result) i (barrett_reduce ((coefficient_normal_form.+((f_coefficients error_2).[i])).+((f_coefficients message).[i]))))) : t_KyberPolynomialRingElement_t in
      result)) : t_KyberPolynomialRingElement_t in
  result.

Definition compute_vector_u (a_as_ntt : nseq nseq t_KyberPolynomialRingElement_t TODO: Int.to_string length TODO: Int.to_string length) (r_as_ntt : nseq t_KyberPolynomialRingElement_t TODO: Int.to_string length) (error_1 : nseq t_KyberPolynomialRingElement_t TODO: Int.to_string length) : nseq t_KyberPolynomialRingElement_t TODO: Int.to_string length :=
  let result := (repeat impl__KyberPolynomialRingElement__ZERO K) : nseq t_KyberPolynomialRingElement_t TODO: Int.to_string length in
  let result := (f_fold (f_into_iter (f_enumerate (impl__iter (unsize a_as_ntt)))) result (fun result '(i,row) =>
      let result := (f_fold (f_into_iter (f_enumerate (impl__iter (unsize row)))) result (fun result '(j,a_element) =>
          let product := (ntt_multiply a_element (r_as_ntt.[j])) : t_KyberPolynomialRingElement_t in
          let result := (update_at result i (add_to_ring_element (result.[i]) product)) : nseq t_KyberPolynomialRingElement_t TODO: Int.to_string length in
          result)) : nseq t_KyberPolynomialRingElement_t TODO: Int.to_string length in
      let result := (update_at result i (invert_ntt_montgomery (result.[i]))) : nseq t_KyberPolynomialRingElement_t TODO: Int.to_string length in
      f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)(impl__len (unsize (f_coefficients (result.[i])))))) result (fun result j =>
        let coefficient_normal_form := (montgomery_reduce (((f_coefficients (result.[i])).[j]).*(@repr WORDSIZE32 1441))) : int32 in
        let result := (update_at result i (Build_t_KyberPolynomialRingElement (update_at (f_coefficients (result.[i])) j (barrett_reduce (coefficient_normal_form.+((f_coefficients (error_1.[i])).[j])))))) : nseq t_KyberPolynomialRingElement_t TODO: Int.to_string length in
        result))) : nseq t_KyberPolynomialRingElement_t TODO: Int.to_string length in
  result.

Definition ntt_vector_u (re : t_KyberPolynomialRingElement_t) : t_KyberPolynomialRingElement_t :=
  let _ := (tt) : unit in
  let zeta_i := ((@repr WORDSIZE32 0)) : uint_size in
  let step := ((@repr WORDSIZE32 1) shift_left (@repr WORDSIZE32 7)) : uint_size in
  let '(re,zeta_i) := (f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)((@repr WORDSIZE32 128)./step))) (re,zeta_i) (fun '(re,zeta_i) round =>
      let zeta_i := (zeta_i.+(@repr WORDSIZE32 1)) : uint_size in
      let offset := ((round.*step).*(@repr WORDSIZE32 2)) : uint_size in
      let re := (f_fold (f_into_iter (Build_Range offset(offset.+step))) re (fun re j =>
          let t := (montgomery_reduce (((f_coefficients re).[(j.+step)]).*(v_ZETAS_MONTGOMERY_DOMAIN.[zeta_i]))) : int32 in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) (j.+step) (((f_coefficients re).[j]).-t))) : t_KyberPolynomialRingElement_t in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) j (((f_coefficients re).[j]).+t))) : t_KyberPolynomialRingElement_t in
          re)) : t_KyberPolynomialRingElement_t in
      (re,zeta_i))) : (t_KyberPolynomialRingElement_t × uint_size) in
  let _ := (tt) : unit in
  let step := ((@repr WORDSIZE32 1) shift_left (@repr WORDSIZE32 6)) : uint_size in
  let '(re,zeta_i) := (f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)((@repr WORDSIZE32 128)./step))) (re,zeta_i) (fun '(re,zeta_i) round =>
      let zeta_i := (zeta_i.+(@repr WORDSIZE32 1)) : uint_size in
      let offset := ((round.*step).*(@repr WORDSIZE32 2)) : uint_size in
      let re := (f_fold (f_into_iter (Build_Range offset(offset.+step))) re (fun re j =>
          let t := (montgomery_reduce (((f_coefficients re).[(j.+step)]).*(v_ZETAS_MONTGOMERY_DOMAIN.[zeta_i]))) : int32 in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) (j.+step) (((f_coefficients re).[j]).-t))) : t_KyberPolynomialRingElement_t in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) j (((f_coefficients re).[j]).+t))) : t_KyberPolynomialRingElement_t in
          re)) : t_KyberPolynomialRingElement_t in
      (re,zeta_i))) : (t_KyberPolynomialRingElement_t × uint_size) in
  let _ := (tt) : unit in
  let step := ((@repr WORDSIZE32 1) shift_left (@repr WORDSIZE32 5)) : uint_size in
  let '(re,zeta_i) := (f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)((@repr WORDSIZE32 128)./step))) (re,zeta_i) (fun '(re,zeta_i) round =>
      let zeta_i := (zeta_i.+(@repr WORDSIZE32 1)) : uint_size in
      let offset := ((round.*step).*(@repr WORDSIZE32 2)) : uint_size in
      let re := (f_fold (f_into_iter (Build_Range offset(offset.+step))) re (fun re j =>
          let t := (montgomery_reduce (((f_coefficients re).[(j.+step)]).*(v_ZETAS_MONTGOMERY_DOMAIN.[zeta_i]))) : int32 in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) (j.+step) (((f_coefficients re).[j]).-t))) : t_KyberPolynomialRingElement_t in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) j (((f_coefficients re).[j]).+t))) : t_KyberPolynomialRingElement_t in
          re)) : t_KyberPolynomialRingElement_t in
      (re,zeta_i))) : (t_KyberPolynomialRingElement_t × uint_size) in
  let _ := (tt) : unit in
  let step := ((@repr WORDSIZE32 1) shift_left (@repr WORDSIZE32 4)) : uint_size in
  let '(re,zeta_i) := (f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)((@repr WORDSIZE32 128)./step))) (re,zeta_i) (fun '(re,zeta_i) round =>
      let zeta_i := (zeta_i.+(@repr WORDSIZE32 1)) : uint_size in
      let offset := ((round.*step).*(@repr WORDSIZE32 2)) : uint_size in
      let re := (f_fold (f_into_iter (Build_Range offset(offset.+step))) re (fun re j =>
          let t := (montgomery_reduce (((f_coefficients re).[(j.+step)]).*(v_ZETAS_MONTGOMERY_DOMAIN.[zeta_i]))) : int32 in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) (j.+step) (((f_coefficients re).[j]).-t))) : t_KyberPolynomialRingElement_t in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) j (((f_coefficients re).[j]).+t))) : t_KyberPolynomialRingElement_t in
          re)) : t_KyberPolynomialRingElement_t in
      (re,zeta_i))) : (t_KyberPolynomialRingElement_t × uint_size) in
  let _ := (tt) : unit in
  let step := ((@repr WORDSIZE32 1) shift_left (@repr WORDSIZE32 3)) : uint_size in
  let '(re,zeta_i) := (f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)((@repr WORDSIZE32 128)./step))) (re,zeta_i) (fun '(re,zeta_i) round =>
      let zeta_i := (zeta_i.+(@repr WORDSIZE32 1)) : uint_size in
      let offset := ((round.*step).*(@repr WORDSIZE32 2)) : uint_size in
      let re := (f_fold (f_into_iter (Build_Range offset(offset.+step))) re (fun re j =>
          let t := (montgomery_reduce (((f_coefficients re).[(j.+step)]).*(v_ZETAS_MONTGOMERY_DOMAIN.[zeta_i]))) : int32 in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) (j.+step) (((f_coefficients re).[j]).-t))) : t_KyberPolynomialRingElement_t in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) j (((f_coefficients re).[j]).+t))) : t_KyberPolynomialRingElement_t in
          re)) : t_KyberPolynomialRingElement_t in
      (re,zeta_i))) : (t_KyberPolynomialRingElement_t × uint_size) in
  let _ := (tt) : unit in
  let step := ((@repr WORDSIZE32 1) shift_left (@repr WORDSIZE32 2)) : uint_size in
  let '(re,zeta_i) := (f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)((@repr WORDSIZE32 128)./step))) (re,zeta_i) (fun '(re,zeta_i) round =>
      let zeta_i := (zeta_i.+(@repr WORDSIZE32 1)) : uint_size in
      let offset := ((round.*step).*(@repr WORDSIZE32 2)) : uint_size in
      let re := (f_fold (f_into_iter (Build_Range offset(offset.+step))) re (fun re j =>
          let t := (montgomery_reduce (((f_coefficients re).[(j.+step)]).*(v_ZETAS_MONTGOMERY_DOMAIN.[zeta_i]))) : int32 in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) (j.+step) (((f_coefficients re).[j]).-t))) : t_KyberPolynomialRingElement_t in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) j (((f_coefficients re).[j]).+t))) : t_KyberPolynomialRingElement_t in
          re)) : t_KyberPolynomialRingElement_t in
      (re,zeta_i))) : (t_KyberPolynomialRingElement_t × uint_size) in
  let _ := (tt) : unit in
  let step := ((@repr WORDSIZE32 1) shift_left (@repr WORDSIZE32 1)) : uint_size in
  let '(re,zeta_i) := (f_fold (f_into_iter (Build_Range (@repr WORDSIZE32 0)((@repr WORDSIZE32 128)./step))) (re,zeta_i) (fun '(re,zeta_i) round =>
      let zeta_i := (zeta_i.+(@repr WORDSIZE32 1)) : uint_size in
      let offset := ((round.*step).*(@repr WORDSIZE32 2)) : uint_size in
      let re := (f_fold (f_into_iter (Build_Range offset(offset.+step))) re (fun re j =>
          let t := (montgomery_reduce (((f_coefficients re).[(j.+step)]).*(v_ZETAS_MONTGOMERY_DOMAIN.[zeta_i]))) : int32 in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) (j.+step) (((f_coefficients re).[j]).-t))) : t_KyberPolynomialRingElement_t in
          let re := (Build_t_KyberPolynomialRingElement (update_at (f_coefficients re) j (((f_coefficients re).[j]).+t))) : t_KyberPolynomialRingElement_t in
          re)) : t_KyberPolynomialRingElement_t in
      (re,zeta_i))) : (t_KyberPolynomialRingElement_t × uint_size) in
  let _ := (tt) : unit in
  let re := (Build_t_KyberPolynomialRingElement (impl_23__map (f_coefficients re) barrett_reduce)) : t_KyberPolynomialRingElement_t in
  re.
