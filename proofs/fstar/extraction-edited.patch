diff -ruN extraction/BitVecEq.fst extraction-edited/BitVecEq.fst
--- extraction/BitVecEq.fst	1970-01-01 01:00:00.000000000 +0100
+++ extraction-edited/BitVecEq.fst	2024-05-16 17:05:53.763567470 +0200
@@ -0,0 +1,12 @@
+module BitVecEq
+
+open Core
+open FStar.Mul
+open FStar.FunctionalExtensionality
+
+let bit_vec_equal #n bv1 bv2 = forall i. bv1 i == bv2 i
+
+let bit_vec_equal_intro bv1 bv2 = ()
+let bit_vec_equal_elim bv1 bv2 = assert (feq bv1 bv2)
+
+
diff -ruN extraction/BitVecEq.fsti extraction-edited/BitVecEq.fsti
--- extraction/BitVecEq.fsti	1970-01-01 01:00:00.000000000 +0100
+++ extraction-edited/BitVecEq.fsti	2024-05-16 17:05:53.759567604 +0200
@@ -0,0 +1,294 @@
+module BitVecEq
+#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
+open Core
+open FStar.Mul
+open MkSeq
+open FStar.FunctionalExtensionality
+
+val bit_vec_equal (#n: nat) (bv1 bv2: bit_vec n): Type0
+val bit_vec_equal_intro (#n: nat) (bv1 bv2: bit_vec n)
+  : Lemma (requires forall i. bv1 i == bv2 i)
+          (ensures bit_vec_equal bv1 bv2)
+val bit_vec_equal_elim (#n: nat) (bv1 bv2: bit_vec n)
+  : Lemma (requires bit_vec_equal #n bv1 bv2)
+          (ensures bv1 == bv2)
+          [SMTPat (bit_vec_equal #n bv1 bv2)]
+
+let bit_vec_equal_intro_principle ()
+  : Lemma (forall n (bv1 bv2: bit_vec n). (forall i. bv1 i == bv2 i) ==> bit_vec_equal #n bv1 bv2)
+  = introduce forall n (bv1 bv2: bit_vec n). _
+    with introduce (forall i. bv1 i == bv2 i) ==> bit_vec_equal #n bv1 bv2
+         with _. bit_vec_equal_intro #n bv1 bv2
+  
+let bit_vec_equal_elim_principle ()
+  : Lemma (forall n (bv1 bv2: bit_vec n). bit_vec_equal #n bv1 bv2 ==> (forall i. bv1 i == bv2 i))
+  = introduce forall n (bv1 bv2: bit_vec n). _
+    with introduce bit_vec_equal #n bv1 bv2 ==> (forall i. bv1 i == bv2 i)
+         with _. bit_vec_equal_elim #n bv1 bv2
+
+let bit_vec_equal_trivial (bv1 bv2: bit_vec 0): Lemma (bv1 == bv2) 
+    [SMTPat (eq2 #(bit_vec 0) bv1 bv2)]
+  = bit_vec_equal_intro bv1 bv2
+
+let bit_vec_sub #n (bv: bit_vec n) (start: nat) (len: nat {start + len <= n})
+  : bit_vec len
+  = on (i: nat {i < len})
+       (fun i -> bv (start + i))
+
+let bit_vec_equal_trivial_sub_smtpat (bv1: bit_vec 'n)
+  : Lemma (forall (bv2: bit_vec 0). bit_vec_sub bv1 0 0 == bv2)
+    [SMTPat (bit_vec_sub bv1 0 0)]
+  = introduce forall (bv2: bit_vec 0). bit_vec_sub bv1 0 0 == bv2
+    with bit_vec_equal_trivial (bit_vec_sub bv1 0 0) bv2
+
+unfold let retype #a #b (#_:unit{a == b})
+  (x: a): b
+  = x
+
+let bit_vec_sub_all_lemma #n (bv: bit_vec n)
+  : Lemma (bit_vec_sub bv 0 n == bv)
+          [SMTPat (bit_vec_sub bv 0 n)]
+  = bit_vec_equal_intro (bit_vec_sub bv 0 n) bv
+
+let int_t_array_bitwise_eq'
+       #t1 #t2 #n1 #n2
+       (arr1: t_Array (int_t t1) n1) (d1: num_bits t1)
+       (arr2: t_Array (int_t t2) n2) (d2: num_bits t2 {v n1 * d1 == v n2 * d2})
+     = bit_vec_equal (bit_vec_of_int_t_array arr1 d1)
+                     (retype (bit_vec_of_int_t_array arr2 d2))
+
+let int_t_array_bitwise_eq
+       #t1 #t2 #n1 #n2
+       (arr1: t_Array (int_t t1) n1) (d1: num_bits t1)
+       (arr2: t_Array (int_t t2) n2) (d2: num_bits t2 {v n1 * d1 == v n2 * d2})
+     =  bit_vec_of_int_t_array arr1 d1
+     == bit_vec_of_int_t_array arr2 d2
+
+// let get_bit_intro ()
+//   : Lemma (forall (#n: inttype) (x: int_t n) (nth: usize {v nth < bits n}). 
+//              get_bit #n x nth == (  if v x >= 0 then get_bit_nat (v x) (v nth)
+//                                 else get_bit_nat (pow2 (bits n) + v x) (v nth)))
+//   = introduce forall (n: inttype) (x: int_t n) (nth: usize {v nth < bits n}). 
+//              get_bit #n x nth == (  if v x >= 0 then get_bit_nat (v x) (v nth)
+//                                 else get_bit_nat (pow2 (bits n) + v x) (v nth))
+//     with get_bit_intro #n x nth
+
+#push-options "--fuel 0 --ifuel 0 --z3rlimit 80"
+/// Rewrite a `bit_vec_of_int_t_array (Seq.slice arr ...)` into a `bit_vec_sub ...`
+let int_t_seq_slice_to_bv_sub_lemma #t #n 
+  (arr: t_Array (int_t t) n)
+  (start: nat) (len: usize {start + v len <= v n})
+  (d: num_bits t) 
+  : Lemma ( bit_vec_of_int_t_array (Seq.slice arr start (start + v len) <: t_Array _ len) d
+     `bit_vec_equal` bit_vec_sub (bit_vec_of_int_t_array arr d) (start * d) (v len * d))
+   [SMTPat (bit_vec_sub (bit_vec_of_int_t_array arr d) (start * d) (v len * d))]
+  = let bv1 = bit_vec_of_int_t_array #_ #len (Seq.slice arr start (start + v len)) d in
+    let bv2 = bit_vec_sub (bit_vec_of_int_t_array arr d) (start * d) (v len * d) in
+    introduce forall i. bv1 i == bv2 i 
+    with ( Seq.lemma_index_slice arr start (start + v len) (i / d);
+           Math.Lemmas.lemma_div_plus i start d;
+           Math.Lemmas.lemma_mod_plus i start d);
+    bit_vec_equal_intro bv1 bv2
+
+#push-options "--split_queries always"
+let int_t_eq_seq_slice_bv_sub_lemma #t #n1 #n2
+  (arr1: t_Array (int_t t) n1) (arr2: t_Array (int_t t) n2)  (d: num_bits t)
+  (start1 start2: nat) (len: nat {start1 + len <= v n1 /\ start2 + len <= v n2})
+  : Lemma (requires Seq.slice arr1 start1 (start1 + len) == Seq.slice arr2 start2 (start2 + len))
+          (ensures  bit_vec_equal
+                       (bit_vec_sub (bit_vec_of_int_t_array arr1 d) (start1 * d) (len * d))
+                       (bit_vec_sub (bit_vec_of_int_t_array arr2 d) (start2 * d) (len * d)))
+          [SMTPat ((bit_vec_sub (bit_vec_of_int_t_array arr1 d) (start1 * d) (len * d)) ==
+                       (bit_vec_sub (bit_vec_of_int_t_array arr2 d) (start2 * d) (len * d)))]
+  = let len = sz len in
+    int_t_seq_slice_to_bv_sub_lemma arr1 start1 len d;
+    int_t_seq_slice_to_bv_sub_lemma arr2 start2 len d;
+    // bit_vec_equal_elim_principle ();
+    bit_vec_equal_intro_principle ()
+#pop-options
+
+let bit_vec_equal_extend #n1 #n2
+  (bv1: bit_vec n1) (bv2: bit_vec n2) (start1 start2: nat)
+  (len1: nat)
+  (len2: nat { start1 + len1 + len2 <= n1 /\ start2 + len1 + len2 <= n2})
+  : Lemma 
+    (requires 
+       bit_vec_sub bv1 start1 len1 == bit_vec_sub bv2 start2 len1
+     /\ bit_vec_sub bv1 (start1 + len1) len2 == bit_vec_sub bv2 (start2 + len1) len2)
+    (ensures bit_vec_sub bv1 start1 (len1+len2) == bit_vec_sub bv2 start2 (len1+len2))
+    // [SMTPat (bit_vec_sub bv1 start1 len1 == bit_vec_sub bv2 start2 len1);
+    //  SMTPat ()
+    // ]
+     // SMTPat (bit_vec_sub bv1 (start1 + len1) len2 == bit_vec_sub bv2 (start2 + len1) len2)]
+  = let left1 = bit_vec_sub bv1 start1 len1 in
+    let left2 = bit_vec_sub bv2 start2 len1 in
+    let right1 = bit_vec_sub bv1 (start1 + len1) len2 in
+    let right2 = bit_vec_sub bv2 (start2 + len1) len2 in
+    // ()
+    // bit_vec_equal_elim left1  left2 ;
+    // bit_vec_equal_elim right1 right2;
+    let entire1 = bit_vec_sub bv1 start1 (len1 + len2) in
+    let entire2 = bit_vec_sub bv2 start2 (len1 + len2) in
+    assert (forall (i:nat). i < len1 ==> left1 i == left2 i);
+    assert (forall (i:nat). i < len2 ==> right1 i == right2 i);
+    introduce forall (i:nat). i < len1 + len2 ==> entire1 i == entire2 i
+    with introduce i < len1 + len2 ==> entire1 i == entire2 i
+         with _. if i < len1 then assert (left1 i == left2 i)
+                             else assert (entire1 i == right1 (i - len1));
+    bit_vec_equal_intro entire1 entire2
+#pop-options
+
+// let bit_vec_equal_trans (#n: nat) (bv1 bv2 bv3: bit_vec n)
+//   : Lemma (requires bv1 `bit_vec_equal` bv2 /\ bv2 `bit_vec_equal` bv3)
+//           (ensures  bv1 `bit_vec_equal` bv3)
+//   = bit_vec_equal_elim_principle ();
+//     bit_vec_equal_intro_principle ()
+
+(*
+let int_arr_bitwise_eq_range
+       #t1 #t2 #n1 #n2
+       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement1: int_t t1 -> Type0)
+       (arr1: t_Array (x: int_t t1 {refinement1 x}) n1)
+       (d1: num_bits t1)
+       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement2: int_t t2 -> Type0)
+       (arr2: t_Array (x: int_t t2 {refinement2 x}) n2)
+       (d2: num_bits t2)
+       (offset1 offset2: nat)
+       (bits: nat {
+           offset1 + bits <= v n1 * d1
+         /\ offset2 + bits <= v n2 * d2
+       })
+     = bit_vec_equal #bits (fun i -> bit_vec_of_int_t_array arr1 d1 (i + offset1))
+     = forall (k: nat). k < bits ==>
+          bit_vec_of_int_t_array arr1 d1 (offset1 + k) 
+       == bit_vec_of_int_t_array arr2 d2 (offset2 + k)
+
+let int_arr_bitwise_eq_range_comm
+       #t1 #t2 #n1 #n2
+       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement1: int_t t1 -> Type0)
+       (arr1: t_Array (x: int_t t1 {refinement1 x}) n1)
+       (d1: num_bits t1)
+       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement2: int_t t2 -> Type0)
+       (arr2: t_Array (x: int_t t2 {refinement2 x}) n2)
+       (d2: num_bits t2)
+       (offset1 offset2: nat)
+       (bits: nat {
+           offset1 + bits <= v n1 * d1
+         /\ offset2 + bits <= v n2 * d2
+       })
+    : Lemma (requires int_arr_bitwise_eq_range arr1 d1 arr2 d2 offset1 offset2 bits)
+            (ensures int_arr_bitwise_eq_range arr2 d2 arr1 d1 offset2 offset1 bits)
+    = ()
+
+// kill that function in favor of range
+let int_arr_bitwise_eq_up_to
+       #t1 #t2 #n1 #n2
+       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement1: int_t t1 -> Type0)
+       (arr1: t_Array (x: int_t t1 {refinement1 x}) n1)
+       (d1: num_bits t1)
+       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement: int_t t2 -> Type0)
+       (arr2: t_Array (x: int_t t2 {refinement x}) n2)
+       (d2: num_bits t2 {v n1 * d1 == v n2 * d2})
+       (max: nat {max <= v n1 * d1})
+     
+     = forall i. i < max
+       ==> bit_vec_of_int_t_array arr1 d1 i == bit_vec_of_int_t_array arr2 d2 i
+
+let int_arr_bitwise_eq_
+       #t1 #t2 #n1 #n2
+       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement1: int_t t1 -> Type0)
+       (arr1: t_Array (x: int_t t1 {refinement1 x}) n1)
+       (d1: num_bits t1)
+       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement: int_t t2 -> Type0)
+       (arr2: t_Array (x: int_t t2 {refinement x}) n2)
+       (d2: num_bits t2 {v n1 * d1 == v n2 * d2})
+     = int_arr_bitwise_eq_up_to arr1 d1 arr2 d2 (v n1 * d1)
+
+// move to fsti
+let bit_vec_equal #n (bv1 bv2: bit_vec n)
+  = forall i. i < n ==> bv1 i == bv2 i
+
+let int_arr_bitwise_eq
+       #t1 #t2 #n1 #n2
+       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement1: int_t t1 -> Type0)
+       (arr1: t_Array (x: int_t t1 {refinement1 x}) n1)
+       (d1: num_bits t1)
+       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement: int_t t2 -> Type0)
+       (arr2: t_Array (x: int_t t2 {refinement x}) n2)
+       (d2: num_bits t2 {v n1 * d1 == v n2 * d2})
+     = forall i. i < v n1 * d1
+       ==> bit_vec_of_int_t_array arr1 d1 i == bit_vec_of_int_t_array arr2 d2 i
+
+let int_arr_bitwise_eq_range_transitivity
+       #t1 #t2 #t3 #n1 #n2 #n3
+       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement1: int_t t1 -> Type0)
+       (arr1: t_Array (x: int_t t1 {refinement1 x}) n1)
+       (d1: num_bits t1)
+       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement2: int_t t2 -> Type0)
+       (arr2: t_Array (x: int_t t2 {refinement2 x}) n2)
+       (d2: num_bits t2)
+       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement3: int_t t3 -> Type0)
+       (arr3: t_Array (x: int_t t3 {refinement3 x}) n3)
+       (d3: num_bits t3)
+       (offset1 offset2 offset3: nat)
+       (bits: nat {
+           offset1 + bits <= v n1 * d1
+         /\ offset2 + bits <= v n2 * d2
+         /\ offset3 + bits <= v n3 * d3
+       })
+   : Lemma 
+     (requires int_arr_bitwise_eq_range #t1 #t2 #n1 #n2 arr1 d1 arr2 d2 offset1 offset2 bits
+             /\ int_arr_bitwise_eq_range #t2 #t3 #n2 #n3 arr2 d2 arr3 d3 offset2 offset3 bits)
+     (ensures  int_arr_bitwise_eq_range #t1 #t3 #n1 #n3 arr1 d1 arr3 d3 offset1 offset3 bits)
+   = ()
+
+
+let int_arr_bitwise_eq_range_intro
+       #t1 #t2 #n1 #n2
+       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement1: int_t t1 -> Type0)
+       (arr1: t_Array (x: int_t t1 {refinement1 x}) n1)
+       (d1: num_bits t1)
+       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement: int_t t2 -> Type0)
+       (arr2: t_Array (x: int_t t2 {refinement x}) n2)
+       (d2: num_bits t2 {v n1 * d1 == v n2 * d2})
+   : Lemma 
+     (requires int_arr_bitwise_eq arr1 d1 arr2 d2)
+     (ensures int_arr_bitwise_eq_range arr1 d1 arr2 d2 0 0 (v n1 * d1))
+   = admit ()
+
+let int_arr_bitwise_eq_range_intro_eq_slice
+       #t #n1 #n2
+       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement: int_t t -> Type0)
+       (arr1: t_Array (x: int_t t {refinement x}) n1)
+       (arr2: t_Array (x: int_t t {refinement x}) n2)
+       (d: num_bits t)
+       (offset1 offset2: nat)
+       (n: nat {offset1 + n < v n1 /\ offset2 + n < v n2})
+       (bits: nat {
+           offset1 + bits <= v n1 * d
+         /\ offset2 + bits <= v n2 * d
+         /\ bits <= n * d
+       })
+   : Lemma (requires Seq.slice arr1 offset1 (offset1 + n) == Seq.slice arr2 offset2 (offset2 + n))
+           (ensures int_arr_bitwise_eq_range arr1 d arr2 d offset1 offset2 bits)
+ = admit ()
+ 
+let int_arr_bitwise_eq_range_intro_eq
+       #t #n1 #n2
+       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement1: int_t t -> Type0)
+       (arr1: t_Array (x: int_t t {refinement1 x}) n1)
+       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement2: int_t t -> Type0)
+       (arr2: t_Array (x: int_t t {refinement2 x}) n2)
+       (d: num_bits t)
+       (n_offset1 n_offset2: nat)
+       (n: nat {n_offset1 + n <= v n1 /\ n_offset2 + n <= v n2})
+       // (offset1 offset2: nat)
+       (bits: nat {
+           n_offset1 * d + bits <= v n1 * d
+         /\ n_offset2 * d + bits <= v n2 * d
+         /\ bits <= n * d
+       })
+   : Lemma (requires forall (i: nat). i < n ==> Seq.index arr1 (i + n_offset1) == Seq.index arr2 (i + n_offset2))
+           (ensures int_arr_bitwise_eq_range arr1 d arr2 d (n_offset1 * d) (n_offset2 * d) bits)
+ = admit ()
+*)
diff -ruN extraction/Libcrux.Digest.fsti extraction-edited/Libcrux.Digest.fsti
--- extraction/Libcrux.Digest.fsti	2024-05-16 17:05:53.713569147 +0200
+++ extraction-edited/Libcrux.Digest.fsti	2024-05-16 17:05:53.752567839 +0200
@@ -3,13 +3,29 @@
 open Core
 open FStar.Mul
 
+val shake128x4_256_ (v_LEN: usize) (data0 data1 data2 data3: t_Slice u8)
+    : Prims.Pure (t_Array u8 v_LEN & t_Array u8 v_LEN & t_Array u8 v_LEN & t_Array u8 v_LEN)
+      Prims.l_True
+      (fun _ -> Prims.l_True)
+
 val sha3_256_ (payload: t_Slice u8)
     : Prims.Pure (t_Array u8 (sz 32)) Prims.l_True (fun _ -> Prims.l_True)
 
 val sha3_512_ (payload: t_Slice u8)
     : Prims.Pure (t_Array u8 (sz 64)) Prims.l_True (fun _ -> Prims.l_True)
 
-/// SHAKE 256
-/// The caller must define the size of the output in the return type.
+val shake128 (v_LEN: usize) (data: t_Slice u8)
+    : Prims.Pure (t_Array u8 v_LEN) Prims.l_True (fun _ -> Prims.l_True)
+
 val shake256 (v_LEN: usize) (data: t_Slice u8)
     : Prims.Pure (t_Array u8 v_LEN) Prims.l_True (fun _ -> Prims.l_True)
+
+val shake128x4_portable (v_LEN: usize) (data0 data1 data2 data3: t_Slice u8)
+    : Prims.Pure (t_Array u8 v_LEN & t_Array u8 v_LEN & t_Array u8 v_LEN & t_Array u8 v_LEN)
+      Prims.l_True
+      (fun _ -> Prims.l_True)
+
+val shake128x4 (v_LEN: usize) (data0 data1 data2 data3: t_Slice u8)
+    : Prims.Pure (t_Array u8 v_LEN & t_Array u8 v_LEN & t_Array u8 v_LEN & t_Array u8 v_LEN)
+      Prims.l_True
+      (fun _ -> Prims.l_True)
diff -ruN extraction/Libcrux.Digest.Incremental_x4.fsti extraction-edited/Libcrux.Digest.Incremental_x4.fsti
--- extraction/Libcrux.Digest.Incremental_x4.fsti	2024-05-16 17:05:53.701569550 +0200
+++ extraction-edited/Libcrux.Digest.Incremental_x4.fsti	1970-01-01 01:00:00.000000000 +0100
@@ -1,31 +0,0 @@
-module Libcrux.Digest.Incremental_x4
-#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
-open Core
-open FStar.Mul
-
-/// Incremental state
-val t_Shake128StateX4:Type0
-
-/// Absorb up to 4 blocks.
-/// The `input` must be of length 1 to 4.
-/// A blocks MUST all be the same length.
-/// Each slice MUST be a multiple of the block length 168.
-val impl__Shake128StateX4__absorb_final
-      (v_N: usize)
-      (self: t_Shake128StateX4)
-      (input: t_Array (t_Slice u8) v_N)
-    : Prims.Pure t_Shake128StateX4 Prims.l_True (fun _ -> Prims.l_True)
-
-/// This is only used internally to work around Eurydice bugs.
-val impl__Shake128StateX4__free_memory (self: t_Shake128StateX4)
-    : Prims.Pure Prims.unit Prims.l_True (fun _ -> Prims.l_True)
-
-/// Create a new Shake128 x4 state.
-val impl__Shake128StateX4__new: Prims.unit
-  -> Prims.Pure t_Shake128StateX4 Prims.l_True (fun _ -> Prims.l_True)
-
-/// Squeeze `M` blocks of length `N`
-val impl__Shake128StateX4__squeeze_blocks (v_N v_M: usize) (self: t_Shake128StateX4)
-    : Prims.Pure (t_Shake128StateX4 & t_Array (t_Array u8 v_N) v_M)
-      Prims.l_True
-      (fun _ -> Prims.l_True)
diff -ruN extraction/Libcrux.Kem.fst extraction-edited/Libcrux.Kem.fst
--- extraction/Libcrux.Kem.fst	1970-01-01 01:00:00.000000000 +0100
+++ extraction-edited/Libcrux.Kem.fst	2024-05-16 17:05:53.744568107 +0200
@@ -0,0 +1,6 @@
+module Libcrux.Kem
+#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
+open Core
+open FStar.Mul
+
+
diff -ruN extraction/Libcrux.Kem.Kyber.Arithmetic.fst extraction-edited/Libcrux.Kem.Kyber.Arithmetic.fst
--- extraction/Libcrux.Kem.Kyber.Arithmetic.fst	2024-05-16 17:05:53.707569349 +0200
+++ extraction-edited/Libcrux.Kem.Kyber.Arithmetic.fst	2024-05-16 17:05:53.754567772 +0200
@@ -1,83 +1,364 @@
 module Libcrux.Kem.Kyber.Arithmetic
-#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
+#set-options "--fuel 0 --ifuel 1 --z3rlimit 100"
 open Core
 open FStar.Mul
 
-let get_n_least_significant_bits (n: u8) (value: u32) =
+
+let lemma_mul_i32_range (n1 n2: i32) (b1 b2: nat)
+    : Lemma (requires (i32_range n1 b1 /\ i32_range n2 b2 /\ b1 * b2 < pow2 31))
+      (ensures (range (v n1 * v n2) i32_inttype /\ i32_range (n1 *! n2) (b1 * b2))) =
+  if v n1 = 0 || v n2 = 0
+  then ()
+  else 
+    let open FStar.Math.Lemmas in
+    lemma_abs_bound (v n1) b1;
+    lemma_abs_bound (v n2) b2;
+    lemma_abs_mul (v n1) (v n2);
+    lemma_mult_le_left (abs (v n1)) (abs (v n2)) b2;
+    lemma_mult_le_right b2 (abs (v n1)) b1;
+    lemma_abs_bound (v n1 * v n2) (b1 * b2)
+
+let lemma_add_i32_range (n1 n2:i32) (b1 b2:nat):
+  Lemma (requires (i32_range n1 b1 /\ i32_range n2 b2 /\ b1 + b2 < pow2 31))
+        (ensures (range (v n1 + v n2) i32_inttype /\
+                  i32_range (n1 +! n2) (b1 + b2)))
+  = ()
+
+let mul_i32_b #b1 #b2 x y = 
+  lemma_mul_i32_range x y b1 b2;
+  x *! y
+
+let add_i32_b #b1 #b2 x y = 
+  lemma_add_i32_range x y b1 b2;
+  x +! y
+
+let sub_i32_b #b1 #b2 x y = 
+  x -! y
+
+let cast_i32_b #b1 #b2 x =
+  x <: i32_b b2 
+
+#push-options "--ifuel 0 --z3rlimit 250"
+let shr_i32_b #b #t x y =
+  let r = (x <: i32) >>! y in
+  assert (v r == v x / pow2 (v y));
+  Math.Lemmas.lemma_div_le (v x) b (pow2 (v y));
+  assert (v x / (pow2 (v y)) <= b / (pow2 (v y)));
+  Math.Lemmas.lemma_div_le (-b) (v x) (pow2 (v y));
+  assert (v x / (pow2 (v y)) >= (-b) / (pow2 (v y)));
+  if (b % pow2 (v y) = 0)  
+  then (Math.Lemmas.div_exact_r b (pow2 (v y));
+        assert (b = (b/pow2 (v y)) * pow2 (v y));
+        assert (-b = -((b/pow2 (v y)) * pow2 (v y)));
+        Math.Lemmas.neg_mul_left (b/pow2 (v y)) (pow2 (v y));
+        assert (-b = (-(b/pow2 (v y))) * pow2 (v y));
+        assert ((-b)/pow2(v y) = ((-(b/pow2 (v y))) * pow2 (v y)) / pow2 (v y));
+        Math.Lemmas.cancel_mul_div (-(b/pow2 (v y))) (pow2 (v y));
+        assert ((-b)/pow2(v y) = -(b/pow2 (v y)));
+        assert (nat_div_ceil b (pow2 (v y)) == b / pow2 (v y));
+        assert (i32_range r (b / pow2 ( v y)));
+        r <: i32_b (nat_div_ceil b (pow2 (v y))))
+  else (let rem = b % pow2 (v y) in
+        let quo = b / pow2 (v y) in
+        Math.Lemmas.lemma_div_mod b (pow2 (v y));        
+        assert (b = quo * pow2 (v y) + rem);
+        assert (-b = -(quo * pow2 (v y)) - rem);
+        Math.Lemmas.neg_mul_left quo (pow2 (v y));
+        assert (-b = (-quo) * pow2 (v y) - rem);
+        assert ((-b)/pow2(v y) = (-rem + (-quo) * pow2 (v y))/pow2 (v y));
+        Math.Lemmas.division_addition_lemma (-rem) (pow2 (v y)) (-quo);
+        assert ((-b)/pow2(v y) = ((-rem)/pow2 (v y) -quo));
+        Math.Lemmas.division_definition (-rem) (pow2 (v y)) (-1);
+        assert ((-rem)/pow2 (v y) == -1);
+        assert ((-b)/pow2(v y) = -1 -quo);
+        assert ((-b)/pow2(v y) = (-quo - 1));
+        assert ((-b)/pow2(v y) = -(quo + 1));
+        assert (nat_div_ceil b (pow2 (v y)) == quo + 1);
+        assert (i32_range r (quo+1));
+        r <: i32_b (nat_div_ceil b (pow2 (v y))))
+#pop-options
+
+let v_BARRETT_R: i64 =
+  let result = 1L <<! v_BARRETT_SHIFT in
+  assert_norm (result == mk_int (67108864 @%. Lib.IntTypes.S64));
+  result
+
+let v_MONTGOMERY_R =
+  let result: i32 = 1l <<! v_MONTGOMERY_SHIFT in
+  assert_norm (result == mk_int (65536 @%. Lib.IntTypes.S32));
+  result
+
+let v_MONTGOMERY_R_INV = 
+  assert_norm((v 169l * pow2 16) % 3329 == 1);
+  169l
+  
+#push-options "--fuel 0 --ifuel 1 --z3rlimit 100 --split_queries always"
+let get_n_least_significant_bits n value = 
   let _:Prims.unit = () <: Prims.unit in
-  value &. ((1ul <<! n <: u32) -! 1ul <: u32)
+  let res = value &. ((1ul <<! n <: u32) -! 1ul <: u32) in
+  calc (==) {
+    v res;
+    (==) { }
+    v (logand value ((1ul <<! n) -! 1ul));
+    (==) {mk_int_equiv_lemma #u32_inttype 1} 
+    v (logand value (((mk_int 1) <<! n) -! (mk_int 1)));
+    (==) { }
+    v (logand value (mk_int ((1 * pow2 (v n)) % pow2 32) -! (mk_int 1)));
+    (==) {Math.Lemmas.small_mod (pow2 (v n)) (pow2 32); Math.Lemmas.pow2_lt_compat 32 (v n)}
+    v (logand value ((mk_int (pow2 (v n))) -! (mk_int 1)));
+    (==) {Math.Lemmas.pow2_lt_compat 32 (v n); logand_mask_lemma value (v n)}
+    v value % (pow2 (v n));
+  };
+  assert (v res < pow2 (v n));
+  res
+#pop-options 
 
-let barrett_reduce (value: i32) =
+#push-options "--z3rlimit 250"
+let barrett_reduce value = 
   let _:Prims.unit = () <: Prims.unit in
+  let x : i32 = value in
   let t:i64 =
-    ((Core.Convert.f_from #i64 #i32 value <: i64) *! v_BARRETT_MULTIPLIER <: i64) +!
+    ((Core.Convert.f_from x <: i64) *! v_BARRETT_MULTIPLIER <: i64) +!
     (v_BARRETT_R >>! 1l <: i64)
   in
+  assert_norm (v v_BARRETT_MULTIPLIER == (pow2 27 + 3329) / (2*3329));
+  assert (v t = v x * v v_BARRETT_MULTIPLIER + pow2 25);
   let quotient:i32 = cast (t >>! v_BARRETT_SHIFT <: i64) <: i32 in
+  assert (v quotient = v t / pow2 26);
   let result:i32 = value -! (quotient *! Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS <: i32) in
-  let _:Prims.unit = () <: Prims.unit in
+  calc (==) {
+    v result % 3329;
+    (==) { }
+    (v value - (v quotient * 3329)) % 3329;
+    (==) {Math.Lemmas.lemma_mod_sub_distr (v value) (v quotient * 3329) 3329}
+    (v value - (v quotient * 3329) % 3329) % 3329;
+    (==) {Math.Lemmas.cancel_mul_mod (v quotient) 3329}
+    (v value - 0) % 3329;    
+    (==) {}
+    (v value) % 3329;    
+  };
   result
+#pop-options 
 
-let montgomery_reduce (value: i32) =
+#push-options "--ifuel 0 --z3rlimit 1600"
+let montgomery_reduce #b value = 
   let _:i32 = v_MONTGOMERY_R in
   let _:Prims.unit = () <: Prims.unit in
+  let v0 = (cast (value <: i32) <: u32) in
+  assert (v v0 == v value % pow2 32);
+  let t0 = (get_n_least_significant_bits v_MONTGOMERY_SHIFT v0 <: u32) in
+  assert (v t0 = (v value % pow2 32) % pow2 16);
+  Math.Lemmas.pow2_modulo_modulo_lemma_1 (v value) 16 32;
+  assert (v t0 = v value % pow2 16);
   let t:u32 =
-    (get_n_least_significant_bits v_MONTGOMERY_SHIFT (cast (value <: i32) <: u32) <: u32) *!
-    v_INVERSE_OF_MODULUS_MOD_MONTGOMERY_R
+    t0 *!
+    v_INVERSE_OF_MODULUS_MOD_R
   in
-  let k:i16 = cast (get_n_least_significant_bits v_MONTGOMERY_SHIFT t <: u32) <: i16 in
-  let k_times_modulus:i32 =
-    (cast (k <: i16) <: i32) *! Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS
+  assert (v t = (v value % pow2 16) * v v_INVERSE_OF_MODULUS_MOD_R);
+  let k0 = get_n_least_significant_bits v_MONTGOMERY_SHIFT t <: u32 in
+  let k:i32_b (pow2 15) = cast (cast k0 <: i16) <: i32 in
+  calc (==) {
+    v k % pow2 16;
+    == { }
+    v k0 % pow2 16;
+    == { }
+    v t % pow2 16;
+    == { }
+    ((v value % pow2 16) * v v_INVERSE_OF_MODULUS_MOD_R) % pow2 16;
+    == {Math.Lemmas.lemma_mod_mul_distr_l (v value) (v v_INVERSE_OF_MODULUS_MOD_R) (pow2 16)}
+    (v value * v v_INVERSE_OF_MODULUS_MOD_R) % pow2 16;
+  };
+  assert_norm((62209 * 3329) % pow2 16 == 1);
+  assert((v v_INVERSE_OF_MODULUS_MOD_R * 3329) % pow2 16 == 1);
+  calc (==) {
+    (v k * 3329) % pow2 16;
+    == {Math.Lemmas.lemma_mod_mul_distr_l (v k) 3329 (pow2 16)}
+    ((v k % pow2 16) * 3329) % pow2 16;
+    == { }
+    ((v value * v v_INVERSE_OF_MODULUS_MOD_R) % pow2 16 * 3329) % pow2 16;
+    == {Math.Lemmas.lemma_mod_mul_distr_l (v value * v v_INVERSE_OF_MODULUS_MOD_R) (3329) (pow2 16)}
+    (v value * v v_INVERSE_OF_MODULUS_MOD_R * 3329) % pow2 16;   
+    == {Math.Lemmas.paren_mul_right (v value) (v v_INVERSE_OF_MODULUS_MOD_R) 3329}
+    (v value * (v v_INVERSE_OF_MODULUS_MOD_R * 3329)) % pow2 16;   
+    == {Math.Lemmas.lemma_mod_mul_distr_r (v value) (v v_INVERSE_OF_MODULUS_MOD_R * 3329) (pow2 16)}
+    (v value * ((v v_INVERSE_OF_MODULUS_MOD_R * 3329) % pow2 16)) % pow2 16;   
+    == {Math.Lemmas.mul_one_right_is_same (v value)}
+    (v value) % pow2 16;   
+  };
+  Math.Lemmas.modulo_add (pow2 16) (- (v k * 3329)) (v value) (v k * 3329);
+  assert ((v value - v k * 3329) % pow2 16 == (v k * 3329 - v k * 3329) % pow2 16);
+  assert ((v value - v k * 3329) % v v_MONTGOMERY_R == 0);
+  let k_times_modulus:i32_b (pow2 15 * 3329) =
+      mul_i32_b k Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS
   in
-  let c:i32 = k_times_modulus >>! v_MONTGOMERY_SHIFT in
-  let value_high:i32 = value >>! v_MONTGOMERY_SHIFT in
-  value_high -! c
+  let c:i32_b 1665 = shr_i32_b k_times_modulus v_MONTGOMERY_SHIFT in
+  let value_high:i32_b (nat_div_ceil b (v v_MONTGOMERY_R)) = shr_i32_b value v_MONTGOMERY_SHIFT in
+  assert (v value_high = v value / v v_MONTGOMERY_R);
+  let res: i32_b (nat_div_ceil b (v v_MONTGOMERY_R) + 1665) = sub_i32_b value_high c in
+  calc (==) {
+    v res;
+    == { }
+    (v value_high - v c);
+    == { }
+    ((v value / v v_MONTGOMERY_R) - ((v k * 3329) / v v_MONTGOMERY_R));
+    == {Math.Lemmas.lemma_div_exact (v value - v k * 3329) (v v_MONTGOMERY_R)}
+    ((v value - (v k * 3329)) / v v_MONTGOMERY_R);
+  };
+  calc (==) {
+    v res % 3329;
+    == {Math.Lemmas.lemma_div_exact (v value - v k * 3329) (v v_MONTGOMERY_R)}
+    (((v value - (v k * 3329)) / v v_MONTGOMERY_R) * ((v v_MONTGOMERY_R * v v_MONTGOMERY_R_INV) % 3329)) % 3329 ;
+    == {Math.Lemmas.lemma_mod_mul_distr_r ((v value - (v k * 3329)) / v v_MONTGOMERY_R) (v v_MONTGOMERY_R * v v_MONTGOMERY_R_INV) 3329}
+    (((v value - (v k * 3329)) / v v_MONTGOMERY_R) * (v v_MONTGOMERY_R * v v_MONTGOMERY_R_INV)) % 3329 ;
+    == {Math.Lemmas.paren_mul_right ((v value - (v k * 3329)) / v v_MONTGOMERY_R) (v v_MONTGOMERY_R) (v v_MONTGOMERY_R_INV)}
+    ((((v value - (v k * 3329)) / v v_MONTGOMERY_R) * v v_MONTGOMERY_R) * v v_MONTGOMERY_R_INV) % 3329 ;
+    == {Math.Lemmas.lemma_div_exact (v value - v k * 3329) (v v_MONTGOMERY_R)}
+    ((v value - (v k * 3329)) * v v_MONTGOMERY_R_INV) % 3329 ;
+    == { }
+    ((v value * v v_MONTGOMERY_R_INV) - ((v k * 3329) * v v_MONTGOMERY_R_INV)) % 3329 ;
+    == {Math.Lemmas.paren_mul_right (v k) 3329 (v v_MONTGOMERY_R_INV)} 
+    ((v value * v v_MONTGOMERY_R_INV) - (v k * (3329 * v v_MONTGOMERY_R_INV))) % 3329 ;
+    == {Math.Lemmas.swap_mul 3329 (v v_MONTGOMERY_R_INV)} 
+    ((v value * v v_MONTGOMERY_R_INV) - (v k * (v v_MONTGOMERY_R_INV * 3329))) % 3329 ;
+    == {Math.Lemmas.paren_mul_right (v k) (v v_MONTGOMERY_R_INV) 3329} 
+    ((v value * v v_MONTGOMERY_R_INV) - ((v k * v v_MONTGOMERY_R_INV) * 3329)) % 3329 ;
+    == {Math.Lemmas.lemma_mod_sub (v value * v v_MONTGOMERY_R_INV) 3329 (v k * v v_MONTGOMERY_R_INV)}
+    (v value * v v_MONTGOMERY_R_INV) % 3329 ;
+  };
+  res
+#pop-options
+
+let montgomery_multiply_sfe_by_fer fe fer =
+  montgomery_reduce (mul_i32_b fe fer)
 
-let montgomery_multiply_fe_by_fer (fe fer: i32) = montgomery_reduce (fe *! fer <: i32)
 
-let to_standard_domain (mfe: i32) =
-  montgomery_reduce (mfe *! v_MONTGOMERY_R_SQUARED_MOD_FIELD_MODULUS <: i32)
+let to_standard_domain mfe =
+  montgomery_reduce (mul_i32_b mfe (v_MONTGOMERY_R_SQUARED_MOD_FIELD_MODULUS <: i32_b 1353))
 
-let to_unsigned_representative (fe: i32) =
+let to_unsigned_representative fe =
   let _:Prims.unit = () <: Prims.unit in
-  cast (fe +! (Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS &. (fe >>! 31l <: i32) <: i32) <: i32)
-  <:
-  u16
+  logand_lemma Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS (fe >>! 31l <: i32);
+  let res =  
+  cast (fe +! (Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS &. (fe >>! 31l <: i32) <: i32) <: i32) <: u16
+  in
+  assert (v fe < 0 ==> (Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS &. (fe >>! 31l <: i32) <: i32) == 3329l);
+  assert (v fe >= 0 ==> (Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS &. (fe >>! 31l <: i32) <: i32) == 0l);
+  assert (v fe + 3329 < pow2 16);
+  assert (v fe >= -3328);
+  assert (v fe < 0 ==> v fe + 3329 >= 0);
+  assert (v fe < 0 ==> v res == (v fe + 3329) % pow2 16);
+  Math.Lemmas.small_mod (v fe + 3329) (pow2 16);
+  assert (v fe < 0 ==> v res == v fe + 3329);
+  assert (v fe >= 0 ==> v res == v fe);
+  res <: int_t_d u16_inttype 12
+
+let derefine_poly_b #b x =
+  let r = createi (sz 256) (fun i -> (x.f_coefficients.[i] <: i32)) in
+  {f_coefficients = r}
+
+let derefine_vector_b #v_K #b x =
+  let r = createi v_K (fun i -> derefine_poly_b #b x.[i]) in
+  r
+
+let derefine_matrix_b #v_K #b x =
+  let r = createi v_K (fun i -> derefine_vector_b #v_K #b x.[i]) in
+  r
 
-let add_to_ring_element (v_K: usize) (lhs rhs: t_PolynomialRingElement) =
+let cast_poly_b #b1 #b2 x =
+  let r = createi (sz 256) (fun i -> (x.f_coefficients.[i] <: i32_b b2)) in
+  let res = {f_coefficients = r} in
+  let dx = (derefine_poly_b x).f_coefficients in
+  let dr = (derefine_poly_b res).f_coefficients in
+  assert (forall (i:usize). v i < 256 ==> 
+    (dx.[i] <: i32) == 
+    (dr.[i] <: i32));
+  assert (forall i. Seq.index dx i == (dx.[sz i] <: i32));
+  eq_intro dx dr;
+  assert(Seq.equal dx dr);
+  res
+
+let cast_vector_b #v_K #b1 #b2 x =
+  let r = createi v_K (fun i -> cast_poly_b #b1 #b2 x.[i]) in
+  let dx = derefine_vector_b x in
+  let dr = derefine_vector_b r in
+  assert (forall (i:usize). v i < v v_K ==>
+    dx.[i] == dr.[i]);
+  assert (forall i. Seq.index dx i == dx.[sz i]);
+  assert (forall i. Seq.index dr i == dr.[sz i]);
+  eq_intro dx dr;
+  r
+
+let down_cast_poly_b #b1 #b2 x =
+  let r = createi (sz 256) 
+      (fun i -> 
+        let xi:i32_b b2 = x.f_coefficients.[i] in
+        xi) in
+  let res = {f_coefficients = r} in
+  let dx = (derefine_poly_b x).f_coefficients in
+  let dr = (derefine_poly_b res).f_coefficients in
+  assert (forall (i:usize). v i < 256 ==> 
+    (dx.[i] <: i32) == 
+    (dr.[i] <: i32));
+  assert (forall i. Seq.index dx i == (dx.[sz i] <: i32));
+  eq_intro dx dr;
+  assert(Seq.equal dx dr);
+  res
+
+let down_cast_vector_b #v_K #b1 #b2 x =
+  let r = createi (v_K) 
+      (fun i -> down_cast_poly_b #b1 #b2 x.[i]) in
+  let dx = derefine_vector_b x in
+  let dr = derefine_vector_b r in
+  assert (forall (i:usize). v i < v v_K ==> 
+    dx.[i] == dr.[i]);
+  assert (forall i. Seq.index dx i == dx.[sz i]);
+  assert (forall i. Seq.index dr i == dr.[sz i]);
+  eq_intro dx dr;
+  assert(Seq.equal dx dr);
+  r
+
+
+let add_to_ring_element #b1 #b2 v_K lhs rhs =
   let _:Prims.unit = () <: Prims.unit in
   let _:Prims.unit = () <: Prims.unit in
-  let lhs:t_PolynomialRingElement =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-            usize)
-          ({
+  let orig_lhs = lhs in
+  [@ inline_let]
+  let inv = fun (acc:t_PolynomialRingElement_b (b1+b2)) (i:usize) ->
+      (forall j. j <. i ==> acc.f_coefficients.[j] == lhs.f_coefficients.[j] +! rhs.f_coefficients.[j]) /\
+      (forall j. j >=. i ==> acc.f_coefficients.[j] == orig_lhs.f_coefficients.[j]) in
+  let lhs:t_PolynomialRingElement_b (b1 + b2) =
+    Rust_primitives.Iterators.foldi_range #_ #(t_PolynomialRingElement_b (b1+b2))  #inv {
               Core.Ops.Range.f_start = sz 0;
-              Core.Ops.Range.f_end
-              =
-              Core.Slice.impl__len #i32 (Rust_primitives.unsize lhs.f_coefficients <: t_Slice i32)
-              <:
-              usize
+              Core.Ops.Range.f_end =
+              Core.Slice.impl__len (Rust_primitives.unsize lhs.f_coefficients <: t_Slice (i32_b b1))
             }
-            <:
-            Core.Ops.Range.t_Range usize)
-        <:
-        Core.Ops.Range.t_Range usize)
-      lhs
+      (cast_poly_b #b1 #(b1+b2) lhs)
       (fun lhs i ->
-          let lhs:t_PolynomialRingElement = lhs in
+          let lhs:t_PolynomialRingElement_b (b1+b2) = lhs in
           let i:usize = i in
+          assert (orig_lhs.f_coefficients.[i] == lhs.f_coefficients.[i]);
+          let lhsi: i32_b b1 = orig_lhs.f_coefficients.[i] in
+          let lhs = 
           {
             lhs with
             f_coefficients
             =
             Rust_primitives.Hax.Monomorphized_update_at.update_at_usize lhs.f_coefficients
               i
-              ((lhs.f_coefficients.[ i ] <: i32) +! (rhs.f_coefficients.[ i ] <: i32) <: i32)
+              (add_i32_b #b1 #b2 (lhsi) (rhs.f_coefficients.[ i ]))
             <:
-            t_Array i32 (sz 256)
+            t_Array (i32_b (b1 + b2)) (sz 256)
           }
           <:
-          t_PolynomialRingElement)
+          t_PolynomialRingElement_b (b1 + b2)
+          in
+          assert (forall j. (j >. i /\ j <. sz 256) ==> lhs.f_coefficients.[j] == orig_lhs.f_coefficients.[j]);
+          lhs
+          )
   in
   let _:Prims.unit = () <: Prims.unit in
+  assert (forall j. j <. sz 256 ==> lhs.f_coefficients.[j] == orig_lhs.f_coefficients.[j] +! rhs.f_coefficients.[j]);
   lhs
+  
+  
+ 
diff -ruN extraction/Libcrux.Kem.Kyber.Arithmetic.fsti extraction-edited/Libcrux.Kem.Kyber.Arithmetic.fsti
--- extraction/Libcrux.Kem.Kyber.Arithmetic.fsti	2024-05-16 17:05:53.695569751 +0200
+++ extraction-edited/Libcrux.Kem.Kyber.Arithmetic.fsti	2024-05-16 17:05:53.778566967 +0200
@@ -3,176 +3,257 @@
 open Core
 open FStar.Mul
 
-/// Values having this type hold a representative 'x' of the Kyber field.
-/// We use 'fe' as a shorthand for this type.
+let pow2_31 = 2147483648
+let i32_range (n:i32) (b:nat) =
+  b < pow2_31 /\ v n <= b /\ v n >= -b
+
+type i32_b b = x:i32{i32_range x b}
+let nat_div_ceil (x:nat) (y:pos) : nat = if (x % y = 0) then x/y else (x/y)+1
+
+val mul_i32_b (#b1:nat) (#b2:nat{b1 * b2 < pow2_31}) (x:i32_b b1) (y: i32_b b2): r:i32_b (b1 * b2){v r == v x * v y}
+val add_i32_b (#b1:nat) (#b2:nat{b1 + b2 < pow2_31}) (x:i32_b b1) (y: i32_b b2): 
+  Pure (i32_b (b1 + b2))
+  (requires True)
+  (ensures fun r -> v r == v x + v y)
+val sub_i32_b (#b1:nat) (#b2:nat{b1 + b2 < pow2_31}) (x:i32_b b1) (y: i32_b b2): r:i32_b (b1 + b2){v r == v x - v y}
+val cast_i32_b (#b1:nat) (#b2:nat{b1 <= b2 /\ b2 < pow2_31}) (x:i32_b b1): r:i32_b b2{v r == v x}
+val shr_i32_b (#b:nat) (#t:inttype) (x:i32_b b) (y:int_t t{v y>0 /\ v y<32}): r:i32_b (nat_div_ceil b (pow2 (v y)))
+
 unfold
 let t_FieldElement = i32
 
-/// If 'x' denotes a value of type `fe`, values having this type hold a
-/// representative y ≡ x·MONTGOMERY_R (mod FIELD_MODULUS).
-/// We use 'fer' as a shorthand for this type.
+unfold
+let t_FieldElement_b b = i32_b b
+
+unfold
+let wfFieldElement = t_FieldElement_b 3328
+
 unfold
 let t_FieldElementTimesMontgomeryR = i32
 
-/// If 'x' denotes a value of type `fe`, values having this type hold a
-/// representative y ≡ x·MONTGOMERY_R^(-1) (mod FIELD_MODULUS).
-/// We use 'mfe' as a shorthand for this type
 unfold
 let t_MontgomeryFieldElement = i32
 
-/// This is calculated as ⌊(BARRETT_R / FIELD_MODULUS) + 1/2⌋
 let v_BARRETT_MULTIPLIER: i64 = 20159L
 
 let v_BARRETT_SHIFT: i64 = 26L
 
-let v_BARRETT_R: i64 = 1L <<! v_BARRETT_SHIFT
+val v_BARRETT_R: x:i64{v x = pow2 26 /\ x = 67108864L}
 
-let v_INVERSE_OF_MODULUS_MOD_MONTGOMERY_R: u32 = 62209ul
+let v_INVERSE_OF_MODULUS_MOD_R: u32 = 62209ul
 
-/// This is calculated as (MONTGOMERY_R)^2 mod FIELD_MODULUS
 let v_MONTGOMERY_R_SQUARED_MOD_FIELD_MODULUS: i32 = 1353l
 
 let v_MONTGOMERY_SHIFT: u8 = 16uy
 
-let v_MONTGOMERY_R: i32 = 1l <<! v_MONTGOMERY_SHIFT
+val v_MONTGOMERY_R: x:i32{v x = pow2 16 /\ x = 65536l}
+
+val v_MONTGOMERY_R_INV: x:i32{v x >= 0 /\ v x < 3329 /\ (v x * v v_MONTGOMERY_R) % 3329 == 1 /\ x = 169l}
+
+let int_to_spec_fe (m:int) : Spec.Kyber.field_element = 
+    let m_v = m % v Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS in
+    assert (m_v > -  v Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS);
+    if m_v < 0 then
+      m_v + v Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS
+    else m_v
 
-val get_n_least_significant_bits (n: u8) (value: u32)
-    : Prims.Pure u32
-      (requires n =. 4uy || n =. 5uy || n =. 10uy || n =. 11uy || n =. v_MONTGOMERY_SHIFT)
+let wf_fe_to_spec_fe (m: wfFieldElement): Spec.Kyber.field_element =
+  if v m < 0
+  then v m + v Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS
+  else v m
+
+let to_spec_fe (m:i32) : Spec.Kyber.field_element = 
+    int_to_spec_fe (v m)
+
+let to_spec_fe_b #b (m:i32_b b) : Spec.Kyber.field_element = to_spec_fe m
+
+let mont_to_spec_fe (m:t_FieldElement) : Spec.Kyber.field_element =
+    int_to_spec_fe (v m * v v_MONTGOMERY_R_INV)
+
+val get_n_least_significant_bits (n: u8 {v n > 0 /\ v n < 32}) (value: u32)
+    : Prims.Pure (int_t_d u32_inttype (v n))
+      (requires v n < 32)
       (ensures
         fun result ->
           let result:u32 = result in
-          result <. (Core.Num.impl__u32__pow 2ul (Core.Convert.f_into #u8 #u32 n <: u32) <: u32))
+          v result = v value % pow2 (v n))
 
-/// Signed Barrett Reduction
-/// Given an input `value`, `barrett_reduce` outputs a representative `result`
-/// such that:
-/// - result ≡ value (mod FIELD_MODULUS)
-/// - the absolute value of `result` is bound as follows:
-/// `|result| ≤ FIELD_MODULUS / 2 · (|value|/BARRETT_R + 1)
-/// In particular, if `|value| < BARRETT_R`, then `|result| < FIELD_MODULUS`.
-val barrett_reduce (value: i32)
-    : Prims.Pure i32
-      (requires
-        (Core.Convert.f_from #i64 #i32 value <: i64) >. (Core.Ops.Arith.Neg.neg v_BARRETT_R <: i64) &&
-        (Core.Convert.f_from #i64 #i32 value <: i64) <. v_BARRETT_R)
-      (ensures
-        fun result ->
-          let result:i32 = result in
-          result >. (Core.Ops.Arith.Neg.neg Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS <: i32) &&
-          result <. Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS)
+//let barrett_pre (value:i32) = 
+//    v value <= v v_BARRETT_R /\ v value >= - v v_BARRETT_R
+// Appears to work up to +/- 2^28, but not at +/- 2^29
 
-/// Signed Montgomery Reduction
-/// Given an input `value`, `montgomery_reduce` outputs a representative `o`
-/// such that:
-/// - o ≡ value · MONTGOMERY_R^(-1) (mod FIELD_MODULUS)
-/// - the absolute value of `o` is bound as follows:
-/// `|result| ≤ (|value| / MONTGOMERY_R) + (FIELD_MODULUS / 2)
-/// In particular, if `|value| ≤ FIELD_MODULUS * MONTGOMERY_R`, then `|o| < (3 · FIELD_MODULUS) / 2`.
-val montgomery_reduce (value: i32)
-    : Prims.Pure i32
-      (requires
-        value >=.
-        ((Core.Ops.Arith.Neg.neg Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS <: i32) *!
-          v_MONTGOMERY_R
-          <:
-          i32) &&
-        value <=. (Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS *! v_MONTGOMERY_R <: i32))
+let barrett_post (value:i32) (result:i32) = 
+    v result % v Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS =
+    v value % v Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS
+
+val barrett_reduce (value: i32_b (v v_BARRETT_R))
+    : Prims.Pure wfFieldElement
+    (requires True)
+    (ensures fun r -> barrett_post value r)
+
+let montgomery_post (value:i32) (result:i32) =
+    v result % v Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS =
+    (v value * v v_MONTGOMERY_R_INV) % v Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS
+
+
+val montgomery_reduce #b (value: i32_b b)
+    : Prims.Pure (i32_b (nat_div_ceil b (v v_MONTGOMERY_R) + 1665))
+      (requires True)
       (ensures
         fun result ->
           let result:i32 = result in
-          result >=.
-          ((Core.Ops.Arith.Neg.neg (3l *! Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS <: i32) <: i32
-            ) /!
-            2l
-            <:
-            i32) &&
-          result <=. ((3l *! Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS <: i32) /! 2l <: i32))
-
-/// If `fe` is some field element 'x' of the Kyber field and `fer` is congruent to
-/// `y · MONTGOMERY_R`, this procedure outputs a value that is congruent to
-/// `x · y`, as follows:
-///    `fe · fer ≡ x · y · MONTGOMERY_R (mod FIELD_MODULUS)`
-/// `montgomery_reduce` takes the value `x · y · MONTGOMERY_R` and outputs a representative
-/// `x · y · MONTGOMERY_R * MONTGOMERY_R^{-1} ≡ x · y (mod FIELD_MODULUS)`.
-val montgomery_multiply_fe_by_fer (fe fer: i32)
-    : Prims.Pure i32 Prims.l_True (fun _ -> Prims.l_True)
-
-/// If x is some field element of the Kyber field and `mfe` is congruent to
-/// x · MONTGOMERY_R^{-1}, this procedure outputs a value that is congruent to
-/// `x`, as follows:
-///    mfe · MONTGOMERY_R_SQUARED_MOD_FIELD_MODULUS ≡ x · MONTGOMERY_R^{-1} * (MONTGOMERY_R)^2 (mod FIELD_MODULUS)
-/// => mfe · MONTGOMERY_R_SQUARED_MOD_FIELD_MODULUS ≡ x · MONTGOMERY_R (mod FIELD_MODULUS)
-/// `montgomery_reduce` takes the value `x · MONTGOMERY_R` and outputs a representative
-/// `x · MONTGOMERY_R * MONTGOMERY_R^{-1} ≡ x (mod FIELD_MODULUS)`
-val to_standard_domain (mfe: i32) : Prims.Pure i32 Prims.l_True (fun _ -> Prims.l_True)
-
-/// Given a field element `fe` such that -FIELD_MODULUS ≤ fe < FIELD_MODULUS,
-/// output `o` such that:
-/// - `o` is congruent to `fe`
-/// - 0 ≤ `o` FIELD_MODULUS
-val to_unsigned_representative (fe: i32)
-    : Prims.Pure u16
-      (requires
-        fe >=. (Core.Ops.Arith.Neg.neg Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS <: i32) &&
-        fe <. Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS)
+          montgomery_post value result)
+
+
+val montgomery_multiply_sfe_by_fer #b1 #b2 (fe:i32_b b1) (fer: i32_b b2)
+    : Pure (i32_b (nat_div_ceil (b1 * b2) (v v_MONTGOMERY_R) + 1665))
+      (requires (b1 * b2 < pow2_31))
+      (ensures (fun result -> 
+          montgomery_post (mul_i32_b fe fer) (result)))
+      
+
+val to_standard_domain #b (mfe: i32_b b) 
+    : Pure (i32_b (nat_div_ceil (b * 1353) (v v_MONTGOMERY_R) + 1665))
+      (requires (b * 1353 < pow2_31))
+      (ensures (fun result -> 
+          montgomery_post (mul_i32_b mfe (1353l <: i32_b 1353)) result))
+
+
+val to_unsigned_representative (fe: wfFieldElement)
+    : Prims.Pure (int_t_d u16_inttype 12)
+      (requires True)
       (ensures
         fun result ->
           let result:u16 = result in
+          v result == to_spec_fe fe /\
           result >=. 0us &&
           result <. (cast (Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS <: i32) <: u16))
 
-type t_PolynomialRingElement = { f_coefficients:t_Array i32 (sz 256) }
+type t_PolynomialRingElement = { f_coefficients:t_Array (t_FieldElement) (sz 256) }
+
+type t_PolynomialRingElement_b b = { f_coefficients:t_Array (i32_b b) (sz 256) }
+
+type wfPolynomialRingElement = t_PolynomialRingElement_b (v Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS - 1)
+
+val derefine_poly_b (#b1:nat) (x:t_PolynomialRingElement_b b1):  
+    r:t_PolynomialRingElement{
+    forall (i:usize). v i < 256 ==> (r.f_coefficients.[i] <: i32) ==  (x.f_coefficients.[i] <: i32)}
+
+val derefine_vector_b (#v_K:usize) (#b:nat) (x:t_Array (t_PolynomialRingElement_b b) v_K):
+    r:t_Array t_PolynomialRingElement v_K{
+    forall (i:usize). (v i < v v_K) ==>
+     (let ri : t_PolynomialRingElement = r.[i] in
+      let xi : t_PolynomialRingElement_b b = x.[i] in
+      ri == derefine_poly_b xi)}
+
+val derefine_matrix_b (#v_K:usize) (#b:nat) 
+  (x:t_Array (t_Array (t_PolynomialRingElement_b b) v_K) v_K) :
+    r:t_Array (t_Array t_PolynomialRingElement v_K) v_K{
+    forall (i:usize). (v i < v v_K) ==>
+     (let ri : t_Array (t_PolynomialRingElement) v_K = r.[i] in
+      let xi : t_Array (t_PolynomialRingElement_b b) v_K = x.[i] in
+      ri == derefine_vector_b xi)}
+
+
+val cast_poly_b (#b1:nat) (#b2:nat{b1 <= b2 /\ b2 < pow2_31}) 
+  (x:t_PolynomialRingElement_b b1)
+  : Pure (t_PolynomialRingElement_b b2) 
+    (requires True)
+    (ensures fun r -> derefine_poly_b x == derefine_poly_b r)
+
+val cast_vector_b (#v_K:usize) (#b1:nat) (#b2:nat{b1 <= b2 /\ b2 < pow2_31}) 
+  (x:t_Array (t_PolynomialRingElement_b b1) v_K)
+  : Pure (t_Array (t_PolynomialRingElement_b b2) v_K)
+    (requires True)
+    (ensures fun r -> derefine_vector_b x == derefine_vector_b r)
+
+let poly_range (#b:nat) (x:t_PolynomialRingElement_b b) (b':nat) =
+  (forall (i:usize). v i < 256 ==> i32_range (x.f_coefficients.[i] <: i32) b')
+
+let vector_range (#v_K:usize) (#b:nat) (x:t_Array (t_PolynomialRingElement_b b) v_K) (b':nat) =
+  (forall (i:usize). v i < v v_K ==> poly_range #b x.[i] b')
+
+val down_cast_poly_b (#b1:nat) (#b2:nat{b2 <= b1 /\ b1 < pow2_31}) 
+  (x:t_PolynomialRingElement_b b1): 
+  Pure (t_PolynomialRingElement_b b2)
+  (requires (poly_range x b2))
+  (ensures fun r ->  derefine_poly_b x == derefine_poly_b r) 
+
+val down_cast_vector_b (#v_K:usize) (#b1:nat) (#b2:nat{b2 <= b1 /\ b1 < pow2_31}) 
+  (x:t_Array (t_PolynomialRingElement_b b1) v_K): 
+  Pure (t_Array (t_PolynomialRingElement_b b2) v_K)
+  (requires (vector_range x b2))
+  (ensures fun r ->  derefine_vector_b x == derefine_vector_b r) 
+
+let op_String_Access #t #l (a:t_Array t l) (i:usize{v i < v l}) : t = a.[i]
+
+let wf_poly_to_spec_poly (re: wfPolynomialRingElement): Spec.Kyber.polynomial =
+    let p = Spec.Kyber.map' (fun x -> wf_fe_to_spec_fe x <: nat) re.f_coefficients in
+    introduce forall i. Seq.index p i < v Spec.Kyber.v_FIELD_MODULUS
+    with assert (Seq.index p i == Seq.index p (v (sz i)));
+    p
+
+let to_spec_poly (m:t_PolynomialRingElement) : (Spec.Kyber.polynomial) =
+    let p = createi #nat (sz 256) (fun i -> to_spec_fe (m.f_coefficients.[i])) in
+    assert (forall i. Seq.index p i = to_spec_fe (m.f_coefficients.[sz i]));
+    assert (forall i. Seq.index p i < v Spec.Kyber.v_FIELD_MODULUS);
+    p
+
+let to_spec_poly_b #b (m:t_PolynomialRingElement_b b) : (Spec.Kyber.polynomial) =
+    to_spec_poly (derefine_poly_b m)
+
+let mont_to_spec_poly (m:t_PolynomialRingElement) : (Spec.Kyber.polynomial) =
+    let p = createi #nat (sz 256) (fun i -> mont_to_spec_fe (m.f_coefficients.[i])) in
+    assert (forall i. Seq.index p i = mont_to_spec_fe (m.f_coefficients.[sz i]));
+    assert (forall i. Seq.index p i < v Spec.Kyber.v_FIELD_MODULUS);
+    p
+
+
+let to_spec_vector (#p:Spec.Kyber.params)
+                   (m:t_Array (t_PolynomialRingElement) p.v_RANK)
+                   : (Spec.Kyber.vector p) =
+    createi p.v_RANK (fun i -> to_spec_poly (m.[i]))
+
+
+let to_spec_vector_b (#p:Spec.Kyber.params) (#b:nat)
+                   (m:t_Array (t_PolynomialRingElement_b b) p.v_RANK)
+                   : (Spec.Kyber.vector p) =
+    to_spec_vector (derefine_vector_b m)
+
+let mont_to_spec_vector (#p:Spec.Kyber.params)
+                   (m:t_Array (t_PolynomialRingElement) p.v_RANK)
+                   : (Spec.Kyber.vector p) =
+    createi p.v_RANK (fun i -> mont_to_spec_poly (m.[i]))
+
+let mont_to_spec_vector_b (#p:Spec.Kyber.params) (#b:nat)
+                   (m:t_Array (t_PolynomialRingElement_b b) p.v_RANK)
+                   : (Spec.Kyber.vector p) =
+    mont_to_spec_vector (derefine_vector_b m)
+
+let to_spec_matrix (#p:Spec.Kyber.params) 
+                   (m:(t_Array (t_Array (t_PolynomialRingElement) p.v_RANK) p.v_RANK))
+                   : (Spec.Kyber.matrix p) =
+    createi p.v_RANK (fun i -> to_spec_vector (m.[i]))
+
+let to_spec_matrix_b (#p:Spec.Kyber.params) (#b:nat)
+                   (m:(t_Array (t_Array (t_PolynomialRingElement_b b) p.v_RANK) p.v_RANK))
+                   : (Spec.Kyber.matrix p) =
+    to_spec_matrix (derefine_matrix_b m)
+
+let mont_to_spec_matrix (#p:Spec.Kyber.params) 
+                   (m:(t_Array (t_Array (t_PolynomialRingElement) p.v_RANK) p.v_RANK))
+                   : (Spec.Kyber.matrix p) =
+    createi p.v_RANK (fun i -> mont_to_spec_vector (m.[i]))
+
+let impl__PolynomialRingElement__ZERO: t_PolynomialRingElement_b 1 =
+  { f_coefficients = Rust_primitives.Hax.repeat (0l <: i32_b 1) (sz 256) } <: t_PolynomialRingElement_b 1
+
+val add_to_ring_element (#b1:nat) (#b2:nat{b1 + b2 < pow2_31}) (v_K: usize) (lhs: t_PolynomialRingElement_b b1) (rhs: t_PolynomialRingElement_b b2)
+    : Prims.Pure (t_PolynomialRingElement_b (b1 + b2))
+      (requires True) 
+      (ensures fun result ->
+        (forall i. v result.f_coefficients.[i] == v lhs.f_coefficients.[i] + v rhs.f_coefficients.[i]))
+
+
 
-let impl__PolynomialRingElement__ZERO: t_PolynomialRingElement =
-  { f_coefficients = Rust_primitives.Hax.repeat 0l (sz 256) } <: t_PolynomialRingElement
 
-/// Given two polynomial ring elements `lhs` and `rhs`, compute the pointwise
-/// sum of their constituent coefficients.
-val add_to_ring_element (v_K: usize) (lhs rhs: t_PolynomialRingElement)
-    : Prims.Pure t_PolynomialRingElement
-      (requires
-        Hax_lib.v_forall #usize
-          (fun i ->
-              let i:usize = i in
-              Hax_lib.implies (i <. Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
-                  <:
-                  bool)
-                (fun temp_0_ ->
-                    let _:Prims.unit = temp_0_ in
-                    ((Core.Num.impl__i32__abs (lhs.f_coefficients.[ i ] <: i32) <: i32) <=.
-                      (((cast (v_K <: usize) <: i32) -! 1l <: i32) *!
-                        Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS
-                        <:
-                        i32)
-                      <:
-                      bool) &&
-                    ((Core.Num.impl__i32__abs (rhs.f_coefficients.[ i ] <: i32) <: i32) <=.
-                      Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS
-                      <:
-                      bool))
-              <:
-              bool))
-      (ensures
-        fun result ->
-          let result:t_PolynomialRingElement = result in
-          Hax_lib.v_forall #usize
-            (fun i ->
-                let i:usize = i in
-                Hax_lib.implies (i <.
-                    (Core.Slice.impl__len #i32
-                        (Rust_primitives.unsize result.f_coefficients <: t_Slice i32)
-                      <:
-                      usize)
-                    <:
-                    bool)
-                  (fun temp_0_ ->
-                      let _:Prims.unit = temp_0_ in
-                      (Core.Num.impl__i32__abs (result.f_coefficients.[ i ] <: i32) <: i32) <=.
-                      ((cast (v_K <: usize) <: i32) *! Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS
-                        <:
-                        i32)
-                      <:
-                      bool)
-                <:
-                bool))
diff -ruN extraction/Libcrux.Kem.Kyber.Compress.fst extraction-edited/Libcrux.Kem.Kyber.Compress.fst
--- extraction/Libcrux.Kem.Kyber.Compress.fst	2024-05-16 17:05:53.722568845 +0200
+++ extraction-edited/Libcrux.Kem.Kyber.Compress.fst	2024-05-16 17:05:53.768567302 +0200
@@ -1,39 +1,79 @@
 module Libcrux.Kem.Kyber.Compress
-#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
+#set-options "--fuel 0 --ifuel 0 --z3rlimit 200"
 open Core
 open FStar.Mul
 
-let compress_ciphertext_coefficient (coefficient_bits: u8) (fe: u16) =
-  let _:Prims.unit = () <: Prims.unit in
-  let _:Prims.unit = () <: Prims.unit in
-  let compressed:u64 = (cast (fe <: u16) <: u64) <<! coefficient_bits in
-  let compressed:u64 = compressed +! 1664uL in
-  let compressed:u64 = compressed *! 10321340uL in
-  let compressed:u64 = compressed >>! 35l in
-  cast (Libcrux.Kem.Kyber.Arithmetic.get_n_least_significant_bits coefficient_bits
-        (cast (compressed <: u64) <: u32)
-      <:
-      u32)
-  <:
-  i32
-
-let compress_message_coefficient (fe: u16) =
+let compress_message_coefficient fe =
   let (shifted: i16):i16 = 1664s -! (cast (fe <: u16) <: i16) in
+  assert (v shifted == 1664 - v fe);
   let mask:i16 = shifted >>! 15l in
+  assert (v mask = v shifted / pow2 15);
+  assert (if v shifted < 0 then mask = ones else mask = zero);
   let shifted_to_positive:i16 = mask ^. shifted in
+  logxor_lemma shifted mask;
+  assert (v shifted < 0 ==> v shifted_to_positive = v (lognot shifted));
+  neg_equiv_lemma shifted;
+  assert (v (lognot shifted) = -(v shifted) -1);
+  assert (v shifted >= 0 ==> v shifted_to_positive = v (mask `logxor` shifted));
+  assert (v shifted >= 0 ==> mask = zero);
+  assert (v shifted >= 0 ==> mask ^. shifted = shifted);
+  assert (v shifted >= 0 ==> v shifted_to_positive = v shifted);
+  assert (shifted_to_positive >=. 0s);
   let shifted_positive_in_range:i16 = shifted_to_positive -! 832s in
-  cast ((shifted_positive_in_range >>! 15l <: i16) &. 1s <: i16) <: u8
+  assert (1664 - v fe >= 0 ==> v shifted_positive_in_range == 832 - v fe);
+  assert (1664 - v fe < 0 ==> v shifted_positive_in_range == -2497 + v fe);
+  let r0 = shifted_positive_in_range >>! 15l in
+  let r1 = r0 &. 1s in
+  let res = cast (r1) <: u8 in
+  assert (v r0 = v shifted_positive_in_range / pow2 15);
+  assert (if v shifted_positive_in_range < 0 then r0 = ones else r0 = zero);
+  logand_lemma 1s r0; 
+  assert (if v shifted_positive_in_range < 0 then r1 = 1s else r1 = 0s);
+  assert ((v fe >= 833 && v fe <= 2496) ==> r1 = 1s);
+  assert (v fe < 833 ==> r1 = 0s);
+  assert (v fe > 2496 ==> r1 = 0s);
+  assert (v res = v r1);
+  res
+
+let compress_ciphertext_coefficient coefficient_bits fe =
+  let _:Prims.unit = () <: Prims.unit in
+  let _:Prims.unit = () <: Prims.unit in
+  let compressed:u32 = (cast (fe <: u16) <: u32) <<! (coefficient_bits +! 1uy <: u8) in
+  let compressed:u32 =
+    compressed +! (cast (Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS <: i32) <: u32)
+  in
+  let compressed:u32 =
+    compressed /! (cast (Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS <<! 1l <: i32) <: u32)
+  in
+  let res = cast (Libcrux.Kem.Kyber.Arithmetic.get_n_least_significant_bits coefficient_bits compressed <: u32
+    )
+  <:
+  i32
+  in
+  res
 
-let decompress_ciphertext_coefficient (coefficient_bits: u8) (fe: i32) =
+#push-options "--z3rlimit 300"
+let decompress_ciphertext_coefficient coefficient_bits fe =
   let _:Prims.unit = () <: Prims.unit in
   let _:Prims.unit = () <: Prims.unit in
+  assert (v (1ul <<! coefficient_bits) <= pow2 11);
+  assert (v fe < pow2 11);
   let decompressed:u32 =
     (cast (fe <: i32) <: u32) *! (cast (Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS <: i32) <: u32)
   in
   let decompressed:u32 = (decompressed <<! 1l <: u32) +! (1ul <<! coefficient_bits <: u32) in
   let decompressed:u32 = decompressed >>! (coefficient_bits +! 1uy <: u8) in
-  cast (decompressed <: u32) <: i32
+  let res = cast (decompressed <: u32) <: i32 in
+  let res : Libcrux.Kem.Kyber.Arithmetic.i32_b 3328 = res in
+  res
 
-let decompress_message_coefficient (fe: i32) =
-  (Core.Ops.Arith.Neg.neg fe <: i32) &.
-  ((Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS +! 1l <: i32) /! 2l <: i32)
+let decompress_message_coefficient fe =
+  let res = (Core.Ops.Arith.Neg.neg fe <: i32) &.
+             ((Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS +! 1l <: i32) /! 2l <: i32) in
+  assert (v ((Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS +! 1l <: i32) /! 2l <: i32) == 1665);
+  assert (res == logand #i32_inttype (Core.Ops.Arith.Neg.neg fe) 1665l);
+  assert (v fe == 0 ==> Core.Ops.Arith.Neg.neg fe = zero);
+  logand_lemma 1665l zero;
+  assert (v fe == 0 ==> res == zero);
+  res <: Libcrux.Kem.Kyber.Arithmetic.i32_b 3328
+#pop-options
diff -ruN extraction/Libcrux.Kem.Kyber.Compress.fsti extraction-edited/Libcrux.Kem.Kyber.Compress.fsti
--- extraction/Libcrux.Kem.Kyber.Compress.fsti	2024-05-16 17:05:53.727568678 +0200
+++ extraction-edited/Libcrux.Kem.Kyber.Compress.fsti	2024-05-16 17:05:53.746568040 +0200
@@ -3,8 +3,19 @@
 open Core
 open FStar.Mul
 
-val compress_ciphertext_coefficient (coefficient_bits: u8) (fe: u16)
-    : Prims.Pure i32
+val compress_message_coefficient (fe: u16)
+    : Prims.Pure u8
+      (requires v fe < 3329)
+      (ensures
+        fun result ->
+          let result:u8 = result in
+          if 833 <= v fe && v fe <=  2496
+          then result =. 1uy
+          else result =. 0uy)
+
+
+val compress_ciphertext_coefficient (coefficient_bits: u8 {v coefficient_bits > 0 /\ v coefficient_bits <= 32}) (fe: u16)
+    : Prims.Pure (int_t_d i32_inttype (v coefficient_bits))
       (requires
         (coefficient_bits =. 4uy || coefficient_bits =. 5uy || coefficient_bits =. 10uy ||
         coefficient_bits =. 11uy) &&
@@ -15,62 +26,19 @@
           result >=. 0l &&
           result <. (Core.Num.impl__i32__pow 2l (cast (coefficient_bits <: u8) <: u32) <: i32))
 
-/// The `compress_*` functions implement the `Compress` function specified in the NIST FIPS
-/// 203 standard (Page 18, Expression 4.5), which is defined as:
-/// ```plaintext
-/// Compress_d: ℤq -> ℤ_{2ᵈ}
-/// Compress_d(x) = ⌈(2ᵈ/q)·x⌋
-/// ```
-/// Since `⌈x⌋ = ⌊x + 1/2⌋` we have:
-/// ```plaintext
-/// Compress_d(x) = ⌊(2ᵈ/q)·x + 1/2⌋
-///               = ⌊(2^{d+1}·x + q) / 2q⌋
-/// ```
-/// For further information about the function implementations, consult the
-/// `implementation_notes.pdf` document in this directory.
-/// The NIST FIPS 203 standard can be found at
-/// <https://csrc.nist.gov/pubs/fips/203/ipd>.
-val compress_message_coefficient (fe: u16)
-    : Prims.Pure u8
-      (requires fe <. (cast (Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS <: i32) <: u16))
-      (ensures
-        fun result ->
-          let result:u8 = result in
-          Hax_lib.implies ((833us <=. fe <: bool) && (fe <=. 2596us <: bool))
-            (fun temp_0_ ->
-                let _:Prims.unit = temp_0_ in
-                result =. 1uy <: bool) &&
-          Hax_lib.implies (~.((833us <=. fe <: bool) && (fe <=. 2596us <: bool)) <: bool)
-            (fun temp_0_ ->
-                let _:Prims.unit = temp_0_ in
-                result =. 0uy <: bool))
+open Rust_primitives.Integers
 
-val decompress_ciphertext_coefficient (coefficient_bits: u8) (fe: i32)
-    : Prims.Pure i32
-      (requires
-        (coefficient_bits =. 4uy || coefficient_bits =. 5uy || coefficient_bits =. 10uy ||
-        coefficient_bits =. 11uy) &&
-        fe >=. 0l &&
-        fe <. (Core.Num.impl__i32__pow 2l (cast (coefficient_bits <: u8) <: u32) <: i32))
+val decompress_ciphertext_coefficient
+    (coefficient_bits: u8 {coefficient_bits =. 4uy || coefficient_bits =. 5uy || coefficient_bits =. 10uy || coefficient_bits =. 11uy})
+    (fe: int_t_d i32_inttype (v coefficient_bits))
+    : Prims.Pure (Libcrux.Kem.Kyber.Arithmetic.i32_b (v Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS - 1))
+      (requires True)
       (ensures
         fun result ->
           let result:i32 = result in
           result <. Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS)
 
-/// The `decompress_*` functions implement the `Decompress` function specified in the NIST FIPS
-/// 203 standard (Page 18, Expression 4.6), which is defined as:
-/// ```plaintext
-/// Decompress_d: ℤ_{2ᵈ} -> ℤq
-/// Decompress_d(y) = ⌈(q/2ᵈ)·y⌋
-/// ```
-/// Since `⌈x⌋ = ⌊x + 1/2⌋` we have:
-/// ```plaintext
-/// Decompress_d(y) = ⌊(q/2ᵈ)·y + 1/2⌋
-///                 = ⌊(2·y·q + 2ᵈ) / 2^{d+1})⌋
-/// ```
-/// For further information about the function implementations, consult the
-/// `implementation_notes.pdf` document in this directory.
-/// The NIST FIPS 203 standard can be found at
-/// <https://csrc.nist.gov/pubs/fips/203/ipd>.
 val decompress_message_coefficient (fe: i32)
-    : Prims.Pure i32 (requires fe =. 0l || fe =. 1l) (fun _ -> Prims.l_True)
+    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.wfFieldElement
+      (requires fe =. 0l || fe =. 1l) 
+      (fun result -> v result >= 0 /\ v result < 3329)
diff -ruN extraction/Libcrux.Kem.Kyber.Constants.fsti extraction-edited/Libcrux.Kem.Kyber.Constants.fsti
--- extraction/Libcrux.Kem.Kyber.Constants.fsti	2024-05-16 17:05:53.719568946 +0200
+++ extraction-edited/Libcrux.Kem.Kyber.Constants.fsti	2024-05-16 17:05:53.765567403 +0200
@@ -3,24 +3,20 @@
 open Core
 open FStar.Mul
 
-/// Each field element needs floor(log_2(FIELD_MODULUS)) + 1 = 12 bits to represent
 let v_BITS_PER_COEFFICIENT: usize = sz 12
 
-/// Coefficients per ring element
 let v_COEFFICIENTS_IN_RING_ELEMENT: usize = sz 256
 
-/// Bits required per (uncompressed) ring element
 let v_BITS_PER_RING_ELEMENT: usize = v_COEFFICIENTS_IN_RING_ELEMENT *! sz 12
 
-/// Bytes required per (uncompressed) ring element
 let v_BYTES_PER_RING_ELEMENT: usize = v_BITS_PER_RING_ELEMENT /! sz 8
 
 let v_CPA_PKE_KEY_GENERATION_SEED_SIZE: usize = sz 32
 
-/// Field modulus: 3329
 let v_FIELD_MODULUS: i32 = 3329l
 
 let v_H_DIGEST_SIZE: usize = sz 32
 
-/// PKE message size
+let v_REJECTION_SAMPLING_SEED_SIZE: usize = sz 168 *! sz 5
+
 let v_SHARED_SECRET_SIZE: usize = sz 32
diff -ruN extraction/Libcrux.Kem.Kyber.Constant_time_ops.fst extraction-edited/Libcrux.Kem.Kyber.Constant_time_ops.fst
--- extraction/Libcrux.Kem.Kyber.Constant_time_ops.fst	2024-05-16 17:05:53.728568644 +0200
+++ extraction-edited/Libcrux.Kem.Kyber.Constant_time_ops.fst	2024-05-16 17:05:53.761567537 +0200
@@ -4,57 +4,163 @@
 open FStar.Mul
 
 let is_non_zero (value: u8) =
+  let orig_value = value in
   let value:u16 = cast (value <: u8) <: u16 in
-  let result:u16 =
-    ((value |. (Core.Num.impl__u16__wrapping_add (~.value <: u16) 1us <: u16) <: u16) >>! 8l <: u16) &.
-    1us
-  in
-  cast (result <: u16) <: u8
+  let result:u8 = cast ((Core.Num.impl__u16__wrapping_add (~.value <: u16) 1us <: u16) >>! 8l <: u16) in
+  let res:u8 = result &. 1uy in
+  if v orig_value = 0 then  (
+    assert(value == zero);
+    lognot_lemma value;
+    assert((~.value +. 1us) == zero);
+    assert((Core.Num.impl__u16__wrapping_add (~.value <: u16) 1us <: u16) == zero);
+    logor_lemma value zero;
+    assert((value |. (Core.Num.impl__u16__wrapping_add (~.value <: u16) 1us <: u16) <: u16) == value);
+    assert (v result == v ((value >>! 8l)));
+    assert ((v value / pow2 8) == 0);
+    assert (result == 0uy);
+    logand_lemma 1uy result;
+    assert (res == 0uy);
+    res)
+  else (
+    assert (v value <> 0);
+    lognot_lemma value;
+    assert (v (~.value) = pow2 16 - 1 - v value);
+    assert (v (~.value) + 1 = pow2 16 - v value);
+    assert (v (value) <= pow2 8 - 1);
+    assert ((v (~.value) + 1) = (pow2 16 - pow2 8) + (pow2 8 - v value));
+    assert ((v (~.value) + 1) = (pow2 8 - 1) * pow2 8 + (pow2 8 - v value));
+    assert ((v (~.value) + 1)/pow2 8 = (pow2 8 - 1));
+    assert (v ((Core.Num.impl__u16__wrapping_add (~.value <: u16) 1us <: u16) >>! 8l) = pow2 8 - 1);
+    assert (result = ones);
+    logand_lemma 1uy result;
+    assert (res = 1uy);
+    res
+  )
 
-let compare_ciphertexts_in_constant_time (v_CIPHERTEXT_SIZE: usize) (lhs rhs: t_Slice u8) =
+let compare_ciphertexts_in_constant_time v_CIPHERTEXT_SIZE lhs rhs =
   let _:Prims.unit = () <: Prims.unit in
   let _:Prims.unit = () <: Prims.unit in
   let (r: u8):u8 = 0uy in
+  [@ inline_let]
+  let inv = fun (acc:u8) (i:usize) ->
+    v i <= v v_CIPHERTEXT_SIZE /\
+   (if (Seq.slice lhs 0 (v i) = Seq.slice rhs 0 (v i)) then
+      acc == 0uy
+    else ~ (acc == 0uy))
+  in
   let r:u8 =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-            usize)
-          ({ Core.Ops.Range.f_start = sz 0; Core.Ops.Range.f_end = v_CIPHERTEXT_SIZE }
-            <:
-            Core.Ops.Range.t_Range usize)
-        <:
-        Core.Ops.Range.t_Range usize)
+    Rust_primitives.Iterators.foldi_range #_ #u8  #inv {
+              Core.Ops.Range.f_start = sz 0;
+              Core.Ops.Range.f_end = v_CIPHERTEXT_SIZE
+            }
       r
       (fun r i ->
           let r:u8 = r in
           let i:usize = i in
-          r |. ((lhs.[ i ] <: u8) ^. (rhs.[ i ] <: u8) <: u8) <: u8)
+          let nr = r |. ((lhs.[ i ] <: u8) ^. (rhs.[ i ] <: u8) <: u8) <: u8 in
+          if r =. 0uy then (
+            if (Seq.index lhs (v i) = Seq.index rhs (v i)) then (
+               logxor_lemma (Seq.index lhs (v i)) (Seq.index rhs (v i));
+               assert (((lhs.[ i ] <: u8) ^. (rhs.[ i ] <: u8) <: u8) = zero);
+               logor_lemma r ((lhs.[ i ] <: u8) ^. (rhs.[ i ] <: u8) <: u8);
+               assert (nr = r);
+               assert (forall j. Seq.index (Seq.slice lhs 0 (v i)) j == Seq.index lhs j);
+               assert (forall j. Seq.index (Seq.slice rhs 0 (v i)) j == Seq.index rhs j);
+               eq_intro (Seq.slice lhs 0 (v i + 1)) (Seq.slice rhs 0 (v i + 1));
+               nr
+            )
+            else (
+               logxor_lemma (Seq.index lhs (v i)) (Seq.index rhs (v i));
+               assert (((lhs.[ i ] <: u8) ^. (rhs.[ i ] <: u8) <: u8) <>  zero);
+               logor_lemma r ((lhs.[ i ] <: u8) ^. (rhs.[ i ] <: u8) <: u8);
+               assert (v nr > 0);
+               assert (Seq.index (Seq.slice lhs 0 (v i+1)) (v i) <> 
+                       Seq.index (Seq.slice rhs 0 (v i+1)) (v i));
+               assert (Seq.slice lhs 0 (v i+1) <> Seq.slice rhs 0 (v i + 1));
+               nr
+            )
+          ) else (
+            logor_lemma r ((lhs.[ i ] <: u8) ^. (rhs.[ i ] <: u8) <: u8);
+            assert (v nr >= v r);
+            assert (Seq.slice lhs 0 (v i) <> Seq.slice rhs 0 (v i));
+            if (Seq.slice lhs 0 (v i+1) = Seq.slice rhs 0 (v i + 1)) then
+              (assert (forall j. j < v i + 1 ==> Seq.index (Seq.slice lhs 0 (v i+1)) j == Seq.index (Seq.slice rhs 0 (v i+1)) j);
+               eq_intro (Seq.slice lhs 0 (v i)) (Seq.slice rhs 0 (v i));
+               assert(False))
+            else nr
+          )
+     )
   in
-  is_non_zero r
+  let res = is_non_zero r in
+  res
 
+#push-options "--ifuel 0 --z3rlimit 50"
 let select_shared_secret_in_constant_time (lhs rhs: t_Slice u8) (selector: u8) =
   let _:Prims.unit = () <: Prims.unit in
   let _:Prims.unit = () <: Prims.unit in
   let mask:u8 = Core.Num.impl__u8__wrapping_sub (is_non_zero selector <: u8) 1uy in
+  assert (if selector = 0uy then mask = ones else mask = zero);
+  lognot_lemma mask;
+  assert (if selector = 0uy then ~.mask = zero else ~.mask = ones);
   let out:t_Array u8 (sz 32) = Rust_primitives.Hax.repeat 0uy (sz 32) in
+  [@ inline_let]
+  let inv = fun (acc:t_Array u8 (sz 32)) (i:usize) ->
+    v i <= 32 /\
+   (forall j. j < v i ==> (if (selector =. 0uy) then Seq.index acc j == Seq.index lhs j else Seq.index acc j == Seq.index rhs j)) /\
+   (forall j. j >= v i ==> Seq.index acc j == 0uy)
+  in
   let out:t_Array u8 (sz 32) =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-            usize)
-          ({
+    Rust_primitives.Iterators.foldi_range #_ #(t_Array u8 (sz 32))  #inv {
               Core.Ops.Range.f_start = sz 0;
               Core.Ops.Range.f_end = Libcrux.Kem.Kyber.Constants.v_SHARED_SECRET_SIZE
             }
-            <:
-            Core.Ops.Range.t_Range usize)
-        <:
-        Core.Ops.Range.t_Range usize)
       out
       (fun out i ->
           let out:t_Array u8 (sz 32) = out in
+          assert ((out.[ i ] <: u8) = 0uy);
+          let outi = 
+            ((out.[ i ] <: u8) |.
+              (((lhs.[ i ] <: u8) &. mask <: u8) |. ((rhs.[ i ] <: u8) &. (~.mask <: u8) <: u8)
+                <:
+                u8)
+              <:
+              u8) in
+          if (selector = 0uy) then (
+            logand_lemma (lhs.[ i ] <: u8) mask;
+            assert (((lhs.[ i ] <: u8) &. mask <: u8) == (lhs.[ i ] <: u8));
+            logand_lemma (rhs.[ i ] <: u8) (~.mask);
+            assert (((rhs.[ i ] <: u8) &. (~.mask <: u8) <: u8) == zero);
+            logor_lemma ((lhs.[ i ] <: u8) &. mask <: u8) ((rhs.[ i ] <: u8) &. (~.mask <: u8) <: u8);
+            assert ((((lhs.[ i ] <: u8) &. mask <: u8) |. ((rhs.[ i ] <: u8) &. (~.mask <: u8) <: u8) <: u8) == (lhs.[ i ] <: u8));
+            logor_lemma (out.[ i ] <: u8) (lhs.[ i ] <: u8);
+            assert (((out.[ i ] <: u8) |. (((lhs.[ i ] <: u8) &. mask <: u8) |. ((rhs.[ i ] <: u8) &. (~.mask <: u8) <: u8) <: u8) <: u8) == (lhs.[ i ] <: u8));
+            assert (outi = (lhs.[ i ] <: u8))
+          )
+          else (
+            logand_lemma (lhs.[ i ] <: u8) mask;
+            assert (((lhs.[ i ] <: u8) &. mask <: u8) == zero);
+            logand_lemma (rhs.[ i ] <: u8) (~.mask);
+            assert (((rhs.[ i ] <: u8) &. (~.mask <: u8) <: u8) == (rhs.[ i ] <: u8));
+            logor_lemma (rhs.[ i ] <: u8) zero;
+            assert ((logor zero (rhs.[ i ] <: u8)) == (rhs.[ i ] <: u8));
+            assert ((((lhs.[ i ] <: u8) &. mask <: u8) |. ((rhs.[ i ] <: u8) &. (~.mask <: u8) <: u8)) == (rhs.[ i ] <: u8));
+            logor_lemma (out.[ i ] <: u8) (rhs.[ i ] <: u8);
+            assert (((out.[ i ] <: u8) |. (((lhs.[ i ] <: u8) &. mask <: u8) |. ((rhs.[ i ] <: u8) &. (~.mask <: u8) <: u8) <: u8) <: u8) == (rhs.[ i ] <: u8));
+            assert (outi = (rhs.[ i ] <: u8))
+          );
           let i:usize = i in
           Rust_primitives.Hax.Monomorphized_update_at.update_at_usize out
             i
-            (((lhs.[ i ] <: u8) &. mask <: u8) |. ((rhs.[ i ] <: u8) &. (~.mask <: u8) <: u8) <: u8)
+            outi
           <:
           t_Array u8 (sz 32))
   in
-  out
+  if (selector =. 0uy) then (
+    eq_intro out lhs;
+    out
+  )
+  else (
+    eq_intro out rhs;
+    out
+  )
+#pop-options
diff -ruN extraction/Libcrux.Kem.Kyber.Constant_time_ops.fsti extraction-edited/Libcrux.Kem.Kyber.Constant_time_ops.fsti
--- extraction/Libcrux.Kem.Kyber.Constant_time_ops.fsti	2024-05-16 17:05:53.730568577 +0200
+++ extraction-edited/Libcrux.Kem.Kyber.Constant_time_ops.fsti	2024-05-16 17:05:53.766567369 +0200
@@ -3,7 +3,6 @@
 open Core
 open FStar.Mul
 
-/// Return 1 if `value` is not zero and 0 otherwise.
 val is_non_zero (value: u8)
     : Prims.Pure u8
       Prims.l_True
@@ -19,11 +18,10 @@
                 let _:Prims.unit = temp_0_ in
                 result =. 1uy <: bool))
 
-/// Return 1 if the bytes of `lhs` and `rhs` do not exactly
-/// match and 0 otherwise.
 val compare_ciphertexts_in_constant_time (v_CIPHERTEXT_SIZE: usize) (lhs rhs: t_Slice u8)
     : Prims.Pure u8
-      Prims.l_True
+      (requires (length lhs == v_CIPHERTEXT_SIZE /\
+                 length rhs == v_CIPHERTEXT_SIZE))
       (ensures
         fun result ->
           let result:u8 = result in
@@ -36,19 +34,12 @@
                 let _:Prims.unit = temp_0_ in
                 result =. 1uy <: bool))
 
-/// If `selector` is not zero, return the bytes in `rhs`; return the bytes in
-/// `lhs` otherwise.
 val select_shared_secret_in_constant_time (lhs rhs: t_Slice u8) (selector: u8)
     : Prims.Pure (t_Array u8 (sz 32))
-      Prims.l_True
+      (requires (length lhs == Libcrux.Kem.Kyber.Constants.v_SHARED_SECRET_SIZE /\
+                 length rhs == Libcrux.Kem.Kyber.Constants.v_SHARED_SECRET_SIZE))
       (ensures
         fun result ->
           let result:t_Array u8 (sz 32) = result in
-          Hax_lib.implies (selector =. 0uy <: bool)
-            (fun temp_0_ ->
-                let _:Prims.unit = temp_0_ in
-                result =. lhs <: bool) &&
-          Hax_lib.implies (selector <>. 0uy <: bool)
-            (fun temp_0_ ->
-                let _:Prims.unit = temp_0_ in
-                result =. rhs <: bool))
+          Hax_lib.implies (selector =. 0uy <: bool) (fun _ -> result =. lhs <: bool) &&
+          Hax_lib.implies (selector <>. 0uy <: bool) (fun _ -> result =. rhs <: bool))
diff -ruN extraction/Libcrux.Kem.Kyber.fst extraction-edited/Libcrux.Kem.Kyber.fst
--- extraction/Libcrux.Kem.Kyber.fst	2024-05-16 17:05:53.721568879 +0200
+++ extraction-edited/Libcrux.Kem.Kyber.fst	2024-05-16 17:05:53.785566732 +0200
@@ -1,28 +1,44 @@
 module Libcrux.Kem.Kyber
-#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
+#set-options "--fuel 0 --ifuel 1 --z3rlimit 100"
 open Core
 open FStar.Mul
 
-let serialize_kem_secret_key
+let update_at_range_lemma #n
+  (s: t_Slice 't)
+  (i: Core.Ops.Range.t_Range (int_t n) {(Core.Ops.Range.impl_index_range_slice 't n).f_index_pre s i}) 
+  (x: t_Slice 't)
+  : Lemma
+    (requires (Seq.length x == v i.f_end - v i.f_start))
+    (ensures (
+      let s' = Rust_primitives.Hax.Monomorphized_update_at.update_at_range s i x in
+      let len = v i.f_start in
+      forall (i: nat). i < len ==> Seq.index s i == Seq.index s' i
+    ))
+    [SMTPat (Rust_primitives.Hax.Monomorphized_update_at.update_at_range s i x)]
+  = let s' = Rust_primitives.Hax.Monomorphized_update_at.update_at_range s i x in
+    let len = v i.f_start in
+    introduce forall (i:nat {i < len}). Seq.index s i == Seq.index s' i
+    with (assert ( Seq.index (Seq.slice s  0 len) i == Seq.index s  i 
+                 /\ Seq.index (Seq.slice s' 0 len) i == Seq.index s' i ))
+
+let serialize_kem_secret_key #p
       (v_SERIALIZED_KEY_LEN: usize)
-      (private_key public_key implicit_rejection_value: t_Slice u8)
-     =
+      (private_key public_key implicit_rejection_value: t_Slice u8) =
   let out:t_Array u8 v_SERIALIZED_KEY_LEN = Rust_primitives.Hax.repeat 0uy v_SERIALIZED_KEY_LEN in
   let pointer:usize = sz 0 in
   let out:t_Array u8 v_SERIALIZED_KEY_LEN =
     Rust_primitives.Hax.Monomorphized_update_at.update_at_range out
       ({
           Core.Ops.Range.f_start = pointer;
-          Core.Ops.Range.f_end = pointer +! (Core.Slice.impl__len #u8 private_key <: usize) <: usize
+          Core.Ops.Range.f_end = pointer +! (Core.Slice.impl__len private_key <: usize) <: usize
         }
         <:
         Core.Ops.Range.t_Range usize)
-      (Core.Slice.impl__copy_from_slice #u8
-          (out.[ {
+      (Core.Slice.impl__copy_from_slice (out.[ {
                 Core.Ops.Range.f_start = pointer;
                 Core.Ops.Range.f_end
                 =
-                pointer +! (Core.Slice.impl__len #u8 private_key <: usize) <: usize
+                pointer +! (Core.Slice.impl__len private_key <: usize) <: usize
               }
               <:
               Core.Ops.Range.t_Range usize ]
@@ -32,21 +48,20 @@
         <:
         t_Slice u8)
   in
-  let pointer:usize = pointer +! (Core.Slice.impl__len #u8 private_key <: usize) in
+  let pointer:usize = pointer +! (Core.Slice.impl__len private_key <: usize) in
   let out:t_Array u8 v_SERIALIZED_KEY_LEN =
     Rust_primitives.Hax.Monomorphized_update_at.update_at_range out
       ({
           Core.Ops.Range.f_start = pointer;
-          Core.Ops.Range.f_end = pointer +! (Core.Slice.impl__len #u8 public_key <: usize) <: usize
+          Core.Ops.Range.f_end = pointer +! (Core.Slice.impl__len public_key <: usize) <: usize
         }
         <:
         Core.Ops.Range.t_Range usize)
-      (Core.Slice.impl__copy_from_slice #u8
-          (out.[ {
+      (Core.Slice.impl__copy_from_slice (out.[ {
                 Core.Ops.Range.f_start = pointer;
                 Core.Ops.Range.f_end
                 =
-                pointer +! (Core.Slice.impl__len #u8 public_key <: usize) <: usize
+                pointer +! (Core.Slice.impl__len public_key <: usize) <: usize
               }
               <:
               Core.Ops.Range.t_Range usize ]
@@ -56,7 +71,9 @@
         <:
         t_Slice u8)
   in
-  let pointer:usize = pointer +! (Core.Slice.impl__len #u8 public_key <: usize) in
+  let pointer:usize = pointer +! (Core.Slice.impl__len public_key <: usize) in
+  let h_public_key = (Rust_primitives.unsize (Libcrux.Kem.Kyber.Hash_functions.v_H public_key)
+                     <: t_Slice u8) in
   let out:t_Array u8 v_SERIALIZED_KEY_LEN =
     Rust_primitives.Hax.Monomorphized_update_at.update_at_range out
       ({
@@ -65,24 +82,14 @@
         }
         <:
         Core.Ops.Range.t_Range usize)
-      (Core.Slice.impl__copy_from_slice #u8
-          (out.[ {
+      (Core.Slice.impl__copy_from_slice (out.[ {
                 Core.Ops.Range.f_start = pointer;
                 Core.Ops.Range.f_end
                 =
                 pointer +! Libcrux.Kem.Kyber.Constants.v_H_DIGEST_SIZE <: usize
               }
               <:
-              Core.Ops.Range.t_Range usize ]
-            <:
-            t_Slice u8)
-          (Rust_primitives.unsize (Libcrux.Kem.Kyber.Hash_functions.v_H public_key
-                <:
-                t_Array u8 (sz 32))
-            <:
-            t_Slice u8)
-        <:
-        t_Slice u8)
+              Core.Ops.Range.t_Range usize ]) h_public_key)
   in
   let pointer:usize = pointer +! Libcrux.Kem.Kyber.Constants.v_H_DIGEST_SIZE in
   let out:t_Array u8 v_SERIALIZED_KEY_LEN =
@@ -91,16 +98,15 @@
           Core.Ops.Range.f_start = pointer;
           Core.Ops.Range.f_end
           =
-          pointer +! (Core.Slice.impl__len #u8 implicit_rejection_value <: usize) <: usize
+          pointer +! (Core.Slice.impl__len implicit_rejection_value <: usize) <: usize
         }
         <:
         Core.Ops.Range.t_Range usize)
-      (Core.Slice.impl__copy_from_slice #u8
-          (out.[ {
+      (Core.Slice.impl__copy_from_slice (out.[ {
                 Core.Ops.Range.f_start = pointer;
                 Core.Ops.Range.f_end
                 =
-                pointer +! (Core.Slice.impl__len #u8 implicit_rejection_value <: usize) <: usize
+                pointer +! (Core.Slice.impl__len implicit_rejection_value <: usize) <: usize
               }
               <:
               Core.Ops.Range.t_Range usize ]
@@ -110,25 +116,47 @@
         <:
         t_Slice u8)
   in
+  assert (Seq.slice out 0 (v #usize_inttype (Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p)) `Seq.equal` private_key);
+  assert (Seq.slice out (v #usize_inttype (Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p))
+                        (v #usize_inttype (Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p +! Spec.Kyber.v_CPA_PKE_PUBLIC_KEY_SIZE p)) `Seq.equal` public_key);
+  assert (Seq.slice out (v #usize_inttype (Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p +!
+                                           Spec.Kyber.v_CPA_PKE_PUBLIC_KEY_SIZE p))
+                        (v #usize_inttype (Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p +!
+                                           Spec.Kyber.v_CPA_PKE_PUBLIC_KEY_SIZE p +!
+                                           Libcrux.Kem.Kyber.Constants.v_H_DIGEST_SIZE))
+          `Seq.equal` Libcrux.Kem.Kyber.Hash_functions.v_H public_key);
+  assert (Seq.slice out (v #usize_inttype (Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p +!
+                                           Spec.Kyber.v_CPA_PKE_PUBLIC_KEY_SIZE p +!
+                                           Libcrux.Kem.Kyber.Constants.v_H_DIGEST_SIZE))
+                        (v #usize_inttype (Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p +!
+                                           Spec.Kyber.v_CPA_PKE_PUBLIC_KEY_SIZE p +!
+                                           Libcrux.Kem.Kyber.Constants.v_H_DIGEST_SIZE +!
+                                           Spec.Kyber.v_SHARED_SECRET_SIZE))
+          == implicit_rejection_value);
+  lemma_slice_append_4 out private_key public_key (Libcrux.Kem.Kyber.Hash_functions.v_H public_key) implicit_rejection_value;
   out
 
-let decapsulate
+let decapsulate #p
       (v_K v_SECRET_KEY_SIZE v_CPA_SECRET_KEY_SIZE v_PUBLIC_KEY_SIZE v_CIPHERTEXT_SIZE v_T_AS_NTT_ENCODED_SIZE v_C1_SIZE v_C2_SIZE v_VECTOR_U_COMPRESSION_FACTOR v_VECTOR_V_COMPRESSION_FACTOR v_C1_BLOCK_SIZE v_ETA1 v_ETA1_RANDOMNESS_SIZE v_ETA2 v_ETA2_RANDOMNESS_SIZE v_IMPLICIT_REJECTION_HASH_INPUT_SIZE:
           usize)
       (secret_key: Libcrux.Kem.Kyber.Types.t_MlKemPrivateKey v_SECRET_KEY_SIZE)
-      (ciphertext: Libcrux.Kem.Kyber.Types.t_MlKemCiphertext v_CIPHERTEXT_SIZE)
-     =
+      (ciphertext: Libcrux.Kem.Kyber.Types.t_MlKemCiphertext v_CIPHERTEXT_SIZE) =
+  let orig_secret_key = secret_key.f_value in
   let ind_cpa_secret_key, secret_key:(t_Slice u8 & t_Slice u8) =
     Libcrux.Kem.Kyber.Types.impl_12__split_at v_SECRET_KEY_SIZE secret_key v_CPA_SECRET_KEY_SIZE
   in
   let ind_cpa_public_key, secret_key:(t_Slice u8 & t_Slice u8) =
-    Core.Slice.impl__split_at #u8 secret_key v_PUBLIC_KEY_SIZE
+    Core.Slice.impl__split_at secret_key v_PUBLIC_KEY_SIZE
   in
   let ind_cpa_public_key_hash, implicit_rejection_value:(t_Slice u8 & t_Slice u8) =
-    Core.Slice.impl__split_at #u8 secret_key Libcrux.Kem.Kyber.Constants.v_H_DIGEST_SIZE
+    Core.Slice.impl__split_at secret_key Libcrux.Kem.Kyber.Constants.v_H_DIGEST_SIZE
   in
+  assert (ind_cpa_secret_key == slice orig_secret_key (sz 0) v_CPA_SECRET_KEY_SIZE);
+  assert (ind_cpa_public_key == slice orig_secret_key v_CPA_SECRET_KEY_SIZE (v_CPA_SECRET_KEY_SIZE +! v_PUBLIC_KEY_SIZE));
+  assert (ind_cpa_public_key_hash == slice orig_secret_key (v_CPA_SECRET_KEY_SIZE +! v_PUBLIC_KEY_SIZE) (v_CPA_SECRET_KEY_SIZE +! v_PUBLIC_KEY_SIZE +! Libcrux.Kem.Kyber.Constants.v_H_DIGEST_SIZE));
+  assert (implicit_rejection_value == slice orig_secret_key (v_CPA_SECRET_KEY_SIZE +! v_PUBLIC_KEY_SIZE +! Libcrux.Kem.Kyber.Constants.v_H_DIGEST_SIZE) (length orig_secret_key));
   let decrypted:t_Array u8 (sz 32) =
-    Libcrux.Kem.Kyber.Ind_cpa.decrypt v_K
+    Libcrux.Kem.Kyber.Ind_cpa.decrypt #p v_K
       v_CIPHERTEXT_SIZE
       v_C1_SIZE
       v_VECTOR_U_COMPRESSION_FACTOR
@@ -145,8 +173,9 @@
       ({ Core.Ops.Range.f_start = Libcrux.Kem.Kyber.Constants.v_SHARED_SECRET_SIZE }
         <:
         Core.Ops.Range.t_RangeFrom usize)
-      (Core.Slice.impl__copy_from_slice #u8
-          (to_hash.[ { Core.Ops.Range.f_start = Libcrux.Kem.Kyber.Constants.v_SHARED_SECRET_SIZE }
+      (Core.Slice.impl__copy_from_slice (to_hash.[ {
+                Core.Ops.Range.f_start = Libcrux.Kem.Kyber.Constants.v_SHARED_SECRET_SIZE
+              }
               <:
               Core.Ops.Range.t_RangeFrom usize ]
             <:
@@ -155,14 +184,20 @@
         <:
         t_Slice u8)
   in
+  lemma_slice_append to_hash decrypted ind_cpa_public_key_hash;
+  assert (decrypted == Spec.Kyber.ind_cpa_decrypt p ind_cpa_secret_key ciphertext.f_value);
+  assert (to_hash == concat decrypted ind_cpa_public_key_hash);
   let hashed:t_Array u8 (sz 64) =
     Libcrux.Kem.Kyber.Hash_functions.v_G (Rust_primitives.unsize to_hash <: t_Slice u8)
   in
   let shared_secret, pseudorandomness:(t_Slice u8 & t_Slice u8) =
-    Core.Slice.impl__split_at #u8
-      (Rust_primitives.unsize hashed <: t_Slice u8)
+    Core.Slice.impl__split_at (Rust_primitives.unsize hashed <: t_Slice u8)
       Libcrux.Kem.Kyber.Constants.v_SHARED_SECRET_SIZE
   in
+  assert ((shared_secret,pseudorandomness) == split hashed Libcrux.Kem.Kyber.Constants.v_SHARED_SECRET_SIZE);
+  assert (length implicit_rejection_value = v_SECRET_KEY_SIZE -! v_CPA_SECRET_KEY_SIZE -! v_PUBLIC_KEY_SIZE -! Libcrux.Kem.Kyber.Constants.v_H_DIGEST_SIZE);
+  assert (length implicit_rejection_value = Spec.Kyber.v_SHARED_SECRET_SIZE);
+  assert (Spec.Kyber.v_SHARED_SECRET_SIZE <=. Spec.Kyber.v_IMPLICIT_REJECTION_HASH_INPUT_SIZE p);
   let (to_hash: t_Array u8 v_IMPLICIT_REJECTION_HASH_INPUT_SIZE):t_Array u8
     v_IMPLICIT_REJECTION_HASH_INPUT_SIZE =
     Libcrux.Kem.Kyber.Ind_cpa.into_padded_array v_IMPLICIT_REJECTION_HASH_INPUT_SIZE
@@ -173,48 +208,46 @@
       ({ Core.Ops.Range.f_start = Libcrux.Kem.Kyber.Constants.v_SHARED_SECRET_SIZE }
         <:
         Core.Ops.Range.t_RangeFrom usize)
-      (Core.Slice.impl__copy_from_slice #u8
-          (to_hash.[ { Core.Ops.Range.f_start = Libcrux.Kem.Kyber.Constants.v_SHARED_SECRET_SIZE }
+      (Core.Slice.impl__copy_from_slice (to_hash.[ {
+                Core.Ops.Range.f_start = Libcrux.Kem.Kyber.Constants.v_SHARED_SECRET_SIZE
+              }
               <:
               Core.Ops.Range.t_RangeFrom usize ]
             <:
             t_Slice u8)
-          (Core.Convert.f_as_ref #(Libcrux.Kem.Kyber.Types.t_MlKemCiphertext v_CIPHERTEXT_SIZE)
-              #(t_Slice u8)
-              ciphertext
-            <:
-            t_Slice u8)
+          (Core.Convert.f_as_ref ciphertext <: t_Slice u8)
         <:
         t_Slice u8)
   in
+  lemma_slice_append to_hash implicit_rejection_value ciphertext.f_value;
   let (implicit_rejection_shared_secret: t_Array u8 (sz 32)):t_Array u8 (sz 32) =
     Libcrux.Kem.Kyber.Hash_functions.v_PRF (sz 32) (Rust_primitives.unsize to_hash <: t_Slice u8)
   in
+  assert (implicit_rejection_shared_secret == Spec.Kyber.v_J to_hash);
+  assert (Seq.length ind_cpa_public_key == v v_PUBLIC_KEY_SIZE);
   let expected_ciphertext:t_Array u8 v_CIPHERTEXT_SIZE =
-    Libcrux.Kem.Kyber.Ind_cpa.encrypt v_K v_CIPHERTEXT_SIZE v_T_AS_NTT_ENCODED_SIZE v_C1_SIZE
+    Libcrux.Kem.Kyber.Ind_cpa.encrypt #p v_K v_CIPHERTEXT_SIZE v_T_AS_NTT_ENCODED_SIZE v_C1_SIZE
       v_C2_SIZE v_VECTOR_U_COMPRESSION_FACTOR v_VECTOR_V_COMPRESSION_FACTOR v_C1_BLOCK_SIZE v_ETA1
       v_ETA1_RANDOMNESS_SIZE v_ETA2 v_ETA2_RANDOMNESS_SIZE ind_cpa_public_key decrypted
       pseudorandomness
   in
   let selector:u8 =
     Libcrux.Kem.Kyber.Constant_time_ops.compare_ciphertexts_in_constant_time v_CIPHERTEXT_SIZE
-      (Core.Convert.f_as_ref #(Libcrux.Kem.Kyber.Types.t_MlKemCiphertext v_CIPHERTEXT_SIZE)
-          #(t_Slice u8)
-          ciphertext
-        <:
-        t_Slice u8)
+      (Core.Convert.f_as_ref ciphertext <: t_Slice u8)
       (Rust_primitives.unsize expected_ciphertext <: t_Slice u8)
   in
+  let res = 
   Libcrux.Kem.Kyber.Constant_time_ops.select_shared_secret_in_constant_time shared_secret
     (Rust_primitives.unsize implicit_rejection_shared_secret <: t_Slice u8)
     selector
+  in
+  res
 
-let encapsulate
+let encapsulate #p
       (v_K v_CIPHERTEXT_SIZE v_PUBLIC_KEY_SIZE v_T_AS_NTT_ENCODED_SIZE v_C1_SIZE v_C2_SIZE v_VECTOR_U_COMPRESSION_FACTOR v_VECTOR_V_COMPRESSION_FACTOR v_VECTOR_U_BLOCK_LEN v_ETA1 v_ETA1_RANDOMNESS_SIZE v_ETA2 v_ETA2_RANDOMNESS_SIZE:
           usize)
       (public_key: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey v_PUBLIC_KEY_SIZE)
-      (randomness: t_Array u8 (sz 32))
-     =
+      (randomness: t_Array u8 (sz 32)) =
   let (to_hash: t_Array u8 (sz 64)):t_Array u8 (sz 64) =
     Libcrux.Kem.Kyber.Ind_cpa.into_padded_array (sz 64)
       (Rust_primitives.unsize randomness <: t_Slice u8)
@@ -224,8 +257,9 @@
       ({ Core.Ops.Range.f_start = Libcrux.Kem.Kyber.Constants.v_H_DIGEST_SIZE }
         <:
         Core.Ops.Range.t_RangeFrom usize)
-      (Core.Slice.impl__copy_from_slice #u8
-          (to_hash.[ { Core.Ops.Range.f_start = Libcrux.Kem.Kyber.Constants.v_H_DIGEST_SIZE }
+      (Core.Slice.impl__copy_from_slice (to_hash.[ {
+                Core.Ops.Range.f_start = Libcrux.Kem.Kyber.Constants.v_H_DIGEST_SIZE
+              }
               <:
               Core.Ops.Range.t_RangeFrom usize ]
             <:
@@ -244,16 +278,19 @@
         <:
         t_Slice u8)
   in
+  assert (Seq.slice to_hash 0 (v Libcrux.Kem.Kyber.Constants.v_H_DIGEST_SIZE) == randomness);
+  lemma_slice_append to_hash randomness (Spec.Kyber.v_H public_key.f_value);
+  assert (to_hash == concat randomness (Spec.Kyber.v_H public_key.f_value));
+
   let hashed:t_Array u8 (sz 64) =
     Libcrux.Kem.Kyber.Hash_functions.v_G (Rust_primitives.unsize to_hash <: t_Slice u8)
   in
   let shared_secret, pseudorandomness:(t_Slice u8 & t_Slice u8) =
-    Core.Slice.impl__split_at #u8
-      (Rust_primitives.unsize hashed <: t_Slice u8)
+    Core.Slice.impl__split_at (Rust_primitives.unsize hashed <: t_Slice u8)
       Libcrux.Kem.Kyber.Constants.v_SHARED_SECRET_SIZE
   in
   let ciphertext:t_Array u8 v_CIPHERTEXT_SIZE =
-    Libcrux.Kem.Kyber.Ind_cpa.encrypt v_K v_CIPHERTEXT_SIZE v_T_AS_NTT_ENCODED_SIZE v_C1_SIZE
+    Libcrux.Kem.Kyber.Ind_cpa.encrypt #p v_K v_CIPHERTEXT_SIZE v_T_AS_NTT_ENCODED_SIZE v_C1_SIZE
       v_C2_SIZE v_VECTOR_U_COMPRESSION_FACTOR v_VECTOR_V_COMPRESSION_FACTOR v_VECTOR_U_BLOCK_LEN
       v_ETA1 v_ETA1_RANDOMNESS_SIZE v_ETA2 v_ETA2_RANDOMNESS_SIZE
       (Rust_primitives.unsize (Libcrux.Kem.Kyber.Types.impl_18__as_slice v_PUBLIC_KEY_SIZE
@@ -263,35 +300,29 @@
         <:
         t_Slice u8) randomness pseudorandomness
   in
-  let shared_secret_array:t_Array u8 (sz 32) = Rust_primitives.Hax.repeat 0uy (sz 32) in
-  let shared_secret_array:t_Array u8 (sz 32) =
-    Core.Slice.impl__copy_from_slice #u8 shared_secret_array shared_secret
-  in
-  Core.Convert.f_into #(t_Array u8 v_CIPHERTEXT_SIZE)
-    #(Libcrux.Kem.Kyber.Types.t_MlKemCiphertext v_CIPHERTEXT_SIZE)
-    ciphertext,
-  shared_secret_array
+  Core.Convert.f_into ciphertext,
+  Core.Result.impl__unwrap (Core.Convert.f_try_into shared_secret
+      <:
+      Core.Result.t_Result (t_Array u8 (sz 32)) Core.Array.t_TryFromSliceError)
   <:
   (Libcrux.Kem.Kyber.Types.t_MlKemCiphertext v_CIPHERTEXT_SIZE & t_Array u8 (sz 32))
 
-let validate_public_key
+#push-options "--z3rlimit 100"
+let validate_public_key #p
       (v_K v_RANKED_BYTES_PER_RING_ELEMENT v_PUBLIC_KEY_SIZE: usize)
       (public_key: t_Array u8 v_PUBLIC_KEY_SIZE)
      =
-  let deserialized_pk:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-    Libcrux.Kem.Kyber.Serialize.deserialize_ring_elements_reduced v_PUBLIC_KEY_SIZE
-      v_K
+  let pk:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
+    Libcrux.Kem.Kyber.Ind_cpa.deserialize_public_key #p v_K
       (public_key.[ { Core.Ops.Range.f_end = v_RANKED_BYTES_PER_RING_ELEMENT }
           <:
-          Core.Ops.Range.t_RangeTo usize ]
-        <:
-        t_Slice u8)
+          Core.Ops.Range.t_RangeTo usize ])
   in
   let public_key_serialized:t_Array u8 v_PUBLIC_KEY_SIZE =
-    Libcrux.Kem.Kyber.Ind_cpa.serialize_public_key v_K
+    Libcrux.Kem.Kyber.Ind_cpa.serialize_public_key #p v_K
       v_RANKED_BYTES_PER_RING_ELEMENT
       v_PUBLIC_KEY_SIZE
-      deserialized_pk
+      pk
       (public_key.[ { Core.Ops.Range.f_start = v_RANKED_BYTES_PER_RING_ELEMENT }
           <:
           Core.Ops.Range.t_RangeFrom usize ]
@@ -299,116 +330,12 @@
         t_Slice u8)
   in
   public_key =. public_key_serialized
+#pop-options
 
-let decapsulate_unpacked
-      (v_K v_SECRET_KEY_SIZE v_CPA_SECRET_KEY_SIZE v_PUBLIC_KEY_SIZE v_CIPHERTEXT_SIZE v_T_AS_NTT_ENCODED_SIZE v_C1_SIZE v_C2_SIZE v_VECTOR_U_COMPRESSION_FACTOR v_VECTOR_V_COMPRESSION_FACTOR v_C1_BLOCK_SIZE v_ETA1 v_ETA1_RANDOMNESS_SIZE v_ETA2 v_ETA2_RANDOMNESS_SIZE v_IMPLICIT_REJECTION_HASH_INPUT_SIZE:
-          usize)
-      (state: t_MlKemState v_K)
-      (ciphertext: Libcrux.Kem.Kyber.Types.t_MlKemCiphertext v_CIPHERTEXT_SIZE)
-     =
-  let (secret_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K):t_Array
-    Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-    state.f_secret_as_ntt
-  in
-  let (tt_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K):t_Array
-    Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-    state.f_t_as_ntt
-  in
-  let (a_transpose: t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K):t_Array
-    (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K =
-    state.f_a_transpose
-  in
-  let (implicit_rejection_value: t_Slice u8):t_Slice u8 = Rust_primitives.unsize state.f_rej in
-  let (ind_cpa_public_key_hash: t_Slice u8):t_Slice u8 =
-    Rust_primitives.unsize state.f_ind_cpa_public_key_hash
-  in
-  let decrypted:t_Array u8 (sz 32) =
-    Libcrux.Kem.Kyber.Ind_cpa.decrypt_unpacked v_K
-      v_CIPHERTEXT_SIZE
-      v_C1_SIZE
-      v_VECTOR_U_COMPRESSION_FACTOR
-      v_VECTOR_V_COMPRESSION_FACTOR
-      secret_as_ntt
-      ciphertext.Libcrux.Kem.Kyber.Types.f_value
-  in
-  let (to_hash: t_Array u8 (sz 64)):t_Array u8 (sz 64) =
-    Libcrux.Kem.Kyber.Ind_cpa.into_padded_array (sz 64)
-      (Rust_primitives.unsize decrypted <: t_Slice u8)
-  in
-  let to_hash:t_Array u8 (sz 64) =
-    Rust_primitives.Hax.Monomorphized_update_at.update_at_range_from to_hash
-      ({ Core.Ops.Range.f_start = Libcrux.Kem.Kyber.Constants.v_SHARED_SECRET_SIZE }
-        <:
-        Core.Ops.Range.t_RangeFrom usize)
-      (Core.Slice.impl__copy_from_slice #u8
-          (to_hash.[ { Core.Ops.Range.f_start = Libcrux.Kem.Kyber.Constants.v_SHARED_SECRET_SIZE }
-              <:
-              Core.Ops.Range.t_RangeFrom usize ]
-            <:
-            t_Slice u8)
-          ind_cpa_public_key_hash
-        <:
-        t_Slice u8)
-  in
-  let hashed:t_Array u8 (sz 64) =
-    Libcrux.Kem.Kyber.Hash_functions.v_G (Rust_primitives.unsize to_hash <: t_Slice u8)
-  in
-  let shared_secret, pseudorandomness:(t_Slice u8 & t_Slice u8) =
-    Core.Slice.impl__split_at #u8
-      (Rust_primitives.unsize hashed <: t_Slice u8)
-      Libcrux.Kem.Kyber.Constants.v_SHARED_SECRET_SIZE
-  in
-  let (to_hash: t_Array u8 v_IMPLICIT_REJECTION_HASH_INPUT_SIZE):t_Array u8
-    v_IMPLICIT_REJECTION_HASH_INPUT_SIZE =
-    Libcrux.Kem.Kyber.Ind_cpa.into_padded_array v_IMPLICIT_REJECTION_HASH_INPUT_SIZE
-      implicit_rejection_value
-  in
-  let to_hash:t_Array u8 v_IMPLICIT_REJECTION_HASH_INPUT_SIZE =
-    Rust_primitives.Hax.Monomorphized_update_at.update_at_range_from to_hash
-      ({ Core.Ops.Range.f_start = Libcrux.Kem.Kyber.Constants.v_SHARED_SECRET_SIZE }
-        <:
-        Core.Ops.Range.t_RangeFrom usize)
-      (Core.Slice.impl__copy_from_slice #u8
-          (to_hash.[ { Core.Ops.Range.f_start = Libcrux.Kem.Kyber.Constants.v_SHARED_SECRET_SIZE }
-              <:
-              Core.Ops.Range.t_RangeFrom usize ]
-            <:
-            t_Slice u8)
-          (Core.Convert.f_as_ref #(Libcrux.Kem.Kyber.Types.t_MlKemCiphertext v_CIPHERTEXT_SIZE)
-              #(t_Slice u8)
-              ciphertext
-            <:
-            t_Slice u8)
-        <:
-        t_Slice u8)
-  in
-  let (implicit_rejection_shared_secret: t_Array u8 (sz 32)):t_Array u8 (sz 32) =
-    Libcrux.Kem.Kyber.Hash_functions.v_PRF (sz 32) (Rust_primitives.unsize to_hash <: t_Slice u8)
-  in
-  let expected_ciphertext:t_Array u8 v_CIPHERTEXT_SIZE =
-    Libcrux.Kem.Kyber.Ind_cpa.encrypt_unpacked v_K v_CIPHERTEXT_SIZE v_T_AS_NTT_ENCODED_SIZE
-      v_C1_SIZE v_C2_SIZE v_VECTOR_U_COMPRESSION_FACTOR v_VECTOR_V_COMPRESSION_FACTOR
-      v_C1_BLOCK_SIZE v_ETA1 v_ETA1_RANDOMNESS_SIZE v_ETA2 v_ETA2_RANDOMNESS_SIZE tt_as_ntt
-      a_transpose decrypted pseudorandomness
-  in
-  let selector:u8 =
-    Libcrux.Kem.Kyber.Constant_time_ops.compare_ciphertexts_in_constant_time v_CIPHERTEXT_SIZE
-      (Core.Convert.f_as_ref #(Libcrux.Kem.Kyber.Types.t_MlKemCiphertext v_CIPHERTEXT_SIZE)
-          #(t_Slice u8)
-          ciphertext
-        <:
-        t_Slice u8)
-      (Rust_primitives.unsize expected_ciphertext <: t_Slice u8)
-  in
-  Libcrux.Kem.Kyber.Constant_time_ops.select_shared_secret_in_constant_time shared_secret
-    (Rust_primitives.unsize implicit_rejection_shared_secret <: t_Slice u8)
-    selector
-
-let generate_keypair
+let generate_keypair #p
       (v_K v_CPA_PRIVATE_KEY_SIZE v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE v_BYTES_PER_RING_ELEMENT v_ETA1 v_ETA1_RANDOMNESS_SIZE:
           usize)
-      (randomness: t_Array u8 (sz 64))
-     =
+      (randomness: t_Array u8 (sz 64)) =
   let ind_cpa_keypair_randomness:t_Slice u8 =
     randomness.[ {
         Core.Ops.Range.f_start = sz 0;
@@ -426,7 +353,7 @@
   in
   let ind_cpa_private_key, public_key:(t_Array u8 v_CPA_PRIVATE_KEY_SIZE &
     t_Array u8 v_PUBLIC_KEY_SIZE) =
-    Libcrux.Kem.Kyber.Ind_cpa.generate_keypair v_K
+    Libcrux.Kem.Kyber.Ind_cpa.generate_keypair #p v_K
       v_CPA_PRIVATE_KEY_SIZE
       v_PUBLIC_KEY_SIZE
       v_BYTES_PER_RING_ELEMENT
@@ -435,83 +362,17 @@
       ind_cpa_keypair_randomness
   in
   let secret_key_serialized:t_Array u8 v_PRIVATE_KEY_SIZE =
-    serialize_kem_secret_key v_PRIVATE_KEY_SIZE
+    serialize_kem_secret_key #p v_PRIVATE_KEY_SIZE
       (Rust_primitives.unsize ind_cpa_private_key <: t_Slice u8)
       (Rust_primitives.unsize public_key <: t_Slice u8)
       implicit_rejection_value
   in
   let (private_key: Libcrux.Kem.Kyber.Types.t_MlKemPrivateKey v_PRIVATE_KEY_SIZE):Libcrux.Kem.Kyber.Types.t_MlKemPrivateKey
   v_PRIVATE_KEY_SIZE =
-    Core.Convert.f_from #(Libcrux.Kem.Kyber.Types.t_MlKemPrivateKey v_PRIVATE_KEY_SIZE)
-      #(t_Array u8 v_PRIVATE_KEY_SIZE)
-      secret_key_serialized
+    Core.Convert.f_from secret_key_serialized
   in
   Libcrux.Kem.Kyber.Types.impl__from v_PRIVATE_KEY_SIZE
     v_PUBLIC_KEY_SIZE
     private_key
-    (Core.Convert.f_into #(t_Array u8 v_PUBLIC_KEY_SIZE)
-        #(Libcrux.Kem.Kyber.Types.t_MlKemPublicKey v_PUBLIC_KEY_SIZE)
-        public_key
-      <:
-      Libcrux.Kem.Kyber.Types.t_MlKemPublicKey v_PUBLIC_KEY_SIZE)
+    (Core.Convert.f_into public_key <: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey v_PUBLIC_KEY_SIZE)
 
-let generate_keypair_unpacked
-      (v_K v_CPA_PRIVATE_KEY_SIZE v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE v_BYTES_PER_RING_ELEMENT v_ETA1 v_ETA1_RANDOMNESS_SIZE:
-          usize)
-      (randomness: t_Array u8 (sz 64))
-     =
-  let ind_cpa_keypair_randomness:t_Slice u8 =
-    randomness.[ {
-        Core.Ops.Range.f_start = sz 0;
-        Core.Ops.Range.f_end = Libcrux.Kem.Kyber.Constants.v_CPA_PKE_KEY_GENERATION_SEED_SIZE
-      }
-      <:
-      Core.Ops.Range.t_Range usize ]
-  in
-  let implicit_rejection_value:t_Slice u8 =
-    randomness.[ {
-        Core.Ops.Range.f_start = Libcrux.Kem.Kyber.Constants.v_CPA_PKE_KEY_GENERATION_SEED_SIZE
-      }
-      <:
-      Core.Ops.Range.t_RangeFrom usize ]
-  in
-  let (secret_as_ntt, tt_as_ntt, a_transpose), ind_cpa_public_key:((t_Array
-        Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-      t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-      t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K) &
-    t_Array u8 v_PUBLIC_KEY_SIZE) =
-    Libcrux.Kem.Kyber.Ind_cpa.generate_keypair_unpacked v_K
-      v_PUBLIC_KEY_SIZE
-      v_BYTES_PER_RING_ELEMENT
-      v_ETA1
-      v_ETA1_RANDOMNESS_SIZE
-      ind_cpa_keypair_randomness
-  in
-  let ind_cpa_public_key_hash:t_Array u8 (sz 32) =
-    Libcrux.Kem.Kyber.Hash_functions.v_H (Rust_primitives.unsize ind_cpa_public_key <: t_Slice u8)
-  in
-  let (rej: t_Array u8 (sz 32)):t_Array u8 (sz 32) =
-    Core.Result.impl__unwrap #(t_Array u8 (sz 32))
-      #Core.Array.t_TryFromSliceError
-      (Core.Convert.f_try_into #(t_Slice u8) #(t_Array u8 (sz 32)) implicit_rejection_value
-        <:
-        Core.Result.t_Result (t_Array u8 (sz 32)) Core.Array.t_TryFromSliceError)
-  in
-  let (pubkey: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey v_PUBLIC_KEY_SIZE):Libcrux.Kem.Kyber.Types.t_MlKemPublicKey
-  v_PUBLIC_KEY_SIZE =
-    Core.Convert.f_from #(Libcrux.Kem.Kyber.Types.t_MlKemPublicKey v_PUBLIC_KEY_SIZE)
-      #(t_Array u8 v_PUBLIC_KEY_SIZE)
-      ind_cpa_public_key
-  in
-  ({
-      f_secret_as_ntt = secret_as_ntt;
-      f_t_as_ntt = tt_as_ntt;
-      f_a_transpose = a_transpose;
-      f_rej = rej;
-      f_ind_cpa_public_key_hash = ind_cpa_public_key_hash
-    }
-    <:
-    t_MlKemState v_K),
-  pubkey
-  <:
-  (t_MlKemState v_K & Libcrux.Kem.Kyber.Types.t_MlKemPublicKey v_PUBLIC_KEY_SIZE)
diff -ruN extraction/Libcrux.Kem.Kyber.fsti extraction-edited/Libcrux.Kem.Kyber.fsti
--- extraction/Libcrux.Kem.Kyber.fsti	2024-05-16 17:05:53.692569852 +0200
+++ extraction-edited/Libcrux.Kem.Kyber.fsti	2024-05-16 17:05:53.762567503 +0200
@@ -6,65 +6,88 @@
 unfold
 let t_MlKemSharedSecret = t_Array u8 (sz 32)
 
-/// Seed size for key generation
 let v_KEY_GENERATION_SEED_SIZE: usize =
   Libcrux.Kem.Kyber.Constants.v_CPA_PKE_KEY_GENERATION_SEED_SIZE +!
   Libcrux.Kem.Kyber.Constants.v_SHARED_SECRET_SIZE
 
-/// Serialize the secret key.
-val serialize_kem_secret_key
+val serialize_kem_secret_key (#p:Spec.Kyber.params)
       (v_SERIALIZED_KEY_LEN: usize)
       (private_key public_key implicit_rejection_value: t_Slice u8)
-    : Prims.Pure (t_Array u8 v_SERIALIZED_KEY_LEN) Prims.l_True (fun _ -> Prims.l_True)
+    : Pure (t_Array u8 v_SERIALIZED_KEY_LEN)
+      (requires (length private_key == Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p /\
+                 length public_key == Spec.Kyber.v_CPA_PKE_PUBLIC_KEY_SIZE p /\
+                 length implicit_rejection_value == Spec.Kyber.v_SHARED_SECRET_SIZE /\
+                 v_SERIALIZED_KEY_LEN == Spec.Kyber.v_SECRET_KEY_SIZE p))
+      (ensures (fun res -> res ==
+                Seq.append private_key (
+                Seq.append public_key (
+                Seq.append (Libcrux.Kem.Kyber.Hash_functions.v_H public_key) implicit_rejection_value))))
 
-val decapsulate
+val decapsulate (#p:Spec.Kyber.params)
       (v_K v_SECRET_KEY_SIZE v_CPA_SECRET_KEY_SIZE v_PUBLIC_KEY_SIZE v_CIPHERTEXT_SIZE v_T_AS_NTT_ENCODED_SIZE v_C1_SIZE v_C2_SIZE v_VECTOR_U_COMPRESSION_FACTOR v_VECTOR_V_COMPRESSION_FACTOR v_C1_BLOCK_SIZE v_ETA1 v_ETA1_RANDOMNESS_SIZE v_ETA2 v_ETA2_RANDOMNESS_SIZE v_IMPLICIT_REJECTION_HASH_INPUT_SIZE:
           usize)
       (secret_key: Libcrux.Kem.Kyber.Types.t_MlKemPrivateKey v_SECRET_KEY_SIZE)
       (ciphertext: Libcrux.Kem.Kyber.Types.t_MlKemCiphertext v_CIPHERTEXT_SIZE)
-    : Prims.Pure (t_Array u8 (sz 32)) Prims.l_True (fun _ -> Prims.l_True)
+    : Pure (t_Array u8 (sz 32))
+    (requires ( p == (let open Spec.Kyber in {v_RANK = v_K; v_ETA1; v_ETA2; v_VECTOR_U_COMPRESSION_FACTOR; v_VECTOR_V_COMPRESSION_FACTOR}) /\
+                Spec.Kyber.valid_params p /\
+                v_ETA1_RANDOMNESS_SIZE == Spec.Kyber.v_ETA1_RANDOMNESS_SIZE p /\
+                v_ETA2_RANDOMNESS_SIZE == Spec.Kyber.v_ETA2_RANDOMNESS_SIZE p /\
+                v_IMPLICIT_REJECTION_HASH_INPUT_SIZE == Spec.Kyber.v_IMPLICIT_REJECTION_HASH_INPUT_SIZE p /\
+                v_SECRET_KEY_SIZE == Spec.Kyber.v_SECRET_KEY_SIZE p /\
+                v_CPA_SECRET_KEY_SIZE == Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p /\
+                v_PUBLIC_KEY_SIZE == Spec.Kyber.v_CPA_PKE_PUBLIC_KEY_SIZE p /\
+                v_CIPHERTEXT_SIZE == Spec.Kyber.v_CPA_PKE_CIPHERTEXT_SIZE p /\
+                v_C1_SIZE == Spec.Kyber.v_C1_SIZE p /\
+                v_C1_BLOCK_SIZE == Spec.Kyber.v_C1_BLOCK_SIZE p /\
+                v_C2_SIZE == Spec.Kyber.v_C2_SIZE p /\
+                v_T_AS_NTT_ENCODED_SIZE = Spec.Kyber.v_T_AS_NTT_ENCODED_SIZE p
+               ))
+    (ensures (fun res ->
+                res == Spec.Kyber.ind_cca_decapsulate p secret_key.f_value ciphertext.f_value))
 
-val encapsulate
+val encapsulate (#p:Spec.Kyber.params)
       (v_K v_CIPHERTEXT_SIZE v_PUBLIC_KEY_SIZE v_T_AS_NTT_ENCODED_SIZE v_C1_SIZE v_C2_SIZE v_VECTOR_U_COMPRESSION_FACTOR v_VECTOR_V_COMPRESSION_FACTOR v_VECTOR_U_BLOCK_LEN v_ETA1 v_ETA1_RANDOMNESS_SIZE v_ETA2 v_ETA2_RANDOMNESS_SIZE:
           usize)
       (public_key: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey v_PUBLIC_KEY_SIZE)
       (randomness: t_Array u8 (sz 32))
-    : Prims.Pure (Libcrux.Kem.Kyber.Types.t_MlKemCiphertext v_CIPHERTEXT_SIZE & t_Array u8 (sz 32))
-      Prims.l_True
-      (fun _ -> Prims.l_True)
+    : Pure (Libcrux.Kem.Kyber.Types.t_MlKemCiphertext v_CIPHERTEXT_SIZE & t_Array u8 (sz 32))
+     (requires (p == (let open Spec.Kyber in {v_RANK = v_K; v_ETA1; v_ETA2; v_VECTOR_U_COMPRESSION_FACTOR; v_VECTOR_V_COMPRESSION_FACTOR}) /\
+                Spec.Kyber.valid_params p /\
+                v_ETA1_RANDOMNESS_SIZE == Spec.Kyber.v_ETA1_RANDOMNESS_SIZE p /\
+                v_ETA2_RANDOMNESS_SIZE == Spec.Kyber.v_ETA2_RANDOMNESS_SIZE p /\
+                v_PUBLIC_KEY_SIZE == Spec.Kyber.v_CPA_PKE_PUBLIC_KEY_SIZE p /\
+                v_CIPHERTEXT_SIZE == Spec.Kyber.v_CPA_PKE_CIPHERTEXT_SIZE p /\
+                v_C1_SIZE == Spec.Kyber.v_C1_SIZE p /\
+                v_C2_SIZE == Spec.Kyber.v_C2_SIZE p /\
+                v_T_AS_NTT_ENCODED_SIZE = Spec.Kyber.v_T_AS_NTT_ENCODED_SIZE p /\
+                v_VECTOR_U_BLOCK_LEN == Spec.Kyber.v_C1_BLOCK_SIZE p
+                ))
 
-val validate_public_key
+      (ensures (fun (ct,ss) ->
+                (ct.f_value,ss) == Spec.Kyber.ind_cca_encapsulate p public_key.f_value randomness))
+
+val validate_public_key (#p:Spec.Kyber.params)
       (v_K v_RANKED_BYTES_PER_RING_ELEMENT v_PUBLIC_KEY_SIZE: usize)
       (public_key: t_Array u8 v_PUBLIC_KEY_SIZE)
-    : Prims.Pure bool Prims.l_True (fun _ -> Prims.l_True)
-
-type t_MlKemState (v_K: usize) = {
-  f_secret_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K;
-  f_t_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K;
-  f_a_transpose:t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K;
-  f_rej:t_Array u8 (sz 32);
-  f_ind_cpa_public_key_hash:t_Array u8 (sz 32)
-}
-
-val decapsulate_unpacked
-      (v_K v_SECRET_KEY_SIZE v_CPA_SECRET_KEY_SIZE v_PUBLIC_KEY_SIZE v_CIPHERTEXT_SIZE v_T_AS_NTT_ENCODED_SIZE v_C1_SIZE v_C2_SIZE v_VECTOR_U_COMPRESSION_FACTOR v_VECTOR_V_COMPRESSION_FACTOR v_C1_BLOCK_SIZE v_ETA1 v_ETA1_RANDOMNESS_SIZE v_ETA2 v_ETA2_RANDOMNESS_SIZE v_IMPLICIT_REJECTION_HASH_INPUT_SIZE:
-          usize)
-      (state: t_MlKemState v_K)
-      (ciphertext: Libcrux.Kem.Kyber.Types.t_MlKemCiphertext v_CIPHERTEXT_SIZE)
-    : Prims.Pure (t_Array u8 (sz 32)) Prims.l_True (fun _ -> Prims.l_True)
-
-val generate_keypair
-      (v_K v_CPA_PRIVATE_KEY_SIZE v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE v_BYTES_PER_RING_ELEMENT v_ETA1 v_ETA1_RANDOMNESS_SIZE:
-          usize)
-      (randomness: t_Array u8 (sz 64))
-    : Prims.Pure (Libcrux.Kem.Kyber.Types.t_MlKemKeyPair v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE)
-      Prims.l_True
-      (fun _ -> Prims.l_True)
+    : Prims.Pure bool
+      (requires (v_K == p.v_RANK /\
+                 v_PUBLIC_KEY_SIZE == Spec.Kyber.v_CPA_PKE_PUBLIC_KEY_SIZE p /\
+                 v_RANKED_BYTES_PER_RING_ELEMENT == Spec.Kyber.v_RANKED_BYTES_PER_RING_ELEMENT p
+                 ))
+      (ensures (fun _ -> Prims.l_True))
 
-val generate_keypair_unpacked
+val generate_keypair (#p:Spec.Kyber.params)
       (v_K v_CPA_PRIVATE_KEY_SIZE v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE v_BYTES_PER_RING_ELEMENT v_ETA1 v_ETA1_RANDOMNESS_SIZE:
           usize)
       (randomness: t_Array u8 (sz 64))
-    : Prims.Pure (t_MlKemState v_K & Libcrux.Kem.Kyber.Types.t_MlKemPublicKey v_PUBLIC_KEY_SIZE)
-      Prims.l_True
-      (fun _ -> Prims.l_True)
+    : Pure (Libcrux.Kem.Kyber.Types.t_MlKemKeyPair v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE)
+      (requires (v_K == p.v_RANK /\ v_ETA1 == p.v_ETA1 /\
+                 v_ETA1_RANDOMNESS_SIZE == Spec.Kyber.v_ETA1_RANDOMNESS_SIZE p /\
+                 v_PUBLIC_KEY_SIZE == Spec.Kyber.v_CPA_PKE_PUBLIC_KEY_SIZE p /\
+                 v_CPA_PRIVATE_KEY_SIZE == Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p /\
+                 v_PRIVATE_KEY_SIZE == Spec.Kyber.v_SECRET_KEY_SIZE p /\
+                 v_BYTES_PER_RING_ELEMENT == Spec.Kyber.v_RANKED_BYTES_PER_RING_ELEMENT p
+                 ))
+      (ensures (fun kp -> 
+                (kp.f_sk.f_value,kp.f_pk.f_value) == Spec.Kyber.ind_cca_generate_keypair p randomness))
diff -ruN extraction/Libcrux.Kem.Kyber.Hash_functions.fst extraction-edited/Libcrux.Kem.Kyber.Hash_functions.fst
--- extraction/Libcrux.Kem.Kyber.Hash_functions.fst	2024-05-16 17:05:53.724568778 +0200
+++ extraction-edited/Libcrux.Kem.Kyber.Hash_functions.fst	2024-05-16 17:05:53.769567268 +0200
@@ -3,126 +3,114 @@
 open Core
 open FStar.Mul
 
-let v_G (input: t_Slice u8) = Libcrux.Digest.sha3_512_ input
-
-let v_H (input: t_Slice u8) = Libcrux.Digest.sha3_256_ input
-
-let v_PRF (v_LEN: usize) (input: t_Slice u8) = Libcrux.Digest.shake256 v_LEN input
-
-let absorb (v_K: usize) (input: t_Array (t_Array u8 (sz 34)) v_K) =
-  let _:Prims.unit =
-    if true
+let v_G (input: t_Slice u8) =
+  let res = Libcrux.Digest.sha3_512_ input in
+  admit(); // We assume that sha3_512 correctly implements G
+  res
+
+let v_H (input: t_Slice u8) =
+  let res = Libcrux.Digest.sha3_256_ input in
+  admit(); // We assume that sha3_512 correctly implements H
+  res
+
+let v_PRF (v_LEN: usize) (input: t_Slice u8) =
+  let res = Libcrux.Digest.shake256 v_LEN input in
+  admit(); // We assume that sha3_512 correctly implements H
+  res
+
+let v_XOFx4 v_K (input: t_Array (t_Array u8 (sz 34)) v_K) =
+  assert (v v_K >= 2);
+  let out:t_Array (t_Array u8 (sz 840)) v_K =
+    Rust_primitives.Hax.repeat (Rust_primitives.Hax.repeat 0uy (sz 840) <: t_Array u8 (sz 840)) v_K
+  in
+  let out:t_Array (t_Array u8 (sz 840)) v_K =
+    if ~.(Libcrux_platform.Platform.simd256_support () <: bool)
     then
-      let _:Prims.unit =
-        if ~.((v_K =. sz 2 <: bool) || (v_K =. sz 3 <: bool) || (v_K =. sz 4 <: bool))
-        then
-          Rust_primitives.Hax.never_to_any (Core.Panicking.panic "assertion failed: K == 2 || K == 3 || K == 4"
-
+      Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
+                Core.Ops.Range.f_start = sz 0;
+                Core.Ops.Range.f_end = v_K
+              }
               <:
-              Rust_primitives.Hax.t_Never)
-      in
-      ()
-  in
-  let state:Libcrux.Digest.Incremental_x4.t_Shake128StateX4 =
-    Libcrux.Digest.Incremental_x4.impl__Shake128StateX4__new ()
-  in
-  let (data: t_Array (t_Slice u8) v_K):t_Array (t_Slice u8) v_K =
-    Rust_primitives.Hax.repeat (Rust_primitives.unsize (let list = [0uy] in
-            FStar.Pervasives.assert_norm (Prims.eq2 (List.Tot.length list) 1);
-            Rust_primitives.Hax.array_of_list 1 list)
-        <:
-        t_Slice u8)
-      v_K
-  in
-  let data:t_Array (t_Slice u8) v_K =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-            usize)
-          ({ Core.Ops.Range.f_start = sz 0; Core.Ops.Range.f_end = v_K }
-            <:
-            Core.Ops.Range.t_Range usize)
-        <:
-        Core.Ops.Range.t_Range usize)
-      data
-      (fun data i ->
-          let data:t_Array (t_Slice u8) v_K = data in
-          let i:usize = i in
-          Rust_primitives.Hax.Monomorphized_update_at.update_at_usize data
-            i
-            (Rust_primitives.unsize (input.[ i ] <: t_Array u8 (sz 34)) <: t_Slice u8)
+              Core.Ops.Range.t_Range usize)
           <:
-          t_Array (t_Slice u8) v_K)
-  in
-  let state:Libcrux.Digest.Incremental_x4.t_Shake128StateX4 =
-    Libcrux.Digest.Incremental_x4.impl__Shake128StateX4__absorb_final v_K state data
-  in
-  state
-
-let free_state (xof_state: Libcrux.Digest.Incremental_x4.t_Shake128StateX4) =
-  let _:Prims.unit = Libcrux.Digest.Incremental_x4.impl__Shake128StateX4__free_memory xof_state in
-  ()
-
-let squeeze_block (v_K: usize) (xof_state: Libcrux.Digest.Incremental_x4.t_Shake128StateX4) =
-  let tmp0, out1:(Libcrux.Digest.Incremental_x4.t_Shake128StateX4 &
-    t_Array (t_Array u8 (sz 168)) v_K) =
-    Libcrux.Digest.Incremental_x4.impl__Shake128StateX4__squeeze_blocks (sz 168) v_K xof_state
-  in
-  let xof_state:Libcrux.Digest.Incremental_x4.t_Shake128StateX4 = tmp0 in
-  let (output: t_Array (t_Array u8 (sz 168)) v_K):t_Array (t_Array u8 (sz 168)) v_K = out1 in
-  let out:t_Array (t_Array u8 (sz 168)) v_K =
-    Rust_primitives.Hax.repeat (Rust_primitives.Hax.repeat 0uy (sz 168) <: t_Array u8 (sz 168)) v_K
-  in
-  let out:t_Array (t_Array u8 (sz 168)) v_K =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-            usize)
-          ({ Core.Ops.Range.f_start = sz 0; Core.Ops.Range.f_end = v_K }
-            <:
-            Core.Ops.Range.t_Range usize)
-        <:
-        Core.Ops.Range.t_Range usize)
-      out
-      (fun out i ->
-          let out:t_Array (t_Array u8 (sz 168)) v_K = out in
-          let i:usize = i in
-          Rust_primitives.Hax.Monomorphized_update_at.update_at_usize out
-            i
-            (output.[ i ] <: t_Array u8 (sz 168))
-          <:
-          t_Array (t_Array u8 (sz 168)) v_K)
-  in
-  let hax_temp_output:t_Array (t_Array u8 (sz 168)) v_K = out in
-  xof_state, hax_temp_output
-  <:
-  (Libcrux.Digest.Incremental_x4.t_Shake128StateX4 & t_Array (t_Array u8 (sz 168)) v_K)
-
-let squeeze_three_blocks (v_K: usize) (xof_state: Libcrux.Digest.Incremental_x4.t_Shake128StateX4) =
-  let tmp0, out1:(Libcrux.Digest.Incremental_x4.t_Shake128StateX4 &
-    t_Array (t_Array u8 (sz 504)) v_K) =
-    Libcrux.Digest.Incremental_x4.impl__Shake128StateX4__squeeze_blocks (sz 504) v_K xof_state
-  in
-  let xof_state:Libcrux.Digest.Incremental_x4.t_Shake128StateX4 = tmp0 in
-  let (output: t_Array (t_Array u8 (sz 504)) v_K):t_Array (t_Array u8 (sz 504)) v_K = out1 in
-  let out:t_Array (t_Array u8 (sz 504)) v_K =
-    Rust_primitives.Hax.repeat (Rust_primitives.Hax.repeat 0uy (sz 504) <: t_Array u8 (sz 504)) v_K
-  in
-  let out:t_Array (t_Array u8 (sz 504)) v_K =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-            usize)
-          ({ Core.Ops.Range.f_start = sz 0; Core.Ops.Range.f_end = v_K }
+          Core.Ops.Range.t_Range usize)
+        out
+        (fun out i ->
+            let out:t_Array (t_Array u8 (sz 840)) v_K = out in
+            let i:usize = i in
+            Rust_primitives.Hax.Monomorphized_update_at.update_at_usize out
+              i
+              (Libcrux.Digest.shake128 (sz 840)
+                  (Rust_primitives.unsize (input.[ i ] <: t_Array u8 (sz 34)) <: t_Slice u8)
+                <:
+                t_Array u8 (sz 840))
             <:
-            Core.Ops.Range.t_Range usize)
-        <:
-        Core.Ops.Range.t_Range usize)
+            t_Array (t_Array u8 (sz 840)) v_K)
+    else
+      let out:t_Array (t_Array u8 (sz 840)) v_K =
+        match cast (v_K <: usize) <: u8 with
+        | 2uy ->
+          let d0, d1, _, _:(t_Array u8 (sz 840) & t_Array u8 (sz 840) & t_Array u8 (sz 840) &
+            t_Array u8 (sz 840)) =
+            Libcrux.Digest.shake128x4 (sz 840)
+              (Rust_primitives.unsize (input.[ sz 0 ] <: t_Array u8 (sz 34)) <: t_Slice u8)
+              (Rust_primitives.unsize (input.[ sz 1 ] <: t_Array u8 (sz 34)) <: t_Slice u8)
+              (Rust_primitives.unsize (input.[ sz 0 ] <: t_Array u8 (sz 34)) <: t_Slice u8)
+              (Rust_primitives.unsize (input.[ sz 1 ] <: t_Array u8 (sz 34)) <: t_Slice u8)
+          in
+          let out:t_Array (t_Array u8 (sz 840)) v_K =
+            Rust_primitives.Hax.Monomorphized_update_at.update_at_usize out (sz 0) d0
+          in
+          let out:t_Array (t_Array u8 (sz 840)) v_K =
+            Rust_primitives.Hax.Monomorphized_update_at.update_at_usize out (sz 1) d1
+          in
+          out
+        | 3uy ->
+          assert (v (cast v_K <: u8) = 3);
+          let d0, d1, d2, _:(t_Array u8 (sz 840) & t_Array u8 (sz 840) & t_Array u8 (sz 840) &
+            t_Array u8 (sz 840)) =
+            Libcrux.Digest.shake128x4 (sz 840)
+              (Rust_primitives.unsize (input.[ sz 0 ] <: t_Array u8 (sz 34)) <: t_Slice u8)
+              (Rust_primitives.unsize (input.[ sz 1 ] <: t_Array u8 (sz 34)) <: t_Slice u8)
+              (Rust_primitives.unsize (input.[ sz 2 ] <: t_Array u8 (sz 34)) <: t_Slice u8)
+              (Rust_primitives.unsize (input.[ sz 0 ] <: t_Array u8 (sz 34)) <: t_Slice u8)
+          in
+          let out:t_Array (t_Array u8 (sz 840)) v_K =
+            Rust_primitives.Hax.Monomorphized_update_at.update_at_usize out (sz 0) d0
+          in
+          let out:t_Array (t_Array u8 (sz 840)) v_K =
+            Rust_primitives.Hax.Monomorphized_update_at.update_at_usize out (sz 1) d1
+          in
+          let out:t_Array (t_Array u8 (sz 840)) v_K =
+            Rust_primitives.Hax.Monomorphized_update_at.update_at_usize out (sz 2) d2
+          in
+          out
+        | 4uy ->
+          assert (v (cast v_K <: u8) = 4);
+          let d0, d1, d2, d3:(t_Array u8 (sz 840) & t_Array u8 (sz 840) & t_Array u8 (sz 840) &
+            t_Array u8 (sz 840)) =
+            Libcrux.Digest.shake128x4 (sz 840)
+              (Rust_primitives.unsize (input.[ sz 0 ] <: t_Array u8 (sz 34)) <: t_Slice u8)
+              (Rust_primitives.unsize (input.[ sz 1 ] <: t_Array u8 (sz 34)) <: t_Slice u8)
+              (Rust_primitives.unsize (input.[ sz 2 ] <: t_Array u8 (sz 34)) <: t_Slice u8)
+              (Rust_primitives.unsize (input.[ sz 3 ] <: t_Array u8 (sz 34)) <: t_Slice u8)
+          in
+          let out:t_Array (t_Array u8 (sz 840)) v_K =
+            Rust_primitives.Hax.Monomorphized_update_at.update_at_usize out (sz 0) d0
+          in
+          let out:t_Array (t_Array u8 (sz 840)) v_K =
+            Rust_primitives.Hax.Monomorphized_update_at.update_at_usize out (sz 1) d1
+          in
+          let out:t_Array (t_Array u8 (sz 840)) v_K =
+            Rust_primitives.Hax.Monomorphized_update_at.update_at_usize out (sz 2) d2
+          in
+          let out:t_Array (t_Array u8 (sz 840)) v_K =
+            Rust_primitives.Hax.Monomorphized_update_at.update_at_usize out (sz 3) d3
+          in
+          out
+        | _ -> out
+      in
       out
-      (fun out i ->
-          let out:t_Array (t_Array u8 (sz 504)) v_K = out in
-          let i:usize = i in
-          Rust_primitives.Hax.Monomorphized_update_at.update_at_usize out
-            i
-            (output.[ i ] <: t_Array u8 (sz 504))
-          <:
-          t_Array (t_Array u8 (sz 504)) v_K)
   in
-  let hax_temp_output:t_Array (t_Array u8 (sz 504)) v_K = out in
-  xof_state, hax_temp_output
-  <:
-  (Libcrux.Digest.Incremental_x4.t_Shake128StateX4 & t_Array (t_Array u8 (sz 504)) v_K)
+  admit(); // We assume that shake128x4 correctly implements XOFx4
+  out 
diff -ruN extraction/Libcrux.Kem.Kyber.Hash_functions.fsti extraction-edited/Libcrux.Kem.Kyber.Hash_functions.fsti
--- extraction/Libcrux.Kem.Kyber.Hash_functions.fsti	2024-05-16 17:05:53.698569651 +0200
+++ extraction-edited/Libcrux.Kem.Kyber.Hash_functions.fsti	2024-05-16 17:05:53.772567168 +0200
@@ -3,35 +3,17 @@
 open Core
 open FStar.Mul
 
-let v_BLOCK_SIZE: usize = sz 168
+val v_G (input: t_Slice u8) : Prims.Pure (t_Array u8 (sz 64)) Prims.l_True
+          (ensures (fun res -> res == Spec.Kyber.v_G input))
 
-val v_G (input: t_Slice u8) : Prims.Pure (t_Array u8 (sz 64)) Prims.l_True (fun _ -> Prims.l_True)
-
-val v_H (input: t_Slice u8) : Prims.Pure (t_Array u8 (sz 32)) Prims.l_True (fun _ -> Prims.l_True)
+val v_H (input: t_Slice u8) : Prims.Pure (t_Array u8 (sz 32)) Prims.l_True
+          (ensures (fun res -> res == Spec.Kyber.v_H input))
 
 val v_PRF (v_LEN: usize) (input: t_Slice u8)
-    : Prims.Pure (t_Array u8 v_LEN) Prims.l_True (fun _ -> Prims.l_True)
-
-let v_THREE_BLOCKS: usize = v_BLOCK_SIZE *! sz 3
-
-val absorb (v_K: usize) (input: t_Array (t_Array u8 (sz 34)) v_K)
-    : Prims.Pure Libcrux.Digest.Incremental_x4.t_Shake128StateX4
-      Prims.l_True
-      (fun _ -> Prims.l_True)
-
-/// Free the memory of the state.
-/// **NOTE:** That this needs to be done manually for now.
-val free_state (xof_state: Libcrux.Digest.Incremental_x4.t_Shake128StateX4)
-    : Prims.Pure Prims.unit Prims.l_True (fun _ -> Prims.l_True)
-
-val squeeze_block (v_K: usize) (xof_state: Libcrux.Digest.Incremental_x4.t_Shake128StateX4)
-    : Prims.Pure
-      (Libcrux.Digest.Incremental_x4.t_Shake128StateX4 & t_Array (t_Array u8 (sz 168)) v_K)
-      Prims.l_True
-      (fun _ -> Prims.l_True)
-
-val squeeze_three_blocks (v_K: usize) (xof_state: Libcrux.Digest.Incremental_x4.t_Shake128StateX4)
-    : Prims.Pure
-      (Libcrux.Digest.Incremental_x4.t_Shake128StateX4 & t_Array (t_Array u8 (sz 504)) v_K)
-      Prims.l_True
-      (fun _ -> Prims.l_True)
+    : Prims.Pure (t_Array u8 v_LEN) Prims.l_True
+          (ensures (fun res -> res == Spec.Kyber.v_PRF v_LEN input))
+          
+val v_XOFx4 (v_K: usize{v v_K >= 2 /\ v v_K <= 4}) (input: t_Array (t_Array u8 (sz 34)) v_K)
+    : Prims.Pure (t_Array (t_Array u8 (sz 840)) v_K) Prims.l_True
+          (ensures (fun res ->
+            (forall i. i < v v_K ==> Seq.index res i == Spec.Kyber.v_XOF (sz 840) (Seq.index input i))))
diff -ruN extraction/Libcrux.Kem.Kyber.Ind_cpa.fst extraction-edited/Libcrux.Kem.Kyber.Ind_cpa.fst
--- extraction/Libcrux.Kem.Kyber.Ind_cpa.fst	2024-05-16 17:05:53.704569449 +0200
+++ extraction-edited/Libcrux.Kem.Kyber.Ind_cpa.fst	2024-05-16 17:05:53.779566933 +0200
@@ -1,5 +1,5 @@
 module Libcrux.Kem.Kyber.Ind_cpa
-#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
+#set-options "--fuel 0 --ifuel 1 --z3rlimit 100"
 open Core
 open FStar.Mul
 
@@ -8,7 +8,7 @@
     if true
     then
       let _:Prims.unit =
-        if ~.((Core.Slice.impl__len #u8 slice <: usize) <=. v_LEN <: bool)
+        if ~.((Core.Slice.impl__len slice <: usize) <=. v_LEN <: bool)
         then
           Rust_primitives.Hax.never_to_any (Core.Panicking.panic "assertion failed: slice.len() <= LEN"
 
@@ -20,16 +20,12 @@
   let out:t_Array u8 v_LEN = Rust_primitives.Hax.repeat 0uy v_LEN in
   let out:t_Array u8 v_LEN =
     Rust_primitives.Hax.Monomorphized_update_at.update_at_range out
-      ({
-          Core.Ops.Range.f_start = sz 0;
-          Core.Ops.Range.f_end = Core.Slice.impl__len #u8 slice <: usize
-        }
+      ({ Core.Ops.Range.f_start = sz 0; Core.Ops.Range.f_end = Core.Slice.impl__len slice <: usize }
         <:
         Core.Ops.Range.t_Range usize)
-      (Core.Slice.impl__copy_from_slice #u8
-          (out.[ {
+      (Core.Slice.impl__copy_from_slice (out.[ {
                 Core.Ops.Range.f_start = sz 0;
-                Core.Ops.Range.f_end = Core.Slice.impl__len #u8 slice <: usize
+                Core.Ops.Range.f_end = Core.Slice.impl__len slice <: usize
               }
               <:
               Core.Ops.Range.t_Range usize ]
@@ -41,32 +37,37 @@
   in
   out
 
-let sample_ring_element_cbd
+unfold let acc_t (v_K v_ETA:usize) = (u8 & t_Array u8 (sz 33) & t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (pow2 (v v_ETA) - 1)) v_K)
+unfold let inv_t v_K v_ETA = acc_t v_K v_ETA -> usize -> Type
+
+let wfZero: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+  (Libcrux.Kem.Kyber.Arithmetic.cast_poly_b #1 #3328 Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO)  
+
+let etaZero (v_ETA:usize{v v_ETA >= 1 /\ v v_ETA < pow2 31}): Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_ETA) =
+  (Libcrux.Kem.Kyber.Arithmetic.cast_poly_b #1 #(v v_ETA) Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO)  
+
+let sample_vector_cbd (#p:Spec.Kyber.params)
       (v_K v_ETA2_RANDOMNESS_SIZE v_ETA2: usize)
-      (prf_input: t_Array u8 (sz 33))
-      (domain_separator: u8)
-     =
-  let error_1_:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-    Rust_primitives.Hax.repeat Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO v_K
-  in
-  let domain_separator, error_1_, prf_input:(u8 &
-    t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-    t_Array u8 (sz 33)) =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-            usize)
-          ({ Core.Ops.Range.f_start = sz 0; Core.Ops.Range.f_end = v_K }
-            <:
-            Core.Ops.Range.t_Range usize)
-        <:
-        Core.Ops.Range.t_Range usize)
-      (domain_separator, error_1_, prf_input
-        <:
-        (u8 & t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K & t_Array u8 (sz 33))
-      )
+      (prf_input: t_Array u8 (sz 33)) domain_separator = 
+  let error_1_:t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (pow2 (v v_ETA2) - 1)) v_K =
+    Rust_primitives.Hax.repeat (etaZero (sz (pow2 (v v_ETA2) - 1))) v_K
+  in
+  let orig_domain_separator = domain_separator in
+  [@ inline_let]
+  let inv : inv_t v_K v_ETA2 = fun (acc:acc_t v_K v_ETA2) (i:usize) ->
+    let (domain_separator,prf_input,error_1_) = acc in
+    if (i >=. sz 0 && i <=. v_K)
+    then
+      domain_separator = orig_domain_separator +! (mk_int #u8_inttype (v i))
+    else true in
+  let (domain_separator, prf_input, error_1_):acc_t v_K (v_ETA2) = 
+    Rust_primitives.Iterators.foldi_range #_ #(acc_t v_K (v_ETA2)) #inv {
+              Core.Ops.Range.f_start = sz 0;
+              Core.Ops.Range.f_end = v_K
+            }
+      (domain_separator, prf_input, error_1_)
       (fun temp_0_ i ->
-          let domain_separator, error_1_, prf_input:(u8 &
-            t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-            t_Array u8 (sz 33)) =
+          let domain_separator, prf_input, error_1_:acc_t v_K (v_ETA2) =
             temp_0_
           in
           let i:usize = i in
@@ -80,48 +81,46 @@
             Libcrux.Kem.Kyber.Hash_functions.v_PRF v_ETA2_RANDOMNESS_SIZE
               (Rust_primitives.unsize prf_input <: t_Slice u8)
           in
-          let error_1_:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+          let error_1_:t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (pow2 (v v_ETA2) - 1)) v_K =
             Rust_primitives.Hax.Monomorphized_update_at.update_at_usize error_1_
               i
-              (Libcrux.Kem.Kyber.Sampling.sample_from_binomial_distribution v_ETA2
+              (Libcrux.Kem.Kyber.Sampling.sample_from_binomial_distribution #p v_ETA2
                   (Rust_primitives.unsize prf_output <: t_Slice u8)
                 <:
-                Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+                Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (pow2 (v v_ETA2) - 1))
           in
-          domain_separator, error_1_, prf_input
-          <:
-          (u8 & t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-            t_Array u8 (sz 33)))
+          domain_separator, prf_input, error_1_)
   in
-  let hax_temp_output:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K = error_1_ in
+  let hax_temp_output:t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (pow2 (v v_ETA2) - 1)) v_K = error_1_ in
+  admit(); //P-F
   prf_input, domain_separator, hax_temp_output
   <:
-  (t_Array u8 (sz 33) & u8 & t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+  (t_Array u8 (sz 33) & u8 & t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_ETA2)) v_K)
 
-let sample_vector_cbd_then_ntt
+#push-options "--split_queries no --z3rlimit 300"
+let sample_vector_cbd_then_ntt (#p:Spec.Kyber.params)
       (v_K v_ETA v_ETA_RANDOMNESS_SIZE: usize)
-      (prf_input: t_Array u8 (sz 33))
-      (domain_separator: u8)
-     =
-  let re_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-    Rust_primitives.Hax.repeat Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO v_K
-  in
-  let domain_separator, prf_input, re_as_ntt:(u8 & t_Array u8 (sz 33) &
-    t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-            usize)
-          ({ Core.Ops.Range.f_start = sz 0; Core.Ops.Range.f_end = v_K }
-            <:
-            Core.Ops.Range.t_Range usize)
-        <:
-        Core.Ops.Range.t_Range usize)
-      (domain_separator, prf_input, re_as_ntt
-        <:
-        (u8 & t_Array u8 (sz 33) & t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-      )
+      (prf_input: t_Array u8 (sz 33)) domain_separator =
+  let re_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
+    Rust_primitives.Hax.repeat (wfZero) v_K
+  in
+  let orig_domain_separator = domain_separator in
+  [@ inline_let]
+  let inv: (u8 & t_Array u8 (sz 33) & t_Array (Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement) v_K) -> usize -> Type = fun acc i ->
+    let (domain_separator,prf_input,re_as_ntt) = acc in
+    if (i >=. sz 0 && i <=. v_K)
+    then 
+      domain_separator = orig_domain_separator +! (mk_int #u8_inttype (v i))
+    else true in
+  let (domain_separator, prf_input, re_as_ntt):(u8 & t_Array u8 (sz 33) & t_Array (Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement) v_K)= 
+    Rust_primitives.Iterators.foldi_range #_ #_  #inv {
+              Core.Ops.Range.f_start = sz 0;
+              Core.Ops.Range.f_end = v_K
+            }
+      (domain_separator, prf_input, re_as_ntt)
       (fun temp_0_ i ->
           let domain_separator, prf_input, re_as_ntt:(u8 & t_Array u8 (sz 33) &
-            t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) =
+            t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) =
             temp_0_
           in
           let i:usize = i in
@@ -135,70 +134,74 @@
             Libcrux.Kem.Kyber.Hash_functions.v_PRF v_ETA_RANDOMNESS_SIZE
               (Rust_primitives.unsize prf_input <: t_Slice u8)
           in
-          let r:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-            Libcrux.Kem.Kyber.Sampling.sample_from_binomial_distribution v_ETA
+          let r:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (pow2 (v v_ETA) - 1) =
+            Libcrux.Kem.Kyber.Sampling.sample_from_binomial_distribution #p v_ETA
               (Rust_primitives.unsize prf_output <: t_Slice u8)
           in
-          let re_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+          let r:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 7 =
+            Libcrux.Kem.Kyber.Arithmetic.cast_poly_b r in
+          let re_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
             Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re_as_ntt
               i
               (Libcrux.Kem.Kyber.Ntt.ntt_binomially_sampled_ring_element r
                 <:
-                Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+                Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
           in
           domain_separator, prf_input, re_as_ntt
           <:
           (u8 & t_Array u8 (sz 33) &
-            t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K))
+            t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K))
   in
+  admit(); //P-F
   re_as_ntt, domain_separator
   <:
-  (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K & u8)
+  (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K & u8)
 
-let compress_then_serialize_u
-      (v_K v_OUT_LEN v_COMPRESSION_FACTOR v_BLOCK_LEN: usize)
-      (input: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-     =
+
+let compress_then_serialize_u #p v_K v_OUT_LEN v_COMPRESSION_FACTOR v_BLOCK_LEN input = 
   let out:t_Array u8 v_OUT_LEN = Rust_primitives.Hax.repeat 0uy v_OUT_LEN in
+  let orig_out = out in
+  let acc_t = t_Array u8 v_OUT_LEN in
+  [@ inline_let]
+  let inv = fun (acc:acc_t) (i:usize) -> True in
   let out:t_Array u8 v_OUT_LEN =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Iter.Adapters.Enumerate.t_Enumerate
-            (Core.Array.Iter.t_IntoIter Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K))
-          (Core.Iter.Traits.Iterator.f_enumerate #(Core.Array.Iter.t_IntoIter
-                  Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-              (Core.Iter.Traits.Collect.f_into_iter #(t_Array
-                      Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-                  input
-                <:
-                Core.Array.Iter.t_IntoIter Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-            <:
-            Core.Iter.Adapters.Enumerate.t_Enumerate
-            (Core.Array.Iter.t_IntoIter Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K))
-        <:
-        Core.Iter.Adapters.Enumerate.t_Enumerate
-        (Core.Array.Iter.t_IntoIter Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K))
+    Rust_primitives.Iterators.foldi_slice #Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement  #acc_t #inv
+      input
       out
       (fun out temp_1_ ->
           let out:t_Array u8 v_OUT_LEN = out in
-          let i, re:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) = temp_1_ in
+          let i, re:(usize & Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement) = temp_1_ in
+          assert (i <. v_K);
+          assert (v i + 1  <=  v v_K);
+          assert (v i * (v v_OUT_LEN / v v_K) < v v_OUT_LEN);
+          assert (((v i + 1) * (v v_OUT_LEN / v v_K)) <= v v_OUT_LEN);
+          assert (v_OUT_LEN /! v_K == Spec.Kyber.v_C1_BLOCK_SIZE p);
+          assert (range (v i * v (Spec.Kyber.v_C1_BLOCK_SIZE p)) usize_inttype);
+          assert (range ((v i + 1) * v (Spec.Kyber.v_C1_BLOCK_SIZE p)) usize_inttype);
+          assert ((Core.Ops.Range.impl_index_range_slice u8 usize_inttype).f_index_pre out 
+                    {
+                      Core.Ops.Range.f_start = i *! Spec.Kyber.v_C1_BLOCK_SIZE p <: usize;
+                      Core.Ops.Range.f_end
+                      =
+                      (i +! sz 1 <: usize) *! Spec.Kyber.v_C1_BLOCK_SIZE p <: usize
+                    });
+          assert (((i +! sz 1 <: usize) *! Spec.Kyber.v_C1_BLOCK_SIZE p) -! (i *! Spec.Kyber.v_C1_BLOCK_SIZE p) == Spec.Kyber.v_C1_BLOCK_SIZE p);
           Rust_primitives.Hax.Monomorphized_update_at.update_at_range out
             ({
-                Core.Ops.Range.f_start = i *! (v_OUT_LEN /! v_K <: usize) <: usize;
-                Core.Ops.Range.f_end = (i +! sz 1 <: usize) *! (v_OUT_LEN /! v_K <: usize) <: usize
+                Core.Ops.Range.f_start = i *! Spec.Kyber.v_C1_BLOCK_SIZE p <: usize;
+                Core.Ops.Range.f_end = (i +! sz 1 <: usize) *! Spec.Kyber.v_C1_BLOCK_SIZE p <: usize
               }
               <:
               Core.Ops.Range.t_Range usize)
-            (Core.Slice.impl__copy_from_slice #u8
-                (out.[ {
-                      Core.Ops.Range.f_start = i *! (v_OUT_LEN /! v_K <: usize) <: usize;
+            (Core.Slice.impl__copy_from_slice (out.[ {
+                      Core.Ops.Range.f_start = i *! Spec.Kyber.v_C1_BLOCK_SIZE p <: usize;
                       Core.Ops.Range.f_end
                       =
-                      (i +! sz 1 <: usize) *! (v_OUT_LEN /! v_K <: usize) <: usize
-                    }
-                    <:
-                    Core.Ops.Range.t_Range usize ]
+                      (i +! sz 1 <: usize) *! Spec.Kyber.v_C1_BLOCK_SIZE p <: usize
+                    } ]
                   <:
                   t_Slice u8)
-                (Rust_primitives.unsize (Libcrux.Kem.Kyber.Serialize.compress_then_serialize_ring_element_u
+                (Rust_primitives.unsize (Libcrux.Kem.Kyber.Serialize.compress_then_serialize_ring_element_u #p
                         v_COMPRESSION_FACTOR
                         v_BLOCK_LEN
                         re
@@ -211,155 +214,168 @@
           <:
           t_Array u8 v_OUT_LEN)
   in
+  admit();//P-F
   out
 
-let encrypt_unpacked
-      (v_K v_CIPHERTEXT_SIZE v_T_AS_NTT_ENCODED_SIZE v_C1_LEN v_C2_LEN v_U_COMPRESSION_FACTOR v_V_COMPRESSION_FACTOR v_BLOCK_LEN v_ETA1 v_ETA1_RANDOMNESS_SIZE v_ETA2 v_ETA2_RANDOMNESS_SIZE:
-          usize)
-      (tt_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-      (a_transpose: t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K)
-      (message: t_Array u8 (sz 32))
-      (randomness: t_Slice u8)
-     =
-  let (prf_input: t_Array u8 (sz 33)):t_Array u8 (sz 33) = into_padded_array (sz 33) randomness in
-  let r_as_ntt, domain_separator:(t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-    u8) =
-    sample_vector_cbd_then_ntt v_K v_ETA1 v_ETA1_RANDOMNESS_SIZE prf_input 0uy
-  in
-  let tmp0, tmp1, out:(t_Array u8 (sz 33) & u8 &
-    t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) =
-    sample_ring_element_cbd v_K v_ETA2_RANDOMNESS_SIZE v_ETA2 prf_input domain_separator
-  in
-  let prf_input:t_Array u8 (sz 33) = tmp0 in
-  let domain_separator:u8 = tmp1 in
-  let error_1_:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K = out in
-  let prf_input:t_Array u8 (sz 33) =
-    Rust_primitives.Hax.Monomorphized_update_at.update_at_usize prf_input (sz 32) domain_separator
-  in
-  let (prf_output: t_Array u8 v_ETA2_RANDOMNESS_SIZE):t_Array u8 v_ETA2_RANDOMNESS_SIZE =
-    Libcrux.Kem.Kyber.Hash_functions.v_PRF v_ETA2_RANDOMNESS_SIZE
-      (Rust_primitives.unsize prf_input <: t_Slice u8)
-  in
-  let error_2_:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Libcrux.Kem.Kyber.Sampling.sample_from_binomial_distribution v_ETA2
-      (Rust_primitives.unsize prf_output <: t_Slice u8)
-  in
-  let u:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-    Libcrux.Kem.Kyber.Matrix.compute_vector_u v_K a_transpose r_as_ntt error_1_
-  in
-  let message_as_ring_element:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Libcrux.Kem.Kyber.Serialize.deserialize_then_decompress_message message
-  in
-  let v:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Libcrux.Kem.Kyber.Matrix.compute_ring_element_v v_K
-      tt_as_ntt
-      r_as_ntt
-      error_2_
-      message_as_ring_element
-  in
-  let c1:t_Array u8 v_C1_LEN =
-    compress_then_serialize_u v_K v_C1_LEN v_U_COMPRESSION_FACTOR v_BLOCK_LEN u
-  in
-  let c2:t_Array u8 v_C2_LEN =
-    Libcrux.Kem.Kyber.Serialize.compress_then_serialize_ring_element_v v_V_COMPRESSION_FACTOR
-      v_C2_LEN
-      v
-  in
-  let (ciphertext: t_Array u8 v_CIPHERTEXT_SIZE):t_Array u8 v_CIPHERTEXT_SIZE =
-    into_padded_array v_CIPHERTEXT_SIZE (Rust_primitives.unsize c1 <: t_Slice u8)
-  in
-  let ciphertext:t_Array u8 v_CIPHERTEXT_SIZE =
-    Rust_primitives.Hax.Monomorphized_update_at.update_at_range_from ciphertext
-      ({ Core.Ops.Range.f_start = v_C1_LEN } <: Core.Ops.Range.t_RangeFrom usize)
-      (Core.Slice.impl__copy_from_slice #u8
-          (ciphertext.[ { Core.Ops.Range.f_start = v_C1_LEN } <: Core.Ops.Range.t_RangeFrom usize ]
-            <:
-            t_Slice u8)
-          (Core.Array.impl_23__as_slice #u8 v_C2_LEN c2 <: t_Slice u8)
-        <:
-        t_Slice u8)
-  in
-  ciphertext
-
-let deserialize_then_decompress_u
-      (v_K v_CIPHERTEXT_SIZE v_U_COMPRESSION_FACTOR: usize)
-      (ciphertext: t_Array u8 v_CIPHERTEXT_SIZE)
-     =
-  let u_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-    Rust_primitives.Hax.repeat Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO v_K
-  in
-  let u_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Iter.Adapters.Enumerate.t_Enumerate
-            (Core.Slice.Iter.t_ChunksExact u8))
-          (Core.Iter.Traits.Iterator.f_enumerate #(Core.Slice.Iter.t_ChunksExact u8)
-              (Core.Slice.impl__chunks_exact #u8
-                  (Rust_primitives.unsize ciphertext <: t_Slice u8)
-                  ((Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT *!
+#push-options "--split_queries always"
+let deserialize_then_decompress_u (#p:Spec.Kyber.params)
+      (v_K v_CIPHERTEXT_SIZE v_VECTOR_U_ENCODED_SIZE v_U_COMPRESSION_FACTOR: usize)
+      (ciphertext: t_Array u8 v_CIPHERTEXT_SIZE) =
+  let u_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
+    Rust_primitives.Hax.repeat wfZero v_K
+  in
+  let acc_t1 = t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K in
+  [@ inline_let]
+  let inv = fun (acc:acc_t1) (i:usize) -> True in
+  let sl : t_Slice u8 = ciphertext.[ 
+                      { Core.Ops.Range.f_end = v_VECTOR_U_ENCODED_SIZE  } <: Core.Ops.Range.t_RangeTo usize ] in
+  assert (length sl == v_VECTOR_U_ENCODED_SIZE);
+  let chunk_len = ((Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT *!
                       v_U_COMPRESSION_FACTOR
                       <:
                       usize) /!
                     sz 8
                     <:
-                    usize)
-                <:
-                Core.Slice.Iter.t_ChunksExact u8)
-            <:
-            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
-        <:
-        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
+                    usize) in
+  FStar.Math.Lemmas.cancel_mul_mod (v p.v_RANK) (v (Spec.Kyber.v_C1_BLOCK_SIZE p)) ;
+  assert (v chunk_len == v (Spec.Kyber.v_C1_BLOCK_SIZE p));
+  assert (Seq.length sl % v (Spec.Kyber.v_C1_BLOCK_SIZE p) = 0);
+  assert (Seq.length sl == v (Spec.Kyber.v_C1_SIZE p));
+  assert (Seq.length sl / v (Spec.Kyber.v_C1_BLOCK_SIZE p) == v v_K);
+  let u_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
+   Rust_primitives.Iterators.foldi_chunks_exact #u8 #acc_t1 #inv
+      sl
+      chunk_len
       u_as_ntt
       (fun u_as_ntt temp_1_ ->
-          let u_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+          let u_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
             u_as_ntt
           in
-          let i, u_bytes:(usize & t_Slice u8) = temp_1_ in
-          let u:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let i, u_bytes:(usize & t_Array u8 chunk_len) = temp_1_ in
+          let u:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
             Libcrux.Kem.Kyber.Serialize.deserialize_then_decompress_ring_element_u v_U_COMPRESSION_FACTOR
               u_bytes
           in
-          let u_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+          assert (v i < v v_K);
+          let u_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
             Rust_primitives.Hax.Monomorphized_update_at.update_at_usize u_as_ntt
               i
               (Libcrux.Kem.Kyber.Ntt.ntt_vector_u v_U_COMPRESSION_FACTOR u
                 <:
-                Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+                Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
           in
           u_as_ntt)
   in
+  admit(); //P-F
   u_as_ntt
+#pop-options
+
+#push-options "--z3rlimit 200"
+let deserialize_public_key (#p:Spec.Kyber.params) 
+    (v_K: usize) (public_key: t_Slice u8) =
+  let tt_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
+    Rust_primitives.Hax.repeat wfZero v_K
+  in
+  let acc_t = t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K in
+  [@ inline_let]
+  let inv = fun (acc:acc_t) (i:usize) -> True in
+  let chunk_len = Libcrux.Kem.Kyber.Constants.v_BYTES_PER_RING_ELEMENT in
+  let tt_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
+   Rust_primitives.Iterators.foldi_chunks_exact #u8 #acc_t #inv
+      public_key
+      chunk_len
+      tt_as_ntt
+      (fun tt_as_ntt temp_1_ ->
+          let tt_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
+            tt_as_ntt
+          in
+          let i, tt_as_ntt_bytes:(usize & t_Array u8 chunk_len) = temp_1_ in
+          Rust_primitives.Hax.Monomorphized_update_at.update_at_usize tt_as_ntt
+            i
+            (Libcrux.Kem.Kyber.Serialize.deserialize_to_uncompressed_ring_element tt_as_ntt_bytes
+              <:
+              Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+          <:
+          t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
+  in
+  admit(); //P-F
+  tt_as_ntt 
+#pop-options
+
+#push-options "--split_queries always"
+let deserialize_secret_key (#p:Spec.Kyber.params) (v_K: usize) (secret_key: t_Slice u8) =
+  let secret_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
+    Rust_primitives.Hax.repeat wfZero v_K
+  in
+  let acc_t = t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K in
+  [@ inline_let]
+  let inv = fun (acc:acc_t) (i:usize) -> True in
+  let sl : t_Slice u8 = secret_key in
+  let chunk_len = Libcrux.Kem.Kyber.Constants.v_BYTES_PER_RING_ELEMENT in
+  assert(v chunk_len == 384);
+  assert(Seq.length secret_key == v (Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p));
+  assert(Seq.length secret_key == (v v_K * 256 * 12)/8);
+  let secret_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
+   Rust_primitives.Iterators.foldi_chunks_exact #u8 #acc_t #inv
+      sl
+      chunk_len
+      secret_as_ntt
+      (fun secret_as_ntt temp_1_ ->
+          let secret_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
+            secret_as_ntt
+          in
+          let i, secret_bytes:(usize & t_Array u8 chunk_len) = temp_1_ in
+          Rust_primitives.Hax.Monomorphized_update_at.update_at_usize secret_as_ntt
+            i
+            (Libcrux.Kem.Kyber.Serialize.deserialize_to_uncompressed_ring_element secret_bytes
+              <:
+              Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+          <:
+          t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
+  in
+  admit(); //P-F
+  secret_as_ntt
+#pop-options
 
-let decrypt_unpacked
+#push-options "--z3rlimit 400 --split_queries no"
+let decrypt #p
       (v_K v_CIPHERTEXT_SIZE v_VECTOR_U_ENCODED_SIZE v_U_COMPRESSION_FACTOR v_V_COMPRESSION_FACTOR:
           usize)
-      (secret_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-      (ciphertext: t_Array u8 v_CIPHERTEXT_SIZE)
-     =
-  let u_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-    deserialize_then_decompress_u v_K v_CIPHERTEXT_SIZE v_U_COMPRESSION_FACTOR ciphertext
+      (secret_key: t_Slice u8)
+      (ciphertext: t_Array u8 v_CIPHERTEXT_SIZE) = 
+  let u_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
+    deserialize_then_decompress_u #p v_K
+      v_CIPHERTEXT_SIZE
+      v_VECTOR_U_ENCODED_SIZE
+      v_U_COMPRESSION_FACTOR
+      ciphertext
   in
-  let v:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Libcrux.Kem.Kyber.Serialize.deserialize_then_decompress_ring_element_v v_V_COMPRESSION_FACTOR
+  let v:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+    Libcrux.Kem.Kyber.Serialize.deserialize_then_decompress_ring_element_v #p v_V_COMPRESSION_FACTOR
       (ciphertext.[ { Core.Ops.Range.f_start = v_VECTOR_U_ENCODED_SIZE }
           <:
           Core.Ops.Range.t_RangeFrom usize ]
         <:
         t_Slice u8)
   in
-  let message:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Libcrux.Kem.Kyber.Matrix.compute_message v_K v secret_as_ntt u_as_ntt
+  let secret_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
+    deserialize_secret_key #p v_K secret_key
   in
-  Libcrux.Kem.Kyber.Serialize.compress_then_serialize_message message
-
-let encrypt
-      (v_K v_CIPHERTEXT_SIZE v_T_AS_NTT_ENCODED_SIZE v_C1_LEN v_C2_LEN v_U_COMPRESSION_FACTOR v_V_COMPRESSION_FACTOR v_BLOCK_LEN v_ETA1 v_ETA1_RANDOMNESS_SIZE v_ETA2 v_ETA2_RANDOMNESS_SIZE:
-          usize)
-      (public_key: t_Slice u8)
+  let message:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+    Libcrux.Kem.Kyber.Matrix.compute_message #p v_K v secret_as_ntt u_as_ntt
+  in
+  let res = Libcrux.Kem.Kyber.Serialize.compress_then_serialize_message message in
+  res
+#pop-options
+
+#push-options "--z3rlimit 200"
+let encrypt #p
+      v_K v_CIPHERTEXT_SIZE v_T_AS_NTT_ENCODED_SIZE v_C1_LEN v_C2_LEN v_U_COMPRESSION_FACTOR v_V_COMPRESSION_FACTOR v_BLOCK_LEN v_ETA1 v_ETA1_RANDOMNESS_SIZE v_ETA2 v_ETA2_RANDOMNESS_SIZE
+      public_key
       (message: t_Array u8 (sz 32))
-      (randomness: t_Slice u8)
-     =
-  let tt_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-    Libcrux.Kem.Kyber.Serialize.deserialize_ring_elements_reduced v_T_AS_NTT_ENCODED_SIZE
-      v_K
+      (randomness: t_Slice u8) =
+  let tt_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
+    deserialize_public_key #p v_K
       (public_key.[ { Core.Ops.Range.f_end = v_T_AS_NTT_ENCODED_SIZE }
           <:
           Core.Ops.Range.t_RangeTo usize ]
@@ -371,90 +387,98 @@
       <:
       Core.Ops.Range.t_RangeFrom usize ]
   in
-  let a_transpose:t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K =
-    Libcrux.Kem.Kyber.Matrix.sample_matrix_A v_K
+  let v_A_transpose:t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) v_K =
+    Libcrux.Kem.Kyber.Matrix.sample_matrix_A #p v_K
       (into_padded_array (sz 34) seed <: t_Array u8 (sz 34))
       false
   in
-  encrypt_unpacked v_K v_CIPHERTEXT_SIZE v_T_AS_NTT_ENCODED_SIZE v_C1_LEN v_C2_LEN
-    v_U_COMPRESSION_FACTOR v_V_COMPRESSION_FACTOR v_BLOCK_LEN v_ETA1 v_ETA1_RANDOMNESS_SIZE v_ETA2
-    v_ETA2_RANDOMNESS_SIZE tt_as_ntt a_transpose message randomness
-
-let deserialize_secret_key (v_K: usize) (secret_key: t_Slice u8) =
-  let secret_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-    Rust_primitives.Hax.repeat Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO v_K
-  in
-  let secret_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Iter.Adapters.Enumerate.t_Enumerate
-            (Core.Slice.Iter.t_ChunksExact u8))
-          (Core.Iter.Traits.Iterator.f_enumerate #(Core.Slice.Iter.t_ChunksExact u8)
-              (Core.Slice.impl__chunks_exact #u8
-                  secret_key
-                  Libcrux.Kem.Kyber.Constants.v_BYTES_PER_RING_ELEMENT
-                <:
-                Core.Slice.Iter.t_ChunksExact u8)
+  let (prf_input: t_Array u8 (sz 33)):t_Array u8 (sz 33) = into_padded_array (sz 33) randomness in
+  let r_as_ntt, domain_separator:(t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K &
+    u8) =
+    sample_vector_cbd_then_ntt #p v_K v_ETA1 v_ETA1_RANDOMNESS_SIZE prf_input 0uy
+  in
+  assert (v domain_separator == v v_K);
+  let tmp0, tmp1, out:(t_Array u8 (sz 33) & u8 &
+    t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) =
+    sample_vector_cbd #p v_K v_ETA2_RANDOMNESS_SIZE v_ETA2 prf_input domain_separator
+  in
+  let prf_input:t_Array u8 (sz 33) = tmp0 in
+  let domain_separator:u8 = tmp1 in
+  let error_1_:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K = out in
+  let prf_input:t_Array u8 (sz 33) =
+    Rust_primitives.Hax.Monomorphized_update_at.update_at_usize prf_input (sz 32) domain_separator
+  in
+  assert (Seq.equal prf_input (Seq.append randomness (Seq.create 1 domain_separator)));
+  assert (prf_input == Seq.append randomness (Seq.create 1 domain_separator));
+  let (prf_output: t_Array u8 v_ETA2_RANDOMNESS_SIZE):t_Array u8 v_ETA2_RANDOMNESS_SIZE =
+    Libcrux.Kem.Kyber.Hash_functions.v_PRF v_ETA2_RANDOMNESS_SIZE
+      (Rust_primitives.unsize prf_input <: t_Slice u8)
+  in
+  let error_2_:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (pow2 (v v_ETA2) - 1) =
+    Libcrux.Kem.Kyber.Sampling.sample_from_binomial_distribution #p v_ETA2
+      (Rust_primitives.unsize prf_output <: t_Slice u8)
+  in
+  let error_2_:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 7 =
+    Libcrux.Kem.Kyber.Arithmetic.cast_poly_b error_2_ in
+  let u:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
+    Libcrux.Kem.Kyber.Matrix.compute_vector_u #p v_K v_A_transpose r_as_ntt error_1_
+  in
+  let message_as_ring_element:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+    Libcrux.Kem.Kyber.Serialize.deserialize_then_decompress_message message
+  in
+  let v:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+    Libcrux.Kem.Kyber.Matrix.compute_ring_element_v #p v_K
+      tt_as_ntt
+      r_as_ntt
+      error_2_
+      message_as_ring_element
+  in
+  let c1:t_Array u8 v_C1_LEN =
+    compress_then_serialize_u #p v_K v_C1_LEN v_U_COMPRESSION_FACTOR v_BLOCK_LEN u
+  in
+  let c2:t_Array u8 v_C2_LEN =
+    Libcrux.Kem.Kyber.Serialize.compress_then_serialize_ring_element_v #p v_V_COMPRESSION_FACTOR
+      v_C2_LEN
+      v
+  in
+  assert (v_C1_LEN = Spec.Kyber.v_C1_SIZE p);
+  assert (v_C2_LEN = Spec.Kyber.v_C2_SIZE p);
+  assert (v_CIPHERTEXT_SIZE == v_C1_LEN +! v_C2_LEN);
+  assert (v_C1_LEN <=. v_CIPHERTEXT_SIZE);
+  let (ciphertext: t_Array u8 v_CIPHERTEXT_SIZE):t_Array u8 v_CIPHERTEXT_SIZE =
+    into_padded_array v_CIPHERTEXT_SIZE (Rust_primitives.unsize c1 <: t_Slice u8)
+  in
+  let ciphertext:t_Array u8 v_CIPHERTEXT_SIZE =
+    Rust_primitives.Hax.Monomorphized_update_at.update_at_range_from ciphertext
+      ({ Core.Ops.Range.f_start = v_C1_LEN } <: Core.Ops.Range.t_RangeFrom usize)
+      (Core.Slice.impl__copy_from_slice (ciphertext.[ { Core.Ops.Range.f_start = v_C1_LEN }
+              <:
+              Core.Ops.Range.t_RangeFrom usize ]
             <:
-            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
+            t_Slice u8)
+          (Core.Array.impl_23__as_slice v_C2_LEN c2 <: t_Slice u8)
         <:
-        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
-      secret_as_ntt
-      (fun secret_as_ntt temp_1_ ->
-          let secret_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-            secret_as_ntt
-          in
-          let i, secret_bytes:(usize & t_Slice u8) = temp_1_ in
-          Rust_primitives.Hax.Monomorphized_update_at.update_at_usize secret_as_ntt
-            i
-            (Libcrux.Kem.Kyber.Serialize.deserialize_to_uncompressed_ring_element secret_bytes
-              <:
-              Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-          <:
-          t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+        t_Slice u8)
   in
-  secret_as_ntt
-
-let decrypt
-      (v_K v_CIPHERTEXT_SIZE v_VECTOR_U_ENCODED_SIZE v_U_COMPRESSION_FACTOR v_V_COMPRESSION_FACTOR:
-          usize)
-      (secret_key: t_Slice u8)
-      (ciphertext: t_Array u8 v_CIPHERTEXT_SIZE)
-     =
-  let secret_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-    deserialize_secret_key v_K secret_key
-  in
-  decrypt_unpacked v_K
-    v_CIPHERTEXT_SIZE
-    v_VECTOR_U_ENCODED_SIZE
-    v_U_COMPRESSION_FACTOR
-    v_V_COMPRESSION_FACTOR
-    secret_as_ntt
-    ciphertext
+  lemma_slice_append ciphertext c1 c2;
+  ciphertext
+#pop-options
 
-let serialize_secret_key
+let serialize_secret_key (#p:Spec.Kyber.params)
       (v_K v_OUT_LEN: usize)
-      (key: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-     =
+      (key: t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) =
   let out:t_Array u8 v_OUT_LEN = Rust_primitives.Hax.repeat 0uy v_OUT_LEN in
+  let orig_out = out in
+  let acc_t = t_Array u8 v_OUT_LEN in
+  [@ inline_let]
+  let inv = fun (acc:acc_t) (i:usize) -> True in
   let out:t_Array u8 v_OUT_LEN =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Iter.Adapters.Enumerate.t_Enumerate
-            (Core.Array.Iter.t_IntoIter Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K))
-          (Core.Iter.Traits.Iterator.f_enumerate #(Core.Array.Iter.t_IntoIter
-                  Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-              (Core.Iter.Traits.Collect.f_into_iter #(t_Array
-                      Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-                  key
-                <:
-                Core.Array.Iter.t_IntoIter Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-            <:
-            Core.Iter.Adapters.Enumerate.t_Enumerate
-            (Core.Array.Iter.t_IntoIter Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K))
-        <:
-        Core.Iter.Adapters.Enumerate.t_Enumerate
-        (Core.Array.Iter.t_IntoIter Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K))
+    Rust_primitives.Iterators.foldi_slice #Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement  #acc_t #inv
+      key
       out
       (fun out temp_1_ ->
           let out:t_Array u8 v_OUT_LEN = out in
-          let i, re:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) = temp_1_ in
+          let i, re:(usize & Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement) = temp_1_ in
           Rust_primitives.Hax.Monomorphized_update_at.update_at_range out
             ({
                 Core.Ops.Range.f_start
@@ -468,8 +492,7 @@
               }
               <:
               Core.Ops.Range.t_Range usize)
-            (Core.Slice.impl__copy_from_slice #u8
-                (out.[ {
+            (Core.Slice.impl__copy_from_slice (out.[ {
                       Core.Ops.Range.f_start
                       =
                       i *! Libcrux.Kem.Kyber.Constants.v_BYTES_PER_RING_ELEMENT <: usize;
@@ -494,13 +517,14 @@
           <:
           t_Array u8 v_OUT_LEN)
   in
+  admit(); //P-F
   out
 
-let serialize_public_key
+
+let serialize_public_key (#p:Spec.Kyber.params)
       (v_K v_RANKED_BYTES_PER_RING_ELEMENT v_PUBLIC_KEY_SIZE: usize)
-      (tt_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-      (seed_for_a: t_Slice u8)
-     =
+      (tt_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
+      (seed_for_a: t_Slice u8) =
   let public_key_serialized:t_Array u8 v_PUBLIC_KEY_SIZE =
     Rust_primitives.Hax.repeat 0uy v_PUBLIC_KEY_SIZE
   in
@@ -509,8 +533,7 @@
       ({ Core.Ops.Range.f_start = sz 0; Core.Ops.Range.f_end = v_RANKED_BYTES_PER_RING_ELEMENT }
         <:
         Core.Ops.Range.t_Range usize)
-      (Core.Slice.impl__copy_from_slice #u8
-          (public_key_serialized.[ {
+      (Core.Slice.impl__copy_from_slice (public_key_serialized.[ {
                 Core.Ops.Range.f_start = sz 0;
                 Core.Ops.Range.f_end = v_RANKED_BYTES_PER_RING_ELEMENT
               }
@@ -518,7 +541,7 @@
               Core.Ops.Range.t_Range usize ]
             <:
             t_Slice u8)
-          (Rust_primitives.unsize (serialize_secret_key v_K
+          (Rust_primitives.unsize (serialize_secret_key #p v_K
                   v_RANKED_BYTES_PER_RING_ELEMENT
                   tt_as_ntt
                 <:
@@ -533,8 +556,9 @@
       ({ Core.Ops.Range.f_start = v_RANKED_BYTES_PER_RING_ELEMENT }
         <:
         Core.Ops.Range.t_RangeFrom usize)
-      (Core.Slice.impl__copy_from_slice #u8
-          (public_key_serialized.[ { Core.Ops.Range.f_start = v_RANKED_BYTES_PER_RING_ELEMENT }
+      (Core.Slice.impl__copy_from_slice (public_key_serialized.[ {
+                Core.Ops.Range.f_start = v_RANKED_BYTES_PER_RING_ELEMENT
+              }
               <:
               Core.Ops.Range.t_RangeFrom usize ]
             <:
@@ -543,231 +567,49 @@
         <:
         t_Slice u8)
   in
+  lemma_slice_append public_key_serialized
+    (Spec.Kyber.vector_encode_12 (Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p tt_as_ntt))
+    seed_for_a;
   public_key_serialized
 
-let generate_keypair_unpacked
-      (v_K v_PUBLIC_KEY_SIZE v_RANKED_BYTES_PER_RING_ELEMENT v_ETA1 v_ETA1_RANDOMNESS_SIZE: usize)
-      (key_generation_seed: t_Slice u8)
-     =
+
+let generate_keypair #p
+      (v_K v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE v_RANKED_BYTES_PER_RING_ELEMENT v_ETA1 v_ETA1_RANDOMNESS_SIZE:
+          usize)
+      (key_generation_seed: t_Slice u8) =
   let hashed:t_Array u8 (sz 64) = Libcrux.Kem.Kyber.Hash_functions.v_G key_generation_seed in
   let seed_for_A, seed_for_secret_and_error:(t_Slice u8 & t_Slice u8) =
-    Core.Slice.impl__split_at #u8 (Rust_primitives.unsize hashed <: t_Slice u8) (sz 32)
+    Core.Slice.impl__split_at (Rust_primitives.unsize hashed <: t_Slice u8) (sz 32)
   in
-  let a_transpose:t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K =
-    Libcrux.Kem.Kyber.Matrix.sample_matrix_A v_K
+  let v_A_transpose:t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) v_K =
+    Libcrux.Kem.Kyber.Matrix.sample_matrix_A #p v_K
       (into_padded_array (sz 34) seed_for_A <: t_Array u8 (sz 34))
       true
   in
   let (prf_input: t_Array u8 (sz 33)):t_Array u8 (sz 33) =
     into_padded_array (sz 33) seed_for_secret_and_error
   in
-  let secret_as_ntt, domain_separator:(t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+  let secret_as_ntt, domain_separator:(t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
       v_K &
     u8) =
-    sample_vector_cbd_then_ntt v_K v_ETA1 v_ETA1_RANDOMNESS_SIZE prf_input 0uy
+    sample_vector_cbd_then_ntt #p v_K v_ETA1 v_ETA1_RANDOMNESS_SIZE prf_input 0uy
   in
-  let error_as_ntt, _:(t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K & u8) =
-    sample_vector_cbd_then_ntt v_K v_ETA1 v_ETA1_RANDOMNESS_SIZE prf_input domain_separator
+  let error_as_ntt, _:(t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K & u8) =
+    sample_vector_cbd_then_ntt #p v_K v_ETA1 v_ETA1_RANDOMNESS_SIZE prf_input domain_separator
   in
-  let tt_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-    Libcrux.Kem.Kyber.Matrix.compute_As_plus_e v_K a_transpose secret_as_ntt error_as_ntt
+  let tt_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
+    Libcrux.Kem.Kyber.Matrix.compute_As_plus_e #p v_K v_A_transpose secret_as_ntt error_as_ntt
   in
   let public_key_serialized:t_Array u8 v_PUBLIC_KEY_SIZE =
-    serialize_public_key v_K v_RANKED_BYTES_PER_RING_ELEMENT v_PUBLIC_KEY_SIZE tt_as_ntt seed_for_A
-  in
-  let secret_as_ntt, tt_as_ntt:(t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-    t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-            usize)
-          ({ Core.Ops.Range.f_start = sz 0; Core.Ops.Range.f_end = v_K }
-            <:
-            Core.Ops.Range.t_Range usize)
-        <:
-        Core.Ops.Range.t_Range usize)
-      (secret_as_ntt, tt_as_ntt
-        <:
-        (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-          t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K))
-      (fun temp_0_ i ->
-          let secret_as_ntt, tt_as_ntt:(t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
-              v_K &
-            t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) =
-            temp_0_
-          in
-          let i:usize = i in
-          Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-                  usize)
-                ({
-                    Core.Ops.Range.f_start = sz 0;
-                    Core.Ops.Range.f_end
-                    =
-                    Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
-                  }
-                  <:
-                  Core.Ops.Range.t_Range usize)
-              <:
-              Core.Ops.Range.t_Range usize)
-            (secret_as_ntt, tt_as_ntt
-              <:
-              (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-                t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K))
-            (fun temp_0_ j ->
-                let secret_as_ntt, tt_as_ntt:(t_Array
-                    Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-                  t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) =
-                  temp_0_
-                in
-                let j:usize = j in
-                let secret_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-                  Rust_primitives.Hax.Monomorphized_update_at.update_at_usize secret_as_ntt
-                    i
-                    ({
-                        (secret_as_ntt.[ i ] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
-                        ) with
-                        Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                        =
-                        Rust_primitives.Hax.Monomorphized_update_at.update_at_usize (secret_as_ntt.[
-                              i ]
-                            <:
-                            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-                            .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                          j
-                          (cast (Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative ((secret_as_ntt.[
-                                        i ]
-                                      <:
-                                      Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-                                      .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ]
-                                    <:
-                                    i32)
-                                <:
-                                u16)
-                            <:
-                            i32)
-                        <:
-                        t_Array i32 (sz 256)
-                      }
-                      <:
-                      Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-                in
-                let tt_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-                  Rust_primitives.Hax.Monomorphized_update_at.update_at_usize tt_as_ntt
-                    i
-                    ({
-                        (tt_as_ntt.[ i ] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) with
-                        Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                        =
-                        Rust_primitives.Hax.Monomorphized_update_at.update_at_usize (tt_as_ntt.[ i ]
-                            <:
-                            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-                            .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                          j
-                          (cast (Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative ((tt_as_ntt.[
-                                        i ]
-                                      <:
-                                      Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-                                      .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ]
-                                    <:
-                                    i32)
-                                <:
-                                u16)
-                            <:
-                            i32)
-                        <:
-                        t_Array i32 (sz 256)
-                      }
-                      <:
-                      Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-                in
-                secret_as_ntt, tt_as_ntt
-                <:
-                (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-                  t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K))
-          <:
-          (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-            t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K))
-  in
-  let a_matrix:t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K =
-    a_transpose
-  in
-  let a_matrix:t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-            usize)
-          ({ Core.Ops.Range.f_start = sz 0; Core.Ops.Range.f_end = v_K }
-            <:
-            Core.Ops.Range.t_Range usize)
-        <:
-        Core.Ops.Range.t_Range usize)
-      a_matrix
-      (fun a_matrix i ->
-          let a_matrix:t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-            v_K =
-            a_matrix
-          in
-          let i:usize = i in
-          Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-                  usize)
-                ({ Core.Ops.Range.f_start = sz 0; Core.Ops.Range.f_end = v_K }
-                  <:
-                  Core.Ops.Range.t_Range usize)
-              <:
-              Core.Ops.Range.t_Range usize)
-            a_matrix
-            (fun a_matrix j ->
-                let a_matrix:t_Array
-                  (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K =
-                  a_matrix
-                in
-                let j:usize = j in
-                Rust_primitives.Hax.Monomorphized_update_at.update_at_usize a_matrix
-                  i
-                  (Rust_primitives.Hax.Monomorphized_update_at.update_at_usize (a_matrix.[ i ]
-                        <:
-                        t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-                      j
-                      ((a_transpose.[ j ]
-                          <:
-                          t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K).[ i ]
-                        <:
-                        Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-                    <:
-                    t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-                <:
-                t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K)
-          <:
-          t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K)
-  in
-  (secret_as_ntt, tt_as_ntt, a_matrix
-    <:
-    (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-      t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-      t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K)),
-  public_key_serialized
-  <:
-  ((t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-      t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-      t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K) &
-    t_Array u8 v_PUBLIC_KEY_SIZE)
-
-let generate_keypair
-      (v_K v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE v_RANKED_BYTES_PER_RING_ELEMENT v_ETA1 v_ETA1_RANDOMNESS_SIZE:
-          usize)
-      (key_generation_seed: t_Slice u8)
-     =
-  let (secret_as_ntt, v__t_as_ntt, v__a_transpose), public_key_serialized:((t_Array
-        Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-      t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-      t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K) &
-    t_Array u8 v_PUBLIC_KEY_SIZE) =
-    generate_keypair_unpacked v_K
-      v_PUBLIC_KEY_SIZE
-      v_RANKED_BYTES_PER_RING_ELEMENT
-      v_ETA1
-      v_ETA1_RANDOMNESS_SIZE
-      key_generation_seed
+    serialize_public_key #p v_K v_RANKED_BYTES_PER_RING_ELEMENT v_PUBLIC_KEY_SIZE tt_as_ntt seed_for_A
   in
   let secret_key_serialized:t_Array u8 v_PRIVATE_KEY_SIZE =
-    serialize_secret_key v_K v_PRIVATE_KEY_SIZE secret_as_ntt
+    serialize_secret_key #p v_K v_PRIVATE_KEY_SIZE secret_as_ntt
   in
+  let res = 
   secret_key_serialized, public_key_serialized
   <:
   (t_Array u8 v_PRIVATE_KEY_SIZE & t_Array u8 v_PUBLIC_KEY_SIZE)
+  in
+  res
+ 
diff -ruN extraction/Libcrux.Kem.Kyber.Ind_cpa.fsti extraction-edited/Libcrux.Kem.Kyber.Ind_cpa.fsti
--- extraction/Libcrux.Kem.Kyber.Ind_cpa.fsti	2024-05-16 17:05:53.697569684 +0200
+++ extraction-edited/Libcrux.Kem.Kyber.Ind_cpa.fsti	2024-05-16 17:05:53.789566598 +0200
@@ -1,196 +1,151 @@
 module Libcrux.Kem.Kyber.Ind_cpa
-#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
+#set-options "--fuel 0 --ifuel 1 --z3rlimit 100"
 open Core
 open FStar.Mul
 
-/// Pad the `slice` with `0`s at the end.
-val into_padded_array (v_LEN: usize) (slice: t_Slice u8)
-    : Prims.Pure (t_Array u8 v_LEN) Prims.l_True (fun _ -> Prims.l_True)
+val into_padded_array (v_LEN: usize) (slice: t_Slice u8) :
+    Pure (t_Array u8 v_LEN)
+    (requires (length slice <=. v_LEN))
+    (ensures (fun res ->  Seq.slice res 0 (Seq.length slice) == slice))
 
-/// Sample a vector of ring elements from a centered binomial distribution.
-val sample_ring_element_cbd
+val sample_vector_cbd (#p:Spec.Kyber.params)
       (v_K v_ETA2_RANDOMNESS_SIZE v_ETA2: usize)
       (prf_input: t_Array u8 (sz 33))
       (domain_separator: u8)
-    : Prims.Pure
-      (t_Array u8 (sz 33) & u8 & t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-      Prims.l_True
-      (fun _ -> Prims.l_True)
-
-/// Sample a vector of ring elements from a centered binomial distribution and
-/// convert them into their NTT representations.
-val sample_vector_cbd_then_ntt
+    : Pure (t_Array u8 (sz 33) & u8 & t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
+      (requires v domain_separator <= v v_K /\ v_K <=. sz 4 /\
+                v_K = p.v_RANK /\ v_ETA2 = p.v_ETA2 /\
+                v_ETA2_RANDOMNESS_SIZE = Spec.Kyber.v_ETA2_RANDOMNESS_SIZE p)
+      (ensures (fun (prf,ds,x) -> v ds == v domain_separator + v v_K /\
+                Seq.slice prf 0 32 == Seq.slice prf_input 0 32 /\
+                Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p x ==
+                Spec.Kyber.sample_vector_cbd #p (Seq.slice prf_input 0 32) (sz (v domain_separator))))
+
+
+val sample_vector_cbd_then_ntt (#p:Spec.Kyber.params)
       (v_K v_ETA v_ETA_RANDOMNESS_SIZE: usize)
       (prf_input: t_Array u8 (sz 33))
-      (domain_separator: u8)
-    : Prims.Pure (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K & u8)
-      Prims.l_True
-      (fun _ -> Prims.l_True)
+      (domain_separator: u8{v domain_separator <= v v_K /\ v_K <=. sz 4})
+    : Pure (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K & u8) 
+      (requires (v_K == p.v_RANK /\ v_ETA == p.v_ETA1 /\ v_ETA_RANDOMNESS_SIZE == Spec.Kyber.v_ETA1_RANDOMNESS_SIZE p))
+      (ensures (fun (x,ds) -> v ds == v domain_separator + v v_K /\
+                Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p x ==
+                Spec.Kyber.sample_vector_cbd_then_ntt #p (Seq.slice prf_input 0 32) (sz (v domain_separator))))
 
-/// Call [`compress_then_serialize_ring_element_u`] on each ring element.
-val compress_then_serialize_u
+val compress_then_serialize_u (#p:Spec.Kyber.params)
       (v_K v_OUT_LEN v_COMPRESSION_FACTOR v_BLOCK_LEN: usize)
-      (input: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-    : Prims.Pure (t_Array u8 v_OUT_LEN) Prims.l_True (fun _ -> Prims.l_True)
-
-/// This function implements <strong>Algorithm 13</strong> of the
-/// NIST FIPS 203 specification; this is the Kyber CPA-PKE encryption algorithm.
-/// Algorithm 13 is reproduced below:
-/// ```plaintext
-/// Input: encryption key ekₚₖₑ ∈ 𝔹^{384k+32}.
-/// Input: message m ∈ 𝔹^{32}.
-/// Input: encryption randomness r ∈ 𝔹^{32}.
-/// Output: ciphertext c ∈ 𝔹^{32(dᵤk + dᵥ)}.
-/// N ← 0
-/// t̂ ← ByteDecode₁₂(ekₚₖₑ[0:384k])
-/// ρ ← ekₚₖₑ[384k: 384k + 32]
-/// for (i ← 0; i < k; i++)
-///     for(j ← 0; j < k; j++)
-///         Â[i,j] ← SampleNTT(XOF(ρ, i, j))
-///     end for
-/// end for
-/// for(i ← 0; i < k; i++)
-///     r[i] ← SamplePolyCBD_{η₁}(PRF_{η₁}(r,N))
-///     N ← N + 1
-/// end for
-/// for(i ← 0; i < k; i++)
-///     e₁[i] ← SamplePolyCBD_{η₂}(PRF_{η₂}(r,N))
-///     N ← N + 1
-/// end for
-/// e₂ ← SamplePolyCBD_{η₂}(PRF_{η₂}(r,N))
-/// r̂ ← NTT(r)
-/// u ← NTT-¹(Âᵀ ◦ r̂) + e₁
-/// μ ← Decompress₁(ByteDecode₁(m)))
-/// v ← NTT-¹(t̂ᵀ ◦ rˆ) + e₂ + μ
-/// c₁ ← ByteEncode_{dᵤ}(Compress_{dᵤ}(u))
-/// c₂ ← ByteEncode_{dᵥ}(Compress_{dᵥ}(v))
-/// return c ← (c₁ ‖ c₂)
-/// ```
-/// The NIST FIPS 203 standard can be found at
-/// <https://csrc.nist.gov/pubs/fips/203/ipd>.
-val encrypt_unpacked
-      (v_K v_CIPHERTEXT_SIZE v_T_AS_NTT_ENCODED_SIZE v_C1_LEN v_C2_LEN v_U_COMPRESSION_FACTOR v_V_COMPRESSION_FACTOR v_BLOCK_LEN v_ETA1 v_ETA1_RANDOMNESS_SIZE v_ETA2 v_ETA2_RANDOMNESS_SIZE:
-          usize)
-      (tt_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-      (a_transpose: t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K)
-      (message: t_Array u8 (sz 32))
-      (randomness: t_Slice u8)
-    : Prims.Pure (t_Array u8 v_CIPHERTEXT_SIZE) Prims.l_True (fun _ -> Prims.l_True)
+      (input: t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
+    : Pure (t_Array u8 v_OUT_LEN)
+      (requires (v_K == p.v_RANK /\ v_OUT_LEN == Spec.Kyber.v_C1_SIZE p /\
+                 v_COMPRESSION_FACTOR == p.v_VECTOR_U_COMPRESSION_FACTOR /\
+                 v_BLOCK_LEN = Spec.Kyber.v_C1_BLOCK_SIZE p))
+      (ensures (fun res -> 
+        res == Spec.Kyber.compress_then_encode_u p 
+               (Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p input)))
 
-/// Call [`deserialize_then_decompress_ring_element_u`] on each ring element
-/// in the `ciphertext`.
-val deserialize_then_decompress_u
-      (v_K v_CIPHERTEXT_SIZE v_U_COMPRESSION_FACTOR: usize)
+val deserialize_then_decompress_u (#p:Spec.Kyber.params)
+      (v_K v_CIPHERTEXT_SIZE v_VECTOR_U_ENCODED_SIZE v_U_COMPRESSION_FACTOR: usize)
       (ciphertext: t_Array u8 v_CIPHERTEXT_SIZE)
-    : Prims.Pure (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-      Prims.l_True
-      (fun _ -> Prims.l_True)
-
-/// This function implements <strong>Algorithm 14</strong> of the
-/// NIST FIPS 203 specification; this is the Kyber CPA-PKE decryption algorithm.
-/// Algorithm 14 is reproduced below:
-/// ```plaintext
-/// Input: decryption key dkₚₖₑ ∈ 𝔹^{384k}.
-/// Input: ciphertext c ∈ 𝔹^{32(dᵤk + dᵥ)}.
-/// Output: message m ∈ 𝔹^{32}.
-/// c₁ ← c[0 : 32dᵤk]
-/// c₂ ← c[32dᵤk : 32(dᵤk + dᵥ)]
-/// u ← Decompress_{dᵤ}(ByteDecode_{dᵤ}(c₁))
-/// v ← Decompress_{dᵥ}(ByteDecode_{dᵥ}(c₂))
-/// ŝ ← ByteDecode₁₂(dkₚₖₑ)
-/// w ← v - NTT-¹(ŝᵀ ◦ NTT(u))
-/// m ← ByteEncode₁(Compress₁(w))
-/// return m
-/// ```
-/// The NIST FIPS 203 standard can be found at
-/// <https://csrc.nist.gov/pubs/fips/203/ipd>.
-val decrypt_unpacked
+    : Pure (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) 
+      (requires v_K == p.v_RANK /\
+                v_CIPHERTEXT_SIZE == Spec.Kyber.v_CPA_PKE_CIPHERTEXT_SIZE p /\
+                v_VECTOR_U_ENCODED_SIZE == Spec.Kyber.v_C1_SIZE p /\
+                v_U_COMPRESSION_FACTOR == p.v_VECTOR_U_COMPRESSION_FACTOR)
+      (ensures fun res ->
+        Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p res ==
+        Spec.Kyber.(vector_ntt (decode_then_decompress_u p (Seq.slice ciphertext 0 (v (Spec.Kyber.v_C1_SIZE p))))))
+
+val deserialize_public_key (#p:Spec.Kyber.params) 
+    (v_K: usize) (public_key: t_Array u8 (Spec.Kyber.v_T_AS_NTT_ENCODED_SIZE p))
+    : Pure (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
+      (requires v_K == p.v_RANK /\
+                length public_key == Spec.Kyber.v_RANKED_BYTES_PER_RING_ELEMENT p)
+      (ensures fun res -> 
+        Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b res ==
+        Spec.Kyber.vector_decode_12 #p public_key)
+   
+val deserialize_secret_key (#p:Spec.Kyber.params) (v_K: usize) (secret_key: t_Slice u8)
+    : Pure (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
+      (requires v_K == p.v_RANK /\
+                length secret_key == Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p)
+      (ensures fun res ->
+         Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p res ==
+         Spec.Kyber.vector_decode_12 #p secret_key)
+    
+
+val decrypt (#p:Spec.Kyber.params)
       (v_K v_CIPHERTEXT_SIZE v_VECTOR_U_ENCODED_SIZE v_U_COMPRESSION_FACTOR v_V_COMPRESSION_FACTOR:
           usize)
-      (secret_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+      (secret_key: t_Slice u8)
       (ciphertext: t_Array u8 v_CIPHERTEXT_SIZE)
-    : Prims.Pure (t_Array u8 (sz 32)) Prims.l_True (fun _ -> Prims.l_True)
+    : Pure (t_Array u8 (sz 32))
+      (requires (v_K == p.v_RANK /\
+                 length secret_key == Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p /\
+                 v_CIPHERTEXT_SIZE == Spec.Kyber.v_CPA_PKE_CIPHERTEXT_SIZE p /\
+                 v_VECTOR_U_ENCODED_SIZE == Spec.Kyber.v_C1_SIZE p /\
+                 v_U_COMPRESSION_FACTOR == p.v_VECTOR_U_COMPRESSION_FACTOR /\
+                 v_V_COMPRESSION_FACTOR == p.v_VECTOR_V_COMPRESSION_FACTOR))
+      (ensures (fun res ->
+                res == Spec.Kyber.ind_cpa_decrypt p secret_key ciphertext))
+
 
-val encrypt
+val encrypt (#p:Spec.Kyber.params)
       (v_K v_CIPHERTEXT_SIZE v_T_AS_NTT_ENCODED_SIZE v_C1_LEN v_C2_LEN v_U_COMPRESSION_FACTOR v_V_COMPRESSION_FACTOR v_BLOCK_LEN v_ETA1 v_ETA1_RANDOMNESS_SIZE v_ETA2 v_ETA2_RANDOMNESS_SIZE:
           usize)
       (public_key: t_Slice u8)
       (message: t_Array u8 (sz 32))
-      (randomness: t_Slice u8)
-    : Prims.Pure (t_Array u8 v_CIPHERTEXT_SIZE) Prims.l_True (fun _ -> Prims.l_True)
-
-/// Call [`deserialize_to_uncompressed_ring_element`] for each ring element.
-val deserialize_secret_key (v_K: usize) (secret_key: t_Slice u8)
-    : Prims.Pure (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-      Prims.l_True
-      (fun _ -> Prims.l_True)
-
-val decrypt
-      (v_K v_CIPHERTEXT_SIZE v_VECTOR_U_ENCODED_SIZE v_U_COMPRESSION_FACTOR v_V_COMPRESSION_FACTOR:
-          usize)
-      (secret_key: t_Slice u8)
-      (ciphertext: t_Array u8 v_CIPHERTEXT_SIZE)
-    : Prims.Pure (t_Array u8 (sz 32)) Prims.l_True (fun _ -> Prims.l_True)
-
-/// Call [`serialize_uncompressed_ring_element`] for each ring element.
-val serialize_secret_key
+      (randomness: t_Slice u8{length randomness <. sz 33})
+    : Pure (t_Array u8 v_CIPHERTEXT_SIZE)
+      (requires (v_K == p.v_RANK /\
+                 v_ETA1 = p.v_ETA1 /\
+                 v_ETA1_RANDOMNESS_SIZE = Spec.Kyber.v_ETA1_RANDOMNESS_SIZE p /\
+                 v_ETA2 = p.v_ETA2 /\
+                 v_BLOCK_LEN == Spec.Kyber.v_C1_BLOCK_SIZE p /\
+                 v_ETA2_RANDOMNESS_SIZE = Spec.Kyber.v_ETA2_RANDOMNESS_SIZE p /\
+                 v_U_COMPRESSION_FACTOR == p.v_VECTOR_U_COMPRESSION_FACTOR /\
+                 v_V_COMPRESSION_FACTOR == p.v_VECTOR_V_COMPRESSION_FACTOR /\
+                 length public_key == Spec.Kyber.v_CPA_PKE_PUBLIC_KEY_SIZE p /\
+                 length randomness == Spec.Kyber.v_SHARED_SECRET_SIZE /\
+                 v_CIPHERTEXT_SIZE == Spec.Kyber.v_CPA_PKE_CIPHERTEXT_SIZE p /\
+                 v_T_AS_NTT_ENCODED_SIZE == Spec.Kyber.v_T_AS_NTT_ENCODED_SIZE p /\
+                 v_C1_LEN == Spec.Kyber.v_C1_SIZE p /\
+                 v_C2_LEN == Spec.Kyber.v_C2_SIZE p))
+      (ensures (fun ct -> ct == Spec.Kyber.ind_cpa_encrypt p public_key message randomness))
+               
+val serialize_secret_key (#p:Spec.Kyber.params)
       (v_K v_OUT_LEN: usize)
-      (key: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-    : Prims.Pure (t_Array u8 v_OUT_LEN) Prims.l_True (fun _ -> Prims.l_True)
-
-/// Concatenate `t` and `ρ` into the public key.
-val serialize_public_key
+      (key: t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
+    : Pure (t_Array u8 v_OUT_LEN)
+      (requires (v_K == p.v_RANK /\ v_OUT_LEN == Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p))
+      (ensures (fun res -> 
+        res == Spec.Kyber.vector_encode_12 #p 
+          (Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p key)))
+      
+val serialize_public_key (#p:Spec.Kyber.params)
       (v_K v_RANKED_BYTES_PER_RING_ELEMENT v_PUBLIC_KEY_SIZE: usize)
-      (tt_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+      (tt_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
       (seed_for_a: t_Slice u8)
-    : Prims.Pure (t_Array u8 v_PUBLIC_KEY_SIZE) Prims.l_True (fun _ -> Prims.l_True)
-
-/// This function implements most of <strong>Algorithm 12</strong> of the
-/// NIST FIPS 203 specification; this is the Kyber CPA-PKE key generation algorithm.
-/// We say "most of" since Algorithm 12 samples the required randomness within
-/// the function itself, whereas this implementation expects it to be provided
-/// through the `key_generation_seed` parameter.
-/// Algorithm 12 is reproduced below:
-/// ```plaintext
-/// Output: encryption key ekₚₖₑ ∈ 𝔹^{384k+32}.
-/// Output: decryption key dkₚₖₑ ∈ 𝔹^{384k}.
-/// d ←$ B
-/// (ρ,σ) ← G(d)
-/// N ← 0
-/// for (i ← 0; i < k; i++)
-///     for(j ← 0; j < k; j++)
-///         Â[i,j] ← SampleNTT(XOF(ρ, i, j))
-///     end for
-/// end for
-/// for(i ← 0; i < k; i++)
-///     s[i] ← SamplePolyCBD_{η₁}(PRF_{η₁}(σ,N))
-///     N ← N + 1
-/// end for
-/// for(i ← 0; i < k; i++)
-///     e[i] ← SamplePolyCBD_{η₂}(PRF_{η₂}(σ,N))
-///     N ← N + 1
-/// end for
-/// ŝ ← NTT(s)
-/// ê ← NTT(e)
-/// t̂ ← Â◦ŝ + ê
-/// ekₚₖₑ ← ByteEncode₁₂(t̂) ‖ ρ
-/// dkₚₖₑ ← ByteEncode₁₂(ŝ)
-/// ```
-/// The NIST FIPS 203 standard can be found at
-/// <https://csrc.nist.gov/pubs/fips/203/ipd>.
-val generate_keypair_unpacked
-      (v_K v_PUBLIC_KEY_SIZE v_RANKED_BYTES_PER_RING_ELEMENT v_ETA1 v_ETA1_RANDOMNESS_SIZE: usize)
-      (key_generation_seed: t_Slice u8)
-    : Prims.Pure
-      ((t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-          t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-          t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K) &
-        t_Array u8 v_PUBLIC_KEY_SIZE) Prims.l_True (fun _ -> Prims.l_True)
+      : Pure (t_Array u8 v_PUBLIC_KEY_SIZE)
+        (requires (v_K == p.v_RANK /\
+                   v_RANKED_BYTES_PER_RING_ELEMENT == Spec.Kyber.v_RANKED_BYTES_PER_RING_ELEMENT p /\
+                   v_PUBLIC_KEY_SIZE == Spec.Kyber.v_CPA_PKE_PUBLIC_KEY_SIZE p /\
+                   length seed_for_a == sz 32))
+        (ensures (fun res -> res == Seq.append (Spec.Kyber.vector_encode_12 
+                              (Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p tt_as_ntt))
+                            seed_for_a))
 
-val generate_keypair
+val generate_keypair (#p:Spec.Kyber.params)
       (v_K v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE v_RANKED_BYTES_PER_RING_ELEMENT v_ETA1 v_ETA1_RANDOMNESS_SIZE:
           usize)
       (key_generation_seed: t_Slice u8)
-    : Prims.Pure (t_Array u8 v_PRIVATE_KEY_SIZE & t_Array u8 v_PUBLIC_KEY_SIZE)
-      Prims.l_True
-      (fun _ -> Prims.l_True)
+    : Pure (t_Array u8 v_PRIVATE_KEY_SIZE & t_Array u8 v_PUBLIC_KEY_SIZE)
+      (requires (v_K == p.v_RANK /\
+                 v_ETA1 == p.v_ETA1 /\
+                 v_ETA1_RANDOMNESS_SIZE == Spec.Kyber.v_ETA1_RANDOMNESS_SIZE p /\
+                 v_PUBLIC_KEY_SIZE == Spec.Kyber.v_CPA_PKE_PUBLIC_KEY_SIZE p /\
+                 v_PRIVATE_KEY_SIZE == Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p /\
+                 v_RANKED_BYTES_PER_RING_ELEMENT == Spec.Kyber.v_RANKED_BYTES_PER_RING_ELEMENT p /\
+                 length key_generation_seed == Spec.Kyber.v_CPA_PKE_KEY_GENERATION_SEED_SIZE))
+      (ensures (fun (sk,pk) -> (sk,pk) == Spec.Kyber.ind_cpa_generate_keypair p key_generation_seed))
+ 
+    
diff -ruN extraction/Libcrux.Kem.Kyber.Kyber1024.fst extraction-edited/Libcrux.Kem.Kyber.Kyber1024.fst
--- extraction/Libcrux.Kem.Kyber.Kyber1024.fst	2024-05-16 17:05:53.703569483 +0200
+++ extraction-edited/Libcrux.Kem.Kyber.Kyber1024.fst	2024-05-16 17:05:53.776567034 +0200
@@ -7,19 +7,19 @@
       (secret_key: Libcrux.Kem.Kyber.Types.t_MlKemPrivateKey (sz 3168))
       (ciphertext: Libcrux.Kem.Kyber.Types.t_MlKemCiphertext (sz 1568))
      =
-  Libcrux.Kem.Kyber.decapsulate (sz 4) (sz 3168) (sz 1536) (sz 1568) (sz 1568) (sz 1536) (sz 1408)
+  Libcrux.Kem.Kyber.decapsulate #Spec.Kyber.kyber1024_params (sz 4) (sz 3168) (sz 1536) (sz 1568) (sz 1568) (sz 1536) (sz 1408)
     (sz 160) (sz 11) (sz 5) (sz 352) (sz 2) (sz 128) (sz 2) (sz 128) (sz 1600) secret_key ciphertext
 
 let encapsulate
       (public_key: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1568))
       (randomness: t_Array u8 (sz 32))
      =
-  Libcrux.Kem.Kyber.encapsulate (sz 4) (sz 1568) (sz 1568) (sz 1536) (sz 1408) (sz 160) (sz 11)
+  Libcrux.Kem.Kyber.encapsulate #Spec.Kyber.kyber1024_params (sz 4) (sz 1568) (sz 1568) (sz 1536) (sz 1408) (sz 160) (sz 11)
     (sz 5) (sz 352) (sz 2) (sz 128) (sz 2) (sz 128) public_key randomness
 
 let validate_public_key (public_key: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1568)) =
   if
-    Libcrux.Kem.Kyber.validate_public_key (sz 4)
+    Libcrux.Kem.Kyber.validate_public_key #Spec.Kyber.kyber1024_params (sz 4)
       (sz 1536)
       (sz 1568)
       public_key.Libcrux.Kem.Kyber.Types.f_value
@@ -32,26 +32,8 @@
     <:
     Core.Option.t_Option (Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1568))
 
-let decapsulate_unpacked
-      (state: Libcrux.Kem.Kyber.t_MlKemState (sz 4))
-      (ciphertext: Libcrux.Kem.Kyber.Types.t_MlKemCiphertext (sz 1568))
-     =
-  Libcrux.Kem.Kyber.decapsulate_unpacked (sz 4) (sz 3168) (sz 1536) (sz 1568) (sz 1568) (sz 1536)
-    (sz 1408) (sz 160) (sz 11) (sz 5) (sz 352) (sz 2) (sz 128) (sz 2) (sz 128) (sz 1600) state
-    ciphertext
-
 let generate_key_pair (randomness: t_Array u8 (sz 64)) =
-  Libcrux.Kem.Kyber.generate_keypair (sz 4)
-    (sz 1536)
-    (sz 3168)
-    (sz 1568)
-    (sz 1536)
-    (sz 2)
-    (sz 128)
-    randomness
-
-let generate_key_pair_unpacked (randomness: t_Array u8 (sz 64)) =
-  Libcrux.Kem.Kyber.generate_keypair_unpacked (sz 4)
+  Libcrux.Kem.Kyber.generate_keypair #Spec.Kyber.kyber1024_params (sz 4)
     (sz 1536)
     (sz 3168)
     (sz 1568)
diff -ruN extraction/Libcrux.Kem.Kyber.Kyber1024.fsti extraction-edited/Libcrux.Kem.Kyber.Kyber1024.fsti
--- extraction/Libcrux.Kem.Kyber.Kyber1024.fsti	2024-05-16 17:05:53.715569080 +0200
+++ extraction-edited/Libcrux.Kem.Kyber.Kyber1024.fsti	2024-05-16 17:05:53.756567705 +0200
@@ -71,13 +71,11 @@
 unfold
 let t_MlKem1024PublicKey = Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1568)
 
-/// Decapsulate ML-KEM 1024
 val decapsulate
       (secret_key: Libcrux.Kem.Kyber.Types.t_MlKemPrivateKey (sz 3168))
       (ciphertext: Libcrux.Kem.Kyber.Types.t_MlKemCiphertext (sz 1568))
     : Prims.Pure (t_Array u8 (sz 32)) Prims.l_True (fun _ -> Prims.l_True)
 
-/// Encapsulate ML-KEM 1024
 val encapsulate
       (public_key: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1568))
       (randomness: t_Array u8 (sz 32))
@@ -85,29 +83,12 @@
       Prims.l_True
       (fun _ -> Prims.l_True)
 
-/// Validate a public key.
-/// Returns `Some(public_key)` if valid, and `None` otherwise.
 val validate_public_key (public_key: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1568))
     : Prims.Pure (Core.Option.t_Option (Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1568)))
       Prims.l_True
       (fun _ -> Prims.l_True)
 
-unfold
-let t_MlKem1024State = Libcrux.Kem.Kyber.t_MlKemState (sz 4)
-
-val decapsulate_unpacked
-      (state: Libcrux.Kem.Kyber.t_MlKemState (sz 4))
-      (ciphertext: Libcrux.Kem.Kyber.Types.t_MlKemCiphertext (sz 1568))
-    : Prims.Pure (t_Array u8 (sz 32)) Prims.l_True (fun _ -> Prims.l_True)
-
-/// Generate ML-KEM 1024 Key Pair
 val generate_key_pair (randomness: t_Array u8 (sz 64))
     : Prims.Pure (Libcrux.Kem.Kyber.Types.t_MlKemKeyPair (sz 3168) (sz 1568))
       Prims.l_True
       (fun _ -> Prims.l_True)
-
-val generate_key_pair_unpacked (randomness: t_Array u8 (sz 64))
-    : Prims.Pure
-      (Libcrux.Kem.Kyber.t_MlKemState (sz 4) & Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1568))
-      Prims.l_True
-      (fun _ -> Prims.l_True)
diff -ruN extraction/Libcrux.Kem.Kyber.Kyber512.fst extraction-edited/Libcrux.Kem.Kyber.Kyber512.fst
--- extraction/Libcrux.Kem.Kyber.Kyber512.fst	2024-05-16 17:05:53.734568443 +0200
+++ extraction-edited/Libcrux.Kem.Kyber.Kyber512.fst	2024-05-16 17:05:53.741568208 +0200
@@ -7,19 +7,19 @@
       (secret_key: Libcrux.Kem.Kyber.Types.t_MlKemPrivateKey (sz 1632))
       (ciphertext: Libcrux.Kem.Kyber.Types.t_MlKemCiphertext (sz 768))
      =
-  Libcrux.Kem.Kyber.decapsulate (sz 2) (sz 1632) (sz 768) (sz 800) (sz 768) (sz 768) (sz 640)
+  Libcrux.Kem.Kyber.decapsulate #Spec.Kyber.kyber512_params (sz 2) (sz 1632) (sz 768) (sz 800) (sz 768) (sz 768) (sz 640)
     (sz 128) (sz 10) (sz 4) (sz 320) (sz 3) (sz 192) (sz 2) (sz 128) (sz 800) secret_key ciphertext
 
 let encapsulate
       (public_key: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 800))
       (randomness: t_Array u8 (sz 32))
      =
-  Libcrux.Kem.Kyber.encapsulate (sz 2) (sz 768) (sz 800) (sz 768) (sz 640) (sz 128) (sz 10) (sz 4)
+  Libcrux.Kem.Kyber.encapsulate #Spec.Kyber.kyber512_params (sz 2) (sz 768) (sz 800) (sz 768) (sz 640) (sz 128) (sz 10) (sz 4)
     (sz 320) (sz 3) (sz 192) (sz 2) (sz 128) public_key randomness
 
 let validate_public_key (public_key: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 800)) =
   if
-    Libcrux.Kem.Kyber.validate_public_key (sz 2)
+    Libcrux.Kem.Kyber.validate_public_key #Spec.Kyber.kyber512_params (sz 2)
       (sz 768)
       (sz 800)
       public_key.Libcrux.Kem.Kyber.Types.f_value
@@ -32,26 +32,8 @@
     <:
     Core.Option.t_Option (Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 800))
 
-let decapsulate_unpacked
-      (state: Libcrux.Kem.Kyber.t_MlKemState (sz 2))
-      (ciphertext: Libcrux.Kem.Kyber.Types.t_MlKemCiphertext (sz 768))
-     =
-  Libcrux.Kem.Kyber.decapsulate_unpacked (sz 2) (sz 1632) (sz 768) (sz 800) (sz 768) (sz 768)
-    (sz 640) (sz 128) (sz 10) (sz 4) (sz 320) (sz 3) (sz 192) (sz 2) (sz 128) (sz 800) state
-    ciphertext
-
 let generate_key_pair (randomness: t_Array u8 (sz 64)) =
-  Libcrux.Kem.Kyber.generate_keypair (sz 2)
-    (sz 768)
-    (sz 1632)
-    (sz 800)
-    (sz 768)
-    (sz 3)
-    (sz 192)
-    randomness
-
-let generate_key_pair_unpacked (randomness: t_Array u8 (sz 64)) =
-  Libcrux.Kem.Kyber.generate_keypair_unpacked (sz 2)
+  Libcrux.Kem.Kyber.generate_keypair #Spec.Kyber.kyber512_params (sz 2)
     (sz 768)
     (sz 1632)
     (sz 800)
diff -ruN extraction/Libcrux.Kem.Kyber.Kyber512.fsti extraction-edited/Libcrux.Kem.Kyber.Kyber512.fsti
--- extraction/Libcrux.Kem.Kyber.Kyber512.fsti	2024-05-16 17:05:53.706569382 +0200
+++ extraction-edited/Libcrux.Kem.Kyber.Kyber512.fsti	2024-05-16 17:05:53.775567067 +0200
@@ -71,13 +71,11 @@
 unfold
 let t_MlKem512PublicKey = Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 800)
 
-/// Decapsulate ML-KEM 512
 val decapsulate
       (secret_key: Libcrux.Kem.Kyber.Types.t_MlKemPrivateKey (sz 1632))
       (ciphertext: Libcrux.Kem.Kyber.Types.t_MlKemCiphertext (sz 768))
     : Prims.Pure (t_Array u8 (sz 32)) Prims.l_True (fun _ -> Prims.l_True)
 
-/// Encapsulate ML-KEM 512
 val encapsulate
       (public_key: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 800))
       (randomness: t_Array u8 (sz 32))
@@ -85,29 +83,12 @@
       Prims.l_True
       (fun _ -> Prims.l_True)
 
-/// Validate a public key.
-/// Returns `Some(public_key)` if valid, and `None` otherwise.
 val validate_public_key (public_key: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 800))
     : Prims.Pure (Core.Option.t_Option (Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 800)))
       Prims.l_True
       (fun _ -> Prims.l_True)
 
-unfold
-let t_MlKem512State = Libcrux.Kem.Kyber.t_MlKemState (sz 2)
-
-val decapsulate_unpacked
-      (state: Libcrux.Kem.Kyber.t_MlKemState (sz 2))
-      (ciphertext: Libcrux.Kem.Kyber.Types.t_MlKemCiphertext (sz 768))
-    : Prims.Pure (t_Array u8 (sz 32)) Prims.l_True (fun _ -> Prims.l_True)
-
-/// Generate ML-KEM 512 Key Pair
 val generate_key_pair (randomness: t_Array u8 (sz 64))
     : Prims.Pure (Libcrux.Kem.Kyber.Types.t_MlKemKeyPair (sz 1632) (sz 800))
       Prims.l_True
       (fun _ -> Prims.l_True)
-
-val generate_key_pair_unpacked (randomness: t_Array u8 (sz 64))
-    : Prims.Pure
-      (Libcrux.Kem.Kyber.t_MlKemState (sz 2) & Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 800))
-      Prims.l_True
-      (fun _ -> Prims.l_True)
diff -ruN extraction/Libcrux.Kem.Kyber.Kyber768.fst extraction-edited/Libcrux.Kem.Kyber.Kyber768.fst
--- extraction/Libcrux.Kem.Kyber.Kyber768.fst	2024-05-16 17:05:53.731568543 +0200
+++ extraction-edited/Libcrux.Kem.Kyber.Kyber768.fst	2024-05-16 17:05:53.743568141 +0200
@@ -7,19 +7,19 @@
       (secret_key: Libcrux.Kem.Kyber.Types.t_MlKemPrivateKey (sz 2400))
       (ciphertext: Libcrux.Kem.Kyber.Types.t_MlKemCiphertext (sz 1088))
      =
-  Libcrux.Kem.Kyber.decapsulate (sz 3) (sz 2400) (sz 1152) (sz 1184) (sz 1088) (sz 1152) (sz 960)
+    Libcrux.Kem.Kyber.decapsulate #Spec.Kyber.kyber768_params (sz 3) (sz 2400) (sz 1152) (sz 1184) (sz 1088) (sz 1152) (sz 960)
     (sz 128) (sz 10) (sz 4) (sz 320) (sz 2) (sz 128) (sz 2) (sz 128) (sz 1120) secret_key ciphertext
 
 let encapsulate
       (public_key: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1184))
       (randomness: t_Array u8 (sz 32))
      =
-  Libcrux.Kem.Kyber.encapsulate (sz 3) (sz 1088) (sz 1184) (sz 1152) (sz 960) (sz 128) (sz 10)
+  Libcrux.Kem.Kyber.encapsulate #Spec.Kyber.kyber768_params (sz 3) (sz 1088) (sz 1184) (sz 1152) (sz 960) (sz 128) (sz 10)
     (sz 4) (sz 320) (sz 2) (sz 128) (sz 2) (sz 128) public_key randomness
 
 let validate_public_key (public_key: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1184)) =
   if
-    Libcrux.Kem.Kyber.validate_public_key (sz 3)
+    Libcrux.Kem.Kyber.validate_public_key #Spec.Kyber.kyber768_params (sz 3)
       (sz 1152)
       (sz 1184)
       public_key.Libcrux.Kem.Kyber.Types.f_value
@@ -32,26 +32,8 @@
     <:
     Core.Option.t_Option (Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1184))
 
-let decapsulate_unpacked
-      (state: Libcrux.Kem.Kyber.t_MlKemState (sz 3))
-      (ciphertext: Libcrux.Kem.Kyber.Types.t_MlKemCiphertext (sz 1088))
-     =
-  Libcrux.Kem.Kyber.decapsulate_unpacked (sz 3) (sz 2400) (sz 1152) (sz 1184) (sz 1088) (sz 1152)
-    (sz 960) (sz 128) (sz 10) (sz 4) (sz 320) (sz 2) (sz 128) (sz 2) (sz 128) (sz 1120) state
-    ciphertext
-
 let generate_key_pair (randomness: t_Array u8 (sz 64)) =
-  Libcrux.Kem.Kyber.generate_keypair (sz 3)
-    (sz 1152)
-    (sz 2400)
-    (sz 1184)
-    (sz 1152)
-    (sz 2)
-    (sz 128)
-    randomness
-
-let generate_key_pair_unpacked (randomness: t_Array u8 (sz 64)) =
-  Libcrux.Kem.Kyber.generate_keypair_unpacked (sz 3)
+  Libcrux.Kem.Kyber.generate_keypair #Spec.Kyber.kyber768_params (sz 3)
     (sz 1152)
     (sz 2400)
     (sz 1184)
diff -ruN extraction/Libcrux.Kem.Kyber.Kyber768.fsti extraction-edited/Libcrux.Kem.Kyber.Kyber768.fsti
--- extraction/Libcrux.Kem.Kyber.Kyber768.fsti	2024-05-16 17:05:53.712569181 +0200
+++ extraction-edited/Libcrux.Kem.Kyber.Kyber768.fsti	2024-05-16 17:05:53.771567201 +0200
@@ -71,43 +71,25 @@
 unfold
 let t_MlKem768PublicKey = Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1184)
 
-/// Decapsulate ML-KEM 768
 val decapsulate
       (secret_key: Libcrux.Kem.Kyber.Types.t_MlKemPrivateKey (sz 2400))
       (ciphertext: Libcrux.Kem.Kyber.Types.t_MlKemCiphertext (sz 1088))
-    : Prims.Pure (t_Array u8 (sz 32)) Prims.l_True (fun _ -> Prims.l_True)
+    : Prims.Pure (t_Array u8 (sz 32)) Prims.l_True
+      (ensures (fun res -> res == Spec.Kyber.kyber768_decapsulate secret_key.f_value ciphertext.f_value))
 
-/// Encapsulate ML-KEM 768
 val encapsulate
       (public_key: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1184))
       (randomness: t_Array u8 (sz 32))
     : Prims.Pure (Libcrux.Kem.Kyber.Types.t_MlKemCiphertext (sz 1088) & t_Array u8 (sz 32))
       Prims.l_True
-      (fun _ -> Prims.l_True)
+      (ensures (fun (ct,ss)-> (ct.f_value,ss) == Spec.Kyber.kyber768_encapsulate public_key.f_value randomness))
 
-/// Validate a public key.
-/// Returns `Some(public_key)` if valid, and `None` otherwise.
 val validate_public_key (public_key: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1184))
     : Prims.Pure (Core.Option.t_Option (Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1184)))
       Prims.l_True
       (fun _ -> Prims.l_True)
 
-unfold
-let t_MlKem768State = Libcrux.Kem.Kyber.t_MlKemState (sz 3)
-
-val decapsulate_unpacked
-      (state: Libcrux.Kem.Kyber.t_MlKemState (sz 3))
-      (ciphertext: Libcrux.Kem.Kyber.Types.t_MlKemCiphertext (sz 1088))
-    : Prims.Pure (t_Array u8 (sz 32)) Prims.l_True (fun _ -> Prims.l_True)
-
-/// Generate ML-KEM 768 Key Pair
 val generate_key_pair (randomness: t_Array u8 (sz 64))
     : Prims.Pure (Libcrux.Kem.Kyber.Types.t_MlKemKeyPair (sz 2400) (sz 1184))
       Prims.l_True
-      (fun _ -> Prims.l_True)
-
-val generate_key_pair_unpacked (randomness: t_Array u8 (sz 64))
-    : Prims.Pure
-      (Libcrux.Kem.Kyber.t_MlKemState (sz 3) & Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1184))
-      Prims.l_True
-      (fun _ -> Prims.l_True)
+      (ensures (fun kp -> (kp.f_sk.f_value,kp.f_pk.f_value) == Spec.Kyber.kyber768_generate_keypair randomness))
diff -ruN extraction/Libcrux.Kem.Kyber.Matrix.fst extraction-edited/Libcrux.Kem.Kyber.Matrix.fst
--- extraction/Libcrux.Kem.Kyber.Matrix.fst	2024-05-16 17:05:53.725568745 +0200
+++ extraction-edited/Libcrux.Kem.Kyber.Matrix.fst	2024-05-16 17:05:53.747568007 +0200
@@ -3,205 +3,188 @@
 open Core
 open FStar.Mul
 
-let compute_As_plus_e
-      (v_K: usize)
-      (matrix_A: t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K)
-      (s_as_ntt error_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-     =
-  let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-    Rust_primitives.Hax.repeat Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO v_K
-  in
-  let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Iter.Adapters.Enumerate.t_Enumerate
-            (Core.Slice.Iter.t_Iter
-              (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)))
-          (Core.Iter.Traits.Iterator.f_enumerate #(Core.Slice.Iter.t_Iter
-                (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K))
-              (Core.Slice.impl__iter #(t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
-                      v_K)
-                  (Rust_primitives.unsize matrix_A
-                    <:
-                    t_Slice (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K))
-                <:
-                Core.Slice.Iter.t_Iter
-                (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K))
-            <:
-            Core.Iter.Adapters.Enumerate.t_Enumerate
-            (Core.Slice.Iter.t_Iter
-              (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)))
-        <:
-        Core.Iter.Adapters.Enumerate.t_Enumerate
-        (Core.Slice.Iter.t_Iter (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)))
+open Libcrux.Kem.Kyber.Arithmetic
+
+let op_Array_Access (x:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement) (i:usize{v i < 256}): i32  =
+    x.f_coefficients.[i]
+    
+
+#push-options "--ifuel 0 --z3rlimit 700"
+let compute_As_plus_e v_K matrix_A s_as_ntt error_as_ntt =
+  let wfZero: wfPolynomialRingElement = (Libcrux.Kem.Kyber.Arithmetic.cast_poly_b #1 #3328 Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO) in
+  let result:t_Array wfPolynomialRingElement v_K =
+    Rust_primitives.Hax.repeat wfZero v_K
+  in
+  [@ inline_let]
+  let inv0 = fun (acc:t_Array wfPolynomialRingElement v_K) (i:usize) -> 
+   (v i <= v v_K) /\
+   (forall (j:usize). (v j >= v i /\ v j < v v_K) ==> (acc.[j] <: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement) == wfZero)
+  in
+  assert (inv0 result (sz 0));
+  let result:t_Array wfPolynomialRingElement v_K =
+    Rust_primitives.Iterators.foldi_slice #(t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) #(t_Array wfPolynomialRingElement v_K) #inv0
+      matrix_A
       result
       (fun result temp_1_ ->
-          let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K = result in
-          let i, row:(usize & t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) =
+          let orig_result = result in
+          let orig_result_cast = (cast_vector_b #v_K #3328 #(v v_K * 3328) orig_result) in
+          let i, row:(usize & t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) =
             temp_1_
           in
-          let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-            Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Iter.Adapters.Enumerate.t_Enumerate
-                    (Core.Slice.Iter.t_Iter Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement))
-                  (Core.Iter.Traits.Iterator.f_enumerate #(Core.Slice.Iter.t_Iter
-                        Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-                      (Core.Slice.impl__iter #Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
-                          (Rust_primitives.unsize row
-                            <:
-                            t_Slice Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-                        <:
-                        Core.Slice.Iter.t_Iter Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-                    <:
-                    Core.Iter.Adapters.Enumerate.t_Enumerate
-                    (Core.Slice.Iter.t_Iter Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement))
-                <:
-                Core.Iter.Adapters.Enumerate.t_Enumerate
-                (Core.Slice.Iter.t_Iter Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement))
-              result
+          [@ inline_let]
+          let inv1 = fun (acc:t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328)) v_K) (inner:usize) ->
+             (v inner <= v v_K) /\
+             (forall (j:usize). (v j < v i /\ v j < v v_K) ==> acc.[j] == orig_result_cast.[j]) /\
+             (forall (j:usize). (v j > v i /\ v j < v v_K) ==> acc.[j] == orig_result_cast.[j]) /\
+             (poly_range (acc.[i] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328)) (v inner * 3328))
+          in
+          assert (forall (k:usize). (v k < 256) ==> v (result.[i] <: wfPolynomialRingElement).f_coefficients.[k] == 0);
+          assert(inv1 orig_result_cast (sz 0));
+          let result:t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328)) v_K =
+            Rust_primitives.Iterators.foldi_slice #Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement #(t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328)) v_K) #inv1
+              row
+              orig_result_cast
               (fun result temp_1_ ->
-                  let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-                    result
-                  in
                   let j, matrix_element:(usize &
-                    Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+                    Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement) =
                     temp_1_
                   in
-                  let product:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+                  let resulti = down_cast_poly_b #(v v_K * 3328) #(v j * 3328) result.[i] in
+                  let product:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
                     Libcrux.Kem.Kyber.Ntt.ntt_multiply matrix_element
-                      (s_as_ntt.[ j ] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+                      (s_as_ntt.[ j ] <: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
                   in
-                  let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+                  let product_sum:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b ((v j + 1) * 3328)  =
+                      (Libcrux.Kem.Kyber.Arithmetic.add_to_ring_element #(v j * 3328) #3328 v_K
+                          resulti
+                          product) in
+                  let product_sum:(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328)) = cast_poly_b #((v j+1)* 3328) #(v v_K * 3328) product_sum in 
+                  let result:t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328)) v_K =
                     Rust_primitives.Hax.Monomorphized_update_at.update_at_usize result
                       i
-                      (Libcrux.Kem.Kyber.Arithmetic.add_to_ring_element v_K
-                          (result.[ i ] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-                          product
-                        <:
-                        Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+                      product_sum
                   in
                   result)
           in
-          Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-                  usize)
-                ({
-                    Core.Ops.Range.f_start = sz 0;
-                    Core.Ops.Range.f_end
-                    =
-                    Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
-                  }
-                  <:
-                  Core.Ops.Range.t_Range usize)
-              <:
-              Core.Ops.Range.t_Range usize)
+          let result1 = result in
+          [@ inline_let]
+          let inv2 = fun (acc:t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328)) v_K) (inner:usize) -> 
+             (v inner <= 256) /\
+             (forall (j:usize). (v j < v i /\ v j < v v_K) ==> acc.[j] == orig_result_cast.[j]) /\
+             (forall (j:usize). (v j > v i /\ v j < v v_K) ==> acc.[j] == orig_result_cast.[j]) /\
+             (forall (j:usize). (v j < v inner) ==> (i32_range (acc.[i] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328)).f_coefficients.[j] 3328))
+             // And all indexes above v inner are unchanged from result1
+          in
+          assert (inv2 result1 (sz 0));
+          let result:t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328)) v_K =
+            Rust_primitives.Iterators.foldi_range #_ #(t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328)) v_K) #inv2 {
+              Core.Ops.Range.f_start = sz 0;
+              Core.Ops.Range.f_end = Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
+            }
             result
-            (fun result j ->
-                let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-                  result
-                in
+            (fun result j -> 
+                let result: t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328)) v_K = result in
                 let j:usize = j in
-                let coefficient_normal_form:i32 =
-                  Libcrux.Kem.Kyber.Arithmetic.to_standard_domain ((result.[ i ]
-                        <:
-                        Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-                        .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ]
-                      <:
-                      i32)
+                let resulti:(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328)) = result.[ i ]  <:  (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328)) in
+                let coefficient_normal_form: i32_b ((nat_div_ceil (v v_K * 3328 * 1353) (pow2 16)) + 1665) =
+                  Libcrux.Kem.Kyber.Arithmetic.to_standard_domain #(v v_K * 3328) (resulti
+                        .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ])
                 in
+                assert ((nat_div_ceil (v v_K * 3328 * 1353) (pow2 16)) + 1665 <= 1940);
+                let coefficient_normal_form: i32_b 1940 = cast_i32_b #((nat_div_ceil (v v_K * 3328 * 1353) (pow2 16)) + 1665)  #1940 coefficient_normal_form in
+                let x1: i32_b 3328 = (error_as_ntt.[ i ]
+                                  <:
+                                  Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+                                  .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ] in
+                let x2: i32_b 5268 = add_i32_b coefficient_normal_form x1 in
+                assert (5268 <= v v_BARRETT_R /\ v v_BARRETT_R < pow2 31);
+                let x3: i32_b (v v_BARRETT_R) = cast_i32_b #5268 #(v v_BARRETT_R) x2 in
+                let resultij: i32_b 3328 =  Libcrux.Kem.Kyber.Arithmetic.barrett_reduce x3 in
+                let resultij: i32_b (v v_K * 3328) =  cast_i32_b #3328 #(v v_K * 3328) resultij in
+                let resulti_coeffs =
+                  Rust_primitives.Hax.Monomorphized_update_at.update_at_usize
+                   (resulti.Libcrux.Kem.Kyber.Arithmetic.f_coefficients)
+                    j resultij in
+                let result = 
                 Rust_primitives.Hax.Monomorphized_update_at.update_at_usize result
                   i
                   ({
-                      (result.[ i ] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) with
+                      resulti with
                       Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                      =
-                      Rust_primitives.Hax.Monomorphized_update_at.update_at_usize (result.[ i ]
-                          <:
-                          Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-                          .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                        j
-                        (Libcrux.Kem.Kyber.Arithmetic.barrett_reduce (coefficient_normal_form +!
-                              ((error_as_ntt.[ i ]
-                                  <:
-                                  Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-                                  .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ]
-                                <:
-                                i32)
-                              <:
-                              i32)
-                          <:
-                          i32)
-                      <:
-                      t_Array i32 (sz 256)
+                      = resulti_coeffs
                     }
                     <:
-                    Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)))
-  in
-  result
+                    Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K*3328)) in
+                assert ((result.[i]).f_coefficients.[j] == resultij);
+                assert(inv2 result (j +! sz 1));
+                let result: x:t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328)) v_K{inv2 x (j +! mk_int 1)} = result in
+                result) in
+      assert (v i + 1 < v v_K ==> result.[i +! sz 1] == orig_result_cast.[i +! sz 1]);
+      let result: t_Array wfPolynomialRingElement v_K =
+        down_cast_vector_b #v_K #(v v_K * 3328) #3328 result in
+      assert (forall (j:usize). (v j >= v i + 1 /\ v j < v v_K) ==> derefine_poly_b result.[j] == derefine_poly_b orig_result.[j]); 
+      assume (inv0 result (i +! sz 1));
+      result)
+  in
+  admit(); //P-F
+  result  
+#pop-options 
 
-let compute_message
-      (v_K: usize)
-      (v: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-      (secret_as_ntt u_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-     =
-  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
-  in
-  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-            usize)
-          ({ Core.Ops.Range.f_start = sz 0; Core.Ops.Range.f_end = v_K }
-            <:
-            Core.Ops.Range.t_Range usize)
-        <:
-        Core.Ops.Range.t_Range usize)
-      result
+#push-options "--ifuel 0 --z3rlimit 100"
+let compute_message #p v_K m_v secret_as_ntt u_as_ntt = 
+  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328) =
+    Libcrux.Kem.Kyber.Arithmetic.cast_poly_b Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
+  in
+  let acc_t = Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328) in
+  [@ inline_let]
+  let inv = fun (acc:acc_t) (i:usize) -> 
+             (v i <= v v_K) /\
+             (poly_range #(v v_K * 3328) acc (v i * 3328))
+  in
+  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328) =
+    Rust_primitives.Iterators.foldi_range #_ #acc_t #inv {
+              Core.Ops.Range.f_start = sz 0;
+              Core.Ops.Range.f_end = v_K
+            }
+      result 
       (fun result i ->
-          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = result in
           let i:usize = i in
-          let product:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let result:t_PolynomialRingElement_b (v i * 3328) = 
+            down_cast_poly_b #(v v_K * 3328) #(v i * 3328) result in
+          let product:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
             Libcrux.Kem.Kyber.Ntt.ntt_multiply (secret_as_ntt.[ i ]
                 <:
-                Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-              (u_as_ntt.[ i ] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+                Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+              (u_as_ntt.[ i ] <: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
           in
-          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b ((v i+1) * 3328)  =
             Libcrux.Kem.Kyber.Arithmetic.add_to_ring_element v_K result product
           in
+          let result = cast_poly_b #((v i + 1) * 3328) #(v v_K * 3328) result in
+          assert(inv result (i +! sz 1));
           result)
   in
-  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Libcrux.Kem.Kyber.Ntt.invert_ntt_montgomery v_K result
+  let acc_t = t_PolynomialRingElement_b (64*v v_K*3328) in
+  let result:acc_t = Libcrux.Kem.Kyber.Ntt.invert_ntt_montgomery v_K result
   in
-  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-            usize)
-          ({
+  [@ inline_let]
+  let inv = fun (acc:acc_t) (i:usize) ->
+    (v i <= 256) /\
+    (forall (j:usize). (v j < v i) ==> i32_range ((acc <: t_PolynomialRingElement_b (64* v v_K * 3328)).f_coefficients.[j]) 3328) in
+  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64*v v_K*3328) =
+    Rust_primitives.Iterators.foldi_range #_ #_ #inv {
               Core.Ops.Range.f_start = sz 0;
               Core.Ops.Range.f_end = Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
             }
-            <:
-            Core.Ops.Range.t_Range usize)
-        <:
-        Core.Ops.Range.t_Range usize)
-      result
+      result 
       (fun result i ->
-          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = result in
           let i:usize = i in
-          let coefficient_normal_form:i32 =
-            Libcrux.Kem.Kyber.Arithmetic.montgomery_reduce ((result
-                    .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ]
-                  <:
-                  i32) *!
-                1441l
-                <:
-                i32)
-          in
-          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-            {
-              result with
-              Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-              =
-              Rust_primitives.Hax.Monomorphized_update_at.update_at_usize result
-                  .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                i
-                (Libcrux.Kem.Kyber.Arithmetic.barrett_reduce ((v
+          let coefficient_normal_form: i32_b (nat_div_ceil (306921472*v v_K) 65536 + 1665) = 
+              Libcrux.Kem.Kyber.Arithmetic.montgomery_reduce 
+                           (Libcrux.Kem.Kyber.Arithmetic.mul_i32_b #(64 * v v_K * 3328) #1441
+                           result.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ] 
+                           (1441l <: Libcrux.Kem.Kyber.Arithmetic.i32_b 1441)) in
+          let resulti : i32_b 3328 = (Libcrux.Kem.Kyber.Arithmetic.barrett_reduce ((m_v
                           .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ]
                         <:
                         i32) -!
@@ -209,82 +192,77 @@
                       <:
                       i32)
                   <:
-                  i32)
+                  i32) in
+          let resulti = cast_i32_b #3328 #(64*v v_K*3328) resulti in
+          let result =
+            {
+              result with
+              Libcrux.Kem.Kyber.Arithmetic.f_coefficients
+              =
+              Rust_primitives.Hax.Monomorphized_update_at.update_at_usize result
+                  .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
+                i resulti
             }
-            <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
+          assert (inv result (i +! sz 1));
           result)
   in
+  admit(); //P-F
   result
+#pop-options
 
-let compute_ring_element_v
-      (v_K: usize)
-      (tt_as_ntt r_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-      (error_2_ message: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-     =
-  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
-  in
-  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-            usize)
-          ({ Core.Ops.Range.f_start = sz 0; Core.Ops.Range.f_end = v_K }
-            <:
-            Core.Ops.Range.t_Range usize)
+#push-options "--ifuel 0 --z3rlimit 100"
+let compute_ring_element_v v_K tt_as_ntt r_as_ntt error_2_ message =
+  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328) =
+    Libcrux.Kem.Kyber.Arithmetic.cast_poly_b Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
+  in
+  [@ inline_let]
+  let inv = fun (acc:t_PolynomialRingElement_b (v v_K * 3328)) (i:usize) ->
+    (v i <= 256) /\
+    (poly_range acc (v i * 3328)) in
+  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328) =
+    Rust_primitives.Iterators.foldi_range #_ #_ #inv ({
+              Core.Ops.Range.f_start = sz 0;
+              Core.Ops.Range.f_end = v_K
+            }
         <:
         Core.Ops.Range.t_Range usize)
       result
       (fun result i ->
-          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = result in
-          let i:usize = i in
-          let product:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let product:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
             Libcrux.Kem.Kyber.Ntt.ntt_multiply (tt_as_ntt.[ i ]
                 <:
-                Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-              (r_as_ntt.[ i ] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+                Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+              (r_as_ntt.[ i ] <: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
           in
-          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let result:t_PolynomialRingElement_b (v i * 3328) = 
+            down_cast_poly_b #(v v_K * 3328) #(v i * 3328) result in
+          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b ((v i + 1) * 3328) =
             Libcrux.Kem.Kyber.Arithmetic.add_to_ring_element v_K result product
           in
-          result)
+          cast_poly_b result)
   in
-  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64 * v v_K * 3328) =
     Libcrux.Kem.Kyber.Ntt.invert_ntt_montgomery v_K result
   in
-  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-            usize)
-          ({
+  [@ inline_let]
+  let inv = fun (acc:t_PolynomialRingElement_b (64 * v v_K * 3328)) (i:usize) -> 
+    (v i <= 256) /\
+    (forall (j:usize). (v j < v i) ==> i32_range ((acc <: t_PolynomialRingElement_b (64* v v_K * 3328)).f_coefficients.[j]) 3328) in
+  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64 * v v_K * 3328) =
+    Rust_primitives.Iterators.foldi_range #_ #_ #inv {
               Core.Ops.Range.f_start = sz 0;
               Core.Ops.Range.f_end = Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
             }
-            <:
-            Core.Ops.Range.t_Range usize)
-        <:
-        Core.Ops.Range.t_Range usize)
-      result
+      result 
       (fun result i ->
-          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = result in
-          let i:usize = i in
-          let coefficient_normal_form:i32 =
-            Libcrux.Kem.Kyber.Arithmetic.montgomery_reduce ((result
-                    .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ]
-                  <:
-                  i32) *!
-                1441l
-                <:
-                i32)
-          in
-          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-            {
-              result with
-              Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-              =
-              Rust_primitives.Hax.Monomorphized_update_at.update_at_usize result
-                  .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                i
-                (Libcrux.Kem.Kyber.Arithmetic.barrett_reduce ((coefficient_normal_form +!
+          let coefficient_normal_form: i32_b (nat_div_ceil (306921472*v v_K) 65536 + 1665) = 
+              Libcrux.Kem.Kyber.Arithmetic.montgomery_reduce 
+                           (Libcrux.Kem.Kyber.Arithmetic.mul_i32_b #(64 * v v_K * 3328) #1441
+                           result.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ] 
+                           (1441l <: Libcrux.Kem.Kyber.Arithmetic.i32_b 1441)) in
+          let resulti : i32_b 3328 = 
+            (Libcrux.Kem.Kyber.Arithmetic.barrett_reduce ((coefficient_normal_form +!
                         (error_2_.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ] <: i32)
                         <:
                         i32) +!
@@ -292,172 +270,155 @@
                       <:
                       i32)
                   <:
-                  i32)
+                  i32) in
+          let resulti = cast_i32_b #3328 #(64*v v_K*3328) resulti in
+          let result =
+            {
+              result with
+              Libcrux.Kem.Kyber.Arithmetic.f_coefficients
+              =
+              Rust_primitives.Hax.Monomorphized_update_at.update_at_usize result
+                  .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
+                i resulti
             }
-            <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
           result)
   in
+  admit(); //P-F
   result
+#pop-options
 
+#push-options "--ifuel 0 --z3rlimit 300"
 let compute_vector_u
       (v_K: usize)
-      (a_as_ntt: t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K)
-      (r_as_ntt error_1_: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-     =
-  let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-    Rust_primitives.Hax.repeat Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO v_K
-  in
-  let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Iter.Adapters.Enumerate.t_Enumerate
-            (Core.Slice.Iter.t_Iter
-              (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)))
-          (Core.Iter.Traits.Iterator.f_enumerate #(Core.Slice.Iter.t_Iter
-                (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K))
-              (Core.Slice.impl__iter #(t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
-                      v_K)
-                  (Rust_primitives.unsize a_as_ntt
-                    <:
-                    t_Slice (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K))
-                <:
-                Core.Slice.Iter.t_Iter
-                (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K))
-            <:
-            Core.Iter.Adapters.Enumerate.t_Enumerate
-            (Core.Slice.Iter.t_Iter
-              (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)))
-        <:
-        Core.Iter.Adapters.Enumerate.t_Enumerate
-        (Core.Slice.Iter.t_Iter (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)))
+      (a_as_ntt: t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) v_K)
+      (r_as_ntt error_1_: t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) =
+  let wfZero: wfPolynomialRingElement = (Libcrux.Kem.Kyber.Arithmetic.cast_poly_b #1 #3328 Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO) in
+  let result:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
+    Rust_primitives.Hax.repeat wfZero v_K
+  in
+  let acc_t = t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K in
+  [@ inline_let]
+  let inv0 = fun (acc:t_Array wfPolynomialRingElement v_K) (i:usize) -> 
+   (v i <= v v_K) /\
+   (forall (j:usize). (v j >= v i /\ v j < v v_K) ==> (acc.[j] <: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement) == wfZero)
+  in
+  let result:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
+    Rust_primitives.Iterators.foldi_slice #(t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) #acc_t #inv0
+      a_as_ntt
       result
       (fun result temp_1_ ->
-          let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K = result in
-          let i, row:(usize & t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) =
+          let result:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K = result in
+          let orig_result = result in
+          let orig_result_cast = (cast_vector_b #v_K #3328 #(64 * v v_K * 3328) orig_result) in
+          let i, row:(usize & t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) =
             temp_1_
           in
-          let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-            Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Iter.Adapters.Enumerate.t_Enumerate
-                    (Core.Slice.Iter.t_Iter Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement))
-                  (Core.Iter.Traits.Iterator.f_enumerate #(Core.Slice.Iter.t_Iter
-                        Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-                      (Core.Slice.impl__iter #Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
-                          (Rust_primitives.unsize row
-                            <:
-                            t_Slice Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-                        <:
-                        Core.Slice.Iter.t_Iter Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-                    <:
-                    Core.Iter.Adapters.Enumerate.t_Enumerate
-                    (Core.Slice.Iter.t_Iter Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement))
-                <:
-                Core.Iter.Adapters.Enumerate.t_Enumerate
-                (Core.Slice.Iter.t_Iter Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement))
-              result
+          [@ inline_let]
+          let inv1 = fun (acc:t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64 * v v_K * 3328)) v_K) (inner:usize) ->
+             (v inner <= v v_K) /\
+             (forall (j:usize). (v j < v i /\ v j < v v_K) ==> acc.[j] == orig_result_cast.[j]) /\
+             (forall (j:usize). (v j > v i /\ v j < v v_K) ==> acc.[j] == orig_result_cast.[j]) /\
+             (poly_range (acc.[i] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64 * v v_K * 3328)) (v inner * 3328))
+          in
+          assert (forall (k:usize). (v k < 256) ==> v (result.[i] <: wfPolynomialRingElement).f_coefficients.[k] == 0);
+          assert(inv1 orig_result_cast (sz 0));
+          let result:t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64 * v v_K * 3328)) v_K =
+            Rust_primitives.Iterators.foldi_slice #Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement #(t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64 * v v_K * 3328)) v_K) #inv1
+              row
+              orig_result_cast
               (fun result temp_1_ ->
-                  let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-                    result
-                  in
-                  let j, a_element:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+                  let j, a_element:(usize & Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement) =
                     temp_1_
                   in
-                  let product:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+                  let resulti = down_cast_poly_b #(64 * v v_K * 3328) #(v j * 3328) result.[i] in
+                  let product:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
                     Libcrux.Kem.Kyber.Ntt.ntt_multiply a_element
-                      (r_as_ntt.[ j ] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+                      (r_as_ntt.[ j ] <: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
                   in
-                  let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+                  let product_sum:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b ((v j + 1) * 3328)  =
+                      (Libcrux.Kem.Kyber.Arithmetic.add_to_ring_element #(v j * 3328) #3328 v_K
+                          resulti
+                          product) in
+                  let product_sum:(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64 * v v_K * 3328)) = cast_poly_b #((v j+1)* 3328) #(64 * v v_K * 3328) product_sum in 
+                  let result:t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64 * v v_K * 3328)) v_K =
                     Rust_primitives.Hax.Monomorphized_update_at.update_at_usize result
                       i
-                      (Libcrux.Kem.Kyber.Arithmetic.add_to_ring_element v_K
-                          (result.[ i ] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-                          product
-                        <:
-                        Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+                      product_sum
                   in
                   result)
           in
-          let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+          assert (forall (j:usize). (v j < v i /\ v j < v v_K) ==> result.[j] == orig_result_cast.[j]);
+          assert (forall (j:usize). (v j > v i /\ v j < v v_K) ==> result.[j] == orig_result_cast.[j]);
+          let resulti : t_PolynomialRingElement_b (v v_K * 3328) = down_cast_poly_b result.[i] in
+          let result =
             Rust_primitives.Hax.Monomorphized_update_at.update_at_usize result
               i
-              (Libcrux.Kem.Kyber.Ntt.invert_ntt_montgomery v_K
-                  (result.[ i ] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-                <:
-                Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-          in
-          Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-                  usize)
-                ({
-                    Core.Ops.Range.f_start = sz 0;
-                    Core.Ops.Range.f_end
-                    =
-                    Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
-                  }
-                  <:
-                  Core.Ops.Range.t_Range usize)
-              <:
-              Core.Ops.Range.t_Range usize)
+              (Libcrux.Kem.Kyber.Ntt.invert_ntt_montgomery v_K resulti)
+           in
+          [@ inline_let]
+          let inv2 = fun (acc:t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64*v v_K * 3328)) v_K) (inner:usize) -> 
+             (v inner <= 256) /\
+             (forall (j:usize). (v j < v i /\ v j < v v_K) ==> acc.[j] == orig_result_cast.[j]) /\
+             (forall (j:usize). (v j > v i /\ v j < v v_K) ==> acc.[j] == orig_result_cast.[j]) /\
+             (forall (j:usize). (v j < v inner) ==> (i32_range (acc.[i] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64*v v_K * 3328)).f_coefficients.[j] 3328))
+             // And all indexes above v inner are unchanged from result1
+          in
+          assert (forall (j:usize). (v j < v i /\ v j < v v_K) ==> result.[j] == orig_result_cast.[j]);
+          assert (forall (j:usize). (v j > v i /\ v j < v v_K) ==> result.[j] == orig_result_cast.[j]);
+          assert (inv2 result (sz 0));
+          let result:t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64*v v_K * 3328)) v_K =
+            Rust_primitives.Iterators.foldi_range #_ #(t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64*v v_K * 3328)) v_K) #inv2 {
+              Core.Ops.Range.f_start = sz 0;
+              Core.Ops.Range.f_end = Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
+            }
             result
             (fun result j ->
-                let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-                  result
-                in
-                let j:usize = j in
-                let coefficient_normal_form:i32 =
-                  Libcrux.Kem.Kyber.Arithmetic.montgomery_reduce (((result.[ i ]
-                          <:
-                          Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-                          .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ]
-                        <:
-                        i32) *!
-                      1441l
-                      <:
-                      i32)
-                in
-                let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+                let result: t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64*v v_K * 3328)) v_K = result in
+                let resulti:(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64*v v_K * 3328)) = result.[ i ]  <:  (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64*v v_K * 3328)) in
+                let coefficient_normal_form: i32_b (nat_div_ceil (306921472*v v_K) 65536 + 1665) = 
+              Libcrux.Kem.Kyber.Arithmetic.montgomery_reduce 
+                           (Libcrux.Kem.Kyber.Arithmetic.mul_i32_b #(64 * v v_K * 3328) #1441
+                           (resulti <: t_PolynomialRingElement_b (64*v v_K * 3328)).f_coefficients.[j] (1441l <: Libcrux.Kem.Kyber.Arithmetic.i32_b 1441)) in
+                let resultij: i32_b 3328 = (Libcrux.Kem.Kyber.Arithmetic.barrett_reduce 
+                                    (add_i32_b coefficient_normal_form ((error_1_.[ i ]
+                                    <:
+                                    Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+                                    .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ]))) in
+                let result =
                   Rust_primitives.Hax.Monomorphized_update_at.update_at_usize result
                     i
                     ({
-                        (result.[ i ] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) with
+                        resulti with
                         Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                         =
-                        Rust_primitives.Hax.Monomorphized_update_at.update_at_usize (result.[ i ]
-                            <:
-                            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-                            .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
+                        Rust_primitives.Hax.Monomorphized_update_at.update_at_usize (resulti
+                            .Libcrux.Kem.Kyber.Arithmetic.f_coefficients)
                           j
-                          (Libcrux.Kem.Kyber.Arithmetic.barrett_reduce (coefficient_normal_form +!
-                                ((error_1_.[ i ]
-                                    <:
-                                    Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-                                    .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ]
-                                  <:
-                                  i32)
-                                <:
-                                i32)
-                            <:
-                            i32)
-                        <:
-                        t_Array i32 (sz 256)
-                      }
-                      <:
-                      Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-                in
-                result))
+                          (cast_i32_b #3328 #(64 * v v_K * 3328) resultij)
+                      }) in
+                result)
+        in
+        let result: t_Array wfPolynomialRingElement v_K =
+          down_cast_vector_b #v_K #(64 * v v_K * 3328) #3328 result in
+        assert (forall (j:usize). (v j >= v i + 1 /\ v j < v v_K) ==> derefine_poly_b result.[j] == derefine_poly_b orig_result.[j]); 
+        assume (inv0 result (i +! sz 1));
+        result)
   in
+  admit(); //P-F
   result
+#pop-options
 
 let sample_matrix_A (v_K: usize) (seed: t_Array u8 (sz 34)) (transpose: bool) =
-  let v_A_transpose:t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K =
-    Rust_primitives.Hax.repeat (Rust_primitives.Hax.repeat Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
-          v_K
-        <:
-        t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-      v_K
+  let wfZero: wfPolynomialRingElement = (Libcrux.Kem.Kyber.Arithmetic.cast_poly_b #1 #3328 Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO) in
+  let v_A_transpose:t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) v_K =
+    Rust_primitives.Hax.repeat (Rust_primitives.Hax.repeat wfZero v_K) v_K
   in
-  let v_A_transpose:t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-            usize)
-          ({ Core.Ops.Range.f_start = sz 0; Core.Ops.Range.f_end = v_K }
+  let v_A_transpose:t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) v_K =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
+              Core.Ops.Range.f_start = sz 0;
+              Core.Ops.Range.f_end = v_K
+            }
             <:
             Core.Ops.Range.t_Range usize)
         <:
@@ -465,15 +426,16 @@
       v_A_transpose
       (fun v_A_transpose i ->
           let v_A_transpose:t_Array
-            (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K =
+            (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) v_K =
             v_A_transpose
           in
           let i:usize = i in
           let seeds:t_Array (t_Array u8 (sz 34)) v_K = Rust_primitives.Hax.repeat seed v_K in
           let seeds:t_Array (t_Array u8 (sz 34)) v_K =
-            Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-                    usize)
-                  ({ Core.Ops.Range.f_start = sz 0; Core.Ops.Range.f_end = v_K }
+            Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
+                      Core.Ops.Range.f_start = sz 0;
+                      Core.Ops.Range.f_end = v_K
+                    }
                     <:
                     Core.Ops.Range.t_Range usize)
                 <:
@@ -506,12 +468,13 @@
                   in
                   seeds)
           in
-          let sampled:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-            Libcrux.Kem.Kyber.Sampling.sample_from_xof v_K seeds
+          let xof_bytes:t_Array (t_Array u8 (sz 840)) v_K =
+            Libcrux.Kem.Kyber.Hash_functions.v_XOFx4 v_K seeds
           in
-          Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-                  usize)
-                ({ Core.Ops.Range.f_start = sz 0; Core.Ops.Range.f_end = v_K }
+          Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
+                    Core.Ops.Range.f_start = sz 0;
+                    Core.Ops.Range.f_end = v_K
+                  }
                   <:
                   Core.Ops.Range.t_Range usize)
               <:
@@ -519,40 +482,46 @@
             v_A_transpose
             (fun v_A_transpose j ->
                 let v_A_transpose:t_Array
-                  (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K =
+                  (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) v_K =
                   v_A_transpose
                 in
                 let j:usize = j in
+                let sampled:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+                  Libcrux.Kem.Kyber.Sampling.sample_from_uniform_distribution (xof_bytes.[ j ]
+                      <:
+                      t_Array u8 (sz 840))
+                in
                 if transpose
                 then
                   let v_A_transpose:t_Array
-                    (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K =
+                    (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) v_K =
                     Rust_primitives.Hax.Monomorphized_update_at.update_at_usize v_A_transpose
                       j
                       (Rust_primitives.Hax.Monomorphized_update_at.update_at_usize (v_A_transpose.[ j
                             ]
                             <:
-                            t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+                            t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
                           i
-                          (sampled.[ j ] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+                          sampled
                         <:
-                        t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+                        t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
                   in
                   v_A_transpose
                 else
                   let v_A_transpose:t_Array
-                    (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K =
+                    (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) v_K =
                     Rust_primitives.Hax.Monomorphized_update_at.update_at_usize v_A_transpose
                       i
                       (Rust_primitives.Hax.Monomorphized_update_at.update_at_usize (v_A_transpose.[ i
                             ]
                             <:
-                            t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+                            t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
                           j
-                          (sampled.[ j ] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+                          sampled
                         <:
-                        t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+                        t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
                   in
                   v_A_transpose))
   in
+  admit(); //P-F
   v_A_transpose
diff -ruN extraction/Libcrux.Kem.Kyber.Matrix.fsti extraction-edited/Libcrux.Kem.Kyber.Matrix.fsti
--- extraction/Libcrux.Kem.Kyber.Matrix.fsti	2024-05-16 17:05:53.718568979 +0200
+++ extraction-edited/Libcrux.Kem.Kyber.Matrix.fsti	2024-05-16 17:05:53.782566832 +0200
@@ -3,46 +3,71 @@
 open Core
 open FStar.Mul
 
-/// Compute Â ◦ ŝ + ê
-val compute_As_plus_e
+
+val compute_As_plus_e (#p:Spec.Kyber.params)
       (v_K: usize)
-      (matrix_A: t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K)
-      (s_as_ntt error_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-    : Prims.Pure (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-      Prims.l_True
-      (fun _ -> Prims.l_True)
-
-/// The following functions compute various expressions involving
-/// vectors and matrices. The computation of these expressions has been
-/// abstracted away into these functions in order to save on loop iterations.
-/// Compute v − InverseNTT(sᵀ ◦ NTT(u))
-val compute_message
+      (matrix_A: t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) v_K)
+      (s_as_ntt error_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
+    : Pure (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) 
+           (requires (v_K == p.v_RANK))
+           (ensures fun res ->
+             let open Libcrux.Kem.Kyber.Arithmetic in
+             v_K == p.v_RANK /\
+             to_spec_vector_b #p res =
+             Spec.Kyber.compute_As_plus_e #p
+               (to_spec_matrix_b #p matrix_A) 
+               (to_spec_vector_b #p s_as_ntt) 
+               (to_spec_vector_b #p error_as_ntt))
+
+
+val compute_message (#p:Spec.Kyber.params)
       (v_K: usize)
-      (v: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-      (secret_as_ntt u_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
-      Prims.l_True
-      (fun _ -> Prims.l_True)
+      (poly_v: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+      (secret_as_ntt u_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
+    : Pure (Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+      (requires (v_K == p.v_RANK))
+      (ensures (fun res -> 
+        let secret_spec = Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p secret_as_ntt in
+        let u_spec = Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p u_as_ntt in
+        let v_spec = Libcrux.Kem.Kyber.Arithmetic.to_spec_poly_b poly_v in
+        Libcrux.Kem.Kyber.Arithmetic.to_spec_poly_b res ==
+        Spec.Kyber.(poly_sub v_spec (poly_inv_ntt #p (vector_dot_product secret_spec u_spec)))))
 
-/// Compute InverseNTT(tᵀ ◦ r̂) + e₂ + message
-val compute_ring_element_v
+// TODO: error_2_ changed from `t_PolynomialRingElement_b 3` to `t_PolynomialRingElement_b 7`
+val compute_ring_element_v (#p:Spec.Kyber.params)
       (v_K: usize)
-      (tt_as_ntt r_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-      (error_2_ message: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
-      Prims.l_True
-      (fun _ -> Prims.l_True)
+      (tt_as_ntt r_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
+      (error_2_: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 7)
+      (message: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+    : Pure (Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+      (requires (v_K == p.v_RANK))
+      (ensures fun res ->
+        let tt_spec = Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p tt_as_ntt in
+        let r_spec = Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p r_as_ntt in
+        let e2_spec = Libcrux.Kem.Kyber.Arithmetic.to_spec_poly_b error_2_ in
+        let m_spec = Libcrux.Kem.Kyber.Arithmetic.to_spec_poly_b message in
+        let res_spec = Libcrux.Kem.Kyber.Arithmetic.to_spec_poly_b res in
+        res_spec == Spec.Kyber.(poly_add (poly_add (vector_dot_product tt_spec r_spec) e2_spec) m_spec))
 
-/// Compute u := InvertNTT(Aᵀ ◦ r̂) + e₁
-val compute_vector_u
+val compute_vector_u (#p:Spec.Kyber.params)
       (v_K: usize)
-      (a_as_ntt: t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K)
-      (r_as_ntt error_1_: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-    : Prims.Pure (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-      Prims.l_True
-      (fun _ -> Prims.l_True)
-
-val sample_matrix_A (v_K: usize) (seed: t_Array u8 (sz 34)) (transpose: bool)
-    : Prims.Pure (t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K)
-      Prims.l_True
-      (fun _ -> Prims.l_True)
+      (a_as_ntt: t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) v_K)
+      (r_as_ntt error_1_: t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
+    : Pure (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
+      (requires (v_K == p.v_RANK))
+      (ensures fun res ->
+        let a_spec = Libcrux.Kem.Kyber.Arithmetic.to_spec_matrix_b #p a_as_ntt in
+        let r_spec = Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p r_as_ntt in
+        let e_spec = Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p error_1_ in
+        let res_spec = Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p res in
+        res_spec == Spec.Kyber.(vector_add (vector_inv_ntt (matrix_vector_mul a_spec r_spec)) e_spec))
+
+
+
+val sample_matrix_A (#p:Spec.Kyber.params) (v_K: usize) (seed: t_Array u8 (sz 34)) (transpose: bool)
+    : Pure (t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) v_K)
+      (requires (v_K == p.v_RANK))
+      (ensures fun res ->
+        let matrix_A = Spec.Kyber.sample_matrix_A #p (Seq.slice seed 0 32) in
+        if transpose then Libcrux.Kem.Kyber.Arithmetic.to_spec_matrix_b #p res == matrix_A
+        else Libcrux.Kem.Kyber.Arithmetic.to_spec_matrix_b #p res == Spec.Kyber.matrix_transpose matrix_A)
diff -ruN extraction/Libcrux.Kem.Kyber.Ntt.fst extraction-edited/Libcrux.Kem.Kyber.Ntt.fst
--- extraction/Libcrux.Kem.Kyber.Ntt.fst	2024-05-16 17:05:53.716569047 +0200
+++ extraction-edited/Libcrux.Kem.Kyber.Ntt.fst	2024-05-16 17:05:53.751567873 +0200
@@ -1,57 +1,130 @@
 module Libcrux.Kem.Kyber.Ntt
-#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
+#set-options "--fuel 0 --ifuel 1 --z3rlimit 100"
 open Core
 open FStar.Mul
 
-let ntt_multiply_binomials (a0, a1: (i32 & i32)) (b0, b1: (i32 & i32)) (zeta: i32) =
-  Libcrux.Kem.Kyber.Arithmetic.montgomery_reduce ((a0 *! b0 <: i32) +!
-      ((Libcrux.Kem.Kyber.Arithmetic.montgomery_reduce (a1 *! b1 <: i32) <: i32) *! zeta <: i32)
-      <:
-      i32),
-  Libcrux.Kem.Kyber.Arithmetic.montgomery_reduce ((a0 *! b1 <: i32) +! (a1 *! b0 <: i32) <: i32)
-  <:
-  (i32 & i32)
-
-let invert_ntt_at_layer
-      (zeta_i: usize)
-      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-      (layer: usize)
-     =
+
+let v_ZETAS_TIMES_MONTGOMERY_R =
+  let list : list (i32_b 1664) =
+    [
+      (-1044l); (-758l); (-359l); (-1517l); 1493l; 1422l; 287l; 202l; (-171l); 622l; 1577l; 182l;
+      962l; (-1202l); (-1474l); 1468l; 573l; (-1325l); 264l; 383l; (-829l); 1458l; (-1602l); (-130l);
+      (-681l); 1017l; 732l; 608l; (-1542l); 411l; (-205l); (-1571l); 1223l; 652l; (-552l); 1015l;
+      (-1293l); 1491l; (-282l); (-1544l); 516l; (-8l); (-320l); (-666l); (-1618l); (-1162l); 126l;
+      1469l; (-853l); (-90l); (-271l); 830l; 107l; (-1421l); (-247l); (-951l); (-398l); 961l;
+      (-1508l); (-725l); 448l; (-1065l); 677l; (-1275l); (-1103l); 430l; 555l; 843l; (-1251l); 871l;
+      1550l; 105l; 422l; 587l; 177l; (-235l); (-291l); (-460l); 1574l; 1653l; (-246l); 778l; 1159l;
+      (-147l); (-777l); 1483l; (-602l); 1119l; (-1590l); 644l; (-872l); 349l; 418l; 329l; (-156l);
+      (-75l); 817l; 1097l; 603l; 610l; 1322l; (-1285l); (-1465l); 384l; (-1215l); (-136l); 1218l;
+      (-1335l); (-874l); 220l; (-1187l); (-1659l); (-1185l); (-1530l); (-1278l); 794l; (-1510l);
+      (-854l); (-870l); 478l; (-108l); (-308l); 996l; 991l; 958l; (-1460l); 1522l; 1628l
+    ]
+  in
+  FStar.Pervasives.assert_norm (Prims.eq2 (List.Tot.length list) 128);
+  FStar.Pervasives.assert_norm (List.Tot.index list 1 == -758l);
+  Seq.of_list list
+  
+open Libcrux.Kem.Kyber.Arithmetic
+
+#push-options "--z3rlimit 50"
+let ntt_multiply_binomials (a0,a1) (b0,b1) zeta =
+  let r0 = montgomery_reduce (mul_i32_b a1 b1) in
+  let res = 
+  montgomery_reduce (add_i32_b (mul_i32_b a0 b0) (mul_i32_b r0 zeta)),
+  montgomery_reduce (add_i32_b (mul_i32_b a0 b1) (mul_i32_b a1 b0)) in
+  res
+#pop-options
+
+val mul_zeta_red   (#v_K:usize{v v_K >= 1 /\ v v_K <= 4})
+                   (#b:nat{b <= v v_K * 3328 * 64}) 
+                   (zeta_i:usize{v zeta_i > 0 /\ v zeta_i <= 128} )
+                   (layer:usize{v layer > 0 /\ 
+                                v layer <= 7 /\ 
+                                v zeta_i == pow2 (8 - v layer) /\ 
+                                b == v v_K * 3328 * pow2(v layer - 1)})
+                   (x:i32_b (2*b))
+                   (i:usize{v i < 128 / pow2 (v layer)}) :
+                   i32_b (2*b)
+let mul_zeta_red #v_K #b zeta_i layer x i = 
+    let zeta_i = zeta_i -! sz 1 -! i in
+    let zeta:i32_b 1664 = v_ZETAS_TIMES_MONTGOMERY_R.[ zeta_i ] in
+    if layer <=. sz 6 then (
+      assert (b <= 4 * 3328 * 32);
+      assert (2*b*1664 < pow2 31);
+      let product:i32_b (2 * b * 1664) = mul_i32_b x zeta in
+      let res = montgomery_reduce product in
+      res
+    ) else (
+      assert (v i  < 1);
+      assert (zeta_i = sz 1);
+      assert (zeta = -758l);
+      let zeta:i32_b 758 = zeta in
+      let product:i32_b (2 * b * 758) = mul_i32_b x zeta in
+      let res = montgomery_reduce product in
+      res
+    )
+
+
+val lemma_zeta_decr: orig:usize -> fin:usize -> layer:usize{v layer <= 7} ->
+  Lemma (v fin == v orig - 128/(pow2 (v layer)) /\
+         v orig == pow2 (8 - v layer) ==>
+         v fin == pow2 (7 - v layer))
+let lemma_zeta_decr orig fin layer = ()
+
+#push-options "--ifuel 0 --z3rlimit 1200"
+let invert_ntt_at_layer #v_K #b zeta_i re layer =
   let step:usize = sz 1 <<! layer in
-  let re, zeta_i:(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement & usize) =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-            usize)
-          ({ Core.Ops.Range.f_start = sz 0; Core.Ops.Range.f_end = sz 128 >>! layer <: usize }
-            <:
-            Core.Ops.Range.t_Range usize)
-        <:
-        Core.Ops.Range.t_Range usize)
-      (re, zeta_i <: (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement & usize))
+  assert (v step > 0);
+  assert (v step == pow2 (v layer));
+  let orig_re = re in
+  let orig_zeta_i = zeta_i in
+  [@ inline_let]
+  let inv = fun (acc:t_PolynomialRingElement_b (2*b) & usize) (i:usize) ->
+    let (re,zeta_i) = acc in 
+    v zeta_i == v orig_zeta_i - v i /\
+    (forall k. (v k >= 2 * v i * v step (* + 2 * v step *)) ==> re.f_coefficients.[k] == orig_re.f_coefficients.[k]) 
+  in
+  let re, zeta_i: (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (2*b) & usize) =
+    Rust_primitives.Iterators.foldi_range #_ #(t_PolynomialRingElement_b (2*b) & usize) #inv {
+              Core.Ops.Range.f_start = sz 0;
+              Core.Ops.Range.f_end = sz 128 /! step
+            }
+      (cast_poly_b #b #(2*b) re, zeta_i <: (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (2*b) & usize))
       (fun temp_0_ round ->
-          let re, zeta_i:(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement & usize) = temp_0_ in
+          let re, zeta_i:(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (2*b) & usize) = temp_0_ in
           let round:usize = round in
+          let orig_re_round = re in
           let zeta_i:usize = zeta_i -! sz 1 in
-          let offset:usize = (round *! step <: usize) *! sz 2 in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-            Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-                    usize)
-                  ({
+          assert(v round * v step < 128);
+          assert(v round * v step + v step <= 128);
+          assert(v round * v step * 2 <= 254);
+          assert(v round * v step * 2 + 2 * v step <= 256);
+          let offset:usize = (round *! step) *! sz 2 in
+          assert (v offset + 2 * v step <= 256);
+          assert (v offset + v step <= 256);
+          assert (forall k. v k >= v offset ==> re.f_coefficients.[k] == orig_re.f_coefficients.[k]);
+          [@ inline_let]
+          let inv = fun (acc:t_PolynomialRingElement_b (2 * b)) (i:usize) ->
+            (forall k. (v k >= v i /\ v k < v offset + v step) ==> acc.f_coefficients.[k] == orig_re.f_coefficients.[k]) /\
+            (forall k. (v k >= v i + v step) ==> acc.f_coefficients.[k] == orig_re.f_coefficients.[k])
+          in
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (2 * b) =
+            Rust_primitives.Iterators.foldi_range #_ #_  #inv {
                       Core.Ops.Range.f_start = offset;
                       Core.Ops.Range.f_end = offset +! step <: usize
-                    }
-                    <:
-                    Core.Ops.Range.t_Range usize)
-                <:
-                Core.Ops.Range.t_Range usize)
+            }
               re
               (fun re j ->
-                  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
+                  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (2 * b) = re in
+                  assert (re.f_coefficients.[j] == orig_re_round.f_coefficients.[j]);
+                  assert (re.f_coefficients.[j +! step] == orig_re_round.f_coefficients.[j +! step]);
+                  assert (re.f_coefficients.[j] == orig_re.f_coefficients.[j]);
+                  assert (re.f_coefficients.[j +! step] == orig_re.f_coefficients.[j +! step]);
+                  let re_j:i32_b b = orig_re.f_coefficients.[j] in
+                  let re_j_step:i32_b b = orig_re.f_coefficients.[j +! step] in
                   let j:usize = j in
-                  let a_minus_b:i32 =
-                    (re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j +! step <: usize ] <: i32) -!
-                    (re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ] <: i32)
-                  in
-                  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+                  let a_minus_b:i32_b (2*b) = sub_i32_b re_j_step re_j in
+                  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (2 * b) =
                     {
                       re with
                       Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -59,17 +132,13 @@
                       Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                           .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                         j
-                        ((re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ] <: i32) +!
-                          (re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j +! step <: usize ]
-                            <:
-                            i32)
-                          <:
-                          i32)
+                        (add_i32_b re_j re_j_step)
                     }
                     <:
-                    Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+                    Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (2 * b)
                   in
-                  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+                  let red = mul_zeta_red #v_K #b orig_zeta_i layer a_minus_b round in
+                  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (2*b) =
                     {
                       re with
                       Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -77,74 +146,77 @@
                       Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                           .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                         (j +! step <: usize)
-                        (Libcrux.Kem.Kyber.Arithmetic.montgomery_reduce (a_minus_b *!
-                              (v_ZETAS_TIMES_MONTGOMERY_R.[ zeta_i ] <: i32)
-                              <:
-                              i32)
-                          <:
-                          i32)
+                        red
                     }
                     <:
-                    Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+                    Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (2*b)
                   in
                   re)
           in
-          re, zeta_i <: (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement & usize))
+          re, zeta_i <: t_PolynomialRingElement_b (2*b) & usize)
   in
-  let hax_temp_output:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
-  zeta_i, hax_temp_output <: (usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+  let hax_temp_output:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (2*b) = re in
+  lemma_zeta_decr orig_zeta_i zeta_i layer;
+  zeta_i, hax_temp_output <: (usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (2*b))  
+#pop-options
 
-let invert_ntt_montgomery (v_K: usize) (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+#push-options "--z3rlimit 500"
+let invert_ntt_montgomery v_K re =
   let _:Prims.unit = () <: Prims.unit in
+  let b = v v_K * 3328 in
+  assert (v v_K <= 4);
+  assert (b <= 4 * 3328);
   let zeta_i:usize = Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT /! sz 2 in
-  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
-    invert_ntt_at_layer zeta_i re (sz 1)
+  assert (v zeta_i == pow2 (8 - 1));
+  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (2*b)) =
+    invert_ntt_at_layer #v_K #b zeta_i re (sz 1)
   in
   let zeta_i:usize = tmp0 in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
-  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
-    invert_ntt_at_layer zeta_i re (sz 2)
+  let hoist1 = out in
+  let re = hoist1 in
+  let tmp0, re:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (4*b)) =
+    invert_ntt_at_layer #v_K zeta_i re (sz 2)
   in
   let zeta_i:usize = tmp0 in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
-  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
-    invert_ntt_at_layer zeta_i re (sz 3)
+  let tmp0, re:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (8*b)) =
+    invert_ntt_at_layer #v_K zeta_i re (sz 3)
   in
   let zeta_i:usize = tmp0 in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
-  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
-    invert_ntt_at_layer zeta_i re (sz 4)
+  assert (8*b = v v_K * 3328 * pow2 (4 - 1));
+  let tmp0, re:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (16*b)) =
+    invert_ntt_at_layer #v_K zeta_i re (sz 4)
   in
   let zeta_i:usize = tmp0 in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
-  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
-    invert_ntt_at_layer zeta_i re (sz 5)
+  assert (16*b == v v_K * 3328 * pow2 (5 - 1));
+  let tmp0, re:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (32*b)) =
+    invert_ntt_at_layer #v_K zeta_i re (sz 5)
   in
   let zeta_i:usize = tmp0 in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
-  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
-    invert_ntt_at_layer zeta_i re (sz 6)
+  assert (32*b = v v_K * 3328 * pow2 (6 - 1));
+  let tmp0, re:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64*b)) =
+    invert_ntt_at_layer #v_K zeta_i re (sz 6)
   in
   let zeta_i:usize = tmp0 in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
-  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
-    invert_ntt_at_layer zeta_i re (sz 7)
+  assert (64*b = v v_K * 3328 * pow2 (7 - 1));
+  let tmp0, re:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (128*b)) =
+    invert_ntt_at_layer #v_K zeta_i re (sz 7)
   in
   let zeta_i:usize = tmp0 in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
   let _:Prims.unit = () <: Prims.unit in
   let _:Prims.unit = () <: Prims.unit in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-            usize)
-          ({ Core.Ops.Range.f_start = sz 0; Core.Ops.Range.f_end = sz 2 }
+  admit();
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64*b) =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
+              Core.Ops.Range.f_start = sz 0;
+              Core.Ops.Range.f_end = sz 8
+            }
             <:
             Core.Ops.Range.t_Range usize)
         <:
         Core.Ops.Range.t_Range usize)
       re
       (fun re i ->
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (128*b) = re in
           let i:usize = i in
           {
             re with
@@ -163,53 +235,84 @@
             t_Array i32 (sz 256)
           }
           <:
-          Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+          Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64*b))
   in
-  re
+  re 
+#pop-options
 
-let ntt_at_layer
-      (zeta_i: usize)
-      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-      (layer v__initial_coefficient_bound: usize)
-     =
-  let step:usize = sz 1 <<! layer in
-  let re, zeta_i:(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement & usize) =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-            usize)
-          ({ Core.Ops.Range.f_start = sz 0; Core.Ops.Range.f_end = sz 128 >>! layer <: usize }
-            <:
-            Core.Ops.Range.t_Range usize)
-        <:
-        Core.Ops.Range.t_Range usize)
-      (re, zeta_i <: (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement & usize))
+#push-options "--z3rlimit 500"
+val mul_zeta_red2   (#b:nat{b <= 31175}) 
+                   (zeta_i:usize{v zeta_i >= 0 /\ v zeta_i <= 63} )
+                   (layer:usize{v layer > 0 /\ 
+                                v layer <= 7 /\ 
+                                v zeta_i == pow2 (7 - v layer) - 1})
+                   (x:i32_b b)
+                   (i:usize{v i < 128/(pow2 (v layer))})
+                   : i32_b 3328
+let mul_zeta_red2 #b zeta_i layer x i = 
+    let zeta_i = zeta_i +! sz 1 +! i in
+    let zeta = v_ZETAS_TIMES_MONTGOMERY_R.[ zeta_i ] in
+    assert (b * 1664 < 65536 * 3328);
+    let red = Libcrux.Kem.Kyber.Arithmetic.montgomery_multiply_sfe_by_fer #(3328+b) #1664 x
+                             (v_ZETAS_TIMES_MONTGOMERY_R.[ zeta_i ] <: i32) in
+    red
+#pop-options
+
+#push-options "--ifuel 0 --z3rlimit 5000"
+let ntt_at_layer #b zeta_i re layer initial_coefficient_bound =
+  let step = sz 1 <<! layer in
+  let loop_end = sz 128 /! step in
+  assert (v loop_end == pow2 (7 - v layer));
+  let orig_re = re in
+  let orig_zeta_i = zeta_i in
+  [@ inline_let]
+  let inv = fun (acc:t_PolynomialRingElement_b (3328+b) & usize) (i:usize) ->
+    let (re,zeta_i) = acc in 
+    v zeta_i == v orig_zeta_i + v i /\
+    (forall k. v k >= 2 * v i * v step  ==> re.f_coefficients.[k] == orig_re.f_coefficients.[k]) 
+  in
+  let re, zeta_i: (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (3328+b) & usize) =
+    Rust_primitives.Iterators.foldi_range #_ #(t_PolynomialRingElement_b (3328+b) & usize) #inv {
+              Core.Ops.Range.f_start = sz 0;
+              Core.Ops.Range.f_end = loop_end
+            }
+      (cast_poly_b #b #(3328+b) re, zeta_i)
       (fun temp_0_ round ->
-          let re, zeta_i:(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement & usize) = temp_0_ in
+          let re, zeta_i:(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (3328+b) & usize) = temp_0_ in
           let round:usize = round in
           let zeta_i:usize = zeta_i +! sz 1 in
-          let offset:usize = (round *! step <: usize) *! sz 2 in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-            Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-                    usize)
-                  ({
+          assert(v round * v step < 128);
+          assert(v round * v step + v step <= 128);
+          assert(v round * v step * 2 <= 254);
+          assert(v round * v step * 2 + 2 * v step <= 256);
+          let offset:usize = (round *! step) *! sz 2 in
+          assert (v offset + 2 * v step <= 256);
+          assert (v offset + v step <= 256);
+          [@ inline_let]
+          let inv: t_PolynomialRingElement_b (3328+b) -> int_t usize_inttype -> Type0 = 
+            fun (acc:t_PolynomialRingElement_b (3328+b)) (i:usize) ->
+            (forall k. (v k >= v i /\ v k < v offset + v step) ==> acc.f_coefficients.[k] == orig_re.f_coefficients.[k]) /\
+            (forall k. (v k >= v i + v step) ==> acc.f_coefficients.[k] == orig_re.f_coefficients.[k])
+          in
+          assert (forall k. (v k >= v offset /\ v k < v offset + v step) ==> re.f_coefficients.[k] == orig_re.f_coefficients.[k]);
+          assert (forall k. (v k >= v offset + v step) ==> re.f_coefficients.[k] == orig_re.f_coefficients.[k]);
+          assert (inv re offset);
+      let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (3328+ b) =
+            Rust_primitives.Iterators.foldi_range #usize_inttype #(t_PolynomialRingElement_b (3328+b))  #inv {
                       Core.Ops.Range.f_start = offset;
                       Core.Ops.Range.f_end = offset +! step <: usize
-                    }
-                    <:
-                    Core.Ops.Range.t_Range usize)
-                <:
-                Core.Ops.Range.t_Range usize)
+            }
               re
               (fun re j ->
-                  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
+                  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (3328+b) = re in
                   let j:usize = j in
-                  let t:i32 =
-                    Libcrux.Kem.Kyber.Arithmetic.montgomery_multiply_fe_by_fer (re
-                          .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j +! step <: usize ]
-                        <:
-                        i32)
-                      (v_ZETAS_TIMES_MONTGOMERY_R.[ zeta_i ] <: i32)
-                  in
-                  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+                  assert (re.f_coefficients.[j] == orig_re.f_coefficients.[j]);
+                  assert (re.f_coefficients.[j +! step] == orig_re.f_coefficients.[j +! step]);                      
+                  let re_j:i32_b b = orig_re.f_coefficients.[j] in
+                  let re_j_step:i32_b b = orig_re.f_coefficients.[j +! step] in
+                  let t:i32_b 3328 = mul_zeta_red2 #b orig_zeta_i layer 
+                                     re_j_step round in
+                  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (3328+b) =
                     {
                       re with
                       Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -217,12 +320,12 @@
                       Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                           .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                         (j +! step <: usize)
-                        ((re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ] <: i32) -! t <: i32)
+                        (sub_i32_b #b #3328 re_j_step t)
                     }
                     <:
-                    Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+                    Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (3328+b)
                   in
-                  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+                  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (3328+b) =
                     {
                       re with
                       Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -230,63 +333,70 @@
                       Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                           .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                         j
-                        ((re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ] <: i32) +! t <: i32)
+                        (add_i32_b #b #3328 re_j t)
                     }
                     <:
-                    Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+                    Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (3328+b)
                   in
                   re)
           in
-          re, zeta_i <: (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement & usize))
+          re, zeta_i <: (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (3328+b) & usize))
   in
   let _:Prims.unit = () <: Prims.unit in
-  let hax_temp_output:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
-  zeta_i, hax_temp_output <: (usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+  let hax_temp_output:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (3328+b) = re in
+  assert (v zeta_i = v orig_zeta_i + 128/v step);
+  assert (v zeta_i = v orig_zeta_i + pow2(7 - v layer));
+  assert (v zeta_i = pow2(8 - v layer) - 1);
+  zeta_i, hax_temp_output
+#pop-options
 
-let ntt_at_layer_3_
-      (zeta_i: usize)
-      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-      (layer: usize)
-     =
-  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
-    ntt_at_layer zeta_i re layer (sz 3)
+let ntt_at_layer_3_ #b zeta_i re layer = 
+  let tmp0, out =
+    ntt_at_layer zeta_i re layer (sz 7879)
   in
   let zeta_i:usize = tmp0 in
-  let hax_temp_output:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
-  zeta_i, hax_temp_output <: (usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-
-let ntt_at_layer_3328_
-      (zeta_i: usize)
-      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-      (layer: usize)
-     =
-  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+  let hax_temp_output = out in
+  zeta_i, hax_temp_output
+ 
+let ntt_at_layer_3328_ zeta_i re layer = 
+  let tmp0, out =
     ntt_at_layer zeta_i re layer (sz 3328)
   in
   let zeta_i:usize = tmp0 in
-  let hax_temp_output:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
-  zeta_i, hax_temp_output <: (usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+  let hax_temp_output = out in
+  zeta_i, hax_temp_output
 
-let ntt_binomially_sampled_ring_element (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+#push-options "--ifuel 0 --z3rlimit 1500"
+#restart-solver
+let ntt_binomially_sampled_ring_element re =
   let _:Prims.unit = () <: Prims.unit in
   let zeta_i:usize = sz 1 in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-            usize)
-          ({ Core.Ops.Range.f_start = sz 0; Core.Ops.Range.f_end = sz 128 }
+  [@ inline_let]
+  let inv = fun (acc:(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 11207)) (i:usize) -> 
+             (v i <= 128) /\
+             (forall (j:usize). (v j >= v i /\ v j < 128) ==>
+                i32_range (acc <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 11207).f_coefficients.[j] 7) /\ 
+             (forall (j:usize). (v j >= v i + 128 /\ v j < 256) ==>
+                i32_range (acc <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 11207).f_coefficients.[j] 7)
+          in
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 11207 = cast_poly_b re in
+  assert (inv re (sz 0));
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 11207 =
+      Rust_primitives.Iterators.foldi_range #_ #(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 11207) #inv ({
+              Core.Ops.Range.f_start = sz 0;
+              Core.Ops.Range.f_end = sz 128
+            }
             <:
             Core.Ops.Range.t_Range usize)
-        <:
-        Core.Ops.Range.t_Range usize)
-      re
+      (cast_poly_b re)
       (fun re j ->
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 11207 = cast_poly_b re in
           let j:usize = j in
-          let t:i32 =
-            (re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j +! sz 128 <: usize ] <: i32) *!
-            (-1600l)
+          let t:i32_b (7*1600) =
+            mul_i32_b (re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j +! sz 128 <: usize ])
+                      (-1600l <: i32_b 1600)
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (11207) =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -294,12 +404,10 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 (j +! sz 128 <: usize)
-                ((re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ] <: i32) -! t <: i32)
+                (sub_i32_b #7 #11200 (re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ] <: i32_b 7) t)
             }
-            <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (11207) =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -307,89 +415,77 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 j
-                ((re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ] <: i32) +! t <: i32)
+                (add_i32_b (re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ]) t)
             }
-            <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
           re)
   in
   let _:Prims.unit = () <: Prims.unit in
-  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+  assert (v zeta_i = pow2 (7 - 6) - 1);
+  let zeta_i, re =
     ntt_at_layer_3_ zeta_i re (sz 6)
   in
-  let zeta_i:usize = tmp0 in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
-  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+  let zeta_i, re =
     ntt_at_layer_3_ zeta_i re (sz 5)
   in
-  let zeta_i:usize = tmp0 in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
-  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+  let zeta_i, re =
     ntt_at_layer_3_ zeta_i re (sz 4)
   in
-  let zeta_i:usize = tmp0 in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
-  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+  let zeta_i, re =
     ntt_at_layer_3_ zeta_i re (sz 3)
   in
-  let zeta_i:usize = tmp0 in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
-  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+  let zeta_i, re =
     ntt_at_layer_3_ zeta_i re (sz 2)
   in
-  let zeta_i:usize = tmp0 in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
-  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+  let zeta_i, re =
     ntt_at_layer_3_ zeta_i re (sz 1)
   in
-  let zeta_i:usize = tmp0 in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-            usize)
-          ({
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (6*3328+11207) = re in
+  [@ inline_let]
+  let inv = fun (acc:(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (6*3328+11207))) (i:usize) -> 
+             (v i <= 256) /\
+             (forall (j:usize). (v j < v i) ==>
+                i32_range (acc <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (6*3328+11207)).f_coefficients.[j] 3328)
+  in
+  assert (inv re (sz 0));
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (6*3328+11207) =
+      Rust_primitives.Iterators.foldi_range #_ #(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (6*3328+11207)) #inv ({
               Core.Ops.Range.f_start = sz 0;
               Core.Ops.Range.f_end = Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
             }
             <:
             Core.Ops.Range.t_Range usize)
-        <:
-        Core.Ops.Range.t_Range usize)
       re
       (fun re i ->
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (6*3328+11207) = re in
+          let rei:i32_b (v v_BARRETT_R) = cast_i32_b #(6*3328+11207) #(v v_BARRETT_R) (re
+                      .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ]) in
+          let rei: i32_b (6*3328+11207) = cast_i32_b #3328 #(6*3328+11207) (
+            Libcrux.Kem.Kyber.Arithmetic.barrett_reduce rei) in
           let i:usize = i in
+          let re_coeffs:t_Array (i32_b (6*3328+11207)) (sz 256) =
+            Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
+                .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
+              i rei in
           {
             re with
             Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-            =
-            Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
-                .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-              i
-              (Libcrux.Kem.Kyber.Arithmetic.barrett_reduce (re
-                      .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ]
-                    <:
-                    i32)
-                <:
-                i32)
-            <:
-            t_Array i32 (sz 256)
-          }
-          <:
-          Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+            = re_coeffs
+          })
   in
-  re
+  let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement = down_cast_poly_b #(6*3328+11207) #3328 re in
+  re 
+#pop-options
+
 
-let ntt_multiply (lhs rhs: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+#push-options "--z3rlimit 100"
+let ntt_multiply lhs rhs =
   let _:Prims.unit = () <: Prims.unit in
-  let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+  let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 1 =
     Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
   in
-  let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-            usize)
-          ({
+  let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3328 =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
               Core.Ops.Range.f_start = sz 0;
               Core.Ops.Range.f_end
               =
@@ -399,34 +495,31 @@
             Core.Ops.Range.t_Range usize)
         <:
         Core.Ops.Range.t_Range usize)
-      out
+      (cast_poly_b out)
       (fun out i ->
-          let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
+          let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3328 = out in
           let i:usize = i in
-          let product:(i32 & i32) =
+          assert (v i * 4 + 4 <= 256);
+          let product =
             ntt_multiply_binomials ((lhs.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ sz 4 *! i
                     <:
                     usize ]
                   <:
-                  i32),
+                  i32_b 3328),
                 (lhs.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ (sz 4 *! i <: usize) +! sz 1
                     <:
                     usize ]
                   <:
-                  i32)
-                <:
-                (i32 & i32))
-              ((rhs.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ sz 4 *! i <: usize ] <: i32),
+                  i32_b 3328))
+              ((rhs.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ sz 4 *! i <: usize ] <: i32_b 3328),
                 (rhs.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ (sz 4 *! i <: usize) +! sz 1
                     <:
                     usize ]
                   <:
-                  i32)
-                <:
-                (i32 & i32))
-              (v_ZETAS_TIMES_MONTGOMERY_R.[ sz 64 +! i <: usize ] <: i32)
+                  i32_b 3328))
+              (v_ZETAS_TIMES_MONTGOMERY_R.[ sz 64 +! i <: usize ] <: i32_b 1664)
           in
-          let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3328 =
             {
               out with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -437,9 +530,9 @@
                 product._1
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3328
           in
-          let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3328 =
             {
               out with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -450,41 +543,29 @@
                 product._2
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3328
           in
-          let product:(i32 & i32) =
+          let product =
             ntt_multiply_binomials ((lhs.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ (sz 4 *! i
                       <:
                       usize) +!
                     sz 2
                     <:
-                    usize ]
-                  <:
-                  i32),
+                    usize ]),
                 (lhs.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ (sz 4 *! i <: usize) +! sz 3
                     <:
-                    usize ]
-                  <:
-                  i32)
-                <:
-                (i32 & i32))
+                    usize ]))
+
               ((rhs.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ (sz 4 *! i <: usize) +! sz 2
                     <:
-                    usize ]
-                  <:
-                  i32),
+                    usize ]),
                 (rhs.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ (sz 4 *! i <: usize) +! sz 3
                     <:
-                    usize ]
-                  <:
-                  i32)
-                <:
-                (i32 & i32))
-              (Core.Ops.Arith.Neg.neg (v_ZETAS_TIMES_MONTGOMERY_R.[ sz 64 +! i <: usize ] <: i32)
-                <:
-                i32)
+                    usize ]))
+              (Core.Ops.Arith.Neg.neg (v_ZETAS_TIMES_MONTGOMERY_R.[ sz 64 +! i <: usize ]) <: i32_b 1664)
+
           in
-          let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3328 =
             {
               out with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -495,9 +576,9 @@
                 product._1
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3328
           in
-          let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3328 =
             {
               out with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -508,67 +589,55 @@
                 product._2
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3328
           in
           out)
   in
   out
+#pop-options
 
-let ntt_vector_u
-      (v_VECTOR_U_COMPRESSION_FACTOR: usize)
-      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-     =
+#push-options "--ifuel 0 --z3rlimit 200"
+let ntt_vector_u v_VECTOR_U_COMPRESSION_FACTOR re =
   let _:Prims.unit = () <: Prims.unit in
   let zeta_i:usize = sz 0 in
-  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+  let zeta_i, re =
     ntt_at_layer_3328_ zeta_i re (sz 7)
   in
-  let zeta_i:usize = tmp0 in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
-  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+  let zeta_i, re =
     ntt_at_layer_3328_ zeta_i re (sz 6)
   in
-  let zeta_i:usize = tmp0 in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
-  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+  let zeta_i, re =
     ntt_at_layer_3328_ zeta_i re (sz 5)
   in
-  let zeta_i:usize = tmp0 in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
-  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+  let zeta_i, re =
     ntt_at_layer_3328_ zeta_i re (sz 4)
   in
-  let zeta_i:usize = tmp0 in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
-  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+  let zeta_i, re =
     ntt_at_layer_3328_ zeta_i re (sz 3)
   in
-  let zeta_i:usize = tmp0 in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
-  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+  let zeta_i, re =
     ntt_at_layer_3328_ zeta_i re (sz 2)
   in
-  let zeta_i:usize = tmp0 in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
-  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+  let zeta_i, re =
     ntt_at_layer_3328_ zeta_i re (sz 1)
   in
-  let zeta_i:usize = tmp0 in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-            usize)
-          ({
+  [@ inline_let]
+  let inv = fun (acc:(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (8*3328))) (i:usize) -> 
+             (v i <= 256) /\
+             (forall (j:usize). (v j < v i) ==>
+                i32_range (acc <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (8*3328)).f_coefficients.[j] 3328)
+  in
+  assert (inv re (sz 0));
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (8*3328) =
+      Rust_primitives.Iterators.foldi_range #_ #(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (8*3328)) #inv ({
               Core.Ops.Range.f_start = sz 0;
               Core.Ops.Range.f_end = Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
             }
             <:
             Core.Ops.Range.t_Range usize)
-        <:
-        Core.Ops.Range.t_Range usize)
       re
       (fun re i ->
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (8*3328) = re in
           let i:usize = i in
           {
             re with
@@ -578,15 +647,10 @@
                 .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
               i
               (Libcrux.Kem.Kyber.Arithmetic.barrett_reduce (re
-                      .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ]
-                    <:
-                    i32)
-                <:
-                i32)
-            <:
-            t_Array i32 (sz 256)
+                      .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ]))
           }
           <:
-          Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+          Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (8*3328))
   in
-  re
+  down_cast_poly_b #(8*3328) #3328 re 
+#pop-options
diff -ruN extraction/Libcrux.Kem.Kyber.Ntt.fsti extraction-edited/Libcrux.Kem.Kyber.Ntt.fsti
--- extraction/Libcrux.Kem.Kyber.Ntt.fsti	2024-05-16 17:05:53.694569785 +0200
+++ extraction-edited/Libcrux.Kem.Kyber.Ntt.fsti	2024-05-16 17:05:53.781566866 +0200
@@ -2,282 +2,80 @@
 #set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
 open Core
 open FStar.Mul
+open Libcrux.Kem.Kyber.Arithmetic
 
-let v_ZETAS_TIMES_MONTGOMERY_R: t_Array i32 (sz 128) =
-  let list =
-    [
-      (-1044l); (-758l); (-359l); (-1517l); 1493l; 1422l; 287l; 202l; (-171l); 622l; 1577l; 182l;
-      962l; (-1202l); (-1474l); 1468l; 573l; (-1325l); 264l; 383l; (-829l); 1458l; (-1602l); (-130l);
-      (-681l); 1017l; 732l; 608l; (-1542l); 411l; (-205l); (-1571l); 1223l; 652l; (-552l); 1015l;
-      (-1293l); 1491l; (-282l); (-1544l); 516l; (-8l); (-320l); (-666l); (-1618l); (-1162l); 126l;
-      1469l; (-853l); (-90l); (-271l); 830l; 107l; (-1421l); (-247l); (-951l); (-398l); 961l;
-      (-1508l); (-725l); 448l; (-1065l); 677l; (-1275l); (-1103l); 430l; 555l; 843l; (-1251l); 871l;
-      1550l; 105l; 422l; 587l; 177l; (-235l); (-291l); (-460l); 1574l; 1653l; (-246l); 778l; 1159l;
-      (-147l); (-777l); 1483l; (-602l); 1119l; (-1590l); 644l; (-872l); 349l; 418l; 329l; (-156l);
-      (-75l); 817l; 1097l; 603l; 610l; 1322l; (-1285l); (-1465l); 384l; (-1215l); (-136l); 1218l;
-      (-1335l); (-874l); 220l; (-1187l); (-1659l); (-1185l); (-1530l); (-1278l); 794l; (-1510l);
-      (-854l); (-870l); 478l; (-108l); (-308l); 996l; 991l; 958l; (-1460l); 1522l; 1628l
-    ]
-  in
-  FStar.Pervasives.assert_norm (Prims.eq2 (List.Tot.length list) 128);
-  Rust_primitives.Hax.array_of_list 128 list
+val v_ZETAS_TIMES_MONTGOMERY_R: x:t_Array (i32_b 1664) (sz 128){v (x.[sz 1] <: i32) == -758}
 
-/// Compute the product of two Kyber binomials with respect to the
-/// modulus `X² - zeta`.
-/// This function almost implements <strong>Algorithm 11</strong> of the
-/// NIST FIPS 203 standard, which is reproduced below:
-/// ```plaintext
-/// Input:  a₀, a₁, b₀, b₁ ∈ ℤq.
-/// Input: γ ∈ ℤq.
-/// Output: c₀, c₁ ∈ ℤq.
-/// c₀ ← a₀·b₀ + a₁·b₁·γ
-/// c₁ ← a₀·b₁ + a₁·b₀
-/// return c₀, c₁
-/// ```
-/// We say "almost" because the coefficients output by this function are in
-/// the Montgomery domain (unlike in the specification).
-/// The NIST FIPS 203 standard can be found at
-/// <https://csrc.nist.gov/pubs/fips/203/ipd>.
-val ntt_multiply_binomials: (i32 & i32) -> (i32 & i32) -> zeta: i32
-  -> Prims.Pure (i32 & i32) Prims.l_True (fun _ -> Prims.l_True)
-
-val invert_ntt_at_layer
-      (zeta_i: usize)
-      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-      (layer: usize)
-    : Prims.Pure (usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-      Prims.l_True
-      (fun _ -> Prims.l_True)
-
-/// Use the Gentleman-Sande butterfly to invert, in-place, the NTT representation
-/// of a `KyberPolynomialRingElement`. The coefficients of the output
-/// ring element are in the Montgomery domain.
-val invert_ntt_montgomery (v_K: usize) (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
-      Prims.l_True
-      (fun _ -> Prims.l_True)
-
-/// Represents an intermediate polynomial splitting step in the NTT. All
-/// resulting coefficients are in the normal domain since the zetas have been
-/// multiplied by MONTGOMERY_R.
-val ntt_at_layer
-      (zeta_i: usize)
-      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-      (layer v__initial_coefficient_bound: usize)
-    : Prims.Pure (usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+val ntt_multiply_binomials (a:wfFieldElement&wfFieldElement) (b: wfFieldElement&wfFieldElement) (zeta: i32_b 1664) :
+    Pure (wfFieldElement & wfFieldElement)
+    (requires True)
+    (ensures (fun _ -> True))
+
+val invert_ntt_at_layer (#v_K:usize{v v_K >= 1 /\ v v_K <= 4})
+      (#b:nat{b <= v v_K * 3328 * 64})
+      (zeta_i: usize{v zeta_i >= 1 /\ v zeta_i <= 128})
+      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b b)
+      (layer: usize{v layer > 0 /\ 
+                    v layer <= 7 /\ 
+                    v zeta_i == pow2 (8 - v layer) /\ 
+                    b == v v_K * 3328 * pow2(v layer - 1)})
+    : Prims.Pure (usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (2*b))
       Prims.l_True
-      (fun _ -> Prims.l_True)
+      (fun x -> let (zeta_fin,re) = x in v zeta_fin == pow2 (7 - v layer))
 
-/// See [`ntt_at_layer`].
-val ntt_at_layer_3_
-      (zeta_i: usize)
-      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-      (layer: usize)
-    : Prims.Pure (usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+val invert_ntt_montgomery (v_K: usize{v v_K >= 1 /\ v v_K <= 4}) 
+      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328))
+    : Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64 * v v_K * 3328)
+
+val ntt_at_layer 
+      (#b:nat{b <= 31175})
+      (zeta_i: usize{v zeta_i < 128})
+      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b b)
+      (layer: usize{v layer > 0 /\ 
+                    v layer <= 7 /\ 
+                    v zeta_i == pow2 (7 - v layer) - 1})
+      (initial_coefficient_bound: usize{b == (7 - v layer) * 3328 + v initial_coefficient_bound})
+    : Pure (usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (3328+b))
+      (requires True)
+      (ensures fun (zeta_i, result) -> v zeta_i == pow2 (8 - v layer) - 1)
+
+val ntt_at_layer_3_ (#b:nat)
+      (zeta_i: usize{v zeta_i < 128})
+      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b b)
+      (layer: usize{v layer > 0 /\ 
+                    v layer <= 6 /\ 
+                    v zeta_i == pow2 (7 - v layer) - 1 /\
+                    b == (6 - v layer) * 3328 + 11207})
+    : Prims.Pure (usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (3328+b))
       Prims.l_True
-      (fun _ -> Prims.l_True)
+      (ensures fun (zeta_i,result) -> v zeta_i == pow2 (8 - v layer) - 1)
 
-/// See [`ntt_at_layer`].
-val ntt_at_layer_3328_
-      (zeta_i: usize)
-      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-      (layer: usize)
-    : Prims.Pure (usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+val ntt_at_layer_3328_ (#b:nat{b <= 7*3328})
+      (zeta_i: usize{v zeta_i < 128})
+      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b b)
+      (layer: usize{v layer > 0 /\ 
+                    v layer <= 7 /\ 
+                    v zeta_i == pow2 (7 - v layer) - 1  /\
+                    b == (7 - v layer) * 3328 + 3328})
+    : Prims.Pure (usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (3328+b))
       Prims.l_True
-      (fun _ -> Prims.l_True)
-
-/// Use the Cooley–Tukey butterfly to compute an in-place NTT representation
-/// of a `KyberPolynomialRingElement`.
-/// This function operates only on those which were produced by binomial
-/// sampling, and thus those which have small coefficients. The small
-/// coefficients let us skip the first round of Montgomery reductions.
-val ntt_binomially_sampled_ring_element (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
-      (requires
-        Hax_lib.v_forall #usize
-          (fun i ->
-              let i:usize = i in
-              Hax_lib.implies (i <.
-                  (Core.Slice.impl__len #i32
-                      (Rust_primitives.unsize re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                        <:
-                        t_Slice i32)
-                    <:
-                    usize)
-                  <:
-                  bool)
-                (fun temp_0_ ->
-                    let _:Prims.unit = temp_0_ in
-                    (Core.Num.impl__i32__abs (re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ]
-                          <:
-                          i32)
-                      <:
-                      i32) <=.
-                    3l
-                    <:
-                    bool)
-              <:
-              bool))
-      (ensures
-        fun result ->
-          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = result in
-          Hax_lib.v_forall #usize
-            (fun i ->
-                let i:usize = i in
-                Hax_lib.implies (i <.
-                    (Core.Slice.impl__len #i32
-                        (Rust_primitives.unsize result.Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                          <:
-                          t_Slice i32)
-                      <:
-                      usize)
-                    <:
-                    bool)
-                  (fun temp_0_ ->
-                      let _:Prims.unit = temp_0_ in
-                      (Core.Num.impl__i32__abs (result.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[
-                              i ]
-                            <:
-                            i32)
-                        <:
-                        i32) <.
-                      Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS
-                      <:
-                      bool)
-                <:
-                bool))
+      (ensures fun (zeta_i,result) -> v zeta_i == pow2 (8 - v layer) - 1)
 
-/// Given two `KyberPolynomialRingElement`s in their NTT representations,
-/// compute their product. Given two polynomials in the NTT domain `f^` and `ĵ`,
-/// the `iᵗʰ` coefficient of the product `k\u{302}` is determined by the calculation:
-/// ```plaintext
-/// ĥ[2·i] + ĥ[2·i + 1]X = (f^[2·i] + f^[2·i + 1]X)·(ĝ[2·i] + ĝ[2·i + 1]X) mod (X² - ζ^(2·BitRev₇(i) + 1))
-/// ```
-/// This function almost implements <strong>Algorithm 10</strong> of the
-/// NIST FIPS 203 standard, which is reproduced below:
-/// ```plaintext
-/// Input: Two arrays fˆ ∈ ℤ₂₅₆ and ĝ ∈ ℤ₂₅₆.
-/// Output: An array ĥ ∈ ℤq.
-/// for(i ← 0; i < 128; i++)
-///     (ĥ[2i], ĥ[2i+1]) ← BaseCaseMultiply(fˆ[2i], fˆ[2i+1], ĝ[2i], ĝ[2i+1], ζ^(2·BitRev₇(i) + 1))
-/// end for
-/// return ĥ
-/// ```
-/// We say \"almost\" because the coefficients of the ring element output by
-/// this function are in the Montgomery domain.
-/// The NIST FIPS 203 standard can be found at
-/// <https://csrc.nist.gov/pubs/fips/203/ipd>.
-val ntt_multiply (lhs rhs: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
-      (requires
-        Hax_lib.v_forall #usize
-          (fun i ->
-              let i:usize = i in
-              Hax_lib.implies (i <. Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
-                  <:
-                  bool)
-                (fun temp_0_ ->
-                    let _:Prims.unit = temp_0_ in
-                    ((lhs.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ] <: i32) >=. 0l <: bool) &&
-                    ((lhs.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ] <: i32) <. 4096l <: bool
-                    ) &&
-                    ((Core.Num.impl__i32__abs (rhs.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ]
-                            <:
-                            i32)
-                        <:
-                        i32) <=.
-                      Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS
-                      <:
-                      bool))
-              <:
-              bool))
-      (ensures
-        fun result ->
-          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = result in
-          Hax_lib.v_forall #usize
-            (fun i ->
-                let i:usize = i in
-                Hax_lib.implies (i <.
-                    (Core.Slice.impl__len #i32
-                        (Rust_primitives.unsize result.Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                          <:
-                          t_Slice i32)
-                      <:
-                      usize)
-                    <:
-                    bool)
-                  (fun temp_0_ ->
-                      let _:Prims.unit = temp_0_ in
-                      (Core.Num.impl__i32__abs (result.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[
-                              i ]
-                            <:
-                            i32)
-                        <:
-                        i32) <=.
-                      Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS
-                      <:
-                      bool)
-                <:
-                bool))
-
-/// Use the Cooley–Tukey butterfly to compute an in-place NTT representation
-/// of a `KyberPolynomialRingElement`.
-/// This function operates on the ring element that partly constitutes
-/// the ciphertext.
+val ntt_binomially_sampled_ring_element (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 7)
+    : Prims.Pure (Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+      (requires True)
+      (ensures (fun _ -> True))
+
+val ntt_multiply (lhs: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3328)
+                 (rhs: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3328)
+    : Prims.Pure (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3328)
+      (requires True)
+      (ensures (fun _ -> True))
+    
 val ntt_vector_u
       (v_VECTOR_U_COMPRESSION_FACTOR: usize)
-      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
-      (requires
-        Hax_lib.v_forall #usize
-          (fun i ->
-              let i:usize = i in
-              Hax_lib.implies (i <.
-                  (Core.Slice.impl__len #i32
-                      (Rust_primitives.unsize re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                        <:
-                        t_Slice i32)
-                    <:
-                    usize)
-                  <:
-                  bool)
-                (fun temp_0_ ->
-                    let _:Prims.unit = temp_0_ in
-                    (Core.Num.impl__i32__abs (re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ]
-                          <:
-                          i32)
-                      <:
-                      i32) <=.
-                    3328l
-                    <:
-                    bool)
-              <:
-              bool))
-      (ensures
-        fun result ->
-          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = result in
-          Hax_lib.v_forall #usize
-            (fun i ->
-                let i:usize = i in
-                Hax_lib.implies (i <.
-                    (Core.Slice.impl__len #i32
-                        (Rust_primitives.unsize result.Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                          <:
-                          t_Slice i32)
-                      <:
-                      usize)
-                    <:
-                    bool)
-                  (fun temp_0_ ->
-                      let _:Prims.unit = temp_0_ in
-                      (Core.Num.impl__i32__abs (result.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[
-                              i ]
-                            <:
-                            i32)
-                        <:
-                        i32) <.
-                      Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS
-                      <:
-                      bool)
-                <:
-                bool))
+      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3328)
+    : Prims.Pure (Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+      (requires True)
+      (ensures fun _ -> True)
+
diff -ruN extraction/Libcrux.Kem.Kyber.Sampling.fst extraction-edited/Libcrux.Kem.Kyber.Sampling.fst
--- extraction/Libcrux.Kem.Kyber.Sampling.fst	2024-05-16 17:05:53.700569583 +0200
+++ extraction-edited/Libcrux.Kem.Kyber.Sampling.fst	2024-05-16 17:05:53.786566698 +0200
@@ -3,26 +3,34 @@
 open Core
 open FStar.Mul
 
+let rejection_sampling_panic_with_diagnostic () : Prims.unit =
+  admit(); // This should never be reachable
+  Rust_primitives.Hax.never_to_any (Core.Panicking.panic "explicit panic"
+      <:
+      Rust_primitives.Hax.t_Never)
+
+#push-options "--ifuel 0 --z3rlimit 100"
 let sample_from_binomial_distribution_2_ (randomness: t_Slice u8) =
-  let (sampled: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement):Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
-  =
-    Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
+  let sampled: t_PolynomialRingElement_b 3 = 
+    cast_poly_b Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
   in
-  let sampled:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Iter.Adapters.Enumerate.t_Enumerate
-            (Core.Slice.Iter.t_ChunksExact u8))
-          (Core.Iter.Traits.Iterator.f_enumerate #(Core.Slice.Iter.t_ChunksExact u8)
-              (Core.Slice.impl__chunks_exact #u8 randomness (sz 4)
-                <:
-                Core.Slice.Iter.t_ChunksExact u8)
-            <:
-            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
-        <:
-        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
+
+  let acc_t = Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3 in
+  [@ inline_let]
+  let inv = fun (acc:acc_t) (i:usize) -> True in
+  let sl : t_Slice u8 = randomness in
+  let chunk_len = sz 4 in
+  assert (v (length sl) == 128);
+  assert (Seq.length sl == 128);
+  assert_norm (128 % 4 == 0);
+  let sampled =
+   Rust_primitives.Iterators.foldi_chunks_exact #u8 #acc_t #inv
+      sl
+      chunk_len
       sampled
       (fun sampled temp_1_ ->
-          let sampled:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = sampled in
-          let chunk_number, byte_chunk:(usize & t_Slice u8) = temp_1_ in
+          let chunk_number, byte_chunk:(usize & t_Array u8 chunk_len) = temp_1_ in
+          assert(chunk_number <. sz 32);
           let (random_bits_as_u32: u32):u32 =
             (((cast (byte_chunk.[ sz 0 ] <: u8) <: u32) |.
                 ((cast (byte_chunk.[ sz 1 ] <: u8) <: u32) <<! 8l <: u32)
@@ -34,36 +42,58 @@
             ((cast (byte_chunk.[ sz 3 ] <: u8) <: u32) <<! 24l <: u32)
           in
           let even_bits:u32 = random_bits_as_u32 &. 1431655765ul in
+          logand_lemma random_bits_as_u32 1431655765ul;
+          assert(even_bits <=. 1431655765ul);
           let odd_bits:u32 = (random_bits_as_u32 >>! 1l <: u32) &. 1431655765ul in
+          logand_lemma (random_bits_as_u32 >>! 1l <: u32) 1431655765ul;
+          assert(odd_bits <=. 1431655765ul);
           let coin_toss_outcomes:u32 = even_bits +! odd_bits in
-          Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Iter.Adapters.Step_by.t_StepBy
-                  (Core.Ops.Range.t_Range u32))
-                (Core.Iter.Traits.Iterator.f_step_by #(Core.Ops.Range.t_Range u32)
-                    ({
+          let acc_t = Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3 in
+          [@ inline_let]
+          let inv : acc_t -> u32 -> Type = fun acc i -> True in
+            Rust_primitives.Iterators.foldi_range_step_by #u32_inttype #(acc_t) #inv ({
                         Core.Ops.Range.f_start = 0ul;
                         Core.Ops.Range.f_end = Core.Num.impl__u32__BITS
-                      }
-                      <:
-                      Core.Ops.Range.t_Range u32)
-                    (sz 4)
-                  <:
-                  Core.Iter.Adapters.Step_by.t_StepBy (Core.Ops.Range.t_Range u32))
-              <:
-              Core.Iter.Adapters.Step_by.t_StepBy (Core.Ops.Range.t_Range u32))
+                        }
+                        <:
+                        Core.Ops.Range.t_Range u32)
+            (sz 4)
             sampled
             (fun sampled outcome_set ->
-                let sampled:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = sampled in
                 let outcome_set:u32 = outcome_set in
+                assert (v outcome_set + 4 <= 32);
+                let out_1 = ((coin_toss_outcomes >>! outcome_set <: u32) &. 3ul <: u32) in
                 let outcome_1_:i32 =
-                  cast ((coin_toss_outcomes >>! outcome_set <: u32) &. 3ul <: u32) <: i32
+                  cast out_1  <: i32
                 in
+                let out_2 = ((coin_toss_outcomes >>! (outcome_set +! 2ul <: u32) <: u32) &. 3ul <: u32) in
                 let outcome_2_:i32 =
-                  cast ((coin_toss_outcomes >>! (outcome_set +! 2ul <: u32) <: u32) &. 3ul <: u32)
-                  <:
-                  i32
+                  cast out_2  <: i32
                 in
+                logand_lemma (coin_toss_outcomes >>! outcome_set <: u32) 3ul;
+                assert (v out_1 >= 0);
+                assert (v out_1 <= 3);
+                assert (v outcome_1_ == v out_1 @% pow2 32);
+                Math.Lemmas.small_modulo_lemma_1 (v out_1) (pow2 32);
+                assert (v outcome_1_ == v out_1);
+                assert (v outcome_1_ >= 0 /\ v outcome_1_ <= 3);
+                logand_lemma (coin_toss_outcomes >>! (outcome_set +! 2ul <: u32) <: u32) 3ul;
+                assert (v out_2 >= 0);
+                assert (v out_2 <= 3);
+                assert (v outcome_2_ == v out_2 @% pow2 32);
+                Math.Lemmas.small_modulo_lemma_1 (v out_2) (pow2 32);
+                assert (v outcome_2_ == v out_2);
+                assert (v outcome_2_ >= 0 /\ v outcome_2_ <= 3);
                 let offset:usize = cast (outcome_set >>! 2l <: u32) <: usize in
-                let sampled:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+                assert (outcome_set <. 32ul);
+                assert (v (outcome_set >>! 2l <: u32) = v outcome_set / 4);
+                assert (v (outcome_set >>! 2l <: u32) < 8);
+                Math.Lemmas.small_modulo_lemma_1 (v (outcome_set >>! 2l <: u32)) (pow2 32);
+                Math.Lemmas.small_modulo_lemma_1 (v (outcome_set >>! 2l <: u32)) (pow2 64);
+                assert (v offset < 8);
+                assert (8 * v chunk_number + 8 <= 256);
+                assert (8 * v chunk_number + v offset < 256);
+                let sampled:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3 =
                   {
                     sampled with
                     Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -74,33 +104,36 @@
                       (outcome_1_ -! outcome_2_ <: i32)
                   }
                   <:
-                  Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+                  Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3
                 in
                 sampled))
-  in
-  let _:Prims.unit = () <: Prims.unit in
-  sampled
+  in 
+  let _:Prims.unit = () <: Prims.unit in 
+  admit(); // P-F
+  sampled 
+#pop-options
 
+#push-options "--ifuel 0 --z3rlimit 200"
 let sample_from_binomial_distribution_3_ (randomness: t_Slice u8) =
-  let (sampled: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement):Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
-  =
-    Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
+  let sampled:t_PolynomialRingElement_b 7 =
+    (Libcrux.Kem.Kyber.Arithmetic.cast_poly_b Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO)
   in
-  let sampled:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Iter.Adapters.Enumerate.t_Enumerate
-            (Core.Slice.Iter.t_ChunksExact u8))
-          (Core.Iter.Traits.Iterator.f_enumerate #(Core.Slice.Iter.t_ChunksExact u8)
-              (Core.Slice.impl__chunks_exact #u8 randomness (sz 3)
-                <:
-                Core.Slice.Iter.t_ChunksExact u8)
-            <:
-            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
-        <:
-        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
+  let acc_t = Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 7 in
+  [@ inline_let]
+  let inv = fun (acc:acc_t) (i:usize) -> True in
+  let sl : t_Slice u8 = randomness in
+  let chunk_len = sz 3 in
+  assert (v (length sl) == 192);
+  assert (Seq.length sl == 192);
+  assert_norm (192 % 3 == 0);
+  let sampled:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 7 =
+   Rust_primitives.Iterators.foldi_chunks_exact #u8 #acc_t #inv
+      sl
+      chunk_len
       sampled
       (fun sampled temp_1_ ->
-          let sampled:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = sampled in
-          let chunk_number, byte_chunk:(usize & t_Slice u8) = temp_1_ in
+          let sampled:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 7 = sampled in
+          let chunk_number, byte_chunk:(usize & t_Array u8 chunk_len) = temp_1_ in
           let (random_bits_as_u24: u32):u32 =
             ((cast (byte_chunk.[ sz 0 ] <: u8) <: u32) |.
               ((cast (byte_chunk.[ sz 1 ] <: u8) <: u32) <<! 8l <: u32)
@@ -109,23 +142,28 @@
             ((cast (byte_chunk.[ sz 2 ] <: u8) <: u32) <<! 16l <: u32)
           in
           let first_bits:u32 = random_bits_as_u24 &. 2396745ul in
+          logand_lemma random_bits_as_u24 2396745ul;
+          assert (first_bits <=. 2396745ul);
           let second_bits:u32 = (random_bits_as_u24 >>! 1l <: u32) &. 2396745ul in
+          logand_lemma (random_bits_as_u24 >>! 1l <: u32) 2396745ul;
+          assert (second_bits <=. 2396745ul);
           let third_bits:u32 = (random_bits_as_u24 >>! 2l <: u32) &. 2396745ul in
+          logand_lemma (random_bits_as_u24 >>! 2l <: u32) 2396745ul;
+          assert (third_bits <=. 2396745ul);
           let coin_toss_outcomes:u32 = (first_bits +! second_bits <: u32) +! third_bits in
-          Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Iter.Adapters.Step_by.t_StepBy
-                  (Core.Ops.Range.t_Range i32))
-                (Core.Iter.Traits.Iterator.f_step_by #(Core.Ops.Range.t_Range i32)
-                    ({ Core.Ops.Range.f_start = 0l; Core.Ops.Range.f_end = 24l }
-                      <:
-                      Core.Ops.Range.t_Range i32)
-                    (sz 6)
-                  <:
-                  Core.Iter.Adapters.Step_by.t_StepBy (Core.Ops.Range.t_Range i32))
-              <:
-              Core.Iter.Adapters.Step_by.t_StepBy (Core.Ops.Range.t_Range i32))
+          let acc_t = Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 7 in
+          [@ inline_let]
+          let inv : acc_t -> i32 -> Type = fun acc i -> True in
+            Rust_primitives.Iterators.foldi_range_step_by #i32_inttype #(acc_t) #inv ({
+                        Core.Ops.Range.f_start = 0l;
+                        Core.Ops.Range.f_end = 24l
+                        }
+                        <:
+                        Core.Ops.Range.t_Range i32)
+            (sz 6)
             sampled
             (fun sampled outcome_set ->
-                let sampled:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = sampled in
+                let sampled:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 7 = sampled in
                 let outcome_set:i32 = outcome_set in
                 let outcome_1_:i32 =
                   cast ((coin_toss_outcomes >>! outcome_set <: u32) &. 7ul <: u32) <: i32
@@ -135,8 +173,22 @@
                   <:
                   i32
                 in
+                logand_lemma (coin_toss_outcomes >>! outcome_set <: u32) 7ul;
+                Math.Lemmas.small_modulo_lemma_1 (v ((coin_toss_outcomes >>! outcome_set <: u32) &. 7ul <: u32)) (pow2 32);
+                assert (v outcome_1_ >= 0 /\ v outcome_1_ <= 7);
+                logand_lemma (coin_toss_outcomes >>! (outcome_set +! 3l <: i32) <: u32) 7ul;
+                Math.Lemmas.small_modulo_lemma_1 (v ((coin_toss_outcomes >>! (outcome_set +! 3l <: i32) <: u32) &. 7ul <: u32)) (pow2 32);
+                assert (v outcome_2_ >= 0 /\ v outcome_2_ <= 7);
                 let offset:usize = cast (outcome_set /! 6l <: i32) <: usize in
-                let sampled:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+                assert (outcome_set <. 24l);
+                assert (v (outcome_set /! 6l <: i32) = v outcome_set / 6);
+                assert (v (outcome_set /! 6l <: i32) < 4);
+                Math.Lemmas.small_modulo_lemma_1 (v (outcome_set /! 6l <: i32)) (pow2 32);
+                Math.Lemmas.small_modulo_lemma_1 (v (outcome_set /! 6l <: i32)) (pow2 64);
+                assert (v offset < 4);
+                assert (4 * v chunk_number + 4 <= 256);
+                assert (4 * v chunk_number + v offset < 256);
+                let sampled:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 7 =
                   {
                     sampled with
                     Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -147,15 +199,18 @@
                       (outcome_1_ -! outcome_2_ <: i32)
                   }
                   <:
-                  Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+                  Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 7
                 in
                 sampled))
   in
   let _:Prims.unit = () <: Prims.unit in
+  admit();
   sampled
+#pop-options
 
 let sample_from_binomial_distribution (v_ETA: usize) (randomness: t_Slice u8) =
   let _:Prims.unit = () <: Prims.unit in
+  Rust_primitives.Integers.mk_int_equiv_lemma #u32_inttype (v v_ETA);
   match cast (v_ETA <: usize) <: u32 with
   | 2ul -> sample_from_binomial_distribution_2_ randomness
   | 3ul -> sample_from_binomial_distribution_3_ randomness
@@ -165,227 +220,131 @@
         <:
         Rust_primitives.Hax.t_Never)
 
-let sample_from_uniform_distribution_next
-      (v_K v_N: usize)
-      (randomness: t_Array (t_Array u8 v_N) v_K)
-      (sampled_coefficients: t_Array usize v_K)
-      (out: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-     =
-  let done:bool = true in
-  let done, out, sampled_coefficients:(bool &
-    t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-    t_Array usize v_K) =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-            usize)
-          ({ Core.Ops.Range.f_start = sz 0; Core.Ops.Range.f_end = v_K }
-            <:
-            Core.Ops.Range.t_Range usize)
-        <:
-        Core.Ops.Range.t_Range usize)
+#push-options "--z3rlimit 50"
+let sample_from_uniform_distribution (randomness: t_Array u8 (sz 840)) =
+  let (sampled_coefficients: usize):usize = sz 0 in
+  let (out: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement):Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+  =
+    Libcrux.Kem.Kyber.Arithmetic.cast_poly_b Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
+  in
+  let done:bool = false in
+  let acc_t = (bool & Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement & usize) in
+  [@ inline_let]
+  let inv = fun (acc:acc_t) -> True in
+  let sl : t_Slice u8 = randomness in
+  let chunk_len = sz 3 in
+  let done, out, sampled_coefficients:(bool & Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement &
+    usize) =
+   Rust_primitives.Iterators.fold_chunks_exact #u8 #acc_t #inv
+      sl
+      chunk_len
       (done, out, sampled_coefficients
         <:
-        (bool & t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K & t_Array usize v_K
-        ))
-      (fun temp_0_ i ->
+        (bool & Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement & usize))
+      (fun temp_0_ bytes ->
           let done, out, sampled_coefficients:(bool &
-            t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-            t_Array usize v_K) =
+            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement &
+            usize) =
             temp_0_
           in
-          let i:usize = i in
-          let out, sampled_coefficients:(t_Array
-              Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-            t_Array usize v_K) =
-            Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Slice.Iter.t_Chunks
-                    u8)
-                  (Core.Slice.impl__chunks #u8
-                      (Rust_primitives.unsize (randomness.[ i ] <: t_Array u8 v_N) <: t_Slice u8)
-                      (sz 3)
-                    <:
-                    Core.Slice.Iter.t_Chunks u8)
+          let bytes:t_Array u8 chunk_len = bytes in
+          if ~.done <: bool
+          then
+            let b1:i32 = cast (bytes.[ sz 0 ] <: u8) <: i32 in
+            let b2:i32 = cast (bytes.[ sz 1 ] <: u8) <: i32 in
+            let b3:i32 = cast (bytes.[ sz 2 ] <: u8) <: i32 in
+            assert(v b1 >= 0 /\ v b1 < pow2 8);
+            assert(v b2 >= 0 /\ v b2 < pow2 8);
+            assert(v b3 >= 0 /\ v b3 < pow2 8);
+            let d1:i32 = ((b2 &. 15l <: i32) <<! 8l <: i32) |. b1 in
+            assert (15 = pow2 4 - 1);
+            mk_int_equiv_lemma #i32_inttype 15;
+            assert (15l = mk_int (pow2 4) -! mk_int 1);
+            logand_mask_lemma b2 4;
+            assert (v ((b2 &. 15l <: i32) <<! 8l <: i32) == (v b2 % 16) * pow2 8);
+            logor_lemma ((b2 &. 15l <: i32) <<! 8l <: i32) b1;
+            assert (v d1 >= v b1);
+            assert (v d1 >= 0);
+            let d2:i32 = (b3 <<! 4l <: i32) |. (b2 >>! 4l <: i32) in
+            logor_lemma (b3 <<! 4l <: i32) (b2 >>! 4l <: i32);
+            assert (v d2 >= v b3 * pow2 4);
+            assert (v d2 >= 0);
+            let out, sampled_coefficients:(Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement &
+              usize) =
+              if
+                d1 <. Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS &&
+                sampled_coefficients <. Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
+              then
+                let out:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+                  {
+                    out with
+                    Libcrux.Kem.Kyber.Arithmetic.f_coefficients
+                    =
+                    Rust_primitives.Hax.Monomorphized_update_at.update_at_usize out
+                        .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
+                      sampled_coefficients
+                      d1
+                  }
+                  <:
+                  Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+                in
+                out, sampled_coefficients +! sz 1
                 <:
-                Core.Slice.Iter.t_Chunks u8)
-              (out, sampled_coefficients
+                (Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement & usize)
+              else
+                out, sampled_coefficients
                 <:
-                (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-                  t_Array usize v_K))
-              (fun temp_0_ bytes ->
-                  let out, sampled_coefficients:(t_Array
-                      Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-                    t_Array usize v_K) =
-                    temp_0_
-                  in
-                  let bytes:t_Slice u8 = bytes in
-                  let b1:i32 = cast (bytes.[ sz 0 ] <: u8) <: i32 in
-                  let b2:i32 = cast (bytes.[ sz 1 ] <: u8) <: i32 in
-                  let b3:i32 = cast (bytes.[ sz 2 ] <: u8) <: i32 in
-                  let d1:i32 = ((b2 &. 15l <: i32) <<! 8l <: i32) |. b1 in
-                  let d2:i32 = (b3 <<! 4l <: i32) |. (b2 >>! 4l <: i32) in
-                  let out, sampled_coefficients:(t_Array
-                      Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-                    t_Array usize v_K) =
-                    if
-                      d1 <. Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS &&
-                      (sampled_coefficients.[ i ] <: usize) <.
-                      Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
-                    then
-                      let out:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-                        Rust_primitives.Hax.Monomorphized_update_at.update_at_usize out
-                          i
-                          ({
-                              (out.[ i ] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) with
-                              Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                              =
-                              Rust_primitives.Hax.Monomorphized_update_at.update_at_usize (out.[ i ]
-                                  <:
-                                  Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-                                  .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                                (sampled_coefficients.[ i ] <: usize)
-                                d1
-                              <:
-                              t_Array i32 (sz 256)
-                            }
-                            <:
-                            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-                      in
-                      out,
-                      Rust_primitives.Hax.Monomorphized_update_at.update_at_usize sampled_coefficients
-                        i
-                        ((sampled_coefficients.[ i ] <: usize) +! sz 1 <: usize)
-                      <:
-                      (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-                        t_Array usize v_K)
-                    else
-                      out, sampled_coefficients
-                      <:
-                      (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-                        t_Array usize v_K)
-                  in
-                  if
-                    d2 <. Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS &&
-                    (sampled_coefficients.[ i ] <: usize) <.
-                    Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
-                  then
-                    let out:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-                      Rust_primitives.Hax.Monomorphized_update_at.update_at_usize out
-                        i
-                        ({
-                            (out.[ i ] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) with
-                            Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                            =
-                            Rust_primitives.Hax.Monomorphized_update_at.update_at_usize (out.[ i ]
-                                <:
-                                Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-                                .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                              (sampled_coefficients.[ i ] <: usize)
-                              d2
-                            <:
-                            t_Array i32 (sz 256)
-                          }
-                          <:
-                          Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-                    in
-                    let sampled_coefficients:t_Array usize v_K =
-                      Rust_primitives.Hax.Monomorphized_update_at.update_at_usize sampled_coefficients
-                        i
-                        ((sampled_coefficients.[ i ] <: usize) +! sz 1 <: usize)
-                    in
-                    out, sampled_coefficients
-                    <:
-                    (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-                      t_Array usize v_K)
-                  else
-                    out, sampled_coefficients
-                    <:
-                    (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-                      t_Array usize v_K))
-          in
-          if
-            (sampled_coefficients.[ i ] <: usize) <.
-            Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
-          then
-            false, out, sampled_coefficients
-            <:
-            (bool & t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-              t_Array usize v_K)
+                (Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement & usize)
+            in
+            let out, sampled_coefficients:(Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement &
+              usize) =
+              if
+                d2 <. Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS &&
+                sampled_coefficients <. Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
+              then
+                let out:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+                  {
+                    out with
+                    Libcrux.Kem.Kyber.Arithmetic.f_coefficients
+                    =
+                    Rust_primitives.Hax.Monomorphized_update_at.update_at_usize out
+                        .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
+                      sampled_coefficients
+                      d2
+                  }
+                  <:
+                  Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+                in
+                let sampled_coefficients:usize = sampled_coefficients +! sz 1 in
+                out, sampled_coefficients
+                <:
+                (Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement & usize)
+              else
+                out, sampled_coefficients
+                <:
+                (Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement & usize)
+            in
+            if sampled_coefficients =. Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
+            then
+              let done:bool = true in
+              done, out, sampled_coefficients
+              <:
+              (bool & Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement & usize)
+            else
+              done, out, sampled_coefficients
+              <:
+              (bool & Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement & usize)
           else
             done, out, sampled_coefficients
             <:
-            (bool & t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-              t_Array usize v_K))
+            (bool & Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement & usize))
   in
-  let hax_temp_output:bool = done in
-  sampled_coefficients, out, hax_temp_output
-  <:
-  (t_Array usize v_K & t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K & bool)
-
-let sample_from_xof (v_K: usize) (seeds: t_Array (t_Array u8 (sz 34)) v_K) =
-  let (sampled_coefficients: t_Array usize v_K):t_Array usize v_K =
-    Rust_primitives.Hax.repeat (sz 0) v_K
-  in
-  let (out: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K):t_Array
-    Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-    Rust_primitives.Hax.repeat Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO v_K
-  in
-  let xof_state:Libcrux.Digest.Incremental_x4.t_Shake128StateX4 =
-    Libcrux.Kem.Kyber.Hash_functions.absorb v_K seeds
-  in
-  let tmp0, out1:(Libcrux.Digest.Incremental_x4.t_Shake128StateX4 &
-    t_Array (t_Array u8 (sz 504)) v_K) =
-    Libcrux.Kem.Kyber.Hash_functions.squeeze_three_blocks v_K xof_state
-  in
-  let xof_state:Libcrux.Digest.Incremental_x4.t_Shake128StateX4 = tmp0 in
-  let randomness:t_Array (t_Array u8 (sz 504)) v_K = out1 in
-  let tmp0, tmp1, out1:(t_Array usize v_K &
-    t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-    bool) =
-    sample_from_uniform_distribution_next v_K (sz 504) randomness sampled_coefficients out
-  in
-  let sampled_coefficients:t_Array usize v_K = tmp0 in
-  let out:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K = tmp1 in
-  let done:bool = out1 in
-  let done, out, sampled_coefficients, xof_state:(bool &
-    t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-    t_Array usize v_K &
-    Libcrux.Digest.Incremental_x4.t_Shake128StateX4) =
-    Rust_primitives.f_while_loop (fun temp_0_ ->
-          let done, out, sampled_coefficients, xof_state:(bool &
-            t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-            t_Array usize v_K &
-            Libcrux.Digest.Incremental_x4.t_Shake128StateX4) =
-            temp_0_
-          in
-          ~.done <: bool)
-      (done, out, sampled_coefficients, xof_state
-        <:
-        (bool & t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K & t_Array usize v_K &
-          Libcrux.Digest.Incremental_x4.t_Shake128StateX4))
-      (fun temp_0_ ->
-          let done, out, sampled_coefficients, xof_state:(bool &
-            t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-            t_Array usize v_K &
-            Libcrux.Digest.Incremental_x4.t_Shake128StateX4) =
-            temp_0_
-          in
-          let tmp0, out1:(Libcrux.Digest.Incremental_x4.t_Shake128StateX4 &
-            t_Array (t_Array u8 (sz 168)) v_K) =
-            Libcrux.Kem.Kyber.Hash_functions.squeeze_block v_K xof_state
-          in
-          let xof_state:Libcrux.Digest.Incremental_x4.t_Shake128StateX4 = tmp0 in
-          let randomness:t_Array (t_Array u8 (sz 168)) v_K = out1 in
-          let tmp0, tmp1, out1:(t_Array usize v_K &
-            t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-            bool) =
-            sample_from_uniform_distribution_next v_K (sz 168) randomness sampled_coefficients out
-          in
-          let sampled_coefficients:t_Array usize v_K = tmp0 in
-          let out:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K = tmp1 in
-          let done:bool = out1 in
-          done, out, sampled_coefficients, xof_state
-          <:
-          (bool & t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
-            t_Array usize v_K &
-            Libcrux.Digest.Incremental_x4.t_Shake128StateX4))
+  let _:Prims.unit =
+    if ~.done
+    then
+      let _:Prims.unit = rejection_sampling_panic_with_diagnostic () in
+      ()
   in
-  let _:Prims.unit = Libcrux.Kem.Kyber.Hash_functions.free_state xof_state in
-  out
+  let _:Prims.unit = () <: Prims.unit in
+  out 
+#pop-options
diff -ruN extraction/Libcrux.Kem.Kyber.Sampling.fsti extraction-edited/Libcrux.Kem.Kyber.Sampling.fsti
--- extraction/Libcrux.Kem.Kyber.Sampling.fsti	2024-05-16 17:05:53.735568409 +0200
+++ extraction-edited/Libcrux.Kem.Kyber.Sampling.fsti	2024-05-16 17:05:53.755567738 +0200
@@ -3,157 +3,37 @@
 open Core
 open FStar.Mul
 
-/// Given a series of uniformly random bytes in `randomness`, for some number `eta`,
-/// the `sample_from_binomial_distribution_{eta}` functions sample
-/// a ring element from a binomial distribution centered at 0 that uses two sets
-/// of `eta` coin flips. If, for example,
-/// `eta = ETA`, each ring coefficient is a value `v` such
-/// such that `v ∈ {-ETA, -ETA + 1, ..., 0, ..., ETA + 1, ETA}` and:
-/// ```plaintext
-/// - If v < 0, Pr[v] = Pr[-v]
-/// - If v >= 0, Pr[v] = BINOMIAL_COEFFICIENT(2 * ETA; ETA - v) / 2 ^ (2 * ETA)
-/// ```
-/// The values `v < 0` are mapped to the appropriate `KyberFieldElement`.
-/// The expected value is:
-/// ```plaintext
-/// E[X] = (-ETA)Pr[-ETA] + (-(ETA - 1))Pr[-(ETA - 1)] + ... + (ETA - 1)Pr[ETA - 1] + (ETA)Pr[ETA]
-///      = 0 since Pr[-v] = Pr[v] when v < 0.
-/// ```
-/// And the variance is:
-/// ```plaintext
-/// Var(X) = E[(X - E[X])^2]
-///        = E[X^2]
-///        = sum_(v=-ETA to ETA)v^2 * (BINOMIAL_COEFFICIENT(2 * ETA; ETA - v) / 2^(2 * ETA))
-///        = ETA / 2
-/// ```
-/// This function implements <strong>Algorithm 7</strong> of the NIST FIPS 203 standard, which is
-/// reproduced below:
-/// ```plaintext
-/// Input: byte array B ∈ 𝔹^{64η}.
-/// Output: array f ∈ ℤ₂₅₆.
-/// b ← BytesToBits(B)
-/// for (i ← 0; i < 256; i++)
-///     x ← ∑(j=0 to η - 1) b[2iη + j]
-///     y ← ∑(j=0 to η - 1) b[2iη + η + j]
-///     f[i] ← x−y mod q
-/// end for
-/// return f
-/// ```
-/// The NIST FIPS 203 standard can be found at
-/// <https://csrc.nist.gov/pubs/fips/203/ipd>.
+open Libcrux.Kem.Kyber.Arithmetic
+
 val sample_from_binomial_distribution_2_ (randomness: t_Slice u8)
-    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
-      (requires (Core.Slice.impl__len #u8 randomness <: usize) =. (sz 2 *! sz 64 <: usize))
+    : Prims.Pure (t_PolynomialRingElement_b 3)
+      (requires (Core.Slice.impl__len randomness <: usize) =. (sz 2 *! sz 64 <: usize))
       (ensures
         fun result ->
-          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = result in
-          Hax_lib.v_forall #usize
-            (fun i ->
-                let i:usize = i in
-                Hax_lib.implies (i <.
-                    (Core.Slice.impl__len #i32
-                        (Rust_primitives.unsize result.Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                          <:
-                          t_Slice i32)
-                      <:
-                      usize)
-                    <:
-                    bool)
-                  (fun temp_0_ ->
-                      let _:Prims.unit = temp_0_ in
-                      (Core.Num.impl__i32__abs (result.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[
-                              i ]
-                            <:
-                            i32)
-                        <:
-                        i32) <=.
-                      2l
-                      <:
-                      bool)
-                <:
-                bool))
+          Libcrux.Kem.Kyber.Arithmetic.to_spec_poly_b result == 
+          Spec.Kyber.sample_poly_binomial (sz 2) randomness)
 
 val sample_from_binomial_distribution_3_ (randomness: t_Slice u8)
-    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
-      (requires (Core.Slice.impl__len #u8 randomness <: usize) =. (sz 3 *! sz 64 <: usize))
+    : Prims.Pure (t_PolynomialRingElement_b 7)
+      (requires (Core.Slice.impl__len randomness <: usize) =. (sz 3 *! sz 64 <: usize))
       (ensures
         fun result ->
-          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = result in
-          Hax_lib.v_forall #usize
-            (fun i ->
-                let i:usize = i in
-                Hax_lib.implies (i <.
-                    (Core.Slice.impl__len #i32
-                        (Rust_primitives.unsize result.Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                          <:
-                          t_Slice i32)
-                      <:
-                      usize)
-                    <:
-                    bool)
-                  (fun temp_0_ ->
-                      let _:Prims.unit = temp_0_ in
-                      (Core.Num.impl__i32__abs (result.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[
-                              i ]
-                            <:
-                            i32)
-                        <:
-                        i32) <=.
-                      3l
-                      <:
-                      bool)
-                <:
-                bool))
-
-val sample_from_binomial_distribution (v_ETA: usize) (randomness: t_Slice u8)
-    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
-      Prims.l_True
-      (fun _ -> Prims.l_True)
+          Libcrux.Kem.Kyber.Arithmetic.to_spec_poly_b result == 
+          Spec.Kyber.sample_poly_binomial (sz 3) randomness)
 
-/// If `bytes` contains a set of uniformly random bytes, this function
-/// uniformly samples a ring element `â` that is treated as being the NTT representation
-/// of the corresponding polynomial `a`.
-/// Since rejection sampling is used, it is possible the supplied bytes are
-/// not enough to sample the element, in which case an `Err` is returned and the
-/// caller must try again with a fresh set of bytes.
-/// This function <strong>partially</strong> implements <strong>Algorithm 6</strong> of the NIST FIPS 203 standard,
-/// We say "partially" because this implementation only accepts a finite set of
-/// bytes as input and returns an error if the set is not enough; Algorithm 6 of
-/// the FIPS 203 standard on the other hand samples from an infinite stream of bytes
-/// until the ring element is filled. Algorithm 6 is reproduced below:
-/// ```plaintext
-/// Input: byte stream B ∈ 𝔹*.
-/// Output: array â ∈ ℤ₂₅₆.
-/// i ← 0
-/// j ← 0
-/// while j < 256 do
-///     d₁ ← B[i] + 256·(B[i+1] mod 16)
-///     d₂ ← ⌊B[i+1]/16⌋ + 16·B[i+2]
-///     if d₁ < q then
-///         â[j] ← d₁
-///         j ← j + 1
-///     end if
-///     if d₂ < q and j < 256 then
-///         â[j] ← d₂
-///         j ← j + 1
-///     end if
-///     i ← i + 3
-/// end while
-/// return â
-/// ```
-/// The NIST FIPS 203 standard can be found at
-/// <https://csrc.nist.gov/pubs/fips/203/ipd>.
-val sample_from_uniform_distribution_next
-      (v_K v_N: usize)
-      (randomness: t_Array (t_Array u8 v_N) v_K)
-      (sampled_coefficients: t_Array usize v_K)
-      (out: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-    : Prims.Pure
-      (t_Array usize v_K & t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K & bool)
-      Prims.l_True
-      (fun _ -> Prims.l_True)
+val sample_from_binomial_distribution (#p:Spec.Kyber.params)
+    (v_ETA: usize) (randomness: t_Slice u8) 
+    : Pure (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (pow2 (v v_ETA) - 1))
+      (requires (v_ETA = p.v_ETA1 \/ v_ETA = p.v_ETA2) /\
+                (Core.Slice.impl__len randomness <: usize) =. (v_ETA *! sz 64 <: usize))
+      (ensures
+        fun result ->
+          Libcrux.Kem.Kyber.Arithmetic.to_spec_poly_b result == 
+          Spec.Kyber.sample_poly_binomial v_ETA randomness)
 
-val sample_from_xof (v_K: usize) (seeds: t_Array (t_Array u8 (sz 34)) v_K)
-    : Prims.Pure (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-      Prims.l_True
-      (fun _ -> Prims.l_True)
+val sample_from_uniform_distribution (randomness: t_Array u8 (sz 840))
+    : Pure Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+      (requires True)
+      (ensures fun _ -> True)
+//      (ensures fun result -> (forall i. v (result.f_coefficients.[i]) >= 0))
+      
diff -ruN extraction/Libcrux.Kem.Kyber.Serialize.fst extraction-edited/Libcrux.Kem.Kyber.Serialize.fst
--- extraction/Libcrux.Kem.Kyber.Serialize.fst	2024-05-16 17:05:53.709569282 +0200
+++ extraction-edited/Libcrux.Kem.Kyber.Serialize.fst	2024-05-16 17:05:53.774567101 +0200
@@ -1,8 +1,15 @@
 module Libcrux.Kem.Kyber.Serialize
-#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
+#set-options "--fuel 0 --ifuel 0 --z3rlimit 50 --retry 3"
 open Core
 open FStar.Mul
 
+open Libcrux.Kem.Kyber.Arithmetic
+
+open MkSeq
+open BitVecEq
+
+#push-options "--z3rlimit 480  --split_queries always"
+[@@"opaque_to_smt"]
 let compress_coefficients_10_ (coefficient1 coefficient2 coefficient3 coefficient4: i32) =
   let coef1:u8 = cast (coefficient1 &. 255l <: i32) <: u8 in
   let coef2:u8 =
@@ -18,12 +25,14 @@
     (cast ((coefficient3 >>! 4l <: i32) &. 63l <: i32) <: u8)
   in
   let coef5:u8 = cast ((coefficient4 >>! 2l <: i32) &. 255l <: i32) <: u8 in
+  bit_vec_equal_intro_principle ();
   coef1, coef2, coef3, coef4, coef5 <: (u8 & u8 & u8 & u8 & u8)
+#pop-options
 
+#push-options "--ifuel 1 --z3rlimit 600 --split_queries always"
+[@@"opaque_to_smt"]
 let compress_coefficients_11_
-      (coefficient1 coefficient2 coefficient3 coefficient4 coefficient5 coefficient6 coefficient7 coefficient8:
-          i32)
-     =
+      coefficient1 coefficient2 coefficient3 coefficient4 coefficient5 coefficient6 coefficient7 coefficient8 =
   let coef1:u8 = cast (coefficient1 <: i32) <: u8 in
   let coef2:u8 =
     ((cast (coefficient2 &. 31l <: i32) <: u8) <<! 3l <: u8) |.
@@ -56,24 +65,32 @@
     (cast (coefficient7 >>! 6l <: i32) <: u8)
   in
   let coef11:u8 = cast (coefficient8 >>! 3l <: i32) <: u8 in
+  bit_vec_equal_intro_principle ();
   coef1, coef2, coef3, coef4, coef5, coef6, coef7, coef8, coef9, coef10, coef11
   <:
   (u8 & u8 & u8 & u8 & u8 & u8 & u8 & u8 & u8 & u8 & u8)
+#pop-options
 
-let compress_coefficients_3_ (coefficient1 coefficient2: u16) =
+#push-options "--z3rlimit 20"
+[@@"opaque_to_smt"]
+let compress_coefficients_3_ coefficient1 coefficient2 =
   let coef1:u8 = cast (coefficient1 &. 255us <: u16) <: u8 in
+  get_bit_pow2_minus_one_u16 255 (sz 0);
   let coef2:u8 =
     cast ((coefficient1 >>! 8l <: u16) |. ((coefficient2 &. 15us <: u16) <<! 4l <: u16) <: u16)
     <:
     u8
   in
   let coef3:u8 = cast ((coefficient2 >>! 4l <: u16) &. 255us <: u16) <: u8 in
-  coef1, coef2, coef3 <: (u8 & u8 & u8)
+  bit_vec_equal_intro_principle ();
+  coef1, coef2, coef3 <: (u8 & u8 & u8) 
+#pop-options
 
+#push-options "--z3rlimit 160 --split_queries always"
+[@@"opaque_to_smt"]
 let compress_coefficients_5_
-      (coefficient2 coefficient1 coefficient4 coefficient3 coefficient5 coefficient7 coefficient6 coefficient8:
-          u8)
-     =
+      coefficient2 coefficient1 coefficient4 coefficient3 coefficient5 coefficient7 coefficient6 coefficient8
+  =
   let coef1:u8 = ((coefficient2 &. 7uy <: u8) <<! 5l <: u8) |. coefficient1 in
   let coef2:u8 =
     (((coefficient4 &. 1uy <: u8) <<! 7l <: u8) |. (coefficient3 <<! 2l <: u8) <: u8) |.
@@ -85,18 +102,29 @@
     (coefficient5 >>! 4l <: u8)
   in
   let coef5:u8 = (coefficient8 <<! 3l <: u8) |. (coefficient7 >>! 2l <: u8) in
+  bit_vec_equal_intro_principle ();
   coef1, coef2, coef3, coef4, coef5 <: (u8 & u8 & u8 & u8 & u8)
+#pop-options
 
-let decompress_coefficients_10_ (byte2 byte1 byte3 byte4 byte5: i32) =
+#push-options "--z3rlimit 500"
+[@@"opaque_to_smt"]
+let decompress_coefficients_10_ byte2 byte1 byte3 byte4 byte5 =
   let coefficient1:i32 = ((byte2 &. 3l <: i32) <<! 8l <: i32) |. (byte1 &. 255l <: i32) in
   let coefficient2:i32 = ((byte3 &. 15l <: i32) <<! 6l <: i32) |. (byte2 >>! 2l <: i32) in
   let coefficient3:i32 = ((byte4 &. 63l <: i32) <<! 4l <: i32) |. (byte3 >>! 4l <: i32) in
   let coefficient4:i32 = (byte5 <<! 2l <: i32) |. (byte4 >>! 6l <: i32) in
-  coefficient1, coefficient2, coefficient3, coefficient4 <: (i32 & i32 & i32 & i32)
+  lemma_get_bit_bounded' coefficient1 10;
+  lemma_get_bit_bounded' coefficient2 10;
+  lemma_get_bit_bounded' coefficient3 10;
+  lemma_get_bit_bounded' coefficient4 10;
+  bit_vec_equal_intro_principle ();
+  coefficient1, coefficient2, coefficient3, coefficient4
+#pop-options
 
+#push-options "--z3rlimit 300"
+[@@"opaque_to_smt"]
 let decompress_coefficients_11_
-      (byte2 byte1 byte3 byte5 byte4 byte6 byte7 byte9 byte8 byte10 byte11: i32)
-     =
+      byte2 byte1 byte3 byte5 byte4 byte6 byte7 byte9 byte8 byte10 byte11 =
   let coefficient1:i32 = ((byte2 &. 7l <: i32) <<! 8l <: i32) |. byte1 in
   let coefficient2:i32 = ((byte3 &. 63l <: i32) <<! 5l <: i32) |. (byte2 >>! 3l <: i32) in
   let coefficient3:i32 =
@@ -109,6 +137,15 @@
   in
   let coefficient7:i32 = ((byte10 &. 31l <: i32) <<! 6l <: i32) |. (byte9 >>! 2l <: i32) in
   let coefficient8:i32 = (byte11 <<! 3l <: i32) |. (byte10 >>! 5l <: i32) in
+  bit_vec_equal_intro_principle ();
+  lemma_get_bit_bounded' coefficient1 11;
+  lemma_get_bit_bounded' coefficient2 11;
+  lemma_get_bit_bounded' coefficient3 11;
+  lemma_get_bit_bounded' coefficient4 11;
+  lemma_get_bit_bounded' coefficient5 11;
+  lemma_get_bit_bounded' coefficient6 11;
+  lemma_get_bit_bounded' coefficient7 11;
+  lemma_get_bit_bounded' coefficient8 11;
   coefficient1,
   coefficient2,
   coefficient3,
@@ -117,15 +154,22 @@
   coefficient6,
   coefficient7,
   coefficient8
-  <:
-  (i32 & i32 & i32 & i32 & i32 & i32 & i32 & i32)
+#pop-options
 
-let decompress_coefficients_4_ (byte: u8) =
+#push-options "--z3rlimit 50"
+[@@"opaque_to_smt"]
+let decompress_coefficients_4_ byte =
   let coefficient1:i32 = cast (byte &. 15uy <: u8) <: i32 in
   let coefficient2:i32 = cast ((byte >>! 4l <: u8) &. 15uy <: u8) <: i32 in
-  coefficient1, coefficient2 <: (i32 & i32)
-
-let decompress_coefficients_5_ (byte1 byte2 byte3 byte4 byte5: i32) =
+  lemma_get_bit_bounded' coefficient1 4;
+  lemma_get_bit_bounded' coefficient2 4;
+  bit_vec_equal_intro_principle ();
+  coefficient1, coefficient2
+#pop-options
+
+#push-options "--z3rlimit 400"
+[@@"opaque_to_smt"]
+let decompress_coefficients_5_ byte1 byte2 byte3 byte4 byte5 =
   let coefficient1:i32 = byte1 &. 31l in
   let coefficient2:i32 = ((byte2 &. 3l <: i32) <<! 3l <: i32) |. (byte1 >>! 5l <: i32) in
   let coefficient3:i32 = (byte2 >>! 2l <: i32) &. 31l in
@@ -134,6 +178,15 @@
   let coefficient6:i32 = (byte4 >>! 1l <: i32) &. 31l in
   let coefficient7:i32 = ((byte5 &. 7l <: i32) <<! 2l <: i32) |. (byte4 >>! 6l <: i32) in
   let coefficient8:i32 = byte5 >>! 3l in
+  bit_vec_equal_intro_principle ();
+  lemma_get_bit_bounded' coefficient1 5;
+  lemma_get_bit_bounded' coefficient2 5;
+  lemma_get_bit_bounded' coefficient3 5;
+  lemma_get_bit_bounded' coefficient4 5;
+  lemma_get_bit_bounded' coefficient5 5;
+  lemma_get_bit_bounded' coefficient6 5;
+  lemma_get_bit_bounded' coefficient7 5;
+  lemma_get_bit_bounded' coefficient8 5;
   coefficient1,
   coefficient2,
   coefficient3,
@@ -142,33 +195,54 @@
   coefficient6,
   coefficient7,
   coefficient8
-  <:
-  (i32 & i32 & i32 & i32 & i32 & i32 & i32 & i32)
+#pop-options
+
+let cast_bound_lemma 
+  #t #u
+  (n: int_t t) 
+  (d: num_bits t)
+  : Lemma (requires bounded n d /\ d <= bits u /\ unsigned u /\ v n >= 0)
+          (ensures  bounded (cast #(int_t t) #(int_t u) n) d)
+          [SMTPat (bounded n d); SMTPat (cast #(int_t t) #(int_t u) n)]
+  = ()
+
+#push-options "--z3rlimit 90"
+[@@"opaque_to_smt"]
+let int_t_d_cast_lemma #t #u d (n: int_t_d t d)
+  : Lemma (requires bits t < bits u /\ v n >= 0)
+          (ensures bounded (cast #(int_t t) #(int_t u) n) d)
+          [SMTPat (bounded (cast #(int_t t) #(int_t u) n) d)]
+  = Math.Lemmas.pow2_double_mult (bits u - 1);
+    Math.Lemmas.small_mod (v n) (modulus u)
+let mul_in_range (n m: nat)
+  : Lemma
+    (requires n <= 256 /\ m <= 256)
+    (ensures range (n * m) usize_inttype)
+  = Math.Lemmas.pow2_plus 8 8;
+    Math.Lemmas.pow2_le_compat 32 16
+#pop-options
 
+#restart-solver
+
+#push-options "--fuel 0 --ifuel 1 --query_stats --z3rlimit 100"
+[@@"opaque_to_smt"]
 let compress_then_serialize_10_
-      (v_OUT_LEN: usize)
-      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-     =
+      v_OUT_LEN
+      re
+    =
+  let accT = t_Array u8 v_OUT_LEN in
+  let inv = fun (acc: t_Array u8 v_OUT_LEN) (i: usize) -> 
+    True
+  in
   let serialized:t_Array u8 v_OUT_LEN = Rust_primitives.Hax.repeat 0uy v_OUT_LEN in
   let serialized:t_Array u8 v_OUT_LEN =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Iter.Adapters.Enumerate.t_Enumerate
-            (Core.Slice.Iter.t_ChunksExact i32))
-          (Core.Iter.Traits.Iterator.f_enumerate #(Core.Slice.Iter.t_ChunksExact i32)
-              (Core.Slice.impl__chunks_exact #i32
-                  (Rust_primitives.unsize re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                    <:
-                    t_Slice i32)
-                  (sz 4)
-                <:
-                Core.Slice.Iter.t_ChunksExact i32)
-            <:
-            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact i32))
-        <:
-        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact i32))
-      serialized
+    Rust_primitives.Iterators.foldi_chunks_exact #_ #accT #inv
+      (re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients)
+      (sz 4)
+      (serialized)
       (fun serialized temp_1_ ->
           let serialized:t_Array u8 v_OUT_LEN = serialized in
-          let i, coefficients:(usize & t_Slice i32) = temp_1_ in
+          let i, coefficients:(usize & _) = temp_1_ in
           let coefficient1:i32 =
             Libcrux.Kem.Kyber.Compress.compress_ciphertext_coefficient 10uy
               (Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 0 ] <: i32
@@ -228,81 +302,96 @@
           serialized)
   in
   serialized
+#pop-options
+
+#push-options "--fuel 0 --ifuel 0 --z3rlimit 30"
+[@@"opaque_to_smt"]
+let update5
+  #n
+  (s: t_Array 't n)
+  (offset: usize {v offset + 5 <= v n})
+  (i0 i1 i2 i3 i4: 't)
+  : s': t_Array 't n {
+     Seq.index s' (v offset +  0) == i0  /\
+     Seq.index s' (v offset +  1) == i1  /\
+     Seq.index s' (v offset +  2) == i2  /\
+     Seq.index s' (v offset +  3) == i3  /\
+     Seq.index s' (v offset +  4) == i4  /\
+     (forall i. (i < v offset \/ i >= v offset + 5) ==> Seq.index s' i == Seq.index s i)
+    }
+ = let open Rust_primitives.Hax.Monomorphized_update_at in
+    let s = update_at_usize s  offset          i0 in
+    let s = update_at_usize s (offset +! sz  1) i1  in
+    let s = update_at_usize s (offset +! sz  2) i2  in
+    let s = update_at_usize s (offset +! sz  3) i3  in
+    let s = update_at_usize s (offset +! sz  4) i4  in
+    s
+#pop-options
 
+#push-options "--fuel 0 --ifuel 1 --z3rlimit 100 --query_stats --split_queries no"
 let compress_then_serialize_11_
-      (v_OUT_LEN: usize)
-      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-     =
+      v_OUT_LEN re
+  =
+  let inv = fun (acc: t_Array u8 v_OUT_LEN) (i: usize) -> True in
   let serialized:t_Array u8 v_OUT_LEN = Rust_primitives.Hax.repeat 0uy v_OUT_LEN in
   let serialized:t_Array u8 v_OUT_LEN =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Iter.Adapters.Enumerate.t_Enumerate
-            (Core.Slice.Iter.t_ChunksExact i32))
-          (Core.Iter.Traits.Iterator.f_enumerate #(Core.Slice.Iter.t_ChunksExact i32)
-              (Core.Slice.impl__chunks_exact #i32
-                  (Rust_primitives.unsize re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                    <:
-                    t_Slice i32)
-                  (sz 8)
-                <:
-                Core.Slice.Iter.t_ChunksExact i32)
-            <:
-            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact i32))
-        <:
-        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact i32))
+    Rust_primitives.Iterators.foldi_chunks_exact #_ #_ #inv
+      (Rust_primitives.unsize re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients)
+      (sz 8)
       serialized
       (fun serialized temp_1_ ->
           let serialized:t_Array u8 v_OUT_LEN = serialized in
-          let i, coefficients:(usize & t_Slice i32) = temp_1_ in
-          let coefficient1:i32 =
+          let i, coefficients:(usize & t_Array Libcrux.Kem.Kyber.Arithmetic.wfFieldElement (sz 8)) = temp_1_ in
+          let coefficient1 =
             Libcrux.Kem.Kyber.Compress.compress_ciphertext_coefficient 11uy
               (Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 0 ] <: i32
                   )
                 <:
                 u16)
           in
-          let coefficient2:i32 =
+          let coefficient2 =
             Libcrux.Kem.Kyber.Compress.compress_ciphertext_coefficient 11uy
               (Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 1 ] <: i32
                   )
                 <:
                 u16)
           in
-          let coefficient3:i32 =
+          let coefficient3 =
             Libcrux.Kem.Kyber.Compress.compress_ciphertext_coefficient 11uy
               (Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 2 ] <: i32
                   )
                 <:
                 u16)
           in
-          let coefficient4:i32 =
+          let coefficient4 =
             Libcrux.Kem.Kyber.Compress.compress_ciphertext_coefficient 11uy
               (Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 3 ] <: i32
                   )
                 <:
                 u16)
           in
-          let coefficient5:i32 =
+          let coefficient5 =
             Libcrux.Kem.Kyber.Compress.compress_ciphertext_coefficient 11uy
               (Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 4 ] <: i32
                   )
                 <:
                 u16)
           in
-          let coefficient6:i32 =
+          let coefficient6 =
             Libcrux.Kem.Kyber.Compress.compress_ciphertext_coefficient 11uy
               (Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 5 ] <: i32
                   )
                 <:
                 u16)
           in
-          let coefficient7:i32 =
+          let coefficient7 =
             Libcrux.Kem.Kyber.Compress.compress_ciphertext_coefficient 11uy
               (Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 6 ] <: i32
                   )
                 <:
                 u16)
           in
-          let coefficient8:i32 =
+          let coefficient8 =
             Libcrux.Kem.Kyber.Compress.compress_ciphertext_coefficient 11uy
               (Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 7 ] <: i32
                   )
@@ -328,6 +417,8 @@
               coefficient7
               coefficient8
           in
+          assert_spinoff (v i < 32 ==> 11 * v i + 11 <= 32 * 11);
+          assert_spinoff (v i < 32 ==> range (v (sz 11) * v i) usize_inttype);
           let serialized:t_Array u8 v_OUT_LEN =
             Rust_primitives.Hax.Monomorphized_update_at.update_at_usize serialized
               (sz 11 *! i <: usize)
@@ -386,31 +477,20 @@
           serialized)
   in
   serialized
+#pop-options
 
-let compress_then_serialize_4_
-      (v_OUT_LEN: usize)
-      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-     =
+let compress_then_serialize_4_ v_OUT_LEN re =
   let serialized:t_Array u8 v_OUT_LEN = Rust_primitives.Hax.repeat 0uy v_OUT_LEN in
+  let accT = t_Array u8 v_OUT_LEN in
+  let inv (acc: accT) (i: usize) = True in
   let serialized:t_Array u8 v_OUT_LEN =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Iter.Adapters.Enumerate.t_Enumerate
-            (Core.Slice.Iter.t_ChunksExact i32))
-          (Core.Iter.Traits.Iterator.f_enumerate #(Core.Slice.Iter.t_ChunksExact i32)
-              (Core.Slice.impl__chunks_exact #i32
-                  (Rust_primitives.unsize re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                    <:
-                    t_Slice i32)
-                  (sz 2)
-                <:
-                Core.Slice.Iter.t_ChunksExact i32)
-            <:
-            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact i32))
-        <:
-        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact i32))
+    Rust_primitives.Iterators.foldi_chunks_exact #_ #_ #inv
+      (Rust_primitives.unsize re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients)
+      (sz 2)
       serialized
       (fun serialized temp_1_ ->
           let serialized:t_Array u8 v_OUT_LEN = serialized in
-          let i, coefficients:(usize & t_Slice i32) = temp_1_ in
+          let i, coefficients:(usize & t_Array Libcrux.Kem.Kyber.Arithmetic.wfFieldElement (sz 2)) = temp_1_ in
           let coefficient1:u8 =
             cast (Libcrux.Kem.Kyber.Compress.compress_ciphertext_coefficient 4uy
                   (Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 0 ]
@@ -445,29 +525,20 @@
   serialized
 
 let compress_then_serialize_5_
-      (v_OUT_LEN: usize)
-      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-     =
+      v_OUT_LEN
+      re
+  =
   let serialized:t_Array u8 v_OUT_LEN = Rust_primitives.Hax.repeat 0uy v_OUT_LEN in
+  let accT = t_Array u8 v_OUT_LEN in
+  let inv (acc: accT) (i: usize) = True in
   let serialized:t_Array u8 v_OUT_LEN =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Iter.Adapters.Enumerate.t_Enumerate
-            (Core.Slice.Iter.t_ChunksExact i32))
-          (Core.Iter.Traits.Iterator.f_enumerate #(Core.Slice.Iter.t_ChunksExact i32)
-              (Core.Slice.impl__chunks_exact #i32
-                  (Rust_primitives.unsize re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                    <:
-                    t_Slice i32)
-                  (sz 8)
-                <:
-                Core.Slice.Iter.t_ChunksExact i32)
-            <:
-            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact i32))
-        <:
-        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact i32))
+    Rust_primitives.Iterators.foldi_chunks_exact #_ #_ #inv
+      (Rust_primitives.unsize re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients)
+      (sz 8)
       serialized
       (fun serialized temp_1_ ->
           let serialized:t_Array u8 v_OUT_LEN = serialized in
-          let i, coefficients:(usize & t_Slice i32) = temp_1_ in
+          let i, coefficients:(usize & t_Array Libcrux.Kem.Kyber.Arithmetic.wfFieldElement (sz 8)) = temp_1_ in
           let coefficient1:u8 =
             cast (Libcrux.Kem.Kyber.Compress.compress_ciphertext_coefficient 5uy
                   (Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 0 ]
@@ -552,6 +623,14 @@
             <:
             u8
           in
+          let coefficient8' = Libcrux.Kem.Kyber.Compress.compress_ciphertext_coefficient 5uy
+                  (Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 7 ]
+                        <:
+                        i32)
+                    <:
+                    u16)
+                <:
+                i32 in
           let coefficient8:u8 =
             cast (Libcrux.Kem.Kyber.Compress.compress_ciphertext_coefficient 5uy
                   (Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 7 ]
@@ -574,6 +653,8 @@
               coefficient6
               coefficient8
           in
+          assert_spinoff (v i < 32 ==> 5 * v i + 5 <= 32 * 5);
+          assert_spinoff (v i < 32 ==> range (v (sz 5) * v i) usize_inttype);
           let serialized:t_Array u8 v_OUT_LEN =
             Rust_primitives.Hax.Monomorphized_update_at.update_at_usize serialized
               (sz 5 *! i <: usize)
@@ -603,39 +684,24 @@
   in
   serialized
 
-let compress_then_serialize_message (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+let compress_then_serialize_message re =
   let serialized:t_Array u8 (sz 32) = Rust_primitives.Hax.repeat 0uy (sz 32) in
+  let accT = t_Array u8 (sz 32) in
+  let inv (acc: accT) (i: usize) = True in
   let serialized:t_Array u8 (sz 32) =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Iter.Adapters.Enumerate.t_Enumerate
-            (Core.Slice.Iter.t_ChunksExact i32))
-          (Core.Iter.Traits.Iterator.f_enumerate #(Core.Slice.Iter.t_ChunksExact i32)
-              (Core.Slice.impl__chunks_exact #i32
-                  (Rust_primitives.unsize re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                    <:
-                    t_Slice i32)
-                  (sz 8)
-                <:
-                Core.Slice.Iter.t_ChunksExact i32)
-            <:
-            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact i32))
-        <:
-        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact i32))
+    Rust_primitives.Iterators.foldi_chunks_exact #_ #_ #inv
+      (re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients)
+      (sz 8)
       serialized
       (fun serialized temp_1_ ->
           let serialized:t_Array u8 (sz 32) = serialized in
-          let i, coefficients:(usize & t_Slice i32) = temp_1_ in
-          Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Iter.Adapters.Enumerate.t_Enumerate
-                  (Core.Slice.Iter.t_Iter i32))
-                (Core.Iter.Traits.Iterator.f_enumerate #(Core.Slice.Iter.t_Iter i32)
-                    (Core.Slice.impl__iter #i32 coefficients <: Core.Slice.Iter.t_Iter i32)
-                  <:
-                  Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_Iter i32))
-              <:
-              Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_Iter i32))
+          let i, coefficients:(usize & t_Array Libcrux.Kem.Kyber.Arithmetic.wfFieldElement _) = temp_1_ in
+          Rust_primitives.Iterators.foldi_slice #_ #_ #(fun _ _ -> True) 
+            coefficients
             serialized
             (fun serialized temp_1_ ->
                 let serialized:t_Array u8 (sz 32) = serialized in
-                let j, coefficient:(usize & i32) = temp_1_ in
+                let j, coefficient:(usize & Libcrux.Kem.Kyber.Arithmetic.wfFieldElement) = temp_1_ in
                 let coefficient:u16 =
                   Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative coefficient
                 in
@@ -648,27 +714,35 @@
           <:
           t_Array u8 (sz 32))
   in
+  admit (); // P-F 
   serialized
 
-let compress_then_serialize_ring_element_u
-      (v_COMPRESSION_FACTOR v_OUT_LEN: usize)
-      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-     =
+let compress_then_serialize_ring_element_u #p
+      v_COMPRESSION_FACTOR
+      v_OUT_LEN
+      (re: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement) =
   let _:Prims.unit = () <: Prims.unit in
+  assert (
+    (v (cast (v_COMPRESSION_FACTOR <: usize) <: u32) == 11) \/
+    (v (cast (v_COMPRESSION_FACTOR <: usize) <: u32) == 10)
+  );
+  Rust_primitives.Integers.mk_int_equiv_lemma #usize_inttype (v v_COMPRESSION_FACTOR);
   match cast (v_COMPRESSION_FACTOR <: usize) <: u32 with
   | 10ul -> compress_then_serialize_10_ v_OUT_LEN re
   | 11ul -> compress_then_serialize_11_ v_OUT_LEN re
   | _ ->
     Rust_primitives.Hax.never_to_any (Core.Panicking.panic "internal error: entered unreachable code"
-
         <:
         Rust_primitives.Hax.t_Never)
 
-let compress_then_serialize_ring_element_v
-      (v_COMPRESSION_FACTOR v_OUT_LEN: usize)
-      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-     =
+let compress_then_serialize_ring_element_v #p v_COMPRESSION_FACTOR v_OUT_LEN re =
   let _:Prims.unit = () <: Prims.unit in
+  Rust_primitives.Integers.mk_int_equiv_lemma #usize_inttype (v v_COMPRESSION_FACTOR);
+  let res = 
+  assert (
+    (v (cast (v_COMPRESSION_FACTOR <: usize) <: u32) == 4) \/
+    (v (cast (v_COMPRESSION_FACTOR <: usize) <: u32) == 5)
+  );
   match cast (v_COMPRESSION_FACTOR <: usize) <: u32 with
   | 4ul -> compress_then_serialize_4_ v_OUT_LEN re
   | 5ul -> compress_then_serialize_5_ v_OUT_LEN re
@@ -677,36 +751,49 @@
 
         <:
         Rust_primitives.Hax.t_Never)
+  in
+  admit (); // P-F
+  res
 
-let deserialize_then_decompress_10_ (serialized: t_Slice u8) =
+#push-options "--z3rlimit 160"
+let deserialize_then_decompress_10_ serialized =
   let _:Prims.unit = () <: Prims.unit in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
+  let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+    Libcrux.Kem.Kyber.Arithmetic.cast_poly_b Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
   in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Iter.Adapters.Enumerate.t_Enumerate
-            (Core.Slice.Iter.t_ChunksExact u8))
-          (Core.Iter.Traits.Iterator.f_enumerate #(Core.Slice.Iter.t_ChunksExact u8)
-              (Core.Slice.impl__chunks_exact #u8 serialized (sz 5)
-                <:
-                Core.Slice.Iter.t_ChunksExact u8)
-            <:
-            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
-        <:
-        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
+  let accT = Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement in
+  let inv (acc: accT) (i: usize) = True in
+  let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+    Rust_primitives.Iterators.foldi_chunks_exact #_ #_ #inv
+      serialized
+      (sz 5)
       re
       (fun re temp_1_ ->
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
-          let i, bytes:(usize & t_Slice u8) = temp_1_ in
-          let byte1:i32 = cast (bytes.[ sz 0 ] <: u8) <: i32 in
-          let byte2:i32 = cast (bytes.[ sz 1 ] <: u8) <: i32 in
-          let byte3:i32 = cast (bytes.[ sz 2 ] <: u8) <: i32 in
-          let byte4:i32 = cast (bytes.[ sz 3 ] <: u8) <: i32 in
-          let byte5:i32 = cast (bytes.[ sz 4 ] <: u8) <: i32 in
-          let coefficient1, coefficient2, coefficient3, coefficient4:(i32 & i32 & i32 & i32) =
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement = re in
+          let i, bytes:(usize & t_Array u8 (sz 5)) = temp_1_ in
+          let byte1: int_t_d i32_inttype 8 = cast (bytes.[ sz 0 ] <: u8) <: i32 in
+          let byte2: int_t_d i32_inttype 8 = cast (bytes.[ sz 1 ] <: u8) <: i32 in
+          let byte3: int_t_d i32_inttype 8 = cast (bytes.[ sz 2 ] <: u8) <: i32 in
+          let byte4: int_t_d i32_inttype 8 = cast (bytes.[ sz 3 ] <: u8) <: i32 in
+          let byte5: int_t_d i32_inttype 8 = cast (bytes.[ sz 4 ] <: u8) <: i32 in
+          let coefficient1, coefficient2, coefficient3, coefficient4 =
             decompress_coefficients_10_ byte2 byte1 byte3 byte4 byte5
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let coefficient1 = (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 10uy coefficient1
+                           <:
+                           i32) in
+          let coefficient2 = (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 10uy coefficient2
+                           <:
+                           i32) in
+          let coefficient3 = (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 10uy coefficient3
+                           <:
+                           i32) in
+          let coefficient4 = (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 10uy coefficient4
+                           <:
+                           i32) in
+          assert_spinoff (v i < 64 ==> 4 * v i + 4 <= 256);
+          assert_spinoff (v i < 64 ==> range (v (sz 4) * v i) usize_inttype);
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -714,14 +801,12 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 (sz 4 *! i <: usize)
-                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 10uy coefficient1
-                  <:
-                  i32)
+                coefficient1 
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -729,14 +814,12 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 4 *! i <: usize) +! sz 1 <: usize)
-                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 10uy coefficient2
-                  <:
-                  i32)
+                coefficient2 
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -744,14 +827,12 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 4 *! i <: usize) +! sz 2 <: usize)
-                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 10uy coefficient3
-                  <:
-                  i32)
+                coefficient3
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -759,48 +840,43 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 4 *! i <: usize) +! sz 3 <: usize)
-                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 10uy coefficient4
-                  <:
-                  i32)
+                coefficient4
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
           in
           re)
   in
   re
+#pop-options
 
-let deserialize_then_decompress_11_ (serialized: t_Slice u8) =
+#push-options "--z3rlimit 100 --ifuel 0"
+let deserialize_then_decompress_11_ serialized
+    : Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
   let _:Prims.unit = () <: Prims.unit in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
+  let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+    Libcrux.Kem.Kyber.Arithmetic.cast_poly_b Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
   in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Iter.Adapters.Enumerate.t_Enumerate
-            (Core.Slice.Iter.t_ChunksExact u8))
-          (Core.Iter.Traits.Iterator.f_enumerate #(Core.Slice.Iter.t_ChunksExact u8)
-              (Core.Slice.impl__chunks_exact #u8 serialized (sz 11)
-                <:
-                Core.Slice.Iter.t_ChunksExact u8)
-            <:
-            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
-        <:
-        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
+  let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+    Rust_primitives.Iterators.foldi_chunks_exact #_ #_ #(fun _ _ -> True)
+      serialized
+      (sz 11)
       re
       (fun re temp_1_ ->
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
-          let i, bytes:(usize & t_Slice u8) = temp_1_ in
-          let byte1:i32 = cast (bytes.[ sz 0 ] <: u8) <: i32 in
-          let byte2:i32 = cast (bytes.[ sz 1 ] <: u8) <: i32 in
-          let byte3:i32 = cast (bytes.[ sz 2 ] <: u8) <: i32 in
-          let byte4:i32 = cast (bytes.[ sz 3 ] <: u8) <: i32 in
-          let byte5:i32 = cast (bytes.[ sz 4 ] <: u8) <: i32 in
-          let byte6:i32 = cast (bytes.[ sz 5 ] <: u8) <: i32 in
-          let byte7:i32 = cast (bytes.[ sz 6 ] <: u8) <: i32 in
-          let byte8:i32 = cast (bytes.[ sz 7 ] <: u8) <: i32 in
-          let byte9:i32 = cast (bytes.[ sz 8 ] <: u8) <: i32 in
-          let byte10:i32 = cast (bytes.[ sz 9 ] <: u8) <: i32 in
-          let byte11:i32 = cast (bytes.[ sz 10 ] <: u8) <: i32 in
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement = re in
+          let i, bytes:(usize & t_Array u8 (sz 11)) = temp_1_ in
+          assert (v i < 32);
+          let byte1: int_t_d i32_inttype 8 = cast (bytes.[ sz 0 ] <: u8) <: i32 in
+          let byte2: int_t_d i32_inttype 8 = cast (bytes.[ sz 1 ] <: u8) <: i32 in
+          let byte3: int_t_d i32_inttype 8 = cast (bytes.[ sz 2 ] <: u8) <: i32 in
+          let byte4: int_t_d i32_inttype 8 = cast (bytes.[ sz 3 ] <: u8) <: i32 in
+          let byte5: int_t_d i32_inttype 8 = cast (bytes.[ sz 4 ] <: u8) <: i32 in
+          let byte6: int_t_d i32_inttype 8 = cast (bytes.[ sz 5 ] <: u8) <: i32 in
+          let byte7: int_t_d i32_inttype 8 = cast (bytes.[ sz 6 ] <: u8) <: i32 in
+          let byte8: int_t_d i32_inttype 8 = cast (bytes.[ sz 7 ] <: u8) <: i32 in
+          let byte9: int_t_d i32_inttype 8 = cast (bytes.[ sz 8 ] <: u8) <: i32 in
+          let byte10: int_t_d i32_inttype 8 = cast (bytes.[ sz 9 ] <: u8) <: i32 in
+          let byte11: int_t_d i32_inttype 8 = cast (bytes.[ sz 10 ] <: u8) <: i32 in
           let
           coefficient1,
           coefficient2,
@@ -809,11 +885,21 @@
           coefficient5,
           coefficient6,
           coefficient7,
-          coefficient8:(i32 & i32 & i32 & i32 & i32 & i32 & i32 & i32) =
+          coefficient8 =
             decompress_coefficients_11_ byte2 byte1 byte3 byte5 byte4 byte6 byte7 byte9 byte8 byte10
               byte11
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let coefficient1 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient1 in
+          let coefficient2 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient2 in
+          let coefficient3 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient3 in
+          let coefficient4 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient4 in
+          let coefficient5 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient5 in
+          let coefficient6 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient6 in
+          let coefficient7 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient7 in
+          let coefficient8 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient8 in
+          assert_spinoff (8 * v i + 8 <= 256);
+          assert_spinoff (range (v (sz 8) * v i) usize_inttype);
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -821,14 +907,12 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 (sz 8 *! i <: usize)
-                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient1
-                  <:
-                  i32)
+                coefficient1
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -836,14 +920,12 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 8 *! i <: usize) +! sz 1 <: usize)
-                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient2
-                  <:
-                  i32)
+                coefficient2
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -851,14 +933,12 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 8 *! i <: usize) +! sz 2 <: usize)
-                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient3
-                  <:
-                  i32)
+                coefficient3
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -866,14 +946,12 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 8 *! i <: usize) +! sz 3 <: usize)
-                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient4
-                  <:
-                  i32)
+                coefficient4
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -881,14 +959,12 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 8 *! i <: usize) +! sz 4 <: usize)
-                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient5
-                  <:
-                  i32)
+                coefficient5
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -896,14 +972,12 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 8 *! i <: usize) +! sz 5 <: usize)
-                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient6
-                  <:
-                  i32)
+                coefficient6
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -911,14 +985,12 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 8 *! i <: usize) +! sz 6 <: usize)
-                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient7
-                  <:
-                  i32)
+                coefficient7
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -926,37 +998,33 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 8 *! i <: usize) +! sz 7 <: usize)
-                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient8
-                  <:
-                  i32)
+                coefficient8
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
           in
           re)
   in
   re
+#pop-options
 
-let deserialize_then_decompress_4_ (serialized: t_Slice u8) =
+#push-options "--z3rlimit 100"
+let deserialize_then_decompress_4_ serialized =
   let _:Prims.unit = () <: Prims.unit in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
+  let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+    Libcrux.Kem.Kyber.Arithmetic.cast_poly_b Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
   in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Iter.Adapters.Enumerate.t_Enumerate
-            (Core.Slice.Iter.t_Iter u8))
-          (Core.Iter.Traits.Iterator.f_enumerate #(Core.Slice.Iter.t_Iter u8)
-              (Core.Slice.impl__iter #u8 serialized <: Core.Slice.Iter.t_Iter u8)
-            <:
-            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_Iter u8))
-        <:
-        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_Iter u8))
+  let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+    Rust_primitives.Iterators.foldi_slice #_ #_ #(fun _ _ -> True)
+      serialized
       re
       (fun re temp_1_ ->
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement = re in
           let i, byte:(usize & u8) = temp_1_ in
-          let coefficient1, coefficient2:(i32 & i32) = decompress_coefficients_4_ byte in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let coefficient1, coefficient2 = decompress_coefficients_4_ byte in
+          assert_spinoff (v i < 128 ==> 2 * v i + 1 < 256);
+          assert_spinoff (v i < 128 ==> range (v (sz 2) * v i) usize_inttype);
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -969,9 +1037,9 @@
                   i32)
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -984,37 +1052,32 @@
                   i32)
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
           in
           re)
   in
   re
+#pop-options
 
-let deserialize_then_decompress_5_ (serialized: t_Slice u8) =
+#push-options "--z3rlimit 150"
+let deserialize_then_decompress_5_ serialized =
   let _:Prims.unit = () <: Prims.unit in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
+  let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+    Libcrux.Kem.Kyber.Arithmetic.cast_poly_b Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
   in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Iter.Adapters.Enumerate.t_Enumerate
-            (Core.Slice.Iter.t_ChunksExact u8))
-          (Core.Iter.Traits.Iterator.f_enumerate #(Core.Slice.Iter.t_ChunksExact u8)
-              (Core.Slice.impl__chunks_exact #u8 serialized (sz 5)
-                <:
-                Core.Slice.Iter.t_ChunksExact u8)
-            <:
-            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
-        <:
-        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
+  let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+     Rust_primitives.Iterators.foldi_chunks_exact #_ #_ #(fun _ _ -> True)
+      serialized (sz 5)
       re
       (fun re temp_1_ ->
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
-          let i, bytes:(usize & t_Slice u8) = temp_1_ in
-          let byte1:i32 = cast (bytes.[ sz 0 ] <: u8) <: i32 in
-          let byte2:i32 = cast (bytes.[ sz 1 ] <: u8) <: i32 in
-          let byte3:i32 = cast (bytes.[ sz 2 ] <: u8) <: i32 in
-          let byte4:i32 = cast (bytes.[ sz 3 ] <: u8) <: i32 in
-          let byte5:i32 = cast (bytes.[ sz 4 ] <: u8) <: i32 in
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement = re in
+          let i, bytes:(usize & t_Array u8 (sz 5)) = temp_1_ in
+          assert (v i < 32);
+          let byte1 = cast (bytes.[ sz 0 ] <: u8) <: i32 in
+          let byte2 = cast (bytes.[ sz 1 ] <: u8) <: i32 in
+          let byte3 = cast (bytes.[ sz 2 ] <: u8) <: i32 in
+          let byte4 = cast (bytes.[ sz 3 ] <: u8) <: i32 in
+          let byte5 = cast (bytes.[ sz 4 ] <: u8) <: i32 in
           let
           coefficient1,
           coefficient2,
@@ -1023,10 +1086,25 @@
           coefficient5,
           coefficient6,
           coefficient7,
-          coefficient8:(i32 & i32 & i32 & i32 & i32 & i32 & i32 & i32) =
+          coefficient8 =
             decompress_coefficients_5_ byte1 byte2 byte3 byte4 byte5
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let coefficient1 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient1 in
+          let coefficient2 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient2 in
+          let coefficient3 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient3 in
+          let coefficient4 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient4 in
+          let coefficient5 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient5 in
+          let coefficient6 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient6 in
+          let coefficient7 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient7 in
+          let coefficient8 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient8 in
+          // assert (Seq.length serialized == 160);
+          // // assert_norm (160 / 5 == 32);
+          // assert_spinoff (v i < Seq.length serialized);
+          // assert (v i < 32);
+          assert_spinoff (v i < 32 ==> 8 * v i + 8 <= 256);
+          mul_in_range 8 (v i);
+          assert_spinoff (v i < 32 ==> range (v (sz 8) * v i) usize_inttype);
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -1034,14 +1112,12 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 (sz 8 *! i <: usize)
-                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient1
-                  <:
-                  i32)
+                coefficient1
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -1049,14 +1125,12 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 8 *! i <: usize) +! sz 1 <: usize)
-                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient2
-                  <:
-                  i32)
+                coefficient2
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -1064,14 +1138,12 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 8 *! i <: usize) +! sz 2 <: usize)
-                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient3
-                  <:
-                  i32)
+                coefficient3
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -1079,14 +1151,12 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 8 *! i <: usize) +! sz 3 <: usize)
-                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient4
-                  <:
-                  i32)
+                coefficient4
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -1094,14 +1164,12 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 8 *! i <: usize) +! sz 4 <: usize)
-                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient5
-                  <:
-                  i32)
+                coefficient5
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -1109,14 +1177,12 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 8 *! i <: usize) +! sz 5 <: usize)
-                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient6
-                  <:
-                  i32)
+                coefficient6
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -1124,14 +1190,12 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 8 *! i <: usize) +! sz 6 <: usize)
-                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient7
-                  <:
-                  i32)
+                coefficient7
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -1139,49 +1203,43 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 8 *! i <: usize) +! sz 7 <: usize)
-                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient8
-                  <:
-                  i32)
+                coefficient8
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
           in
           re)
   in
   re
+#pop-options
 
+#push-options "--z3rlimit 60"
 let deserialize_then_decompress_message (serialized: t_Array u8 (sz 32)) =
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
+  let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+   Libcrux.Kem.Kyber.Arithmetic.cast_poly_b Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
   in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Iter.Adapters.Enumerate.t_Enumerate
-            (Core.Array.Iter.t_IntoIter u8 (sz 32)))
-          (Core.Iter.Traits.Iterator.f_enumerate #(Core.Array.Iter.t_IntoIter u8 (sz 32))
-              (Core.Iter.Traits.Collect.f_into_iter #(t_Array u8 (sz 32)) serialized
-                <:
-                Core.Array.Iter.t_IntoIter u8 (sz 32))
-            <:
-            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Array.Iter.t_IntoIter u8 (sz 32)))
-        <:
-        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Array.Iter.t_IntoIter u8 (sz 32)))
+  let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+    Rust_primitives.Iterators.foldi_slice #_ #_ #(fun _ _ -> True)
+      serialized
       re
       (fun re temp_1_ ->
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement = re in
           let i, byte:(usize & u8) = temp_1_ in
-          Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Ops.Range.t_Range
-                  usize)
-                ({ Core.Ops.Range.f_start = sz 0; Core.Ops.Range.f_end = sz 8 }
+          Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
+                    Core.Ops.Range.f_start = sz 0;
+                    Core.Ops.Range.f_end = sz 8
+                  }
                   <:
                   Core.Ops.Range.t_Range usize)
               <:
               Core.Ops.Range.t_Range usize)
             re
             (fun re j ->
-                let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
+                let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement = re in
                 let j:usize = j in
                 let coefficient_compressed:i32 = cast ((byte >>! j <: u8) &. 1uy <: u8) <: i32 in
-                let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+                lemma_get_bit_bounded' coefficient_compressed 1;
+                let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
                   {
                     re with
                     Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -1195,19 +1253,20 @@
                         i32)
                   }
                   <:
-                  Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+                  Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
                 in
                 re)
           <:
-          Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+          Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
   in
+  admit(); //P-F
   re
+#pop-options
 
-let deserialize_then_decompress_ring_element_u
-      (v_COMPRESSION_FACTOR: usize)
-      (serialized: t_Slice u8)
-     =
+let deserialize_then_decompress_ring_element_u v_COMPRESSION_FACTOR serialized = 
   let _:Prims.unit = () <: Prims.unit in
+  mk_int_equiv_lemma #usize_inttype (v v_COMPRESSION_FACTOR);
+  assert (v (cast (v_COMPRESSION_FACTOR <: usize) <: u32) == 10 \/ v (cast (v_COMPRESSION_FACTOR <: usize) <: u32) == 11);
   match cast (v_COMPRESSION_FACTOR <: usize) <: u32 with
   | 10ul -> deserialize_then_decompress_10_ serialized
   | 11ul -> deserialize_then_decompress_11_ serialized
@@ -1217,11 +1276,11 @@
         <:
         Rust_primitives.Hax.t_Never)
 
-let deserialize_then_decompress_ring_element_v
-      (v_COMPRESSION_FACTOR: usize)
-      (serialized: t_Slice u8)
-     =
+let deserialize_then_decompress_ring_element_v v_COMPRESSION_FACTOR serialized =
   let _:Prims.unit = () <: Prims.unit in
+  mk_int_equiv_lemma #u32_inttype (v v_COMPRESSION_FACTOR);
+  assert (v (cast (v_COMPRESSION_FACTOR <: usize) <: u32) == 4 \/ v (cast (v_COMPRESSION_FACTOR <: usize) <: u32) == 5);
+  let res = 
   match cast (v_COMPRESSION_FACTOR <: usize) <: u32 with
   | 4ul -> deserialize_then_decompress_4_ serialized
   | 5ul -> deserialize_then_decompress_5_ serialized
@@ -1230,153 +1289,32 @@
 
         <:
         Rust_primitives.Hax.t_Never)
-
-let deserialize_to_reduced_ring_element (ring_element: t_Slice u8) =
-  let _:Prims.unit = () <: Prims.unit in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
   in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Iter.Adapters.Enumerate.t_Enumerate
-            (Core.Slice.Iter.t_ChunksExact u8))
-          (Core.Iter.Traits.Iterator.f_enumerate #(Core.Slice.Iter.t_ChunksExact u8)
-              (Core.Slice.impl__chunks_exact #u8 ring_element (sz 3)
-                <:
-                Core.Slice.Iter.t_ChunksExact u8)
-            <:
-            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
-        <:
-        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
-      re
-      (fun re temp_1_ ->
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
-          let i, bytes:(usize & t_Slice u8) = temp_1_ in
-          let byte1:i32 = cast (bytes.[ sz 0 ] <: u8) <: i32 in
-          let byte2:i32 = cast (bytes.[ sz 1 ] <: u8) <: i32 in
-          let byte3:i32 = cast (bytes.[ sz 2 ] <: u8) <: i32 in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-            {
-              re with
-              Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-              =
-              Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
-                  .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                (sz 2 *! i <: usize)
-                (((byte2 &. 15l <: i32) <<! 8l <: i32) |. (byte1 &. 255l <: i32) <: i32)
-            }
-            <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
-          in
-          let tmp:i32 =
-            (re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ sz 2 *! i <: usize ] <: i32) %! 3329l
-          in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-            {
-              re with
-              Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-              =
-              Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
-                  .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                (sz 2 *! i <: usize)
-                tmp
-            }
-            <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
-          in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-            {
-              re with
-              Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-              =
-              Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
-                  .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                ((sz 2 *! i <: usize) +! sz 1 <: usize)
-                ((byte3 <<! 4l <: i32) |. ((byte2 >>! 4l <: i32) &. 15l <: i32) <: i32)
-            }
-            <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
-          in
-          let tmp:i32 =
-            (re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ (sz 2 *! i <: usize) +! sz 1 <: usize
-              ]
-              <:
-              i32) %!
-            3329l
-          in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-            {
-              re with
-              Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-              =
-              Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
-                  .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                ((sz 2 *! i <: usize) +! sz 1 <: usize)
-                tmp
-            }
-            <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
-          in
-          re)
-  in
-  re
-
-let deserialize_ring_elements_reduced (v_PUBLIC_KEY_SIZE v_K: usize) (public_key: t_Slice u8) =
-  let deserialized_pk:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-    Rust_primitives.Hax.repeat Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO v_K
-  in
-  let deserialized_pk:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Iter.Adapters.Enumerate.t_Enumerate
-            (Core.Slice.Iter.t_ChunksExact u8))
-          (Core.Iter.Traits.Iterator.f_enumerate #(Core.Slice.Iter.t_ChunksExact u8)
-              (Core.Slice.impl__chunks_exact #u8
-                  public_key
-                  Libcrux.Kem.Kyber.Constants.v_BYTES_PER_RING_ELEMENT
-                <:
-                Core.Slice.Iter.t_ChunksExact u8)
-            <:
-            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
-        <:
-        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
-      deserialized_pk
-      (fun deserialized_pk temp_1_ ->
-          let deserialized_pk:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
-            deserialized_pk
-          in
-          let i, ring_element:(usize & t_Slice u8) = temp_1_ in
-          Rust_primitives.Hax.Monomorphized_update_at.update_at_usize deserialized_pk
-            i
-            (deserialize_to_reduced_ring_element ring_element
-              <:
-              Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-          <:
-          t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-  in
-  deserialized_pk
+  admit(); //P-F
+  res
 
-let deserialize_to_uncompressed_ring_element (serialized: t_Slice u8) =
+#push-options "--z3rlimit 220"
+let deserialize_to_uncompressed_ring_element (serialized: t_Slice u8) = 
   let _:Prims.unit = () <: Prims.unit in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
+  let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+   Libcrux.Kem.Kyber.Arithmetic.cast_poly_b Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
   in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Iter.Adapters.Enumerate.t_Enumerate
-            (Core.Slice.Iter.t_ChunksExact u8))
-          (Core.Iter.Traits.Iterator.f_enumerate #(Core.Slice.Iter.t_ChunksExact u8)
-              (Core.Slice.impl__chunks_exact #u8 serialized (sz 3)
-                <:
-                Core.Slice.Iter.t_ChunksExact u8)
-            <:
-            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
-        <:
-        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
+  let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+    Rust_primitives.Iterators.foldi_chunks_exact #_ #_ #(fun _ _ -> True)
+      serialized
+      (sz 3)
       re
       (fun re temp_1_ ->
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
-          let i, bytes:(usize & t_Slice u8) = temp_1_ in
-          let byte1:i32 = cast (bytes.[ sz 0 ] <: u8) <: i32 in
-          let byte2:i32 = cast (bytes.[ sz 1 ] <: u8) <: i32 in
-          let byte3:i32 = cast (bytes.[ sz 2 ] <: u8) <: i32 in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement = re in
+          let i, bytes:(usize & t_Array u8 (sz 3)) = temp_1_ in
+          let byte1:int_t_d i32_inttype 8 = cast (bytes.[ sz 0 ] <: u8) <: i32 in
+          let byte2:int_t_d i32_inttype 8 = cast (bytes.[ sz 1 ] <: u8) <: i32 in
+          let byte3:int_t_d i32_inttype 8 = cast (bytes.[ sz 2 ] <: u8) <: i32 in
+          let coef1 = (((byte2 &. 15l <: i32) <<! 8l <: i32) |. (byte1 &. 255l <: i32) <: i32) in
+          let coef2 = ((byte3 <<! 4l <: i32) |. ((byte2 >>! 4l <: i32) &. 15l <: i32) <: i32) in
+          lemma_get_bit_bounded' coef1 11;
+          lemma_get_bit_bounded' coef2 11;
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -1384,12 +1322,12 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 (sz 2 *! i <: usize)
-                (((byte2 &. 15l <: i32) <<! 8l <: i32) |. (byte1 &. 255l <: i32) <: i32)
+                coef1
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -1397,60 +1335,89 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 2 *! i <: usize) +! sz 1 <: usize)
-                ((byte3 <<! 4l <: i32) |. ((byte2 >>! 4l <: i32) &. 15l <: i32) <: i32)
+                coef2
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
           in
           re)
   in
   re
+#pop-options
 
-let serialize_uncompressed_ring_element (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
-  let serialized:t_Array u8 (sz 384) = Rust_primitives.Hax.repeat 0uy (sz 384) in
-  let serialized:t_Array u8 (sz 384) =
-    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter #(Core.Iter.Adapters.Enumerate.t_Enumerate
-            (Core.Slice.Iter.t_ChunksExact i32))
-          (Core.Iter.Traits.Iterator.f_enumerate #(Core.Slice.Iter.t_ChunksExact i32)
-              (Core.Slice.impl__chunks_exact #i32
-                  (Rust_primitives.unsize re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                    <:
-                    t_Slice i32)
-                  (sz 2)
-                <:
-                Core.Slice.Iter.t_ChunksExact i32)
-            <:
-            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact i32))
-        <:
-        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact i32))
+module A = Libcrux.Kem.Kyber.Arithmetic
+
+[@@"opaque_to_smt"]
+let update3 #n (s: t_Array 't n) (offset: usize {v offset + 3 <= v n}) (i0 i1 i2: 't)
+  : s': t_Array 't n { Seq.index s' (v offset +  0) == i0
+                    /\ Seq.index s' (v offset +  1) == i1
+                    /\ Seq.index s' (v offset +  2) == i2
+                    /\ (forall i. (i < v offset \/ i >= v offset + 3) ==> Seq.index s' i == Seq.index s i) }
+ = let open Rust_primitives.Hax.Monomorphized_update_at in
+    let s = update_at_usize s  offset           i0 in
+    let s = update_at_usize s (offset +! sz  1) i1 in
+    update_at_usize s (offset +! sz  2) i2
+
+let slice_map_lemma #t #u #n (f: t -> u) (arr: t_Array t n)
+  (start: nat) (len: nat {start + len <= v n})
+  : Lemma (  Seq.slice (Spec.Kyber.map' f arr) start (start + len)
+          == Spec.Kyber.map' f (Seq.slice arr start (start + len))
+          )
+  = let f_arr = Spec.Kyber.map' f arr in
+    let lhs = Seq.slice f_arr start (start + len) in
+    let rhs = Spec.Kyber.map' f (Seq.slice arr start (start + len)) in
+    introduce forall i. Seq.index lhs i == Seq.index rhs i
+    with (
+      Seq.lemma_index_slice f_arr start (start + len) i;
+      Seq.lemma_index_slice   arr start (start + len) i;
+      let sz_i_start, sz_i = sz (i + start), sz i in
+      assert (Seq.index f_arr (v sz_i_start) == f (Seq.index arr (v (sz_i_start))));
+      assert (Seq.index rhs (v sz_i) == f (Seq.index (Seq.slice arr start (start + len)) (v sz_i)))
+    );
+    assert (Seq.equal lhs rhs)
+
+#push-options "--z3rlimit 2800 --fuel 0 --ifuel 0 --retry 0 --split_queries no"
+let serialize_uncompressed_ring_element re =
+  let serialized: t_Array u8 (sz 384) = Rust_primitives.Hax.repeat 0uy (sz 384) in
+  let max = v (sz 384) * 8 in
+  assert (max == 256 * 12 /\ max == 384 * 8 /\ 128 * 2 * 12 == max);
+  assert (128 == v (length re.f_coefficients /! (sz 2)));
+  let serialized =
+    Rust_primitives.Iterators.foldi_chunks_exact #_ #_ 
+      #(fun serialized i -> 
+        let i = v i in
+        i <= 128 /\ (
+            let limit = i * 2 * 12 in
+            let coefficients: t_Array _ (sz 256) = Spec.Kyber.map' to_unsigned_representative re.f_coefficients in
+            bit_vec_sub (bit_vec_of_int_t_array serialized   8 ) 0 limit
+         == bit_vec_sub (bit_vec_of_int_t_array coefficients 12) 0 limit)
+      )
+      (re.A.f_coefficients <: t_Array _ (sz 256))
+      (sz 2)
       serialized
-      (fun serialized temp_1_ ->
-          let serialized:t_Array u8 (sz 384) = serialized in
-          let i, coefficients:(usize & t_Slice i32) = temp_1_ in
-          let coefficient1:u16 =
-            Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 0 ] <: i32)
-          in
-          let coefficient2:u16 =
-            Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 1 ] <: i32)
-          in
-          let coef1, coef2, coef3:(u8 & u8 & u8) =
-            compress_coefficients_3_ coefficient1 coefficient2
-          in
-          let serialized:t_Array u8 (sz 384) =
-            Rust_primitives.Hax.Monomorphized_update_at.update_at_usize serialized
-              (sz 3 *! i <: usize)
-              coef1
-          in
-          let serialized:t_Array u8 (sz 384) =
-            Rust_primitives.Hax.Monomorphized_update_at.update_at_usize serialized
-              ((sz 3 *! i <: usize) +! sz 1 <: usize)
-              coef2
-          in
-          let serialized:t_Array u8 (sz 384) =
-            Rust_primitives.Hax.Monomorphized_update_at.update_at_usize serialized
-              ((sz 3 *! i <: usize) +! sz 2 <: usize)
-              coef3
-          in
-          serialized)
+      (fun serialized it -> let i, coefficients = it in
+
+    let coefficient1 = A.to_unsigned_representative (coefficients.[ sz 0 ] <: i32) in
+    let coefficient2 = A.to_unsigned_representative (coefficients.[ sz 1 ] <: i32) in
+    let (coef1, coef2, coef3) = compress_coefficients_3_ coefficient1 coefficient2 in
+    let j = sz 3 *! i in
+    let serialized' = update3 serialized j coef1 coef2 coef3 in
+    assert (      Seq.slice serialized' (v j) (v j + 3)
+      `Seq.equal` Seq.slice (create3 (coef1, coef2, coef3)) 0 3);
+    bit_vec_equal_intro 
+        (let coefficients: t_Array _ (sz 2) = Spec.Kyber.map' to_unsigned_representative coefficients in
+         bit_vec_of_int_t_array coefficients 12)
+        (retype (bit_vec_sub (bit_vec_of_int_t_array serialized'   8) (3 * v i * 8) (3 * 8)));
+    let full_coefficients: t_Array u16 (sz 256) = Spec.Kyber.map' to_unsigned_representative re.f_coefficients in
+    slice_map_lemma #_ #u16 to_unsigned_representative re.f_coefficients (v i * 2) 2;
+    bit_vec_equal_intro
+        (bit_vec_sub (bit_vec_of_int_t_array serialized'   8) 0 (v i * 2 * 12))
+        (bit_vec_sub (bit_vec_of_int_t_array serialized   8 ) 0 (v i * 2 * 12));
+    bit_vec_equal_extend (bit_vec_of_int_t_array serialized' 8)
+                         (bit_vec_of_int_t_array full_coefficients 12)
+                         0 0 (v i * 2 * 12) (3 * 8);
+    serialized' <: t_Array u8 (sz 384))
   in
   serialized
+#pop-options
+
diff -ruN extraction/Libcrux.Kem.Kyber.Serialize.fsti extraction-edited/Libcrux.Kem.Kyber.Serialize.fsti
--- extraction/Libcrux.Kem.Kyber.Serialize.fsti	2024-05-16 17:05:53.733568476 +0200
+++ extraction-edited/Libcrux.Kem.Kyber.Serialize.fsti	2024-05-16 17:05:53.788566631 +0200
@@ -2,133 +2,188 @@
 #set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
 open Core
 open FStar.Mul
+open MkSeq
+open BitVecEq
 
 val compress_coefficients_10_ (coefficient1 coefficient2 coefficient3 coefficient4: i32)
-    : Prims.Pure (u8 & u8 & u8 & u8 & u8) Prims.l_True (fun _ -> Prims.l_True)
+    : Prims.Pure (u8 & u8 & u8 & u8 & u8)
+      (requires True)
+      (ensures fun tuple ->
+         int_t_array_bitwise_eq'
+                (create4 (coefficient1, coefficient2, coefficient3, coefficient4)) 10
+                (create5 tuple) 8
+      )
 
 val compress_coefficients_11_
       (coefficient1 coefficient2 coefficient3 coefficient4 coefficient5 coefficient6 coefficient7 coefficient8:
-          i32)
+          int_t_d i32_inttype 11)
     : Prims.Pure (u8 & u8 & u8 & u8 & u8 & u8 & u8 & u8 & u8 & u8 & u8)
-      Prims.l_True
-      (fun _ -> Prims.l_True)
-
-val compress_coefficients_3_ (coefficient1 coefficient2: u16)
-    : Prims.Pure (u8 & u8 & u8) Prims.l_True (fun _ -> Prims.l_True)
+      (requires True)
+      (ensures fun tuple ->
+         int_t_array_bitwise_eq'
+                (create8 (coefficient1, coefficient2, coefficient3, coefficient4, coefficient5, coefficient6, coefficient7, coefficient8)) 11
+                (create11 tuple) 8
+      )
+
+val compress_coefficients_3_ (coefficient1 coefficient2: int_t_d u16_inttype 12)
+    : Prims.Pure (u8 & u8 & u8)
+    (requires True)
+    (ensures fun tuple ->
+       int_t_array_bitwise_eq'
+              (create2 (coefficient1, coefficient2)) 12
+              (create3 tuple) 8
+    )
 
 val compress_coefficients_5_
-      (coefficient2 coefficient1 coefficient4 coefficient3 coefficient5 coefficient7 coefficient6 coefficient8:
-          u8)
-    : Prims.Pure (u8 & u8 & u8 & u8 & u8) Prims.l_True (fun _ -> Prims.l_True)
-
-val decompress_coefficients_10_ (byte2 byte1 byte3 byte4 byte5: i32)
-    : Prims.Pure (i32 & i32 & i32 & i32) Prims.l_True (fun _ -> Prims.l_True)
+      (coefficient2 coefficient1 coefficient4 coefficient3 coefficient5 coefficient7 coefficient6 coefficient8: int_t_d u8_inttype 5)
+    : Prims.Pure (u8 & u8 & u8 & u8 & u8)
+      (requires True)
+      (ensures fun tuple ->
+         int_t_array_bitwise_eq'
+                (create8 (coefficient1, coefficient2, coefficient3, coefficient4, coefficient5, coefficient6, coefficient7, coefficient8)) 5
+                (create5 tuple) 8
+      )
+
+private unfold type i32_d = int_t_d i32_inttype
+val decompress_coefficients_10_ (byte2 byte1 byte3 byte4 byte5: int_t_d i32_inttype 8)
+    : Prims.Pure (i32_d 10 & i32_d 10 & i32_d 10 & i32_d 10)
+      (requires True)
+      (ensures fun (r1, r2, r3, r4) ->
+         int_t_array_bitwise_eq'
+                (create5 (byte1, byte2, byte3, byte4, byte5)) 8
+                (create4 #i32 (r1, r2, r3, r4)) 10
+      )
 
 val decompress_coefficients_11_
-      (byte2 byte1 byte3 byte5 byte4 byte6 byte7 byte9 byte8 byte10 byte11: i32)
-    : Prims.Pure (i32 & i32 & i32 & i32 & i32 & i32 & i32 & i32)
-      Prims.l_True
-      (fun _ -> Prims.l_True)
+      (byte2 byte1 byte3 byte5 byte4 byte6 byte7 byte9 byte8 byte10 byte11: int_t_d i32_inttype 8)
+    : Prims.Pure (i32_d 11 & i32_d 11 & i32_d 11 & i32_d 11 & i32_d 11 & i32_d 11 & i32_d 11 & i32_d 11)
+      (requires True)
+      (ensures fun (r1, r2, r3, r4, r5, r6, r7, r8) ->
+         int_t_array_bitwise_eq'
+                (create11 #i32 (byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8, byte9, byte10, byte11)) 8
+                (create8 #i32 (r1, r2, r3, r4, r5, r6, r7, r8)) 11
+      )
 
 val decompress_coefficients_4_ (byte: u8)
-    : Prims.Pure (i32 & i32) Prims.l_True (fun _ -> Prims.l_True)
-
-val decompress_coefficients_5_ (byte1 byte2 byte3 byte4 byte5: i32)
-    : Prims.Pure (i32 & i32 & i32 & i32 & i32 & i32 & i32 & i32)
-      Prims.l_True
-      (fun _ -> Prims.l_True)
+    : Prims.Pure (i32_d 4 & i32_d 4)
+      (requires True)
+      (ensures fun (r1, r2) ->
+         int_t_array_bitwise_eq'
+                (create1 byte) 8
+                (create2 #i32 (r1, r2)) 4
+      )
+
+val decompress_coefficients_5_ (byte1 byte2 byte3 byte4 byte5: int_t_d i32_inttype 8)
+    : Prims.Pure (i32_d 5 & i32_d 5 & i32_d 5 & i32_d 5 & i32_d 5 & i32_d 5 & i32_d 5 & i32_d 5)
+      (requires True)
+      (ensures fun (r1, r2, r3, r4, r5, r6, r7, r8) ->
+         int_t_array_bitwise_eq'
+                (create5 #i32 (byte1, byte2, byte3, byte4, byte5)) 8
+                (create8 #i32 (r1, r2, r3, r4, r5, r6, r7, r8)) 5
+      )
 
 val compress_then_serialize_10_
-      (v_OUT_LEN: usize)
-      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+      (v_OUT_LEN: usize {v v_OUT_LEN >= 320})
+      (re: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
     : Prims.Pure (t_Array u8 v_OUT_LEN) Prims.l_True (fun _ -> Prims.l_True)
 
 val compress_then_serialize_11_
-      (v_OUT_LEN: usize)
-      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+      (v_OUT_LEN: usize {v v_OUT_LEN >= 352})
+      (re: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
     : Prims.Pure (t_Array u8 v_OUT_LEN) Prims.l_True (fun _ -> Prims.l_True)
 
 val compress_then_serialize_4_
-      (v_OUT_LEN: usize)
-      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+      (v_OUT_LEN: usize {v v_OUT_LEN >= 128})
+      (re: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
     : Prims.Pure (t_Array u8 v_OUT_LEN) Prims.l_True (fun _ -> Prims.l_True)
 
 val compress_then_serialize_5_
-      (v_OUT_LEN: usize)
-      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+      (v_OUT_LEN: usize {v v_OUT_LEN >= 160})
+      (re: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
     : Prims.Pure (t_Array u8 v_OUT_LEN) Prims.l_True (fun _ -> Prims.l_True)
 
-val compress_then_serialize_message (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-    : Prims.Pure (t_Array u8 (sz 32)) Prims.l_True (fun _ -> Prims.l_True)
+val compress_then_serialize_message (re: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+    : Pure (t_Array u8 (sz 32))
+      (requires True)
+      (ensures (fun res ->
+        res == Spec.Kyber.compress_then_encode_message (Libcrux.Kem.Kyber.Arithmetic.to_spec_poly_b re)))
 
 val compress_then_serialize_ring_element_u
-      (v_COMPRESSION_FACTOR v_OUT_LEN: usize)
-      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-    : Prims.Pure (t_Array u8 v_OUT_LEN) Prims.l_True (fun _ -> Prims.l_True)
-
-val compress_then_serialize_ring_element_v
-      (v_COMPRESSION_FACTOR v_OUT_LEN: usize)
-      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-    : Prims.Pure (t_Array u8 v_OUT_LEN) Prims.l_True (fun _ -> Prims.l_True)
+      (#p:Spec.Kyber.params)
+      (v_COMPRESSION_FACTOR: usize {v v_COMPRESSION_FACTOR == 10 \/ v v_COMPRESSION_FACTOR == 11})
+      (v_OUT_LEN: usize { v v_OUT_LEN = 32 * v v_COMPRESSION_FACTOR })
+      (re: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+    : t_Array u8 v_OUT_LEN
+      
+val compress_then_serialize_ring_element_v (#p:Spec.Kyber.params)
+      (v_COMPRESSION_FACTOR: usize {v_COMPRESSION_FACTOR = sz 4 || v_COMPRESSION_FACTOR = sz 5})
+      (v_OUT_LEN: usize {v v_OUT_LEN = 32 * v v_COMPRESSION_FACTOR})
+      (re: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+    : Pure (t_Array u8 v_OUT_LEN)
+      (requires True)
+      (ensures (fun res -> 
+        res == 
+        Spec.Kyber.compress_then_encode_v p 
+          (Libcrux.Kem.Kyber.Arithmetic.to_spec_poly_b re)))
 
-val deserialize_then_decompress_10_ (serialized: t_Slice u8)
-    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+val deserialize_then_decompress_10_ (serialized: t_Slice u8 {Seq.length serialized == 320})
+    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
       Prims.l_True
       (fun _ -> Prims.l_True)
 
-val deserialize_then_decompress_11_ (serialized: t_Slice u8)
-    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+val deserialize_then_decompress_11_ (serialized: t_Slice u8 {Seq.length serialized == 352})
+    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
       Prims.l_True
       (fun _ -> Prims.l_True)
 
-val deserialize_then_decompress_4_ (serialized: t_Slice u8)
-    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+val deserialize_then_decompress_4_ (serialized: t_Slice u8 {Seq.length serialized == 128})
+    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
       Prims.l_True
       (fun _ -> Prims.l_True)
 
-val deserialize_then_decompress_5_ (serialized: t_Slice u8)
-    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+val deserialize_then_decompress_5_ 
+  (serialized: t_Slice u8 {Seq.length serialized == 160})
+    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
       Prims.l_True
       (fun _ -> Prims.l_True)
 
 val deserialize_then_decompress_message (serialized: t_Array u8 (sz 32))
-    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
-      Prims.l_True
-      (fun _ -> Prims.l_True)
+    : Pure (Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+      (requires True)
+      (ensures fun res ->
+        Libcrux.Kem.Kyber.Arithmetic.to_spec_poly_b res == 
+        Spec.Kyber.decode_then_decompress_message serialized)
 
 val deserialize_then_decompress_ring_element_u
       (v_COMPRESSION_FACTOR: usize)
-      (serialized: t_Slice u8)
-    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
-      Prims.l_True
-      (fun _ -> Prims.l_True)
+      (serialized: t_Slice u8 {
+        match v v_COMPRESSION_FACTOR with
+        | 10 -> Seq.length serialized == 320
+        | 11 -> Seq.length serialized == 352
+        | _ -> False
+      })
+    : Pure (Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+      (requires v_COMPRESSION_FACTOR = sz 10 || v_COMPRESSION_FACTOR = sz 11)
+      (ensures fun _ -> True)
 
-val deserialize_then_decompress_ring_element_v
-      (v_COMPRESSION_FACTOR: usize)
+val deserialize_then_decompress_ring_element_v (#p:Spec.Kyber.params)
+      (v_COMPRESSION_FACTOR: usize {v v_COMPRESSION_FACTOR == 4 \/ v v_COMPRESSION_FACTOR == 5})
       (serialized: t_Slice u8)
-    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
-      Prims.l_True
-      (fun _ -> Prims.l_True)
-
-/// Only use with public values.
-/// This MUST NOT be used with secret inputs, like its caller `deserialize_ring_elements_reduced`.
-val deserialize_to_reduced_ring_element (ring_element: t_Slice u8)
-    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
-      Prims.l_True
-      (fun _ -> Prims.l_True)
-
-/// This function deserializes ring elements and reduces the result by the field
-/// modulus.
-/// This function MUST NOT be used on secret inputs.
-val deserialize_ring_elements_reduced (v_PUBLIC_KEY_SIZE v_K: usize) (public_key: t_Slice u8)
-    : Prims.Pure (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
-      Prims.l_True
-      (fun _ -> Prims.l_True)
+    : Pure (Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+      (requires (p.v_VECTOR_V_COMPRESSION_FACTOR == v_COMPRESSION_FACTOR /\
+                 length serialized == Spec.Kyber.v_C2_SIZE p))
+      (ensures fun res -> Libcrux.Kem.Kyber.Arithmetic.to_spec_poly_b res
+                    == Spec.Kyber.decode_then_decompress_v p serialized)
 
 val deserialize_to_uncompressed_ring_element (serialized: t_Slice u8)
-    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
-      Prims.l_True
-      (fun _ -> Prims.l_True)
-
-val serialize_uncompressed_ring_element (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
-    : Prims.Pure (t_Array u8 (sz 384)) Prims.l_True (fun _ -> Prims.l_True)
+    : Pure (Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+      (requires (length serialized == Spec.Kyber.v_BYTES_PER_RING_ELEMENT))
+      (ensures fun _ -> True)
+
+val serialize_uncompressed_ring_element (re: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+    : Pure (t_Array u8 (sz 384))
+      (requires True)
+      (ensures (fun res ->
+        let coefficients: t_Array _ (sz 256) = Spec.Kyber.map' Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative re.f_coefficients in
+        int_t_array_bitwise_eq res 8 coefficients 12
+      ))
diff -ruN extraction/Libcrux.Kem.Kyber.Types.fst extraction-edited/Libcrux.Kem.Kyber.Types.fst
--- extraction/Libcrux.Kem.Kyber.Types.fst	2024-05-16 17:05:53.710569248 +0200
+++ extraction-edited/Libcrux.Kem.Kyber.Types.fst	2024-05-16 17:05:53.784566765 +0200
@@ -29,7 +29,7 @@
     f_from
     =
     fun (value: t_Array u8 v_SIZE) ->
-      { f_value = Core.Clone.f_clone #(t_Array u8 v_SIZE) value } <: t_MlKemCiphertext v_SIZE
+      { f_value = Core.Clone.f_clone value } <: t_MlKemCiphertext v_SIZE
   }
 
 [@@ FStar.Tactics.Typeclasses.tcinstance]
@@ -40,14 +40,42 @@
     f_from = fun (value: t_MlKemCiphertext v_SIZE) -> value.f_value
   }
 
+[@@ FStar.Tactics.Typeclasses.tcinstance]
+let impl_5 (v_SIZE: usize) : Core.Convert.t_TryFrom (t_MlKemCiphertext v_SIZE) (t_Slice u8) =
+  {
+    f_Error = Core.Array.t_TryFromSliceError;
+    f_try_from_pre = (fun (value: t_Slice u8) -> true);
+    f_try_from_post
+    =
+    (fun
+        (value: t_Slice u8)
+        (out: Core.Result.t_Result (t_MlKemCiphertext v_SIZE) Core.Array.t_TryFromSliceError)
+        ->
+        true);
+    f_try_from
+    =
+    fun (value: t_Slice u8) ->
+      match Core.Convert.f_try_into value with
+      | Core.Result.Result_Ok value ->
+        Core.Result.Result_Ok ({ f_value = value } <: t_MlKemCiphertext v_SIZE)
+        <:
+        Core.Result.t_Result (t_MlKemCiphertext v_SIZE) Core.Array.t_TryFromSliceError
+      | Core.Result.Result_Err e ->
+        Core.Result.Result_Err e
+        <:
+        Core.Result.t_Result (t_MlKemCiphertext v_SIZE) Core.Array.t_TryFromSliceError
+  }
+
 let impl_6__as_slice (v_SIZE: usize) (self: t_MlKemCiphertext v_SIZE) : t_Array u8 v_SIZE =
   self.f_value
 
 let impl_6__len (v_SIZE: usize) (self: t_MlKemCiphertext v_SIZE) : usize = v_SIZE
 
 let impl_6__split_at (v_SIZE: usize) (self: t_MlKemCiphertext v_SIZE) (mid: usize)
-    : (t_Slice u8 & t_Slice u8) =
-  Core.Slice.impl__split_at #u8 (Rust_primitives.unsize self.f_value <: t_Slice u8) mid
+    : Pure (t_Slice u8 & t_Slice u8)
+      (requires (mid <=. v_SIZE))
+      (ensures (fun (x,y) -> Seq.length x == v mid /\ Seq.length y == v (v_SIZE -! mid))) =
+  Core.Slice.impl__split_at (Rust_primitives.unsize self.f_value <: t_Slice u8) mid
 
 type t_MlKemPrivateKey (v_SIZE: usize) = { f_value:t_Array u8 v_SIZE }
 
@@ -75,7 +103,7 @@
     f_from
     =
     fun (value: t_Array u8 v_SIZE) ->
-      { f_value = Core.Clone.f_clone #(t_Array u8 v_SIZE) value } <: t_MlKemPrivateKey v_SIZE
+      { f_value = Core.Clone.f_clone value } <: t_MlKemPrivateKey v_SIZE
   }
 
 [@@ FStar.Tactics.Typeclasses.tcinstance]
@@ -86,14 +114,52 @@
     f_from = fun (value: t_MlKemPrivateKey v_SIZE) -> value.f_value
   }
 
+[@@ FStar.Tactics.Typeclasses.tcinstance]
+let impl_11 (v_SIZE: usize) : Core.Convert.t_TryFrom (t_MlKemPrivateKey v_SIZE) (t_Slice u8) =
+  {
+    f_Error = Core.Array.t_TryFromSliceError;
+    f_try_from_pre = (fun (value: t_Slice u8) -> true);
+    f_try_from_post
+    =
+    (fun
+        (value: t_Slice u8)
+        (out: Core.Result.t_Result (t_MlKemPrivateKey v_SIZE) Core.Array.t_TryFromSliceError)
+        ->
+        true);
+    f_try_from
+    =
+    fun (value: t_Slice u8) ->
+      match Core.Convert.f_try_into value with
+      | Core.Result.Result_Ok value ->
+        Core.Result.Result_Ok ({ f_value = value } <: t_MlKemPrivateKey v_SIZE)
+        <:
+        Core.Result.t_Result (t_MlKemPrivateKey v_SIZE) Core.Array.t_TryFromSliceError
+      | Core.Result.Result_Err e ->
+        Core.Result.Result_Err e
+        <:
+        Core.Result.t_Result (t_MlKemPrivateKey v_SIZE) Core.Array.t_TryFromSliceError
+  }
+
 let impl_12__as_slice (v_SIZE: usize) (self: t_MlKemPrivateKey v_SIZE) : t_Array u8 v_SIZE =
   self.f_value
 
 let impl_12__len (v_SIZE: usize) (self: t_MlKemPrivateKey v_SIZE) : usize = v_SIZE
 
 let impl_12__split_at (v_SIZE: usize) (self: t_MlKemPrivateKey v_SIZE) (mid: usize)
-    : (t_Slice u8 & t_Slice u8) =
-  Core.Slice.impl__split_at #u8 (Rust_primitives.unsize self.f_value <: t_Slice u8) mid
+    : Pure (t_Slice u8 & t_Slice u8)
+      (requires (mid <=. v_SIZE))
+      (ensures (fun (x,y) -> Seq.length x == v mid /\ Seq.length y == v (v_SIZE -! mid))) =
+  Core.Slice.impl__split_at (Rust_primitives.unsize self.f_value <: t_Slice u8) mid
+
+
+
+
+
+
+
+
+
+
 
 type t_MlKemPublicKey (v_SIZE: usize) = { f_value:t_Array u8 v_SIZE }
 
@@ -121,7 +187,7 @@
     f_from
     =
     fun (value: t_Array u8 v_SIZE) ->
-      { f_value = Core.Clone.f_clone #(t_Array u8 v_SIZE) value } <: t_MlKemPublicKey v_SIZE
+      { f_value = Core.Clone.f_clone value } <: t_MlKemPublicKey v_SIZE
   }
 
 [@@ FStar.Tactics.Typeclasses.tcinstance]
@@ -132,67 +198,6 @@
     f_from = fun (value: t_MlKemPublicKey v_SIZE) -> value.f_value
   }
 
-let impl_18__as_slice (v_SIZE: usize) (self: t_MlKemPublicKey v_SIZE) : t_Array u8 v_SIZE =
-  self.f_value
-
-let impl_18__len (v_SIZE: usize) (self: t_MlKemPublicKey v_SIZE) : usize = v_SIZE
-
-let impl_18__split_at (v_SIZE: usize) (self: t_MlKemPublicKey v_SIZE) (mid: usize)
-    : (t_Slice u8 & t_Slice u8) =
-  Core.Slice.impl__split_at #u8 (Rust_primitives.unsize self.f_value <: t_Slice u8) mid
-
-[@@ FStar.Tactics.Typeclasses.tcinstance]
-let impl_5 (v_SIZE: usize) : Core.Convert.t_TryFrom (t_MlKemCiphertext v_SIZE) (t_Slice u8) =
-  {
-    f_Error = Core.Array.t_TryFromSliceError;
-    f_try_from_pre = (fun (value: t_Slice u8) -> true);
-    f_try_from_post
-    =
-    (fun
-        (value: t_Slice u8)
-        (out: Core.Result.t_Result (t_MlKemCiphertext v_SIZE) Core.Array.t_TryFromSliceError)
-        ->
-        true);
-    f_try_from
-    =
-    fun (value: t_Slice u8) ->
-      match Core.Convert.f_try_into #(t_Slice u8) #(t_Array u8 v_SIZE) value with
-      | Core.Result.Result_Ok value ->
-        Core.Result.Result_Ok ({ f_value = value } <: t_MlKemCiphertext v_SIZE)
-        <:
-        Core.Result.t_Result (t_MlKemCiphertext v_SIZE) Core.Array.t_TryFromSliceError
-      | Core.Result.Result_Err e ->
-        Core.Result.Result_Err e
-        <:
-        Core.Result.t_Result (t_MlKemCiphertext v_SIZE) Core.Array.t_TryFromSliceError
-  }
-
-[@@ FStar.Tactics.Typeclasses.tcinstance]
-let impl_11 (v_SIZE: usize) : Core.Convert.t_TryFrom (t_MlKemPrivateKey v_SIZE) (t_Slice u8) =
-  {
-    f_Error = Core.Array.t_TryFromSliceError;
-    f_try_from_pre = (fun (value: t_Slice u8) -> true);
-    f_try_from_post
-    =
-    (fun
-        (value: t_Slice u8)
-        (out: Core.Result.t_Result (t_MlKemPrivateKey v_SIZE) Core.Array.t_TryFromSliceError)
-        ->
-        true);
-    f_try_from
-    =
-    fun (value: t_Slice u8) ->
-      match Core.Convert.f_try_into #(t_Slice u8) #(t_Array u8 v_SIZE) value with
-      | Core.Result.Result_Ok value ->
-        Core.Result.Result_Ok ({ f_value = value } <: t_MlKemPrivateKey v_SIZE)
-        <:
-        Core.Result.t_Result (t_MlKemPrivateKey v_SIZE) Core.Array.t_TryFromSliceError
-      | Core.Result.Result_Err e ->
-        Core.Result.Result_Err e
-        <:
-        Core.Result.t_Result (t_MlKemPrivateKey v_SIZE) Core.Array.t_TryFromSliceError
-  }
-
 [@@ FStar.Tactics.Typeclasses.tcinstance]
 let impl_17 (v_SIZE: usize) : Core.Convert.t_TryFrom (t_MlKemPublicKey v_SIZE) (t_Slice u8) =
   {
@@ -208,7 +213,7 @@
     f_try_from
     =
     fun (value: t_Slice u8) ->
-      match Core.Convert.f_try_into #(t_Slice u8) #(t_Array u8 v_SIZE) value with
+      match Core.Convert.f_try_into value with
       | Core.Result.Result_Ok value ->
         Core.Result.Result_Ok ({ f_value = value } <: t_MlKemPublicKey v_SIZE)
         <:
@@ -219,7 +224,17 @@
         Core.Result.t_Result (t_MlKemPublicKey v_SIZE) Core.Array.t_TryFromSliceError
   }
 
-/// An ML-KEM key pair
+let impl_18__as_slice (v_SIZE: usize) (self: t_MlKemPublicKey v_SIZE) : t_Array u8 v_SIZE =
+  self.f_value
+
+let impl_18__len (v_SIZE: usize) (self: t_MlKemPublicKey v_SIZE) : usize = v_SIZE
+
+let impl_18__split_at (v_SIZE: usize) (self: t_MlKemPublicKey v_SIZE) (mid: usize)
+    : Pure (t_Slice u8 & t_Slice u8)
+      (requires (mid <=. v_SIZE))
+      (ensures (fun (x,y) -> Seq.length x == v mid /\ Seq.length y == v (v_SIZE -! mid))) =
+  Core.Slice.impl__split_at (Rust_primitives.unsize self.f_value <: t_Slice u8) mid
+
 type t_MlKemKeyPair (v_PRIVATE_KEY_SIZE: usize) (v_PUBLIC_KEY_SIZE: usize) = {
   f_sk:t_MlKemPrivateKey v_PRIVATE_KEY_SIZE;
   f_pk:t_MlKemPublicKey v_PUBLIC_KEY_SIZE
@@ -232,20 +247,12 @@
     : t_MlKemKeyPair v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE =
   { f_sk = sk; f_pk = pk } <: t_MlKemKeyPair v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE
 
-/// Creates a new [`MlKemKeyPair`].
 let impl__new
       (v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE: usize)
       (sk: t_Array u8 v_PRIVATE_KEY_SIZE)
       (pk: t_Array u8 v_PUBLIC_KEY_SIZE)
     : t_MlKemKeyPair v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE =
-  {
-    f_sk
-    =
-    Core.Convert.f_into #(t_Array u8 v_PRIVATE_KEY_SIZE) #(t_MlKemPrivateKey v_PRIVATE_KEY_SIZE) sk;
-    f_pk
-    =
-    Core.Convert.f_into #(t_Array u8 v_PUBLIC_KEY_SIZE) #(t_MlKemPublicKey v_PUBLIC_KEY_SIZE) pk
-  }
+  { f_sk = Core.Convert.f_into sk; f_pk = Core.Convert.f_into pk }
   <:
   t_MlKemKeyPair v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE
 
diff -ruN extraction/Libcrux_platform.Platform.fsti extraction-edited/Libcrux_platform.Platform.fsti
--- extraction/Libcrux_platform.Platform.fsti	1970-01-01 01:00:00.000000000 +0100
+++ extraction-edited/Libcrux_platform.Platform.fsti	2024-05-16 17:05:53.740568242 +0200
@@ -0,0 +1,20 @@
+module Libcrux_platform.Platform
+#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
+open Core
+open FStar.Mul
+
+val bmi2_adx_support: Prims.unit -> Prims.Pure bool Prims.l_True (fun _ -> Prims.l_True)
+
+val simd256_support: Prims.unit -> Prims.Pure bool Prims.l_True (fun _ -> Prims.l_True)
+
+val x25519_support: Prims.unit -> Prims.Pure bool Prims.l_True (fun _ -> Prims.l_True)
+
+val adv_simd_support: Prims.unit -> Prims.Pure bool Prims.l_True (fun _ -> Prims.l_True)
+
+val aes_ni_support: Prims.unit -> Prims.Pure bool Prims.l_True (fun _ -> Prims.l_True)
+
+val pmull_support: Prims.unit -> Prims.Pure bool Prims.l_True (fun _ -> Prims.l_True)
+
+val sha256_support: Prims.unit -> Prims.Pure bool Prims.l_True (fun _ -> Prims.l_True)
+
+val simd128_support: Prims.unit -> Prims.Pure bool Prims.l_True (fun _ -> Prims.l_True)
diff -ruN extraction/MkSeq.fst extraction-edited/MkSeq.fst
--- extraction/MkSeq.fst	1970-01-01 01:00:00.000000000 +0100
+++ extraction-edited/MkSeq.fst	2024-05-16 17:05:53.758567637 +0200
@@ -0,0 +1,91 @@
+module MkSeq
+open Core
+
+open FStar.Tactics.V2
+
+private let init (len: nat) (f: (i:nat{i < len}) -> Tac 'a): Tac (list 'a)
+  = let rec h (i: nat {i <= len}): Tac (list 'a)
+     = if i = len then [] else f i :: h (i + 1)
+    in h 0
+
+private let tuple_proj (n: nat) (i: nat): Tac term
+  = if n = 1 then `(id) else
+    let name = "__proj__Mktuple" ^ string_of_int n ^ "__item___" ^ string_of_int (i + 1) in
+    Tv_FVar (pack_fv ["FStar";"Pervasives";"Native";name])
+
+private let tuple_type (n: nat): Tac term
+  = if n = 1 then `(id) else
+    let name = "tuple" ^ string_of_int n in
+    Tv_FVar (pack_fv ["FStar";"Pervasives";"Native";name])
+
+open Rust_primitives.Integers
+open Libcrux.Kem.Kyber.Arithmetic
+
+// let create4 (x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10: 'a)
+//   : Pure 
+//     (t_Array 'a (sz 11))
+//     (requires True)
+//     (ensures fun (r: t_Array 'a (sz 11)) -> 
+//       r.[sz 0] == x0 /\
+//       r.[sz 1] == x1 /\
+//       r.[sz 2] == x2 /\
+//       r.[sz 3] == x3 /\
+//       r.[sz 4] == x4 /\
+//       r.[sz 5] == x5 /\
+//       r.[sz 6] == x6 /\
+//       r.[sz 7] == x7 /\
+//       True
+//       )
+//   = Libcrux.Kem.Kyber.Arithmetic.createi
+//     (sz 11) 
+//     (fun x -> match v x with
+//       | 0 -> x0
+//       | 1 -> x1
+//       | 2 -> x2
+//       | 3 -> x3
+//       | 4 -> x4
+//       | 5 -> x5
+//       | 6 -> x6
+//       | 7 -> x7
+//       | 8 -> x8
+//       | 9 -> x9
+//       | 10 -> x10
+//       )
+
+private let create_gen_tac (n: nat): Tac sigelt
+  = let typ_bd = {fresh_binder_named "t" (`Type0) with qual = FStar.Reflection.V2.Q_Implicit} in
+    let typ = binder_to_term typ_bd in
+    let input_typ = mk_e_app (tuple_type n) (init n (fun _ -> typ)) in
+    let input_bd = fresh_binder_named "tup" input_typ in
+    let output_type = `t_Array (`#typ) (sz (`@n)) in
+    let nth i = `((`#(tuple_proj n i)) (`#input_bd)) in
+    let mk_and: term -> term -> Tac term = fun t u -> `(`#t /\ `#u) in
+    let post =
+      let mk_inv s i = `(Seq.index (`#s) (`@i) == (`#(tuple_proj n i)) (`#input_bd)) in
+      let invs s = Tactics.fold_left mk_and (`(Seq.length (`#s) == (`@n))) (init n (mk_inv s)) in
+      let bd = fresh_binder_named "s" output_type in
+      mk_abs [bd] (invs bd)
+    in
+    let comp = C_Eff [] ["Prims"; "Pure"]
+      (`t_Array (`#typ) (sz (`@n)))
+      [ (`(requires True), Q_Explicit); (post, Q_Explicit)] []
+    in
+    let args = [typ_bd; input_bd] in
+    let l = Tactics.fold_right (fun hd tl -> `((`#hd)::(`#tl))) (init n nth) (`[]) in
+    let indexes =
+      let f i = `((`#(nth i)) == List.Tot.index (`#l) (`@i)) in
+      Tactics.fold_left mk_and (`True) (init n f)
+    in
+    let lb_def = mk_abs args (`(
+      let l = `#l in
+      let s = Seq.createL l <: t_Array (`#typ) (sz (`@n)) in
+      FStar.Classical.forall_intro (Seq.lemma_index_is_nth s);
+      assert (`#indexes) by (Tactics.norm [primops; iota; delta; zeta]);
+      s
+    )) in
+    let lb_typ = mk_arr args (pack_comp comp) in
+    let open FStar.List.Tot in
+    let lb_fv = pack_fv (cur_module () @ ["create" ^ string_of_int n]) in
+    Sg_Let { isrec = false; lbs = [{ lb_fv; lb_us = []; lb_typ; lb_def }] }
+
+%splice[] (init 13 (fun i -> create_gen_tac (i + 1)))
diff -ruN extraction/Spec.Kyber.fst extraction-edited/Spec.Kyber.fst
--- extraction/Spec.Kyber.fst	1970-01-01 01:00:00.000000000 +0100
+++ extraction-edited/Spec.Kyber.fst	2024-05-16 17:05:53.749567940 +0200
@@ -0,0 +1,435 @@
+module Spec.Kyber
+#set-options "--fuel 0 --ifuel 1 --z3rlimit 100"
+open Core
+open FStar.Mul
+
+(** Utils *)
+let map' #a #b
+  (f:(x:a -> b))
+  (s: t_Slice a): t_Slice b
+  = createi (length s) (fun i -> f (Seq.index s (v i)))
+
+#push-options "--fuel 0 --ifuel 0 --z3rlimit 500"
+let flatten #t #n
+  (#m: usize {range (v n * v m) usize_inttype})
+  (x: t_Array (t_Array t m) n)
+  : t_Array t (m *! n)
+  = createi (m *! n) (fun i -> Seq.index (Seq.index x (v i / v m)) (v i % v m))
+#pop-options
+
+(** Constants *)
+let v_BITS_PER_COEFFICIENT: usize = sz 12
+
+let v_COEFFICIENTS_IN_RING_ELEMENT: usize = sz 256
+
+let v_BITS_PER_RING_ELEMENT: usize = sz 3072 // v_COEFFICIENTS_IN_RING_ELEMENT *! sz 12
+
+let v_BYTES_PER_RING_ELEMENT: usize = sz 384 // v_BITS_PER_RING_ELEMENT /! sz 8
+
+let v_CPA_PKE_KEY_GENERATION_SEED_SIZE: usize = sz 32
+
+let v_FIELD_MODULUS: i32 = 3329l
+
+let v_H_DIGEST_SIZE: usize = sz 32 
+//  Libcrux.Digest.digest_size (Libcrux.Digest.Algorithm_Sha3_256_ <: Libcrux.Digest.t_Algorithm)
+
+let v_REJECTION_SAMPLING_SEED_SIZE: usize =  sz 840 // sz 168 *! sz 5
+
+let v_SHARED_SECRET_SIZE: usize = v_H_DIGEST_SIZE
+
+type params_ = {
+    v_RANK: usize;
+    v_ETA1: usize;
+    v_ETA2: usize;
+    v_VECTOR_U_COMPRESSION_FACTOR: usize;
+    v_VECTOR_V_COMPRESSION_FACTOR: usize;
+}
+
+let valid_params p =
+  (p.v_RANK = sz 2 || p.v_RANK = sz 3 || p.v_RANK = sz 4) &&
+  (p.v_ETA1 = sz 2 || p.v_ETA1 = sz 3) &&
+  p.v_ETA2 =. sz 2 &&
+  (p.v_VECTOR_U_COMPRESSION_FACTOR = sz 10 || p.v_VECTOR_U_COMPRESSION_FACTOR = sz 11) &&
+  (p.v_VECTOR_V_COMPRESSION_FACTOR = sz 4 || p.v_VECTOR_V_COMPRESSION_FACTOR = sz 5)
+
+let params = p:params_{valid_params p}
+
+val v_ETA1_RANDOMNESS_SIZE (p:params) : u:usize{u == sz 128 \/ u == sz 192}
+let v_ETA1_RANDOMNESS_SIZE (p:params) = p.v_ETA1 *! sz 64
+
+val v_ETA2_RANDOMNESS_SIZE (p:params) : u:usize{u == sz 128}
+let v_ETA2_RANDOMNESS_SIZE (p:params) = p.v_ETA2 *! sz 64
+
+val v_RANKED_BYTES_PER_RING_ELEMENT (p:params) : u:usize{u = sz 768 \/ u = sz 1152 \/ u = sz 1536}
+let v_RANKED_BYTES_PER_RING_ELEMENT (p:params)  = p.v_RANK *! v_BYTES_PER_RING_ELEMENT
+
+let v_T_AS_NTT_ENCODED_SIZE (p:params) = v_RANKED_BYTES_PER_RING_ELEMENT p
+let v_CPA_PKE_SECRET_KEY_SIZE (p:params) = v_RANKED_BYTES_PER_RING_ELEMENT p
+
+val v_CPA_PKE_PUBLIC_KEY_SIZE (p:params) : u:usize{u = sz 800 \/ u = sz 1184 \/ u = sz 1568}
+let v_CPA_PKE_PUBLIC_KEY_SIZE (p:params) = v_RANKED_BYTES_PER_RING_ELEMENT p +! sz 32
+
+val v_SECRET_KEY_SIZE (p:params) : u:usize{u = sz 1632 \/ u = sz 2400 \/ u = sz 3168}
+let v_SECRET_KEY_SIZE (p:params) =
+  (v_CPA_PKE_SECRET_KEY_SIZE p +! v_CPA_PKE_PUBLIC_KEY_SIZE p +! v_H_DIGEST_SIZE +! v_SHARED_SECRET_SIZE)
+
+val v_C1_BLOCK_SIZE (p:params): u:usize{(u = sz 320 \/ u = sz 352) /\ v u == 32 * v p.v_VECTOR_U_COMPRESSION_FACTOR}
+let v_C1_BLOCK_SIZE (p:params) = sz 32 *! p.v_VECTOR_U_COMPRESSION_FACTOR
+
+val v_C1_SIZE (p:params) : u:usize{(u >=. sz 640 \/ u <=. sz 1448) /\ 
+                                    v u == v (v_C1_BLOCK_SIZE p) * v p.v_RANK}
+let v_C1_SIZE (p:params) = v_C1_BLOCK_SIZE p *! p.v_RANK
+
+val v_C2_SIZE (p:params) : u:usize{(u = sz 128 \/ u = sz 160) /\ v u == 32 * v p.v_VECTOR_V_COMPRESSION_FACTOR }
+let v_C2_SIZE (p:params) = sz 32 *! p.v_VECTOR_V_COMPRESSION_FACTOR
+
+val v_CPA_PKE_CIPHERTEXT_SIZE (p:params) : u:usize {v u = v (v_C1_SIZE p) + v (v_C2_SIZE p)}
+let v_CPA_PKE_CIPHERTEXT_SIZE (p:params) = v_C1_SIZE p +! v_C2_SIZE p
+
+val v_IMPLICIT_REJECTION_HASH_INPUT_SIZE (p:params): u:usize{v u == v v_SHARED_SECRET_SIZE + 
+                                                                    v (v_CPA_PKE_CIPHERTEXT_SIZE p)}
+let v_IMPLICIT_REJECTION_HASH_INPUT_SIZE (p:params) =
+    v_SHARED_SECRET_SIZE +! v_CPA_PKE_CIPHERTEXT_SIZE p
+
+val v_KEY_GENERATION_SEED_SIZE: u:usize{u = sz 64}
+let v_KEY_GENERATION_SEED_SIZE: usize =
+  v_CPA_PKE_KEY_GENERATION_SEED_SIZE +!
+  v_SHARED_SECRET_SIZE
+
+(** Types *)
+
+type t_Error = | Error_RejectionSampling : t_Error
+
+type t_Result a b = 
+  | Ok: a -> t_Result a b
+  | Err: b -> t_Result a b
+
+type t_KyberPublicKey (p:params) = t_Array u8 (v_CPA_PKE_PUBLIC_KEY_SIZE p)
+type t_KyberPrivateKey (p:params) = t_Array u8 (v_SECRET_KEY_SIZE p)
+type t_KyberKeyPair (p:params) = t_KyberPrivateKey p & t_KyberPublicKey p
+
+type t_KyberCPAPrivateKey (p:params) = t_Array u8 (v_CPA_PKE_SECRET_KEY_SIZE p)
+type t_KyberCPAKeyPair (p:params) = t_KyberCPAPrivateKey p & t_KyberPublicKey p
+
+type t_KyberCiphertext (p:params) = t_Array u8 (v_CPA_PKE_CIPHERTEXT_SIZE p)
+type t_KyberSharedSecret = t_Array u8 (v_SHARED_SECRET_SIZE)
+
+(** Utility and Hash Function *)
+assume val v_G (input: t_Slice u8) : t_Array u8 (sz 64)
+assume val v_H (input: t_Slice u8) : t_Array u8 (sz 32)
+assume val v_PRF (v_LEN: usize) (input: t_Slice u8) : t_Array u8 v_LEN
+let v_J (input: t_Slice u8) : t_Array u8 (sz 32) = v_PRF (sz 32) input
+assume val v_XOF (v_LEN: usize) (input: t_Slice u8) : t_Array u8 v_LEN
+
+(** Kyber Math and Sampling *)
+
+type field_element = n:nat{n < v v_FIELD_MODULUS}
+type polynomial = arr: t_Array nat (sz 256) {forall i. Seq.index arr i < v v_FIELD_MODULUS}
+type vector (p:params) = t_Array polynomial p.v_RANK
+type matrix (p:params) = t_Array (vector p) p.v_RANK
+
+assume val poly_add: polynomial -> polynomial -> polynomial
+assume val poly_sub: polynomial -> polynomial -> polynomial
+assume val vector_add: #p:params -> vector p -> vector p -> vector p
+assume val vector_dot_product: #p:params -> vector p -> vector p -> polynomial
+
+assume val matrix_transpose: #p:params -> matrix p -> matrix p
+assume val matrix_vector_mul: #p:params -> matrix p -> vector p -> vector p
+val compute_As_plus_e: #p:params -> a:matrix p -> s:vector p -> e:vector p -> vector p
+let compute_As_plus_e #p a s e = vector_add (matrix_vector_mul a s) e
+
+assume val poly_inv_ntt: #p:params -> polynomial -> polynomial
+assume val vector_ntt: #p:params -> vector p -> vector p
+assume val vector_inv_ntt: #p:params -> vector p -> vector p
+
+// note we take seed of size 32 not 34 as in hacspec
+assume val sample_matrix_A: #p:params -> seed:t_Array u8 (sz 32) -> matrix p
+// note we take seed of size 32 not 33 as in hacspec
+assume val sample_vector_cbd: #p:params -> seed:t_Array u8 (sz 32) -> domain_sep:usize -> vector p
+// note we take seed of size 32 not 33 as in hacspec
+
+assume val sample_poly_binomial: v_ETA:usize{v v_ETA <= 3}  -> t_Array u8 (v_ETA *! sz 64) -> polynomial
+
+open Rust_primitives.Integers
+
+val sample_poly_cbd: #p:params -> seed:t_Array u8 (sz 32) -> domain_sep:usize{v domain_sep < 256} -> polynomial
+let sample_poly_cbd #p seed domain_sep =
+  let prf_input = Seq.append seed (Seq.create 1 (mk_int #u8_inttype (v domain_sep))) in
+  let prf_output = v_PRF (v_ETA2_RANDOMNESS_SIZE p) prf_input in
+  sample_poly_binomial p.v_ETA2 prf_output
+
+let sample_vector_cbd_then_ntt (#p:params) (seed:t_Array u8 (sz 32)) (domain_sep:usize) =
+  vector_ntt (sample_vector_cbd #p seed domain_sep)
+
+type dT = d: nat {d = 1 \/ d = 4 \/ d = 5 \/ d = 10 \/ d = 11 \/ d = 12}
+
+let compress_d (d: dT {d <> 12}) (x: field_element): field_element
+  = (pow2 d * x + 1664) / v v_FIELD_MODULUS
+
+let bits_to_bytes (#bytes: usize) (bv: bit_vec (v bytes * 8))
+  : Pure (t_Array u8 bytes)
+         (requires True)
+         (ensures fun r -> (forall i. bit_vec_of_int_t_array r 8 i == bv i))
+  = bit_vec_to_int_t_array 8 bv
+
+let bytes_to_bits (#bytes: usize) (r: t_Array u8 bytes)
+  : Pure (i: bit_vec (v bytes * 8))
+         (requires True)
+         (ensures fun f -> (forall i. bit_vec_of_int_t_array r 8 i == f i))
+  = bit_vec_of_int_t_array r 8
+
+unfold let retype_bit_vector #a #b (#_:unit{a == b}) (x: a): b = x
+
+let byte_encode (d: dT) (coefficients: polynomial): t_Array u8 (sz (32 * d))
+  = bits_to_bytes #(sz (32 * d))
+       (retype_bit_vector (bit_vec_of_nat_array coefficients d))
+
+let byte_decode (d: dT) (coefficients: t_Array u8 (sz (32 * d))): polynomial
+  = let bv = bit_vec_of_int_t_array coefficients 8 in
+    let arr: t_Array nat (sz 256) = bit_vec_to_nat_array d (retype_bit_vector bv) in
+    let p = map' (fun (x: nat) -> x % v v_FIELD_MODULUS <: nat) arr in
+    introduce forall i. Seq.index p i < v v_FIELD_MODULUS
+    with assert (Seq.index p i == Seq.index p (v (sz i)));
+    p
+
+let vector_encode_12 (#p:params) (v: vector p): t_Array u8 (v_T_AS_NTT_ENCODED_SIZE p)
+  = let s: t_Array (t_Array _ (sz 384)) p.v_RANK = map' (byte_encode 12) v in
+    flatten s
+
+let vector_decode_12 (#p:params) (arr: t_Array u8 (v_T_AS_NTT_ENCODED_SIZE p)): vector p
+  = createi p.v_RANK (fun block -> 
+      let block_size = (sz (32 * 12)) in
+      let slice = Seq.slice arr (v block * v block_size) 
+                                (v block * v block_size + v block_size) in
+      byte_decode 12 slice
+    )
+
+let compress_then_byte_encode (d: dT {d <> 12}) (coefficients: polynomial): t_Array u8 (sz (32 * d))
+  = let coefs: t_Array nat (sz 256) = map (fun (f: nat {f < v v_FIELD_MODULUS}) ->
+           compress_d d f <: nat
+         ) coefficients
+    in
+    byte_encode d coefficients
+
+let compress_then_encode_message: polynomial -> t_Array u8 v_SHARED_SECRET_SIZE
+  = byte_encode 1
+
+let decode_then_decompress_message: t_Array u8 v_SHARED_SECRET_SIZE -> polynomial
+  = byte_decode 1
+
+let compress_then_encode_u (p:params) (vec: vector p): t_Array u8 (v_C1_SIZE p)
+  = let d = p.v_VECTOR_U_COMPRESSION_FACTOR in
+    flatten (map #_ #_ #(fun _ -> True) (byte_encode (v d)) vec)
+
+let decode_then_decompress_u (p:params) (arr: t_Array u8 (v_C1_SIZE p)): vector p
+  = let d = p.v_VECTOR_U_COMPRESSION_FACTOR in
+    createi p.v_RANK (fun block -> 
+      let block_size = v_C1_BLOCK_SIZE p in
+      let slice = Seq.slice arr (v block * v block_size) 
+                                (v block * v block_size + v block_size) in
+      byte_decode (v d) slice
+    )
+
+let compress_then_encode_v (p:params): polynomial -> t_Array u8 (v_C2_SIZE p)
+  = byte_encode (v p.v_VECTOR_V_COMPRESSION_FACTOR)
+
+let decode_then_decompress_v (p:params): t_Array u8 (v_C2_SIZE p) -> polynomial
+  = byte_decode (v p.v_VECTOR_V_COMPRESSION_FACTOR)
+
+(** IND-CPA Functions *)
+
+/// This function implements most of <strong>Algorithm 12</strong> of the
+/// NIST FIPS 203 specification; this is the Kyber CPA-PKE key generation algorithm.
+///
+/// We say "most of" since Algorithm 12 samples the required randomness within
+/// the function itself, whereas this implementation expects it to be provided
+/// through the `key_generation_seed` parameter.
+
+val ind_cpa_generate_keypair (p:params) (randomness:t_Array u8 v_CPA_PKE_KEY_GENERATION_SEED_SIZE) :
+                             t_KyberCPAKeyPair p
+let ind_cpa_generate_keypair p randomness =
+    let hashed = v_G randomness in
+    let (seed_for_A, seed_for_secret_and_error) = split hashed (sz 32) in
+    let matrix_A_as_ntt = sample_matrix_A #p seed_for_A in
+    let secret_as_ntt = sample_vector_cbd_then_ntt #p seed_for_secret_and_error (sz 0) in
+    let error_as_ntt = sample_vector_cbd_then_ntt #p seed_for_secret_and_error p.v_RANK in
+    let t_as_ntt = compute_As_plus_e #p matrix_A_as_ntt secret_as_ntt error_as_ntt in
+    let public_key_serialized = Seq.append (vector_encode_12 #p t_as_ntt) seed_for_A in
+    let secret_key_serialized = vector_encode_12 #p secret_as_ntt in
+    (secret_key_serialized,public_key_serialized)
+
+/// This function implements <strong>Algorithm 13</strong> of the
+/// NIST FIPS 203 specification; this is the Kyber CPA-PKE encryption algorithm.
+
+val ind_cpa_encrypt (p:params) (public_key: t_KyberPublicKey p)
+                    (message: t_Array u8 v_SHARED_SECRET_SIZE)
+                    (randomness:t_Array u8 v_SHARED_SECRET_SIZE) :
+                    t_KyberCiphertext p
+
+let ind_cpa_encrypt p public_key message randomness =
+    let (t_as_ntt_bytes, seed_for_A) = split public_key (v_T_AS_NTT_ENCODED_SIZE p) in
+    let t_as_ntt = vector_decode_12 #p t_as_ntt_bytes in 
+    let matrix_A_as_ntt = sample_matrix_A #p seed_for_A in
+    let r_as_ntt = sample_vector_cbd_then_ntt #p randomness (sz 0) in
+    let error_1 = sample_vector_cbd #p randomness p.v_RANK in
+    let error_2 = sample_poly_cbd #p randomness (p.v_RANK +! p.v_RANK) in
+    let u = vector_add (vector_inv_ntt (matrix_vector_mul (matrix_transpose matrix_A_as_ntt) r_as_ntt)) error_1 in
+    let mu = decode_then_decompress_message message in
+    let v = poly_add (poly_add (vector_dot_product t_as_ntt r_as_ntt) error_2) mu in  
+    let c1 = compress_then_encode_u p u in
+    let c2 = compress_then_encode_v p v in
+    concat c1 c2
+
+/// This function implements <strong>Algorithm 14</strong> of the
+/// NIST FIPS 203 specification; this is the Kyber CPA-PKE decryption algorithm.
+
+val ind_cpa_decrypt (p:params) (secret_key: t_KyberCPAPrivateKey p)
+                    (ciphertext: t_KyberCiphertext p): 
+                    t_KyberSharedSecret
+
+let ind_cpa_decrypt p secret_key ciphertext =
+    let (c1,c2) = split ciphertext (v_C1_SIZE p) in
+    let u = decode_then_decompress_u p c1 in
+    let v = decode_then_decompress_v p c2 in
+    let secret_as_ntt = vector_decode_12 #p secret_key in
+    let w = poly_sub v (poly_inv_ntt #p (vector_dot_product secret_as_ntt (vector_ntt u))) in
+    compress_then_encode_message w
+
+(** IND-CCA Functions *)
+
+
+/// This function implements most of Algorithm 15 of the
+/// NIST FIPS 203 specification; this is the Kyber CCA-KEM key generation algorithm.
+///
+/// We say "most of" since Algorithm 15 samples the required randomness within
+/// the function itself, whereas this implementation expects it to be provided
+/// through the `randomness` parameter.
+/// 
+/// TODO: input validation
+
+val ind_cca_generate_keypair (p:params) (randomness:t_Array u8 v_KEY_GENERATION_SEED_SIZE) :
+                             t_KyberKeyPair p
+let ind_cca_generate_keypair p randomness =
+    let (ind_cpa_keypair_randomness, implicit_rejection_value) =
+        split randomness v_CPA_PKE_KEY_GENERATION_SEED_SIZE in
+        
+    let (ind_cpa_secret_key,ind_cpa_public_key) = ind_cpa_generate_keypair p ind_cpa_keypair_randomness in
+    let ind_cca_secret_key = Seq.append ind_cpa_secret_key (
+                             Seq.append ind_cpa_public_key (
+                             Seq.append (v_H ind_cpa_public_key) implicit_rejection_value)) in
+    (ind_cca_secret_key, ind_cpa_public_key)
+
+/// This function implements most of Algorithm 16 of the
+/// NIST FIPS 203 specification; this is the Kyber CCA-KEM encapsulation algorithm.
+///
+/// We say "most of" since Algorithm 16 samples the required randomness within
+/// the function itself, whereas this implementation expects it to be provided
+/// through the `randomness` parameter.
+///
+/// TODO: input validation
+
+val ind_cca_encapsulate (p:params) (public_key: t_KyberPublicKey p)
+                        (randomness:t_Array u8 v_SHARED_SECRET_SIZE) :
+                        (t_KyberCiphertext p &  t_KyberSharedSecret)
+let ind_cca_encapsulate p public_key randomness =
+    let to_hash = concat randomness (v_H public_key) in
+    let hashed = v_G to_hash in
+    let (shared_secret, pseudorandomness) = split hashed v_SHARED_SECRET_SIZE in
+    let ciphertext = ind_cpa_encrypt p public_key randomness pseudorandomness in
+    (ciphertext,shared_secret)
+    
+
+/// This function implements Algorithm 17 of the
+/// NIST FIPS 203 specification; this is the Kyber CCA-KEM encapsulation algorithm.
+
+val ind_cca_decapsulate (p:params) (secret_key: t_KyberPrivateKey p)
+                        (ciphertext: t_KyberCiphertext p): 
+                         t_KyberSharedSecret
+let ind_cca_decapsulate p secret_key ciphertext =
+    let (ind_cpa_secret_key,rest) = split secret_key (v_CPA_PKE_SECRET_KEY_SIZE p) in
+    let (ind_cpa_public_key,rest) = split rest (v_CPA_PKE_PUBLIC_KEY_SIZE p) in
+    let (ind_cpa_public_key_hash,implicit_rejection_value) = split rest v_H_DIGEST_SIZE in
+    
+    let decrypted = ind_cpa_decrypt p ind_cpa_secret_key ciphertext in
+    let to_hash = concat decrypted ind_cpa_public_key_hash in
+    let hashed = v_G to_hash in
+    let (success_shared_secret, pseudorandomness) = split hashed v_SHARED_SECRET_SIZE in
+
+    assert (Seq.length implicit_rejection_value = 32);
+    let to_hash = concat implicit_rejection_value ciphertext in
+    let rejection_shared_secret = v_J to_hash in
+
+    let reencrypted = ind_cpa_encrypt p ind_cpa_public_key decrypted pseudorandomness in
+    if reencrypted = ciphertext
+    then success_shared_secret
+    else rejection_shared_secret
+   
+
+(** Kyber-768 Instantiation *)
+
+let kyber768_params : params = {
+    v_RANK = sz 3;
+    v_ETA1 = sz 2;
+    v_ETA2 = sz 2;
+    v_VECTOR_U_COMPRESSION_FACTOR = sz 10;
+    v_VECTOR_V_COMPRESSION_FACTOR = sz 4;
+}
+
+let kyber768_generate_keypair (randomness:t_Array u8 (sz 64)):
+                              (t_Array u8 (sz 2400) & t_Array u8 (sz 1184)) =
+    ind_cca_generate_keypair kyber768_params randomness
+
+let kyber768_encapsulate (public_key: t_Array u8 (sz 1184)) (randomness: t_Array u8 (sz 32)):
+                         (t_Array u8 (sz 1088) & t_Array u8 (sz 32)) =
+    ind_cca_encapsulate kyber768_params public_key randomness
+
+
+let kyber768_decapsulate (secret_key: t_Array u8 (sz 2400)) (ciphertext: t_Array u8 (sz 1088)):
+                         t_Array u8 (sz 32) =
+    ind_cca_decapsulate kyber768_params secret_key ciphertext
+
+(** Kyber-1024 Instantiation *)
+
+let kyber1024_params : params = {
+    v_RANK = sz 4;
+    v_ETA1 = sz 2;
+    v_ETA2 = sz 2;
+    v_VECTOR_U_COMPRESSION_FACTOR = sz 11;
+    v_VECTOR_V_COMPRESSION_FACTOR = sz 5;
+}
+
+let kyber1024_generate_keypair (randomness:t_Array u8 (sz 64)):
+                               (t_Array u8 (sz 3168) & t_Array u8 (sz 1568)) =
+    ind_cca_generate_keypair kyber1024_params randomness
+
+let kyber1024_encapsulate (public_key: t_Array u8 (sz 1568)) (randomness: t_Array u8 (sz 32)):
+                          (t_Array u8 (sz 1568) & t_Array u8 (sz 32)) =
+    ind_cca_encapsulate kyber1024_params public_key randomness
+
+
+let kyber1024_decapsulate (secret_key: t_Array u8 (sz 3168)) (ciphertext: t_Array u8 (sz 1568)):
+                           t_Array u8 (sz 32) =
+    ind_cca_decapsulate kyber1024_params secret_key ciphertext
+
+(** Kyber-512 Instantiation *)
+
+let kyber512_params : params = {
+    v_RANK = sz 2;
+    v_ETA1 = sz 3;
+    v_ETA2 = sz 2;
+    v_VECTOR_U_COMPRESSION_FACTOR = sz 10;
+    v_VECTOR_V_COMPRESSION_FACTOR = sz 4;
+}
+
+let kyber512_generate_keypair (randomness:t_Array u8 (sz 64)):
+                              (t_Array u8 (sz 1632) & t_Array u8 (sz 800))  =
+    ind_cca_generate_keypair kyber512_params randomness
+
+let kyber512_encapsulate (public_key: t_Array u8 (sz 800)) (randomness: t_Array u8 (sz 32)):
+                         (t_Array u8 (sz 768) & t_Array u8 (sz 32)) =
+    ind_cca_encapsulate kyber512_params public_key randomness
+
+
+let kyber512_decapsulate (secret_key: t_Array u8 (sz 1632)) (ciphertext: t_Array u8 (sz 768)):
+                         t_Array u8 (sz 32) =
+    ind_cca_decapsulate kyber512_params secret_key ciphertext
