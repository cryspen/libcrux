/* 
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>
  KaRaMeL invocation: /Users/bhargava/Desktop/repositories/karamel/krml -tmpdir dist/ -skip-compilation obj/FStar_Pervasives_Native.krml obj/FStar_Pervasives.krml obj/FStar_Squash.krml obj/FStar_Classical.krml obj/FStar_StrongExcludedMiddle.krml obj/FStar_Classical_Sugar.krml obj/FStar_List_Tot_Base.krml obj/FStar_List_Tot_Properties.krml obj/FStar_List_Tot.krml obj/FStar_Float.krml obj/FStar_Mul.krml obj/FStar_Preorder.krml obj/FStar_Sealed.krml obj/FStar_Range.krml obj/FStar_Calc.krml obj/FStar_Seq_Base.krml obj/FStar_Seq_Properties.krml obj/FStar_Seq.krml obj/FStar_Math_Lib.krml obj/FStar_Math_Lemmas.krml obj/FStar_BitVector.krml obj/FStar_UInt.krml obj/FStar_UInt32.krml obj/FStar_Char.krml obj/FStar_Issue.krml obj/FStar_Monotonic_Pure.krml obj/FStar_Ghost.krml obj/FStar_VConfig.krml obj/FStar_Sealed_Inhabited.krml obj/FStar_Order.krml obj/FStar_FunctionalExtensionality.krml obj/FStar_Set.krml obj/FStar_ErasedLogic.krml obj/FStar_PropositionalExtensionality.krml obj/FStar_PredicateExtensionality.krml obj/FStar_TSet.krml obj/FStar_Monotonic_Heap.krml obj/FStar_Heap.krml obj/FStar_Map.krml obj/FStar_Monotonic_Witnessed.krml obj/FStar_Monotonic_HyperHeap.krml obj/FStar_Monotonic_HyperStack.krml obj/FStar_HyperStack.krml obj/FStar_HyperStack_ST.krml obj/FStar_Universe.krml obj/FStar_GSet.krml obj/FStar_ModifiesGen.krml obj/FStar_IndefiniteDescription.krml obj/FStar_BigOps.krml obj/LowStar_Monotonic_Buffer.krml obj/LowStar_Buffer.krml obj/LowStar_BufferOps.krml obj/Spec_Loops.krml obj/FStar_UInt64.krml obj/C_Loops.krml obj/FStar_Int.krml obj/FStar_Int64.krml obj/FStar_Int32.krml obj/FStar_Int16.krml obj/FStar_Int8.krml obj/FStar_UInt16.krml obj/FStar_UInt8.krml obj/FStar_Int_Cast.krml obj/FStar_Exn.krml obj/FStar_ST.krml obj/FStar_All.krml obj/FStar_List.krml obj/FStar_BV.krml obj/FStar_UInt128.krml obj/FStar_Int_Cast_Full.krml obj/FStar_Int128.krml obj/Lib_IntTypes.krml obj/Lib_Loops.krml obj/Rust_primitives_Integers.krml obj/Rust_primitives_Arrays.krml obj/Rust_primitives.krml obj/Core_Array.krml obj/Core_Result.krml obj/Core_Ops_Index_IndexMut.krml obj/Core_Ops_Index.krml obj/Core_Ops.krml obj/Core_Slice_Iter.krml obj/Core_Slice.krml obj/Rust_primitives_Hax.krml obj/Core_Iter_Adapters_Step_by.krml obj/Core_Iter_Adapters_Enumerate.krml obj/Core_Iter_Traits_Iterator.krml obj/Core_Ops_Range.krml obj/Core_Iter.krml obj/Core_Num_Error.krml obj/Core_Num.krml obj/Core.krml obj/Libcrux_Digest.krml obj/Libcrux_Kem_Kyber_Constants.krml obj/Rust_primitives_Hax_Monomorphized_update_at.krml obj/Libcrux_Kem_Kyber_Constant_time_ops.krml obj/Core_Option.krml obj/Core_Convert.krml obj/Libcrux_Kem_Kyber_Hash_functions.krml obj/Core_Panicking.krml obj/Libcrux_Kem_Kyber_Conversions.krml obj/Core_Ops_Arith_Neg.krml obj/Libcrux_Kem_Kyber_Arithmetic.krml obj/Libcrux_Kem_Kyber_Ntt.krml obj/Libcrux_Kem_Kyber_Matrix.krml obj/Libcrux_Kem_Kyber_Compress.krml obj/Libcrux_Kem_Kyber_Serialize.krml obj/Core_Clone.krml obj/Libcrux_Kem_Kyber_Types.krml obj/Libcrux_Kem_Kyber_Sampling.krml obj/Libcrux_Kem_Kyber_Ind_cpa.krml obj/Libcrux_Kem_Kyber.krml obj/Libcrux_Kem_Kyber_Kyber768.krml -warn-error @4@5@18 -fparentheses -bundle LowStar.*,Prims -bundle Libcrux.Kem.Kyber.Kyber768=Rust_primitives.*,Rust_primitives,Core.*,Core,Hax_lib.*,Hax_lib,Libcrux.Digest,Libcrux.Kem.Kyber.*,Libcrux.Kem.Kyber -minimal -bundle FStar.* -add-include <stdint.h> -add-include "krml/internal/target.h" -bundle Hacl.Spec.*,Spec.*[rename=Hacl_Spec] -bundle Lib.*[rename=Hacl_Lib] -drop Lib.IntVector.Intrinsics -drop Lib.IntTypes.Intrinsics -drop Lib.IntTypes.Intrinsics_128 -fparentheses -fno-shadow -fcurly-braces -fnoreturn-else -bundle Prims,C.Failure,C,C.String,C.Loops,Spec.Loops,C.Endianness,FStar.*,LowStar.*[rename=Hacl_Krmllib] -bundle Meta.* -minimal -add-early-include <string.h> -add-early-include "krml/internal/types.h" -add-early-include "krml/lowstar_endianness.h" -dmonomorphization
  F* version: fe6dec16
  KaRaMeL version: a7be2a7c
 */

#include "Libcrux_Kem_Kyber_Kyber768.h"

#define TryFromSliceError 0

typedef uint8_t t_TryFromSliceError;

static uint8_t impl__u8__wrapping_sub(uint8_t a, uint8_t b)
{
  return (uint32_t)a - (uint32_t)b;
}

static uint16_t impl__u16__wrapping_add(uint16_t a, uint16_t b)
{
  return (uint32_t)a + (uint32_t)b;
}

static uint32_t impl__u32__BITS = 32U;

typedef struct t_nonempty_Slice__uint8_t_s
{
  uint8_t *buffer;
  uint32_t len;
}
t_nonempty_Slice__uint8_t;

extern uint8_t *Libcrux_Digest_sha3_256_(t_nonempty_Slice__uint8_t payload);

extern uint8_t *Libcrux_Digest_sha3_512_(t_nonempty_Slice__uint8_t payload);

extern uint8_t *Libcrux_Digest_shake128(uint32_t v_LEN, t_nonempty_Slice__uint8_t data);

extern uint8_t *Libcrux_Digest_shake256(uint32_t v_LEN, t_nonempty_Slice__uint8_t data);

static uint32_t v_COEFFICIENTS_IN_RING_ELEMENT = 256U;

static uint32_t v_BYTES_PER_RING_ELEMENT = 384U;

static uint32_t v_CPA_PKE_KEY_GENERATION_SEED_SIZE = 32U;

static int32_t v_FIELD_MODULUS = (int32_t)3329;

static uint32_t v_H_DIGEST_SIZE = 32U;

static uint32_t v_SHARED_SECRET_SIZE = 32U;

static uint8_t is_non_zero(uint8_t value)
{
  uint16_t value1 = (uint16_t)value;
  uint16_t
  result =
    (((uint32_t)value1 | (uint32_t)impl__u16__wrapping_add(~value1, 1U)) & 0xFFFFU)
    >> (uint32_t)(int32_t)8
    & 1U;
  uint32_t m = 8U;
  uint16_t pow2_bits = 256U;
  uint16_t pow2_bits_minus_one = 128U;
  uint16_t a2 = ((uint32_t)result & ((1U << m) - 1U)) - (uint32_t)pow2_bits_minus_one;
  uint16_t mask = (uint32_t)a2 >> 15U;
  uint16_t a3 = ((uint32_t)result & ((1U << m) - 1U)) - (uint32_t)pow2_bits;
  uint16_t b = (uint32_t)a3 + ((uint32_t)mask & (uint32_t)pow2_bits);
  return (uint8_t)b;
}

static uint8_t
*select_shared_secret_in_constant_time(
  t_nonempty_Slice__uint8_t lhs,
  t_nonempty_Slice__uint8_t rhs,
  uint8_t selector
)
{
  uint8_t mask = impl__u8__wrapping_sub(is_non_zero(selector), 1U);
  uint8_t out[32U] = { 0U };
  uint32_t start = 0U;
  uint32_t finish = v_SHARED_SECRET_SIZE;
  for (uint32_t i = start; i < finish; i++)
  {
    uint32_t i1 = i;
    out[i1] =
      (uint32_t)out[i1]
      | (((uint32_t)lhs.buffer[i1] & (uint32_t)mask) | ((uint32_t)rhs.buffer[i1] & (uint32_t)~mask));
  }
  return out;
}

static uint8_t *v_G(t_nonempty_Slice__uint8_t input)
{
  return Libcrux_Digest_sha3_512_(input);
}

static uint8_t *v_H(t_nonempty_Slice__uint8_t input)
{
  return Libcrux_Digest_sha3_256_(input);
}

static uint8_t *v_PRF(uint32_t v_LEN, t_nonempty_Slice__uint8_t input)
{
  return Libcrux_Digest_shake256(v_LEN, input);
}

static uint8_t **v_XOFx4(uint32_t v_LEN, uint32_t v_K, uint8_t **input)
{
  KRML_CHECK_SIZE(sizeof (uint8_t), v_LEN);
  uint8_t buf[v_LEN];
  memset(buf, 0U, v_LEN * sizeof (uint8_t));
  KRML_CHECK_SIZE(sizeof (uint8_t *), v_K);
  uint8_t *out[v_K];
  for (uint32_t _i = 0U; _i < v_K; ++_i)
    out[_i] = buf;
  uint32_t start = 0U;
  uint32_t finish = v_K;
  for (uint32_t i = start; i < finish; i++)
  {
    uint32_t i1 = i;
    out[i1] =
      Libcrux_Digest_shake128(v_LEN,
        ((t_nonempty_Slice__uint8_t){ .buffer = input[i1], .len = 34U }));
  }
  return out;
}

typedef struct t_UpdatableArray_s
{
  uint8_t *f_value;
  uint32_t f_pointer;
}
t_UpdatableArray;

static int64_t v_BARRETT_MULTIPLIER = (int64_t)20159;

static int64_t v_BARRETT_SHIFT = (int64_t)26;

static int64_t v_BARRETT_R = (int64_t)1 << (uint32_t)(int64_t)26;

static uint32_t v_INVERSE_OF_MODULUS_MOD_R = 62209U;

static int32_t v_MONTGOMERY_R_SQUARED_MOD_FIELD_MODULUS = (int32_t)1353;

static uint8_t v_MONTGOMERY_SHIFT = 16U;

static uint32_t get_montgomery_r_least_significant_bits(uint32_t value)
{
  return value & ((1U << (uint32_t)v_MONTGOMERY_SHIFT) - 1U);
}

static int32_t barrett_reduce(int32_t value)
{
  int64_t
  t =
    (int64_t)value
    * v_BARRETT_MULTIPLIER
    + FStar_Int64_shift_arithmetic_right(v_BARRETT_R, (uint32_t)(int32_t)1);
  uint32_t m = 32U;
  int64_t pow2_bits = (int64_t)1 << 32U;
  int64_t pow2_bits_minus_one = (int64_t)1 << 31U;
  int64_t
  a2 =
    (FStar_Int64_shift_arithmetic_right(t,
      (uint32_t)v_BARRETT_SHIFT)
    & (((int64_t)1 << m) - (int64_t)1))
    - pow2_bits_minus_one;
  int64_t mask = FStar_Int64_shift_arithmetic_right(a2, 63U);
  int64_t
  a3 =
    (FStar_Int64_shift_arithmetic_right(t,
      (uint32_t)v_BARRETT_SHIFT)
    & (((int64_t)1 << m) - (int64_t)1))
    - pow2_bits;
  int64_t b = a3 + (mask & pow2_bits);
  int32_t quotient = (int32_t)b;
  return value - quotient * v_FIELD_MODULUS;
}

static int32_t montgomery_reduce(int32_t value)
{
  uint32_t
  t = get_montgomery_r_least_significant_bits((uint32_t)value) * v_INVERSE_OF_MODULUS_MOD_R;
  uint32_t m = 16U;
  uint32_t pow2_bits = 65536U;
  uint32_t pow2_bits_minus_one = 32768U;
  uint32_t
  a2 = (get_montgomery_r_least_significant_bits(t) & ((1U << m) - 1U)) - pow2_bits_minus_one;
  uint32_t mask = a2 >> 31U;
  uint32_t a3 = (get_montgomery_r_least_significant_bits(t) & ((1U << m) - 1U)) - pow2_bits;
  uint32_t b = a3 + (mask & pow2_bits);
  int16_t k = (int16_t)b;
  int32_t k_times_modulus = (int32_t)k * v_FIELD_MODULUS;
  int32_t c = FStar_Int32_shift_arithmetic_right(k_times_modulus, (uint32_t)v_MONTGOMERY_SHIFT);
  int32_t value_high = FStar_Int32_shift_arithmetic_right(value, (uint32_t)v_MONTGOMERY_SHIFT);
  return value_high - c;
}

static int32_t montgomery_multiply_sfe_by_fer(int32_t fe, int32_t fer)
{
  return montgomery_reduce(fe * fer);
}

static int32_t to_standard_domain(int32_t mfe)
{
  return montgomery_reduce(mfe * v_MONTGOMERY_R_SQUARED_MOD_FIELD_MODULUS);
}

static uint16_t to_unsigned_representative(int32_t fe)
{
  uint32_t m = 16U;
  int32_t pow2_bits = (int32_t)1 << 16U;
  int32_t pow2_bits_minus_one = (int32_t)1 << 15U;
  int32_t
  a2 =
    ((fe + (v_FIELD_MODULUS & FStar_Int32_shift_arithmetic_right(fe, (uint32_t)(int32_t)31)))
    & (((int32_t)1 << m) - (int32_t)1))
    - pow2_bits_minus_one;
  int32_t mask = FStar_Int32_shift_arithmetic_right(a2, 31U);
  int32_t
  a3 =
    ((fe + (v_FIELD_MODULUS & FStar_Int32_shift_arithmetic_right(fe, (uint32_t)(int32_t)31)))
    & (((int32_t)1 << m) - (int32_t)1))
    - pow2_bits;
  int32_t b = a3 + (mask & pow2_bits);
  return (uint16_t)b;
}

typedef int32_t *t_PolynomialRingElement;

static int32_t impl__PolynomialRingElement__ZERO[256U];

static void add_to_ring_element(int32_t *lhs, int32_t *rhs)
{
  uint32_t start = 0U;
  uint32_t finish = 256U;
  for (uint32_t i = start; i < finish; i++)
  {
    uint32_t i1 = i;
    lhs[i1] = lhs[i1] + rhs[i1];
  }
}

static int32_t
v_ZETAS_TIMES_MONTGOMERY_R[128U] =
  {
    (int32_t)-1044, (int32_t)-758, (int32_t)-359, (int32_t)-1517, (int32_t)1493, (int32_t)1422,
    (int32_t)287, (int32_t)202, (int32_t)-171, (int32_t)622, (int32_t)1577, (int32_t)182,
    (int32_t)962, (int32_t)-1202, (int32_t)-1474, (int32_t)1468, (int32_t)573, (int32_t)-1325,
    (int32_t)264, (int32_t)383, (int32_t)-829, (int32_t)1458, (int32_t)-1602, (int32_t)-130,
    (int32_t)-681, (int32_t)1017, (int32_t)732, (int32_t)608, (int32_t)-1542, (int32_t)411,
    (int32_t)-205, (int32_t)-1571, (int32_t)1223, (int32_t)652, (int32_t)-552, (int32_t)1015,
    (int32_t)-1293, (int32_t)1491, (int32_t)-282, (int32_t)-1544, (int32_t)516, (int32_t)-8,
    (int32_t)-320, (int32_t)-666, (int32_t)-1618, (int32_t)-1162, (int32_t)126, (int32_t)1469,
    (int32_t)-853, (int32_t)-90, (int32_t)-271, (int32_t)830, (int32_t)107, (int32_t)-1421,
    (int32_t)-247, (int32_t)-951, (int32_t)-398, (int32_t)961, (int32_t)-1508, (int32_t)-725,
    (int32_t)448, (int32_t)-1065, (int32_t)677, (int32_t)-1275, (int32_t)-1103, (int32_t)430,
    (int32_t)555, (int32_t)843, (int32_t)-1251, (int32_t)871, (int32_t)1550, (int32_t)105,
    (int32_t)422, (int32_t)587, (int32_t)177, (int32_t)-235, (int32_t)-291, (int32_t)-460,
    (int32_t)1574, (int32_t)1653, (int32_t)-246, (int32_t)778, (int32_t)1159, (int32_t)-147,
    (int32_t)-777, (int32_t)1483, (int32_t)-602, (int32_t)1119, (int32_t)-1590, (int32_t)644,
    (int32_t)-872, (int32_t)349, (int32_t)418, (int32_t)329, (int32_t)-156, (int32_t)-75,
    (int32_t)817, (int32_t)1097, (int32_t)603, (int32_t)610, (int32_t)1322, (int32_t)-1285,
    (int32_t)-1465, (int32_t)384, (int32_t)-1215, (int32_t)-136, (int32_t)1218, (int32_t)-1335,
    (int32_t)-874, (int32_t)220, (int32_t)-1187, (int32_t)-1659, (int32_t)-1185, (int32_t)-1530,
    (int32_t)-1278, (int32_t)794, (int32_t)-1510, (int32_t)-854, (int32_t)-870, (int32_t)478,
    (int32_t)-108, (int32_t)-308, (int32_t)996, (int32_t)991, (int32_t)958, (int32_t)-1460,
    (int32_t)1522, (int32_t)1628
  };

typedef struct __int32_t_int32_t_s
{
  int32_t fst;
  int32_t snd;
}
__int32_t_int32_t;

static __int32_t_int32_t
ntt_multiply_binomials(__int32_t_int32_t a, __int32_t_int32_t b, int32_t zeta)
{
  return
    (
      (__int32_t_int32_t){
        .fst = montgomery_reduce(a.fst * b.fst + montgomery_reduce(a.snd * b.snd) * zeta),
        .snd = montgomery_reduce(a.fst * b.snd + a.snd * b.fst)
      }
    );
}

static void invert_ntt_montgomery(int32_t *re)
{
  uint32_t zeta_i[1U] = { v_COEFFICIENTS_IN_RING_ELEMENT / 2U };
  uint32_t step = 2U;
  uint32_t start0 = 0U;
  uint32_t finish0 = 128U / step;
  for (uint32_t i0 = start0; i0 < finish0; i0++)
  {
    uint32_t round = i0;
    zeta_i[0U] = zeta_i[0U] - 1U;
    uint32_t offset = round * step * 2U;
    uint32_t start1 = offset;
    uint32_t finish1 = offset + step;
    for (uint32_t i = start1; i < finish1; i++)
    {
      uint32_t j = i;
      int32_t a_minus_b = re[j + step] - re[j];
      re[j] = re[j] + re[j + step];
      re[j + step] = montgomery_reduce(a_minus_b * v_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
    }
  }
  uint32_t step1 = 4U;
  uint32_t start2 = 0U;
  uint32_t finish2 = 128U / step1;
  for (uint32_t i0 = start2; i0 < finish2; i0++)
  {
    uint32_t round = i0;
    zeta_i[0U] = zeta_i[0U] - 1U;
    uint32_t offset = round * step1 * 2U;
    uint32_t start1 = offset;
    uint32_t finish1 = offset + step1;
    for (uint32_t i = start1; i < finish1; i++)
    {
      uint32_t j = i;
      int32_t a_minus_b = re[j + step1] - re[j];
      re[j] = re[j] + re[j + step1];
      re[j + step1] = montgomery_reduce(a_minus_b * v_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
    }
  }
  uint32_t step2 = 8U;
  uint32_t start3 = 0U;
  uint32_t finish3 = 128U / step2;
  for (uint32_t i0 = start3; i0 < finish3; i0++)
  {
    uint32_t round = i0;
    zeta_i[0U] = zeta_i[0U] - 1U;
    uint32_t offset = round * step2 * 2U;
    uint32_t start1 = offset;
    uint32_t finish1 = offset + step2;
    for (uint32_t i = start1; i < finish1; i++)
    {
      uint32_t j = i;
      int32_t a_minus_b = re[j + step2] - re[j];
      re[j] = re[j] + re[j + step2];
      re[j + step2] = montgomery_reduce(a_minus_b * v_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
    }
  }
  uint32_t step3 = 16U;
  uint32_t start4 = 0U;
  uint32_t finish4 = 128U / step3;
  for (uint32_t i0 = start4; i0 < finish4; i0++)
  {
    uint32_t round = i0;
    zeta_i[0U] = zeta_i[0U] - 1U;
    uint32_t offset = round * step3 * 2U;
    uint32_t start1 = offset;
    uint32_t finish1 = offset + step3;
    for (uint32_t i = start1; i < finish1; i++)
    {
      uint32_t j = i;
      int32_t a_minus_b = re[j + step3] - re[j];
      re[j] = re[j] + re[j + step3];
      re[j + step3] = montgomery_reduce(a_minus_b * v_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
    }
  }
  uint32_t step4 = 32U;
  uint32_t start5 = 0U;
  uint32_t finish5 = 128U / step4;
  for (uint32_t i0 = start5; i0 < finish5; i0++)
  {
    uint32_t round = i0;
    zeta_i[0U] = zeta_i[0U] - 1U;
    uint32_t offset = round * step4 * 2U;
    uint32_t start1 = offset;
    uint32_t finish1 = offset + step4;
    for (uint32_t i = start1; i < finish1; i++)
    {
      uint32_t j = i;
      int32_t a_minus_b = re[j + step4] - re[j];
      re[j] = re[j] + re[j + step4];
      re[j + step4] = montgomery_reduce(a_minus_b * v_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
    }
  }
  uint32_t step5 = 64U;
  uint32_t start6 = 0U;
  uint32_t finish6 = 128U / step5;
  for (uint32_t i0 = start6; i0 < finish6; i0++)
  {
    uint32_t round = i0;
    zeta_i[0U] = zeta_i[0U] - 1U;
    uint32_t offset = round * step5 * 2U;
    uint32_t start1 = offset;
    uint32_t finish1 = offset + step5;
    for (uint32_t i = start1; i < finish1; i++)
    {
      uint32_t j = i;
      int32_t a_minus_b = re[j + step5] - re[j];
      re[j] = re[j] + re[j + step5];
      re[j + step5] = montgomery_reduce(a_minus_b * v_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
    }
  }
  uint32_t step6 = 128U;
  uint32_t start = 0U;
  uint32_t finish7 = 128U / step6;
  for (uint32_t i0 = start; i0 < finish7; i0++)
  {
    uint32_t round = i0;
    zeta_i[0U] = zeta_i[0U] - 1U;
    uint32_t offset = round * step6 * 2U;
    uint32_t start1 = offset;
    uint32_t finish1 = offset + step6;
    for (uint32_t i = start1; i < finish1; i++)
    {
      uint32_t j = i;
      int32_t a_minus_b = re[j + step6] - re[j];
      re[j] = re[j] + re[j + step6];
      re[j + step6] = montgomery_reduce(a_minus_b * v_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
    }
  }
  uint32_t start1 = 0U;
  uint32_t finish = 8U;
  for (uint32_t i = start1; i < finish; i++)
  {
    uint32_t i1 = i;
    re[i1] = barrett_reduce(re[i1]);
  }
}

static int32_t *impl_23__map__int32_t_int32_t(uint32_t n)
{
  KRML_MAYBE_UNUSED_VAR(n);
  KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "");
  KRML_HOST_EXIT(255U);
}

static int32_t *ntt_binomially_sampled_ring_element(int32_t *re)
{
  uint32_t zeta_i[1U] = { 0U };
  zeta_i[0U] = zeta_i[0U] + 1U;
  uint32_t start0 = 0U;
  uint32_t finish0 = 128U;
  for (uint32_t i = start0; i < finish0; i++)
  {
    uint32_t j = i;
    int32_t t = re[j + 128U] * (int32_t)-1600;
    re[j + 128U] = re[j] - t;
    re[j] = re[j] + t;
  }
  uint32_t step = 64U;
  uint32_t start2 = 0U;
  uint32_t finish2 = 128U / step;
  for (uint32_t i0 = start2; i0 < finish2; i0++)
  {
    uint32_t round = i0;
    zeta_i[0U] = zeta_i[0U] + 1U;
    uint32_t offset = round * step * 2U;
    uint32_t start1 = offset;
    uint32_t finish1 = offset + step;
    for (uint32_t i = start1; i < finish1; i++)
    {
      uint32_t j = i;
      int32_t
      t = montgomery_multiply_sfe_by_fer(re[j + step], v_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
      re[j + step] = re[j] - t;
      re[j] = re[j] + t;
    }
  }
  uint32_t step1 = 32U;
  uint32_t start3 = 0U;
  uint32_t finish3 = 128U / step1;
  for (uint32_t i0 = start3; i0 < finish3; i0++)
  {
    uint32_t round = i0;
    zeta_i[0U] = zeta_i[0U] + 1U;
    uint32_t offset = round * step1 * 2U;
    uint32_t start1 = offset;
    uint32_t finish1 = offset + step1;
    for (uint32_t i = start1; i < finish1; i++)
    {
      uint32_t j = i;
      int32_t
      t = montgomery_multiply_sfe_by_fer(re[j + step1], v_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
      re[j + step1] = re[j] - t;
      re[j] = re[j] + t;
    }
  }
  uint32_t step2 = 16U;
  uint32_t start4 = 0U;
  uint32_t finish4 = 128U / step2;
  for (uint32_t i0 = start4; i0 < finish4; i0++)
  {
    uint32_t round = i0;
    zeta_i[0U] = zeta_i[0U] + 1U;
    uint32_t offset = round * step2 * 2U;
    uint32_t start1 = offset;
    uint32_t finish1 = offset + step2;
    for (uint32_t i = start1; i < finish1; i++)
    {
      uint32_t j = i;
      int32_t
      t = montgomery_multiply_sfe_by_fer(re[j + step2], v_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
      re[j + step2] = re[j] - t;
      re[j] = re[j] + t;
    }
  }
  uint32_t step3 = 8U;
  uint32_t start5 = 0U;
  uint32_t finish5 = 128U / step3;
  for (uint32_t i0 = start5; i0 < finish5; i0++)
  {
    uint32_t round = i0;
    zeta_i[0U] = zeta_i[0U] + 1U;
    uint32_t offset = round * step3 * 2U;
    uint32_t start1 = offset;
    uint32_t finish1 = offset + step3;
    for (uint32_t i = start1; i < finish1; i++)
    {
      uint32_t j = i;
      int32_t
      t = montgomery_multiply_sfe_by_fer(re[j + step3], v_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
      re[j + step3] = re[j] - t;
      re[j] = re[j] + t;
    }
  }
  uint32_t step4 = 4U;
  uint32_t start6 = 0U;
  uint32_t finish6 = 128U / step4;
  for (uint32_t i0 = start6; i0 < finish6; i0++)
  {
    uint32_t round = i0;
    zeta_i[0U] = zeta_i[0U] + 1U;
    uint32_t offset = round * step4 * 2U;
    uint32_t start1 = offset;
    uint32_t finish1 = offset + step4;
    for (uint32_t i = start1; i < finish1; i++)
    {
      uint32_t j = i;
      int32_t
      t = montgomery_multiply_sfe_by_fer(re[j + step4], v_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
      re[j + step4] = re[j] - t;
      re[j] = re[j] + t;
    }
  }
  uint32_t step5 = 2U;
  uint32_t start = 0U;
  uint32_t finish = 128U / step5;
  for (uint32_t i0 = start; i0 < finish; i0++)
  {
    uint32_t round = i0;
    zeta_i[0U] = zeta_i[0U] + 1U;
    uint32_t offset = round * step5 * 2U;
    uint32_t start1 = offset;
    uint32_t finish1 = offset + step5;
    for (uint32_t i = start1; i < finish1; i++)
    {
      uint32_t j = i;
      int32_t
      t = montgomery_multiply_sfe_by_fer(re[j + step5], v_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
      re[j + step5] = re[j] - t;
      re[j] = re[j] + t;
    }
  }
  int32_t *re1 = impl_23__map__int32_t_int32_t(256U);
  return re1;
}

static int32_t *ntt_multiply(int32_t *left, int32_t *right)
{
  int32_t *out = impl__PolynomialRingElement__ZERO;
  uint32_t start = 0U;
  uint32_t finish = v_COEFFICIENTS_IN_RING_ELEMENT / 4U;
  for (uint32_t i = start; i < finish; i++)
  {
    uint32_t i1 = i;
    __int32_t_int32_t
    product =
      ntt_multiply_binomials((
          (__int32_t_int32_t){ .fst = left[4U * i1], .snd = left[4U * i1 + 1U] }
        ),
        ((__int32_t_int32_t){ .fst = right[4U * i1], .snd = right[4U * i1 + 1U] }),
        v_ZETAS_TIMES_MONTGOMERY_R[64U + i1]);
    out[4U * i1] = product.fst;
    out[4U * i1 + 1U] = product.snd;
    __int32_t_int32_t
    product1 =
      ntt_multiply_binomials((
          (__int32_t_int32_t){ .fst = left[4U * i1 + 2U], .snd = left[4U * i1 + 3U] }
        ),
        ((__int32_t_int32_t){ .fst = right[4U * i1 + 2U], .snd = right[4U * i1 + 3U] }),
        (int32_t)0 - v_ZETAS_TIMES_MONTGOMERY_R[64U + i1]);
    out[4U * i1 + 2U] = product1.fst;
    out[4U * i1 + 3U] = product1.snd;
  }
  return out;
}

static int32_t *ntt_vector_u(int32_t *re)
{
  uint32_t zeta_i[1U] = { 0U };
  uint32_t step = 128U;
  uint32_t start0 = 0U;
  uint32_t finish0 = 128U / step;
  for (uint32_t i0 = start0; i0 < finish0; i0++)
  {
    uint32_t round = i0;
    zeta_i[0U] = zeta_i[0U] + 1U;
    uint32_t offset = round * step * 2U;
    uint32_t start1 = offset;
    uint32_t finish1 = offset + step;
    for (uint32_t i = start1; i < finish1; i++)
    {
      uint32_t j = i;
      int32_t
      t = montgomery_multiply_sfe_by_fer(re[j + step], v_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
      re[j + step] = re[j] - t;
      re[j] = re[j] + t;
    }
  }
  uint32_t step1 = 64U;
  uint32_t start2 = 0U;
  uint32_t finish2 = 128U / step1;
  for (uint32_t i0 = start2; i0 < finish2; i0++)
  {
    uint32_t round = i0;
    zeta_i[0U] = zeta_i[0U] + 1U;
    uint32_t offset = round * step1 * 2U;
    uint32_t start1 = offset;
    uint32_t finish1 = offset + step1;
    for (uint32_t i = start1; i < finish1; i++)
    {
      uint32_t j = i;
      int32_t
      t = montgomery_multiply_sfe_by_fer(re[j + step1], v_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
      re[j + step1] = re[j] - t;
      re[j] = re[j] + t;
    }
  }
  uint32_t step2 = 32U;
  uint32_t start3 = 0U;
  uint32_t finish3 = 128U / step2;
  for (uint32_t i0 = start3; i0 < finish3; i0++)
  {
    uint32_t round = i0;
    zeta_i[0U] = zeta_i[0U] + 1U;
    uint32_t offset = round * step2 * 2U;
    uint32_t start1 = offset;
    uint32_t finish1 = offset + step2;
    for (uint32_t i = start1; i < finish1; i++)
    {
      uint32_t j = i;
      int32_t
      t = montgomery_multiply_sfe_by_fer(re[j + step2], v_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
      re[j + step2] = re[j] - t;
      re[j] = re[j] + t;
    }
  }
  uint32_t step3 = 16U;
  uint32_t start4 = 0U;
  uint32_t finish4 = 128U / step3;
  for (uint32_t i0 = start4; i0 < finish4; i0++)
  {
    uint32_t round = i0;
    zeta_i[0U] = zeta_i[0U] + 1U;
    uint32_t offset = round * step3 * 2U;
    uint32_t start1 = offset;
    uint32_t finish1 = offset + step3;
    for (uint32_t i = start1; i < finish1; i++)
    {
      uint32_t j = i;
      int32_t
      t = montgomery_multiply_sfe_by_fer(re[j + step3], v_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
      re[j + step3] = re[j] - t;
      re[j] = re[j] + t;
    }
  }
  uint32_t step4 = 8U;
  uint32_t start5 = 0U;
  uint32_t finish5 = 128U / step4;
  for (uint32_t i0 = start5; i0 < finish5; i0++)
  {
    uint32_t round = i0;
    zeta_i[0U] = zeta_i[0U] + 1U;
    uint32_t offset = round * step4 * 2U;
    uint32_t start1 = offset;
    uint32_t finish1 = offset + step4;
    for (uint32_t i = start1; i < finish1; i++)
    {
      uint32_t j = i;
      int32_t
      t = montgomery_multiply_sfe_by_fer(re[j + step4], v_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
      re[j + step4] = re[j] - t;
      re[j] = re[j] + t;
    }
  }
  uint32_t step5 = 4U;
  uint32_t start6 = 0U;
  uint32_t finish6 = 128U / step5;
  for (uint32_t i0 = start6; i0 < finish6; i0++)
  {
    uint32_t round = i0;
    zeta_i[0U] = zeta_i[0U] + 1U;
    uint32_t offset = round * step5 * 2U;
    uint32_t start1 = offset;
    uint32_t finish1 = offset + step5;
    for (uint32_t i = start1; i < finish1; i++)
    {
      uint32_t j = i;
      int32_t
      t = montgomery_multiply_sfe_by_fer(re[j + step5], v_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
      re[j + step5] = re[j] - t;
      re[j] = re[j] + t;
    }
  }
  uint32_t step6 = 2U;
  uint32_t start = 0U;
  uint32_t finish = 128U / step6;
  for (uint32_t i0 = start; i0 < finish; i0++)
  {
    uint32_t round = i0;
    zeta_i[0U] = zeta_i[0U] + 1U;
    uint32_t offset = round * step6 * 2U;
    uint32_t start1 = offset;
    uint32_t finish1 = offset + step6;
    for (uint32_t i = start1; i < finish1; i++)
    {
      uint32_t j = i;
      int32_t
      t = montgomery_multiply_sfe_by_fer(re[j + step6], v_ZETAS_TIMES_MONTGOMERY_R[zeta_i[0U]]);
      re[j + step6] = re[j] - t;
      re[j] = re[j] + t;
    }
  }
  int32_t *re1 = impl_23__map__int32_t_int32_t(256U);
  return re1;
}

static int32_t
**compute_As_plus_e(
  uint32_t v_K,
  int32_t ***matrix_A,
  int32_t **s_as_ntt,
  int32_t **error_as_ntt
)
{
  KRML_CHECK_SIZE(sizeof (int32_t *), v_K);
  int32_t *result[v_K];
  for (uint32_t _i = 0U; _i < v_K; ++_i)
    result[_i] = impl__PolynomialRingElement__ZERO;
  uint32_t start = 0U;
  uint32_t finish = v_K;
  for (uint32_t i0 = start; i0 < finish; i0++)
  {
    uint32_t i1 = i0;
    int32_t **row = matrix_A[i1];
    uint32_t start1 = 0U;
    uint32_t finish10 = v_K;
    for (uint32_t i = start1; i < finish10; i++)
    {
      uint32_t j = i;
      int32_t *matrix_element = row[j];
      int32_t *product = ntt_multiply(matrix_element, s_as_ntt[j]);
      add_to_ring_element(result[i1], product);
    }
    uint32_t start10 = 0U;
    uint32_t finish1 = v_COEFFICIENTS_IN_RING_ELEMENT;
    for (uint32_t i = start10; i < finish1; i++)
    {
      uint32_t j = i;
      int32_t *result_i = result[i1];
      int32_t *error_as_ntt_i = error_as_ntt[i1];
      int32_t coefficient_normal_form = to_standard_domain(result_i[j]);
      int32_t *uu____0 = result[i1];
      uu____0[j] = barrett_reduce(coefficient_normal_form + error_as_ntt_i[j]);
    }
  }
  return result;
}

static int32_t
*compute_message(uint32_t v_K, int32_t *v, int32_t **secret_as_ntt, int32_t **u_as_ntt)
{
  int32_t *result = impl__PolynomialRingElement__ZERO;
  uint32_t start = 0U;
  uint32_t finish0 = v_K;
  for (uint32_t i = start; i < finish0; i++)
  {
    uint32_t i1 = i;
    int32_t *product = ntt_multiply(secret_as_ntt[i1], u_as_ntt[i1]);
    add_to_ring_element(result, product);
  }
  invert_ntt_montgomery(result);
  uint32_t start0 = 0U;
  uint32_t finish = v_COEFFICIENTS_IN_RING_ELEMENT;
  for (uint32_t i = start0; i < finish; i++)
  {
    uint32_t i1 = i;
    int32_t coefficient_normal_form = montgomery_reduce(result[i1] * (int32_t)1441);
    result[i1] = barrett_reduce(v[i1] - coefficient_normal_form);
  }
  return result;
}

static int32_t
*compute_ring_element_v(
  uint32_t v_K,
  int32_t **tt_as_ntt,
  int32_t **r_as_ntt,
  int32_t *error_2_,
  int32_t *message
)
{
  int32_t *result = impl__PolynomialRingElement__ZERO;
  uint32_t start = 0U;
  uint32_t finish0 = v_K;
  for (uint32_t i = start; i < finish0; i++)
  {
    uint32_t i1 = i;
    int32_t *product = ntt_multiply(tt_as_ntt[i1], r_as_ntt[i1]);
    add_to_ring_element(result, product);
  }
  invert_ntt_montgomery(result);
  uint32_t start0 = 0U;
  uint32_t finish = v_COEFFICIENTS_IN_RING_ELEMENT;
  for (uint32_t i = start0; i < finish; i++)
  {
    uint32_t i1 = i;
    int32_t coefficient_normal_form = montgomery_reduce(result[i1] * (int32_t)1441);
    result[i1] = barrett_reduce(coefficient_normal_form + error_2_[i1] + message[i1]);
  }
  return result;
}

static int32_t
**compute_vector_u(uint32_t v_K, int32_t ***a_as_ntt, int32_t **r_as_ntt, int32_t **error_1_)
{
  KRML_CHECK_SIZE(sizeof (int32_t *), v_K);
  int32_t *result[v_K];
  for (uint32_t _i = 0U; _i < v_K; ++_i)
    result[_i] = impl__PolynomialRingElement__ZERO;
  uint32_t start = 0U;
  uint32_t finish = v_K;
  for (uint32_t i0 = start; i0 < finish; i0++)
  {
    uint32_t i1 = i0;
    int32_t **row = a_as_ntt[i1];
    uint32_t start1 = 0U;
    uint32_t finish10 = v_K;
    for (uint32_t i = start1; i < finish10; i++)
    {
      uint32_t j = i;
      int32_t *a_element = row[j];
      int32_t *product = ntt_multiply(a_element, r_as_ntt[j]);
      add_to_ring_element(result[i1], product);
    }
    invert_ntt_montgomery(result[i1]);
    uint32_t start10 = 0U;
    uint32_t finish1 = v_COEFFICIENTS_IN_RING_ELEMENT;
    for (uint32_t i = start10; i < finish1; i++)
    {
      uint32_t j = i;
      int32_t *result_i = result[i1];
      int32_t *error_1_i = error_1_[i1];
      int32_t coefficient_normal_form = montgomery_reduce(result_i[j] * (int32_t)1441);
      int32_t *uu____0 = result[i1];
      uu____0[j] = barrett_reduce(coefficient_normal_form + error_1_i[j]);
    }
  }
  return result;
}

static uint8_t compress_message_coefficient(uint16_t fe)
{
  int16_t shifted = (int16_t)1664 - (int16_t)fe;
  int16_t
  shifted_to_positive =
    FStar_Int16_shift_arithmetic_right(shifted,
      (uint32_t)(int32_t)15)
    ^ shifted;
  int16_t shifted_positive_in_range = shifted_to_positive - (int16_t)832;
  uint32_t m = 8U;
  int16_t pow2_bits = (int16_t)1 << 8U;
  int16_t pow2_bits_minus_one = (int16_t)1 << 7U;
  int16_t
  a2 =
    ((FStar_Int16_shift_arithmetic_right(shifted_positive_in_range,
      (uint32_t)(int32_t)15)
    & (int16_t)1)
    & (((int16_t)1 << m) - (int16_t)1))
    - pow2_bits_minus_one;
  int16_t mask = FStar_Int16_shift_arithmetic_right(a2, 15U);
  int16_t
  a3 =
    ((FStar_Int16_shift_arithmetic_right(shifted_positive_in_range,
      (uint32_t)(int32_t)15)
    & (int16_t)1)
    & (((int16_t)1 << m) - (int16_t)1))
    - pow2_bits;
  int16_t b = a3 + (mask & pow2_bits);
  return (uint8_t)b;
}

static uint32_t get_n_least_significant_bits(uint8_t n, uint32_t value)
{
  return value & ((1U << (uint32_t)n) - 1U);
}

static int32_t compress_ciphertext_coefficient(uint8_t coefficient_bits, uint16_t fe)
{
  uint32_t compressed = (uint32_t)fe << (uint32_t)((uint32_t)coefficient_bits + 1U);
  uint32_t compressed1 = compressed + (uint32_t)v_FIELD_MODULUS;
  uint32_t compressed2 = compressed1 / (uint32_t)(v_FIELD_MODULUS << (uint32_t)(int32_t)1);
  return (int32_t)get_n_least_significant_bits(coefficient_bits, compressed2);
}

static int32_t decompress_ciphertext_coefficient(uint8_t coefficient_bits, int32_t fe)
{
  uint32_t decompressed = (uint32_t)fe * (uint32_t)v_FIELD_MODULUS;
  uint32_t
  decompressed1 = (decompressed << (uint32_t)(int32_t)1) + (1U << (uint32_t)coefficient_bits);
  uint32_t decompressed2 = decompressed1 >> (uint32_t)((uint32_t)coefficient_bits + 1U);
  return (int32_t)decompressed2;
}

static int32_t decompress_message_coefficient(int32_t fe)
{
  return ((int32_t)0 - fe) & (v_FIELD_MODULUS + (int32_t)1) / (int32_t)2;
}

static uint8_t *compress_then_serialize_10_(uint32_t v_OUT_LEN, int32_t *re)
{
  KRML_CHECK_SIZE(sizeof (uint8_t), v_OUT_LEN);
  uint8_t serialized[v_OUT_LEN];
  memset(serialized, 0U, v_OUT_LEN * sizeof (uint8_t));
  uint32_t start = 0U;
  uint32_t finish = 256U / 4U;
  for (uint32_t i = start; i < finish; i++)
  {
    uint32_t i1 = i;
    int32_t
    coefficient1 =
      compress_ciphertext_coefficient(10U,
        to_unsigned_representative(re[i1 * 4U + 0U]));
    int32_t
    coefficient2 =
      compress_ciphertext_coefficient(10U,
        to_unsigned_representative(re[i1 * 4U + 1U]));
    int32_t
    coefficient3 =
      compress_ciphertext_coefficient(10U,
        to_unsigned_representative(re[i1 * 4U + 2U]));
    int32_t
    coefficient4 =
      compress_ciphertext_coefficient(10U,
        to_unsigned_representative(re[i1 * 4U + 3U]));
    uint32_t m0 = 8U;
    int32_t pow2_bits0 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one0 = (int32_t)1 << 7U;
    int32_t
    a2 = ((coefficient1 & (int32_t)255) & (((int32_t)1 << m0) - (int32_t)1)) - pow2_bits_minus_one0;
    int32_t mask = FStar_Int32_shift_arithmetic_right(a2, 31U);
    int32_t a30 = ((coefficient1 & (int32_t)255) & (((int32_t)1 << m0) - (int32_t)1)) - pow2_bits0;
    int32_t b = a30 + (mask & pow2_bits0);
    serialized[5U * i1] = (uint8_t)b;
    uint32_t m1 = 8U;
    int32_t pow2_bits1 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one1 = (int32_t)1 << 7U;
    int32_t
    a20 = ((coefficient2 & (int32_t)63) & (((int32_t)1 << m1) - (int32_t)1)) - pow2_bits_minus_one1;
    int32_t mask0 = FStar_Int32_shift_arithmetic_right(a20, 31U);
    int32_t a31 = ((coefficient2 & (int32_t)63) & (((int32_t)1 << m1) - (int32_t)1)) - pow2_bits1;
    int32_t b0 = a31 + (mask0 & pow2_bits1);
    uint32_t m2 = 8U;
    int32_t pow2_bits2 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one2 = (int32_t)1 << 7U;
    int32_t
    a21 =
      ((FStar_Int32_shift_arithmetic_right(coefficient1, (uint32_t)(int32_t)8) & (int32_t)3)
      & (((int32_t)1 << m2) - (int32_t)1))
      - pow2_bits_minus_one2;
    int32_t mask1 = FStar_Int32_shift_arithmetic_right(a21, 31U);
    int32_t
    a32 =
      ((FStar_Int32_shift_arithmetic_right(coefficient1, (uint32_t)(int32_t)8) & (int32_t)3)
      & (((int32_t)1 << m2) - (int32_t)1))
      - pow2_bits2;
    int32_t b1 = a32 + (mask1 & pow2_bits2);
    serialized[5U * i1 + 1U] =
      (uint32_t)(uint8_t)b0
      << (uint32_t)(int32_t)2
      | (uint32_t)(uint8_t)b1;
    uint32_t m3 = 8U;
    int32_t pow2_bits3 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one3 = (int32_t)1 << 7U;
    int32_t
    a22 = ((coefficient3 & (int32_t)15) & (((int32_t)1 << m3) - (int32_t)1)) - pow2_bits_minus_one3;
    int32_t mask2 = FStar_Int32_shift_arithmetic_right(a22, 31U);
    int32_t a33 = ((coefficient3 & (int32_t)15) & (((int32_t)1 << m3) - (int32_t)1)) - pow2_bits3;
    int32_t b2 = a33 + (mask2 & pow2_bits3);
    uint32_t m4 = 8U;
    int32_t pow2_bits4 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one4 = (int32_t)1 << 7U;
    int32_t
    a23 =
      ((FStar_Int32_shift_arithmetic_right(coefficient2, (uint32_t)(int32_t)6) & (int32_t)15)
      & (((int32_t)1 << m4) - (int32_t)1))
      - pow2_bits_minus_one4;
    int32_t mask3 = FStar_Int32_shift_arithmetic_right(a23, 31U);
    int32_t
    a34 =
      ((FStar_Int32_shift_arithmetic_right(coefficient2, (uint32_t)(int32_t)6) & (int32_t)15)
      & (((int32_t)1 << m4) - (int32_t)1))
      - pow2_bits4;
    int32_t b3 = a34 + (mask3 & pow2_bits4);
    serialized[5U * i1 + 2U] =
      (uint32_t)(uint8_t)b2
      << (uint32_t)(int32_t)4
      | (uint32_t)(uint8_t)b3;
    uint32_t m5 = 8U;
    int32_t pow2_bits5 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one5 = (int32_t)1 << 7U;
    int32_t
    a24 = ((coefficient4 & (int32_t)3) & (((int32_t)1 << m5) - (int32_t)1)) - pow2_bits_minus_one5;
    int32_t mask4 = FStar_Int32_shift_arithmetic_right(a24, 31U);
    int32_t a35 = ((coefficient4 & (int32_t)3) & (((int32_t)1 << m5) - (int32_t)1)) - pow2_bits5;
    int32_t b4 = a35 + (mask4 & pow2_bits5);
    uint32_t m = 8U;
    int32_t pow2_bits6 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one6 = (int32_t)1 << 7U;
    int32_t
    a25 =
      ((FStar_Int32_shift_arithmetic_right(coefficient3, (uint32_t)(int32_t)4) & (int32_t)63)
      & (((int32_t)1 << m) - (int32_t)1))
      - pow2_bits_minus_one6;
    int32_t mask5 = FStar_Int32_shift_arithmetic_right(a25, 31U);
    int32_t
    a36 =
      ((FStar_Int32_shift_arithmetic_right(coefficient3, (uint32_t)(int32_t)4) & (int32_t)63)
      & (((int32_t)1 << m) - (int32_t)1))
      - pow2_bits6;
    int32_t b5 = a36 + (mask5 & pow2_bits6);
    serialized[5U * i1 + 3U] =
      (uint32_t)(uint8_t)b4
      << (uint32_t)(int32_t)6
      | (uint32_t)(uint8_t)b5;
    uint32_t m6 = 8U;
    int32_t pow2_bits = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one = (int32_t)1 << 7U;
    int32_t
    a26 =
      ((FStar_Int32_shift_arithmetic_right(coefficient4, (uint32_t)(int32_t)2) & (int32_t)255)
      & (((int32_t)1 << m6) - (int32_t)1))
      - pow2_bits_minus_one;
    int32_t mask6 = FStar_Int32_shift_arithmetic_right(a26, 31U);
    int32_t
    a3 =
      ((FStar_Int32_shift_arithmetic_right(coefficient4, (uint32_t)(int32_t)2) & (int32_t)255)
      & (((int32_t)1 << m6) - (int32_t)1))
      - pow2_bits;
    int32_t b6 = a3 + (mask6 & pow2_bits);
    serialized[5U * i1 + 4U] = (uint8_t)b6;
  }
  return serialized;
}

static uint8_t *compress_then_serialize_11_(uint32_t v_OUT_LEN, int32_t *re)
{
  KRML_CHECK_SIZE(sizeof (uint8_t), v_OUT_LEN);
  uint8_t serialized[v_OUT_LEN];
  memset(serialized, 0U, v_OUT_LEN * sizeof (uint8_t));
  uint32_t start = 0U;
  uint32_t finish = 256U / 8U;
  for (uint32_t i = start; i < finish; i++)
  {
    uint32_t i1 = i;
    int32_t
    coefficient1 =
      compress_ciphertext_coefficient(11U,
        to_unsigned_representative(re[i1 * 8U + 0U]));
    int32_t
    coefficient2 =
      compress_ciphertext_coefficient(11U,
        to_unsigned_representative(re[i1 * 8U + 1U]));
    int32_t
    coefficient3 =
      compress_ciphertext_coefficient(11U,
        to_unsigned_representative(re[i1 * 8U + 2U]));
    int32_t
    coefficient4 =
      compress_ciphertext_coefficient(11U,
        to_unsigned_representative(re[i1 * 8U + 3U]));
    int32_t
    coefficient5 =
      compress_ciphertext_coefficient(11U,
        to_unsigned_representative(re[i1 * 8U + 4U]));
    int32_t
    coefficient6 =
      compress_ciphertext_coefficient(11U,
        to_unsigned_representative(re[i1 * 8U + 5U]));
    int32_t
    coefficient7 =
      compress_ciphertext_coefficient(11U,
        to_unsigned_representative(re[i1 * 8U + 6U]));
    int32_t
    coefficient8 =
      compress_ciphertext_coefficient(11U,
        to_unsigned_representative(re[i1 * 8U + 7U]));
    uint32_t m0 = 8U;
    int32_t pow2_bits0 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one0 = (int32_t)1 << 7U;
    int32_t a2 = (coefficient1 & (((int32_t)1 << m0) - (int32_t)1)) - pow2_bits_minus_one0;
    int32_t mask = FStar_Int32_shift_arithmetic_right(a2, 31U);
    int32_t a30 = (coefficient1 & (((int32_t)1 << m0) - (int32_t)1)) - pow2_bits0;
    int32_t b = a30 + (mask & pow2_bits0);
    serialized[11U * i1] = (uint8_t)b;
    uint32_t m1 = 8U;
    int32_t pow2_bits1 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one1 = (int32_t)1 << 7U;
    int32_t
    a20 = ((coefficient2 & (int32_t)31) & (((int32_t)1 << m1) - (int32_t)1)) - pow2_bits_minus_one1;
    int32_t mask0 = FStar_Int32_shift_arithmetic_right(a20, 31U);
    int32_t a31 = ((coefficient2 & (int32_t)31) & (((int32_t)1 << m1) - (int32_t)1)) - pow2_bits1;
    int32_t b0 = a31 + (mask0 & pow2_bits1);
    uint32_t m2 = 8U;
    int32_t pow2_bits2 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one2 = (int32_t)1 << 7U;
    int32_t
    a21 =
      (FStar_Int32_shift_arithmetic_right(coefficient1,
        (uint32_t)(int32_t)8)
      & (((int32_t)1 << m2) - (int32_t)1))
      - pow2_bits_minus_one2;
    int32_t mask1 = FStar_Int32_shift_arithmetic_right(a21, 31U);
    int32_t
    a32 =
      (FStar_Int32_shift_arithmetic_right(coefficient1,
        (uint32_t)(int32_t)8)
      & (((int32_t)1 << m2) - (int32_t)1))
      - pow2_bits2;
    int32_t b1 = a32 + (mask1 & pow2_bits2);
    serialized[11U * i1 + 1U] =
      (uint32_t)(uint8_t)b0
      << (uint32_t)(int32_t)3
      | (uint32_t)(uint8_t)b1;
    uint32_t m3 = 8U;
    int32_t pow2_bits3 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one3 = (int32_t)1 << 7U;
    int32_t
    a22 = ((coefficient3 & (int32_t)3) & (((int32_t)1 << m3) - (int32_t)1)) - pow2_bits_minus_one3;
    int32_t mask2 = FStar_Int32_shift_arithmetic_right(a22, 31U);
    int32_t a33 = ((coefficient3 & (int32_t)3) & (((int32_t)1 << m3) - (int32_t)1)) - pow2_bits3;
    int32_t b2 = a33 + (mask2 & pow2_bits3);
    uint32_t m4 = 8U;
    int32_t pow2_bits4 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one4 = (int32_t)1 << 7U;
    int32_t
    a23 =
      (FStar_Int32_shift_arithmetic_right(coefficient2,
        (uint32_t)(int32_t)5)
      & (((int32_t)1 << m4) - (int32_t)1))
      - pow2_bits_minus_one4;
    int32_t mask3 = FStar_Int32_shift_arithmetic_right(a23, 31U);
    int32_t
    a34 =
      (FStar_Int32_shift_arithmetic_right(coefficient2,
        (uint32_t)(int32_t)5)
      & (((int32_t)1 << m4) - (int32_t)1))
      - pow2_bits4;
    int32_t b3 = a34 + (mask3 & pow2_bits4);
    serialized[11U * i1 + 2U] =
      (uint32_t)(uint8_t)b2
      << (uint32_t)(int32_t)6
      | (uint32_t)(uint8_t)b3;
    uint32_t m5 = 8U;
    int32_t pow2_bits5 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one5 = (int32_t)1 << 7U;
    int32_t
    a24 =
      ((FStar_Int32_shift_arithmetic_right(coefficient3, (uint32_t)(int32_t)2) & (int32_t)255)
      & (((int32_t)1 << m5) - (int32_t)1))
      - pow2_bits_minus_one5;
    int32_t mask4 = FStar_Int32_shift_arithmetic_right(a24, 31U);
    int32_t
    a35 =
      ((FStar_Int32_shift_arithmetic_right(coefficient3, (uint32_t)(int32_t)2) & (int32_t)255)
      & (((int32_t)1 << m5) - (int32_t)1))
      - pow2_bits5;
    int32_t b4 = a35 + (mask4 & pow2_bits5);
    serialized[11U * i1 + 3U] = (uint8_t)b4;
    uint32_t m6 = 8U;
    int32_t pow2_bits6 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one6 = (int32_t)1 << 7U;
    int32_t
    a25 =
      ((coefficient4 & (int32_t)127) & (((int32_t)1 << m6) - (int32_t)1))
      - pow2_bits_minus_one6;
    int32_t mask5 = FStar_Int32_shift_arithmetic_right(a25, 31U);
    int32_t a36 = ((coefficient4 & (int32_t)127) & (((int32_t)1 << m6) - (int32_t)1)) - pow2_bits6;
    int32_t b5 = a36 + (mask5 & pow2_bits6);
    uint32_t m7 = 8U;
    int32_t pow2_bits7 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one7 = (int32_t)1 << 7U;
    int32_t
    a26 =
      (FStar_Int32_shift_arithmetic_right(coefficient3,
        (uint32_t)(int32_t)10)
      & (((int32_t)1 << m7) - (int32_t)1))
      - pow2_bits_minus_one7;
    int32_t mask6 = FStar_Int32_shift_arithmetic_right(a26, 31U);
    int32_t
    a37 =
      (FStar_Int32_shift_arithmetic_right(coefficient3,
        (uint32_t)(int32_t)10)
      & (((int32_t)1 << m7) - (int32_t)1))
      - pow2_bits7;
    int32_t b6 = a37 + (mask6 & pow2_bits7);
    serialized[11U * i1 + 4U] =
      (uint32_t)(uint8_t)b5
      << (uint32_t)(int32_t)1
      | (uint32_t)(uint8_t)b6;
    uint32_t m8 = 8U;
    int32_t pow2_bits8 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one8 = (int32_t)1 << 7U;
    int32_t
    a27 = ((coefficient5 & (int32_t)15) & (((int32_t)1 << m8) - (int32_t)1)) - pow2_bits_minus_one8;
    int32_t mask7 = FStar_Int32_shift_arithmetic_right(a27, 31U);
    int32_t a38 = ((coefficient5 & (int32_t)15) & (((int32_t)1 << m8) - (int32_t)1)) - pow2_bits8;
    int32_t b7 = a38 + (mask7 & pow2_bits8);
    uint32_t m9 = 8U;
    int32_t pow2_bits9 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one9 = (int32_t)1 << 7U;
    int32_t
    a28 =
      (FStar_Int32_shift_arithmetic_right(coefficient4,
        (uint32_t)(int32_t)7)
      & (((int32_t)1 << m9) - (int32_t)1))
      - pow2_bits_minus_one9;
    int32_t mask8 = FStar_Int32_shift_arithmetic_right(a28, 31U);
    int32_t
    a39 =
      (FStar_Int32_shift_arithmetic_right(coefficient4,
        (uint32_t)(int32_t)7)
      & (((int32_t)1 << m9) - (int32_t)1))
      - pow2_bits9;
    int32_t b8 = a39 + (mask8 & pow2_bits9);
    serialized[11U * i1 + 5U] =
      (uint32_t)(uint8_t)b7
      << (uint32_t)(int32_t)4
      | (uint32_t)(uint8_t)b8;
    uint32_t m10 = 8U;
    int32_t pow2_bits10 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one10 = (int32_t)1 << 7U;
    int32_t
    a29 =
      ((coefficient6 & (int32_t)1) & (((int32_t)1 << m10) - (int32_t)1))
      - pow2_bits_minus_one10;
    int32_t mask9 = FStar_Int32_shift_arithmetic_right(a29, 31U);
    int32_t
    a310 = ((coefficient6 & (int32_t)1) & (((int32_t)1 << m10) - (int32_t)1)) - pow2_bits10;
    int32_t b9 = a310 + (mask9 & pow2_bits10);
    uint32_t m11 = 8U;
    int32_t pow2_bits11 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one11 = (int32_t)1 << 7U;
    int32_t
    a210 =
      (FStar_Int32_shift_arithmetic_right(coefficient5,
        (uint32_t)(int32_t)4)
      & (((int32_t)1 << m11) - (int32_t)1))
      - pow2_bits_minus_one11;
    int32_t mask10 = FStar_Int32_shift_arithmetic_right(a210, 31U);
    int32_t
    a311 =
      (FStar_Int32_shift_arithmetic_right(coefficient5,
        (uint32_t)(int32_t)4)
      & (((int32_t)1 << m11) - (int32_t)1))
      - pow2_bits11;
    int32_t b10 = a311 + (mask10 & pow2_bits11);
    serialized[11U * i1 + 6U] =
      (uint32_t)(uint8_t)b9
      << (uint32_t)(int32_t)7
      | (uint32_t)(uint8_t)b10;
    uint32_t m12 = 8U;
    int32_t pow2_bits12 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one12 = (int32_t)1 << 7U;
    int32_t
    a211 =
      ((FStar_Int32_shift_arithmetic_right(coefficient6, (uint32_t)(int32_t)1) & (int32_t)255)
      & (((int32_t)1 << m12) - (int32_t)1))
      - pow2_bits_minus_one12;
    int32_t mask11 = FStar_Int32_shift_arithmetic_right(a211, 31U);
    int32_t
    a312 =
      ((FStar_Int32_shift_arithmetic_right(coefficient6, (uint32_t)(int32_t)1) & (int32_t)255)
      & (((int32_t)1 << m12) - (int32_t)1))
      - pow2_bits12;
    int32_t b11 = a312 + (mask11 & pow2_bits12);
    serialized[11U * i1 + 7U] = (uint8_t)b11;
    uint32_t m13 = 8U;
    int32_t pow2_bits13 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one13 = (int32_t)1 << 7U;
    int32_t
    a212 =
      ((coefficient7 & (int32_t)63) & (((int32_t)1 << m13) - (int32_t)1))
      - pow2_bits_minus_one13;
    int32_t mask12 = FStar_Int32_shift_arithmetic_right(a212, 31U);
    int32_t
    a313 = ((coefficient7 & (int32_t)63) & (((int32_t)1 << m13) - (int32_t)1)) - pow2_bits13;
    int32_t b12 = a313 + (mask12 & pow2_bits13);
    uint32_t m14 = 8U;
    int32_t pow2_bits14 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one14 = (int32_t)1 << 7U;
    int32_t
    a213 =
      (FStar_Int32_shift_arithmetic_right(coefficient6,
        (uint32_t)(int32_t)9)
      & (((int32_t)1 << m14) - (int32_t)1))
      - pow2_bits_minus_one14;
    int32_t mask13 = FStar_Int32_shift_arithmetic_right(a213, 31U);
    int32_t
    a314 =
      (FStar_Int32_shift_arithmetic_right(coefficient6,
        (uint32_t)(int32_t)9)
      & (((int32_t)1 << m14) - (int32_t)1))
      - pow2_bits14;
    int32_t b13 = a314 + (mask13 & pow2_bits14);
    serialized[11U * i1 + 8U] =
      (uint32_t)(uint8_t)b12
      << (uint32_t)(int32_t)2
      | (uint32_t)(uint8_t)b13;
    uint32_t m15 = 8U;
    int32_t pow2_bits15 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one15 = (int32_t)1 << 7U;
    int32_t
    a214 =
      ((coefficient8 & (int32_t)7) & (((int32_t)1 << m15) - (int32_t)1))
      - pow2_bits_minus_one15;
    int32_t mask14 = FStar_Int32_shift_arithmetic_right(a214, 31U);
    int32_t
    a315 = ((coefficient8 & (int32_t)7) & (((int32_t)1 << m15) - (int32_t)1)) - pow2_bits15;
    int32_t b14 = a315 + (mask14 & pow2_bits15);
    uint32_t m = 8U;
    int32_t pow2_bits16 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one16 = (int32_t)1 << 7U;
    int32_t
    a215 =
      (FStar_Int32_shift_arithmetic_right(coefficient7,
        (uint32_t)(int32_t)6)
      & (((int32_t)1 << m) - (int32_t)1))
      - pow2_bits_minus_one16;
    int32_t mask15 = FStar_Int32_shift_arithmetic_right(a215, 31U);
    int32_t
    a316 =
      (FStar_Int32_shift_arithmetic_right(coefficient7,
        (uint32_t)(int32_t)6)
      & (((int32_t)1 << m) - (int32_t)1))
      - pow2_bits16;
    int32_t b15 = a316 + (mask15 & pow2_bits16);
    serialized[11U * i1 + 9U] =
      (uint32_t)(uint8_t)b14
      << (uint32_t)(int32_t)5
      | (uint32_t)(uint8_t)b15;
    uint32_t m16 = 8U;
    int32_t pow2_bits = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one = (int32_t)1 << 7U;
    int32_t
    a216 =
      (FStar_Int32_shift_arithmetic_right(coefficient8,
        (uint32_t)(int32_t)3)
      & (((int32_t)1 << m16) - (int32_t)1))
      - pow2_bits_minus_one;
    int32_t mask16 = FStar_Int32_shift_arithmetic_right(a216, 31U);
    int32_t
    a3 =
      (FStar_Int32_shift_arithmetic_right(coefficient8,
        (uint32_t)(int32_t)3)
      & (((int32_t)1 << m16) - (int32_t)1))
      - pow2_bits;
    int32_t b16 = a3 + (mask16 & pow2_bits);
    serialized[11U * i1 + 10U] = (uint8_t)b16;
  }
  return serialized;
}

static uint8_t *compress_then_serialize_4_(uint32_t v_OUT_LEN, int32_t *re)
{
  KRML_CHECK_SIZE(sizeof (uint8_t), v_OUT_LEN);
  uint8_t serialized[v_OUT_LEN];
  memset(serialized, 0U, v_OUT_LEN * sizeof (uint8_t));
  uint32_t start = 0U;
  uint32_t finish = 256U / 2U;
  for (uint32_t i = start; i < finish; i++)
  {
    uint32_t i1 = i;
    int32_t
    uu____0 = compress_ciphertext_coefficient(4U, to_unsigned_representative(re[i1 * 2U + 0U]));
    uint32_t m0 = 8U;
    int32_t pow2_bits0 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one0 = (int32_t)1 << 7U;
    int32_t a2 = (uu____0 & (((int32_t)1 << m0) - (int32_t)1)) - pow2_bits_minus_one0;
    int32_t mask = FStar_Int32_shift_arithmetic_right(a2, 31U);
    int32_t a30 = (uu____0 & (((int32_t)1 << m0) - (int32_t)1)) - pow2_bits0;
    int32_t b = a30 + (mask & pow2_bits0);
    uint8_t coefficient1 = (uint8_t)b;
    int32_t
    uu____1 = compress_ciphertext_coefficient(4U, to_unsigned_representative(re[i1 * 2U + 1U]));
    uint32_t m = 8U;
    int32_t pow2_bits = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one = (int32_t)1 << 7U;
    int32_t a20 = (uu____1 & (((int32_t)1 << m) - (int32_t)1)) - pow2_bits_minus_one;
    int32_t mask0 = FStar_Int32_shift_arithmetic_right(a20, 31U);
    int32_t a3 = (uu____1 & (((int32_t)1 << m) - (int32_t)1)) - pow2_bits;
    int32_t b0 = a3 + (mask0 & pow2_bits);
    uint8_t coefficient2 = (uint8_t)b0;
    serialized[i1] = (uint32_t)coefficient2 << (uint32_t)(int32_t)4 | (uint32_t)coefficient1;
  }
  return serialized;
}

static uint8_t *compress_then_serialize_5_(uint32_t v_OUT_LEN, int32_t *re)
{
  KRML_CHECK_SIZE(sizeof (uint8_t), v_OUT_LEN);
  uint8_t serialized[v_OUT_LEN];
  memset(serialized, 0U, v_OUT_LEN * sizeof (uint8_t));
  uint32_t start = 0U;
  uint32_t finish = 256U / 8U;
  for (uint32_t i = start; i < finish; i++)
  {
    uint32_t i1 = i;
    int32_t
    uu____0 = compress_ciphertext_coefficient(5U, to_unsigned_representative(re[i1 * 8U + 0U]));
    uint32_t m0 = 8U;
    int32_t pow2_bits0 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one0 = (int32_t)1 << 7U;
    int32_t a2 = (uu____0 & (((int32_t)1 << m0) - (int32_t)1)) - pow2_bits_minus_one0;
    int32_t mask = FStar_Int32_shift_arithmetic_right(a2, 31U);
    int32_t a30 = (uu____0 & (((int32_t)1 << m0) - (int32_t)1)) - pow2_bits0;
    int32_t b = a30 + (mask & pow2_bits0);
    uint8_t coefficient1 = (uint8_t)b;
    int32_t
    uu____1 = compress_ciphertext_coefficient(5U, to_unsigned_representative(re[i1 * 8U + 1U]));
    uint32_t m1 = 8U;
    int32_t pow2_bits1 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one1 = (int32_t)1 << 7U;
    int32_t a20 = (uu____1 & (((int32_t)1 << m1) - (int32_t)1)) - pow2_bits_minus_one1;
    int32_t mask0 = FStar_Int32_shift_arithmetic_right(a20, 31U);
    int32_t a31 = (uu____1 & (((int32_t)1 << m1) - (int32_t)1)) - pow2_bits1;
    int32_t b0 = a31 + (mask0 & pow2_bits1);
    uint8_t coefficient2 = (uint8_t)b0;
    int32_t
    uu____2 = compress_ciphertext_coefficient(5U, to_unsigned_representative(re[i1 * 8U + 2U]));
    uint32_t m2 = 8U;
    int32_t pow2_bits2 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one2 = (int32_t)1 << 7U;
    int32_t a21 = (uu____2 & (((int32_t)1 << m2) - (int32_t)1)) - pow2_bits_minus_one2;
    int32_t mask1 = FStar_Int32_shift_arithmetic_right(a21, 31U);
    int32_t a32 = (uu____2 & (((int32_t)1 << m2) - (int32_t)1)) - pow2_bits2;
    int32_t b1 = a32 + (mask1 & pow2_bits2);
    uint8_t coefficient3 = (uint8_t)b1;
    int32_t
    uu____3 = compress_ciphertext_coefficient(5U, to_unsigned_representative(re[i1 * 8U + 3U]));
    uint32_t m3 = 8U;
    int32_t pow2_bits3 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one3 = (int32_t)1 << 7U;
    int32_t a22 = (uu____3 & (((int32_t)1 << m3) - (int32_t)1)) - pow2_bits_minus_one3;
    int32_t mask2 = FStar_Int32_shift_arithmetic_right(a22, 31U);
    int32_t a33 = (uu____3 & (((int32_t)1 << m3) - (int32_t)1)) - pow2_bits3;
    int32_t b2 = a33 + (mask2 & pow2_bits3);
    uint8_t coefficient4 = (uint8_t)b2;
    int32_t
    uu____4 = compress_ciphertext_coefficient(5U, to_unsigned_representative(re[i1 * 8U + 4U]));
    uint32_t m4 = 8U;
    int32_t pow2_bits4 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one4 = (int32_t)1 << 7U;
    int32_t a23 = (uu____4 & (((int32_t)1 << m4) - (int32_t)1)) - pow2_bits_minus_one4;
    int32_t mask3 = FStar_Int32_shift_arithmetic_right(a23, 31U);
    int32_t a34 = (uu____4 & (((int32_t)1 << m4) - (int32_t)1)) - pow2_bits4;
    int32_t b3 = a34 + (mask3 & pow2_bits4);
    uint8_t coefficient5 = (uint8_t)b3;
    int32_t
    uu____5 = compress_ciphertext_coefficient(5U, to_unsigned_representative(re[i1 * 8U + 5U]));
    uint32_t m5 = 8U;
    int32_t pow2_bits5 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one5 = (int32_t)1 << 7U;
    int32_t a24 = (uu____5 & (((int32_t)1 << m5) - (int32_t)1)) - pow2_bits_minus_one5;
    int32_t mask4 = FStar_Int32_shift_arithmetic_right(a24, 31U);
    int32_t a35 = (uu____5 & (((int32_t)1 << m5) - (int32_t)1)) - pow2_bits5;
    int32_t b4 = a35 + (mask4 & pow2_bits5);
    uint8_t coefficient6 = (uint8_t)b4;
    int32_t
    uu____6 = compress_ciphertext_coefficient(5U, to_unsigned_representative(re[i1 * 8U + 6U]));
    uint32_t m6 = 8U;
    int32_t pow2_bits6 = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one6 = (int32_t)1 << 7U;
    int32_t a25 = (uu____6 & (((int32_t)1 << m6) - (int32_t)1)) - pow2_bits_minus_one6;
    int32_t mask5 = FStar_Int32_shift_arithmetic_right(a25, 31U);
    int32_t a36 = (uu____6 & (((int32_t)1 << m6) - (int32_t)1)) - pow2_bits6;
    int32_t b5 = a36 + (mask5 & pow2_bits6);
    uint8_t coefficient7 = (uint8_t)b5;
    int32_t
    uu____7 = compress_ciphertext_coefficient(5U, to_unsigned_representative(re[i1 * 8U + 7U]));
    uint32_t m = 8U;
    int32_t pow2_bits = (int32_t)1 << 8U;
    int32_t pow2_bits_minus_one = (int32_t)1 << 7U;
    int32_t a26 = (uu____7 & (((int32_t)1 << m) - (int32_t)1)) - pow2_bits_minus_one;
    int32_t mask6 = FStar_Int32_shift_arithmetic_right(a26, 31U);
    int32_t a3 = (uu____7 & (((int32_t)1 << m) - (int32_t)1)) - pow2_bits;
    int32_t b6 = a3 + (mask6 & pow2_bits);
    uint8_t coefficient8 = (uint8_t)b6;
    serialized[5U * i1] =
      ((uint32_t)coefficient2 & 7U)
      << (uint32_t)(int32_t)5
      | (uint32_t)coefficient1;
    serialized[5U * i1 + 1U] =
      (((uint32_t)coefficient4 & 1U)
      << (uint32_t)(int32_t)7
      | (uint32_t)coefficient3 << (uint32_t)(int32_t)2)
      | (uint32_t)coefficient2 >> (uint32_t)(int32_t)3;
    serialized[5U * i1 + 2U] =
      ((uint32_t)coefficient5 & 15U)
      << (uint32_t)(int32_t)4
      | (uint32_t)coefficient4 >> (uint32_t)(int32_t)1;
    serialized[5U * i1 + 3U] =
      (((uint32_t)coefficient7 & 3U)
      << (uint32_t)(int32_t)6
      | (uint32_t)coefficient6 << (uint32_t)(int32_t)1)
      | (uint32_t)coefficient5 >> (uint32_t)(int32_t)4;
    serialized[5U * i1 + 4U] =
      (uint32_t)coefficient8
      << (uint32_t)(int32_t)3
      | (uint32_t)coefficient7 >> (uint32_t)(int32_t)2;
  }
  return serialized;
}

static uint8_t *compress_then_serialize_message(int32_t *re)
{
  uint8_t serialized[32U] = { 0U };
  uint32_t start = 0U;
  uint32_t finish = 256U / 8U;
  for (uint32_t i0 = start; i0 < finish; i0++)
  {
    uint32_t i1 = i0;
    uint32_t start1 = 0U;
    uint32_t finish1 = 8U;
    for (uint32_t i = start1; i < finish1; i++)
    {
      uint32_t j = i;
      uint16_t coefficient = to_unsigned_representative(re[i1 * 8U + j]);
      uint8_t coefficient_compressed = compress_message_coefficient(coefficient);
      serialized[i1] = (uint32_t)serialized[i1] | (uint32_t)coefficient_compressed << j;
    }
  }
  return serialized;
}

static uint8_t
*compress_then_serialize_ring_element_u(
  uint32_t v_COMPRESSION_FACTOR,
  uint32_t v_OUT_LEN,
  int32_t *re
)
{
  switch (v_COMPRESSION_FACTOR)
  {
    case 10U:
      {
        return compress_then_serialize_10_(v_OUT_LEN, re);
      }
    case 11U:
      {
        return compress_then_serialize_11_(v_OUT_LEN, re);
      }
    default:
      {
        KRML_HOST_EPRINTF("KaRaMeL incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
}

static uint8_t
*compress_then_serialize_ring_element_v(
  uint32_t v_COMPRESSION_FACTOR,
  uint32_t v_OUT_LEN,
  int32_t *re
)
{
  switch (v_COMPRESSION_FACTOR)
  {
    case 4U:
      {
        return compress_then_serialize_4_(v_OUT_LEN, re);
      }
    case 5U:
      {
        return compress_then_serialize_5_(v_OUT_LEN, re);
      }
    default:
      {
        KRML_HOST_EPRINTF("KaRaMeL incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
}

static int32_t *deserialize_then_decompress_10_(t_nonempty_Slice__uint8_t serialized)
{
  int32_t *re = impl__PolynomialRingElement__ZERO;
  uint32_t start = 0U;
  uint32_t finish = serialized.len / 5U;
  for (uint32_t i = start; i < finish; i++)
  {
    uint32_t i1 = i;
    int32_t byte1 = (int32_t)serialized.buffer[i1 * 5U + 0U];
    int32_t byte2 = (int32_t)serialized.buffer[i1 * 5U + 1U];
    int32_t byte3 = (int32_t)serialized.buffer[i1 * 5U + 2U];
    int32_t byte4 = (int32_t)serialized.buffer[i1 * 5U + 3U];
    int32_t byte5 = (int32_t)serialized.buffer[i1 * 5U + 4U];
    int32_t coefficient1 = (byte2 & (int32_t)3) << (uint32_t)(int32_t)8 | (byte1 & (int32_t)255);
    re[4U * i1] = decompress_ciphertext_coefficient(10U, coefficient1);
    int32_t
    coefficient2 =
      (byte3 & (int32_t)15)
      << (uint32_t)(int32_t)6
      | FStar_Int32_shift_arithmetic_right(byte2, (uint32_t)(int32_t)2);
    re[4U * i1 + 1U] = decompress_ciphertext_coefficient(10U, coefficient2);
    int32_t
    coefficient3 =
      (byte4 & (int32_t)63)
      << (uint32_t)(int32_t)4
      | FStar_Int32_shift_arithmetic_right(byte3, (uint32_t)(int32_t)4);
    re[4U * i1 + 2U] = decompress_ciphertext_coefficient(10U, coefficient3);
    int32_t
    coefficient4 =
      byte5
      << (uint32_t)(int32_t)2
      | FStar_Int32_shift_arithmetic_right(byte4, (uint32_t)(int32_t)6);
    re[4U * i1 + 3U] = decompress_ciphertext_coefficient(10U, coefficient4);
  }
  return re;
}

static int32_t *deserialize_then_decompress_11_(t_nonempty_Slice__uint8_t serialized)
{
  int32_t *re = impl__PolynomialRingElement__ZERO;
  uint32_t start = 0U;
  uint32_t finish = serialized.len / 11U;
  for (uint32_t i = start; i < finish; i++)
  {
    uint32_t i1 = i;
    int32_t byte1 = (int32_t)serialized.buffer[i1 * 11U + 0U];
    int32_t byte2 = (int32_t)serialized.buffer[i1 * 11U + 1U];
    int32_t byte3 = (int32_t)serialized.buffer[i1 * 11U + 2U];
    int32_t byte4 = (int32_t)serialized.buffer[i1 * 11U + 3U];
    int32_t byte5 = (int32_t)serialized.buffer[i1 * 11U + 4U];
    int32_t byte6 = (int32_t)serialized.buffer[i1 * 11U + 5U];
    int32_t byte7 = (int32_t)serialized.buffer[i1 * 11U + 6U];
    int32_t byte8 = (int32_t)serialized.buffer[i1 * 11U + 7U];
    int32_t byte9 = (int32_t)serialized.buffer[i1 * 11U + 8U];
    int32_t byte10 = (int32_t)serialized.buffer[i1 * 11U + 9U];
    int32_t byte11 = (int32_t)serialized.buffer[i1 * 11U + 10U];
    int32_t coefficient1 = (byte2 & (int32_t)7) << (uint32_t)(int32_t)8 | byte1;
    re[8U * i1] = decompress_ciphertext_coefficient(11U, coefficient1);
    int32_t
    coefficient2 =
      (byte3 & (int32_t)63)
      << (uint32_t)(int32_t)5
      | FStar_Int32_shift_arithmetic_right(byte2, (uint32_t)(int32_t)3);
    re[8U * i1 + 1U] = decompress_ciphertext_coefficient(11U, coefficient2);
    int32_t
    coefficient3 =
      ((byte5 & (int32_t)1) << (uint32_t)(int32_t)10 | byte4 << (uint32_t)(int32_t)2)
      | FStar_Int32_shift_arithmetic_right(byte3, (uint32_t)(int32_t)6);
    re[8U * i1 + 2U] = decompress_ciphertext_coefficient(11U, coefficient3);
    int32_t
    coefficient4 =
      (byte6 & (int32_t)15)
      << (uint32_t)(int32_t)7
      | FStar_Int32_shift_arithmetic_right(byte5, (uint32_t)(int32_t)1);
    re[8U * i1 + 3U] = decompress_ciphertext_coefficient(11U, coefficient4);
    int32_t
    coefficient5 =
      (byte7 & (int32_t)127)
      << (uint32_t)(int32_t)4
      | FStar_Int32_shift_arithmetic_right(byte6, (uint32_t)(int32_t)4);
    re[8U * i1 + 4U] = decompress_ciphertext_coefficient(11U, coefficient5);
    int32_t
    coefficient6 =
      ((byte9 & (int32_t)3) << (uint32_t)(int32_t)9 | byte8 << (uint32_t)(int32_t)1)
      | FStar_Int32_shift_arithmetic_right(byte7, (uint32_t)(int32_t)7);
    re[8U * i1 + 5U] = decompress_ciphertext_coefficient(11U, coefficient6);
    int32_t
    coefficient7 =
      (byte10 & (int32_t)31)
      << (uint32_t)(int32_t)6
      | FStar_Int32_shift_arithmetic_right(byte9, (uint32_t)(int32_t)2);
    re[8U * i1 + 6U] = decompress_ciphertext_coefficient(11U, coefficient7);
    int32_t
    coefficient8 =
      byte11
      << (uint32_t)(int32_t)3
      | FStar_Int32_shift_arithmetic_right(byte10, (uint32_t)(int32_t)5);
    re[8U * i1 + 7U] = decompress_ciphertext_coefficient(11U, coefficient8);
  }
  return re;
}

static int32_t *deserialize_then_decompress_4_(t_nonempty_Slice__uint8_t serialized)
{
  int32_t *re = impl__PolynomialRingElement__ZERO;
  uint32_t start = 0U;
  uint32_t finish = serialized.len;
  for (uint32_t i = start; i < finish; i++)
  {
    uint32_t i1 = i;
    int32_t coefficient1 = (int32_t)((uint32_t)serialized.buffer[i1] & 15U);
    re[2U * i1] = decompress_ciphertext_coefficient(4U, coefficient1);
    int32_t
    coefficient2 = (int32_t)((uint32_t)serialized.buffer[i1] >> (uint32_t)(int32_t)4 & 15U);
    re[2U * i1 + 1U] = decompress_ciphertext_coefficient(4U, coefficient2);
  }
  return re;
}

static int32_t *deserialize_then_decompress_5_(t_nonempty_Slice__uint8_t serialized)
{
  int32_t *re = impl__PolynomialRingElement__ZERO;
  uint32_t start = 0U;
  uint32_t finish = serialized.len / 5U;
  for (uint32_t i = start; i < finish; i++)
  {
    uint32_t i1 = i;
    int32_t byte1 = (int32_t)serialized.buffer[i1 * 5U + 0U];
    int32_t byte2 = (int32_t)serialized.buffer[i1 * 5U + 1U];
    int32_t byte3 = (int32_t)serialized.buffer[i1 * 5U + 2U];
    int32_t byte4 = (int32_t)serialized.buffer[i1 * 5U + 3U];
    int32_t byte5 = (int32_t)serialized.buffer[i1 * 5U + 4U];
    int32_t coefficient1 = byte1 & (int32_t)31;
    re[8U * i1] = decompress_ciphertext_coefficient(5U, coefficient1);
    int32_t
    coefficient2 =
      (byte2 & (int32_t)3)
      << (uint32_t)(int32_t)3
      | FStar_Int32_shift_arithmetic_right(byte1, (uint32_t)(int32_t)5);
    re[8U * i1 + 1U] = decompress_ciphertext_coefficient(5U, coefficient2);
    int32_t
    coefficient3 = FStar_Int32_shift_arithmetic_right(byte2, (uint32_t)(int32_t)2) & (int32_t)31;
    re[8U * i1 + 2U] = decompress_ciphertext_coefficient(5U, coefficient3);
    int32_t
    coefficient4 =
      (byte3 & (int32_t)15)
      << (uint32_t)(int32_t)1
      | FStar_Int32_shift_arithmetic_right(byte2, (uint32_t)(int32_t)7);
    re[8U * i1 + 3U] = decompress_ciphertext_coefficient(5U, coefficient4);
    int32_t
    coefficient5 =
      (byte4 & (int32_t)1)
      << (uint32_t)(int32_t)4
      | FStar_Int32_shift_arithmetic_right(byte3, (uint32_t)(int32_t)4);
    re[8U * i1 + 4U] = decompress_ciphertext_coefficient(5U, coefficient5);
    int32_t
    coefficient6 = FStar_Int32_shift_arithmetic_right(byte4, (uint32_t)(int32_t)1) & (int32_t)31;
    re[8U * i1 + 5U] = decompress_ciphertext_coefficient(5U, coefficient6);
    int32_t
    coefficient7 =
      (byte5 & (int32_t)7)
      << (uint32_t)(int32_t)2
      | FStar_Int32_shift_arithmetic_right(byte4, (uint32_t)(int32_t)6);
    re[8U * i1 + 6U] = decompress_ciphertext_coefficient(5U, coefficient7);
    int32_t coefficient8 = FStar_Int32_shift_arithmetic_right(byte5, (uint32_t)(int32_t)3);
    re[8U * i1 + 7U] = decompress_ciphertext_coefficient(5U, coefficient8);
  }
  return re;
}

static int32_t *deserialize_then_decompress_message(uint8_t *serialized)
{
  int32_t *re = impl__PolynomialRingElement__ZERO;
  uint32_t start = 0U;
  uint32_t finish = 32U;
  for (uint32_t i0 = start; i0 < finish; i0++)
  {
    uint32_t i1 = i0;
    uint8_t byte = serialized[i1];
    uint32_t start1 = 0U;
    uint32_t finish1 = 8U;
    for (uint32_t i = start1; i < finish1; i++)
    {
      uint32_t j = i;
      int32_t coefficient_compressed = (int32_t)((uint32_t)byte >> j & 1U);
      re[8U * i1 + j] = decompress_message_coefficient(coefficient_compressed);
    }
  }
  return re;
}

static int32_t
*deserialize_then_decompress_ring_element_u(
  uint32_t v_COMPRESSION_FACTOR,
  t_nonempty_Slice__uint8_t serialized
)
{
  switch (v_COMPRESSION_FACTOR)
  {
    case 10U:
      {
        return deserialize_then_decompress_10_(serialized);
      }
    case 11U:
      {
        return deserialize_then_decompress_11_(serialized);
      }
    default:
      {
        KRML_HOST_EPRINTF("KaRaMeL incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
}

static int32_t
*deserialize_then_decompress_ring_element_v(
  uint32_t v_COMPRESSION_FACTOR,
  t_nonempty_Slice__uint8_t serialized
)
{
  switch (v_COMPRESSION_FACTOR)
  {
    case 4U:
      {
        return deserialize_then_decompress_4_(serialized);
      }
    case 5U:
      {
        return deserialize_then_decompress_5_(serialized);
      }
    default:
      {
        KRML_HOST_EPRINTF("KaRaMeL incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
}

static int32_t *deserialize_to_uncompressed_ring_element(t_nonempty_Slice__uint8_t serialized)
{
  int32_t *re = impl__PolynomialRingElement__ZERO;
  uint32_t start = 0U;
  uint32_t finish = serialized.len / 3U;
  for (uint32_t i = start; i < finish; i++)
  {
    uint32_t i1 = i;
    int32_t byte1 = (int32_t)serialized.buffer[i1 * 3U + 0U];
    int32_t byte2 = (int32_t)serialized.buffer[i1 * 3U + 1U];
    int32_t byte3 = (int32_t)serialized.buffer[i1 * 3U + 2U];
    re[2U * i1] = (byte2 & (int32_t)15) << (uint32_t)(int32_t)8 | (byte1 & (int32_t)255);
    re[2U * i1 + 1U] =
      byte3
      << (uint32_t)(int32_t)4
      | (FStar_Int32_shift_arithmetic_right(byte2, (uint32_t)(int32_t)4) & (int32_t)15);
  }
  return re;
}

static uint8_t *serialize_uncompressed_ring_element(int32_t *re)
{
  uint8_t serialized[384U] = { 0U };
  uint32_t start = 0U;
  uint32_t finish = 256U / 2U;
  for (uint32_t i = start; i < finish; i++)
  {
    uint32_t i1 = i;
    uint16_t coefficient1 = to_unsigned_representative(re[i1 * 2U + 0U]);
    uint16_t coefficient2 = to_unsigned_representative(re[i1 * 2U + 1U]);
    uint32_t m = 8U;
    uint16_t pow2_bits0 = 256U;
    uint16_t pow2_bits_minus_one0 = 128U;
    uint16_t
    a2 = (((uint32_t)coefficient1 & 255U) & ((1U << m) - 1U)) - (uint32_t)pow2_bits_minus_one0;
    uint16_t mask = (uint32_t)a2 >> 15U;
    uint16_t a30 = (((uint32_t)coefficient1 & 255U) & ((1U << m) - 1U)) - (uint32_t)pow2_bits0;
    uint16_t b = (uint32_t)a30 + ((uint32_t)mask & (uint32_t)pow2_bits0);
    serialized[3U * i1] = (uint8_t)b;
    uint32_t m0 = 8U;
    uint16_t pow2_bits1 = 256U;
    uint16_t pow2_bits_minus_one1 = 128U;
    uint16_t
    a20 =
      (((uint32_t)coefficient1
      >> (uint32_t)(int32_t)8
      | ((uint32_t)coefficient2 & 15U) << (uint32_t)(int32_t)4)
      & ((1U << m0) - 1U))
      - (uint32_t)pow2_bits_minus_one1;
    uint16_t mask0 = (uint32_t)a20 >> 15U;
    uint16_t
    a31 =
      (((uint32_t)coefficient1
      >> (uint32_t)(int32_t)8
      | ((uint32_t)coefficient2 & 15U) << (uint32_t)(int32_t)4)
      & ((1U << m0) - 1U))
      - (uint32_t)pow2_bits1;
    uint16_t b0 = (uint32_t)a31 + ((uint32_t)mask0 & (uint32_t)pow2_bits1);
    serialized[3U * i1 + 1U] = (uint8_t)b0;
    uint32_t m1 = 8U;
    uint16_t pow2_bits = 256U;
    uint16_t pow2_bits_minus_one = 128U;
    uint16_t
    a21 =
      (((uint32_t)coefficient2 >> (uint32_t)(int32_t)4 & 255U) & ((1U << m1) - 1U))
      - (uint32_t)pow2_bits_minus_one;
    uint16_t mask1 = (uint32_t)a21 >> 15U;
    uint16_t
    a3 =
      (((uint32_t)coefficient2 >> (uint32_t)(int32_t)4 & 255U) & ((1U << m1) - 1U))
      - (uint32_t)pow2_bits;
    uint16_t b1 = (uint32_t)a3 + ((uint32_t)mask1 & (uint32_t)pow2_bits);
    serialized[3U * i1 + 2U] = (uint8_t)b1;
  }
  return serialized;
}

typedef uint8_t *t_KyberCiphertext;

typedef uint8_t *t_KyberPrivateKey;

typedef uint8_t *t_KyberPublicKey;

typedef uint8_t *t_PrivateKey;

static void increment(uint32_t x)
{
  KRML_MAYBE_UNUSED_VAR(x);
}

static int32_t *sample_from_binomial_distribution_2_(t_nonempty_Slice__uint8_t randomness)
{
  int32_t *sampled = impl__PolynomialRingElement__ZERO;
  uint32_t start = 0U;
  uint32_t finish = randomness.len / 4U;
  for (uint32_t i0 = start; i0 < finish; i0++)
  {
    uint32_t chunk_number = i0;
    uint32_t offset = chunk_number * 4U;
    uint32_t
    random_bits_as_u32 =
      (((uint32_t)randomness.buffer[offset + 0U]
      | (uint32_t)randomness.buffer[offset + 1U] << (uint32_t)(int32_t)8)
      | (uint32_t)randomness.buffer[offset + 2U] << (uint32_t)(int32_t)16)
      | (uint32_t)randomness.buffer[offset + 3U] << (uint32_t)(int32_t)24;
    uint32_t even_bits = random_bits_as_u32 & 1431655765U;
    uint32_t odd_bits = random_bits_as_u32 >> (uint32_t)(int32_t)1 & 1431655765U;
    uint32_t coin_toss_outcomes = even_bits + odd_bits;
    uint32_t start1 = 0U;
    uint32_t finish1 = impl__u32__BITS / 4U;
    for (uint32_t i = start1; i < finish1; i++)
    {
      uint32_t i2 = i;
      uint32_t outcome_set = i2 * 4U;
      int32_t outcome_1_ = (int32_t)(coin_toss_outcomes >> outcome_set & 3U);
      int32_t outcome_2_ = (int32_t)(coin_toss_outcomes >> (outcome_set + 2U) & 3U);
      uint32_t offset1 = outcome_set >> (uint32_t)(int32_t)2;
      sampled[8U * chunk_number + offset1] = outcome_1_ - outcome_2_;
    }
  }
  return sampled;
}

static int32_t *sample_from_binomial_distribution_3_(t_nonempty_Slice__uint8_t randomness)
{
  int32_t *sampled = impl__PolynomialRingElement__ZERO;
  uint32_t start = 0U;
  uint32_t finish = randomness.len / 3U;
  for (uint32_t i0 = start; i0 < finish; i0++)
  {
    uint32_t chunk_number = i0;
    uint32_t offset = chunk_number * 3U;
    uint32_t
    random_bits_as_u24 =
      ((uint32_t)randomness.buffer[offset + 0U]
      | (uint32_t)randomness.buffer[offset + 1U] << (uint32_t)(int32_t)8)
      | (uint32_t)randomness.buffer[offset + 2U] << (uint32_t)(int32_t)16;
    uint32_t first_bits = random_bits_as_u24 & 2396745U;
    uint32_t second_bits = random_bits_as_u24 >> (uint32_t)(int32_t)1 & 2396745U;
    uint32_t third_bits = random_bits_as_u24 >> (uint32_t)(int32_t)2 & 2396745U;
    uint32_t coin_toss_outcomes = first_bits + second_bits + third_bits;
    uint32_t start1 = (uint32_t)(int32_t)0;
    uint32_t finish1 = (uint32_t)((int32_t)24 / (int32_t)6);
    for (uint32_t i = start1; i < finish1; i++)
    {
      int32_t i2 = (int32_t)i;
      int32_t outcome_set = i2 * (int32_t)6;
      int32_t outcome_1_ = (int32_t)(coin_toss_outcomes >> (uint32_t)outcome_set & 7U);
      int32_t
      outcome_2_ = (int32_t)(coin_toss_outcomes >> (uint32_t)(outcome_set + (int32_t)3) & 7U);
      uint32_t offset1 = (uint32_t)(outcome_set / (int32_t)6);
      sampled[4U * chunk_number + offset1] = outcome_1_ - outcome_2_;
    }
  }
  return sampled;
}

static int32_t
*sample_from_binomial_distribution(uint32_t v_ETA, t_nonempty_Slice__uint8_t randomness)
{
  switch (v_ETA)
  {
    case 2U:
      {
        return sample_from_binomial_distribution_2_(randomness);
      }
    case 3U:
      {
        return sample_from_binomial_distribution_3_(randomness);
      }
    default:
      {
        KRML_HOST_EPRINTF("KaRaMeL incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
}

#define Option_Some 0
#define Option_None 1

typedef uint8_t t_Option__Libcrux_Kem_Kyber_Types_t_Error_tags;

typedef struct t_Option__Libcrux_Kem_Kyber_Types_t_Error_s
{
  t_Option__Libcrux_Kem_Kyber_Types_t_Error_tags tag;
  Libcrux_Kem_Kyber_Types_t_Error _0;
}
t_Option__Libcrux_Kem_Kyber_Types_t_Error;

static int32_t *sample_from_uniform_distribution(uint32_t v_SEED_SIZE, uint8_t *randomness)
{
  uint32_t sampled_coefficients = 0U;
  int32_t *out = impl__PolynomialRingElement__ZERO;
  bool done[1U] = { false };
  uint32_t start = 0U;
  uint32_t finish = v_SEED_SIZE / 3U;
  for (uint32_t i = start; i < finish; i++)
  {
    uint32_t i1 = i;
    uint32_t offset = i1 * 3U;
    if (!done[0U])
    {
      int32_t b1 = (int32_t)randomness[offset + 0U];
      int32_t b2 = (int32_t)randomness[offset + 1U];
      int32_t b3 = (int32_t)randomness[offset + 2U];
      int32_t d1 = (b2 & (int32_t)15) << (uint32_t)(int32_t)8 | b1;
      int32_t
      d2 = b3 << (uint32_t)(int32_t)4 | FStar_Int32_shift_arithmetic_right(b2, (uint32_t)(int32_t)4);
      if (d1 < v_FIELD_MODULUS && sampled_coefficients < v_COEFFICIENTS_IN_RING_ELEMENT)
      {
        out[sampled_coefficients] = d1;
        increment(sampled_coefficients);
      }
      if (d2 < v_FIELD_MODULUS && sampled_coefficients < v_COEFFICIENTS_IN_RING_ELEMENT)
      {
        out[sampled_coefficients] = d2;
        increment(sampled_coefficients);
      }
      if (sampled_coefficients == v_COEFFICIENTS_IN_RING_ELEMENT)
      {
        done[0U] = true;
      }
    }
  }
  if (done[0U])
  {
    return out;
  }
  return out;
}

static uint8_t *mk_ciphertext(uint8_t *x)
{
  return x;
}

static uint8_t *mk_privatekey(uint8_t *x)
{
  return x;
}

static uint8_t *mk_publickey(uint8_t *x)
{
  return x;
}

static uint8_t *mk_kyberprivatekey(uint8_t *x)
{
  return x;
}

static void update_domain_separator(uint8_t value)
{
  KRML_MAYBE_UNUSED_VAR(value);
}

typedef struct t_Range__uint32_t_s
{
  uint32_t f_start1;
  uint32_t f_end1;
}
t_Range__uint32_t;

static uint8_t
*serialize_secret_key(
  uint32_t v_SERIALIZED_KEY_LEN,
  t_nonempty_Slice__uint8_t private_key,
  t_nonempty_Slice__uint8_t public_key,
  t_nonempty_Slice__uint8_t implicit_rejection_value
)
{
  KRML_CHECK_SIZE(sizeof (uint8_t), v_SERIALIZED_KEY_LEN);
  uint8_t buf[v_SERIALIZED_KEY_LEN];
  memset(buf, 0U, v_SERIALIZED_KEY_LEN * sizeof (uint8_t));
  t_UpdatableArray uu____0 = { .f_value = buf, .f_pointer = 0U };
  t_Range__uint32_t
  uu____1 = { .f_start1 = uu____0.f_pointer, .f_end1 = uu____0.f_pointer + private_key.len };
  uint32_t f_start0 = uu____1.f_start1;
  uint32_t f_end0 = uu____1.f_end1;
  uint32_t len = f_end0 - f_start0;
  uint8_t *buffer0 = uu____0.f_value + f_start0;
  memcpy(private_key.buffer,
    ((t_nonempty_Slice__uint8_t){ .buffer = buffer0, .len = len }).buffer,
    private_key.len * sizeof (uint8_t));
  t_UpdatableArray
  uu____2 = { .f_value = uu____0.f_value, .f_pointer = uu____0.f_pointer + private_key.len };
  t_Range__uint32_t
  uu____3 = { .f_start1 = uu____2.f_pointer, .f_end1 = uu____2.f_pointer + public_key.len };
  uint32_t f_start1 = uu____3.f_start1;
  uint32_t f_end1 = uu____3.f_end1;
  uint32_t len0 = f_end1 - f_start1;
  uint8_t *buffer1 = uu____2.f_value + f_start1;
  memcpy(public_key.buffer,
    ((t_nonempty_Slice__uint8_t){ .buffer = buffer1, .len = len0 }).buffer,
    public_key.len * sizeof (uint8_t));
  t_UpdatableArray
  uu____4 = { .f_value = uu____2.f_value, .f_pointer = uu____2.f_pointer + public_key.len };
  t_nonempty_Slice__uint8_t uu____5 = { .buffer = v_H(public_key), .len = 32U };
  t_Range__uint32_t
  uu____6 = { .f_start1 = uu____4.f_pointer, .f_end1 = uu____4.f_pointer + uu____5.len };
  uint32_t f_start2 = uu____6.f_start1;
  uint32_t f_end2 = uu____6.f_end1;
  uint32_t len1 = f_end2 - f_start2;
  uint8_t *buffer2 = uu____4.f_value + f_start2;
  memcpy(uu____5.buffer,
    ((t_nonempty_Slice__uint8_t){ .buffer = buffer2, .len = len1 }).buffer,
    uu____5.len * sizeof (uint8_t));
  t_UpdatableArray
  uu____7 = { .f_value = uu____4.f_value, .f_pointer = uu____4.f_pointer + uu____5.len };
  t_Range__uint32_t
  uu____8 =
    { .f_start1 = uu____7.f_pointer, .f_end1 = uu____7.f_pointer + implicit_rejection_value.len };
  uint32_t f_start = uu____8.f_start1;
  uint32_t f_end = uu____8.f_end1;
  uint32_t len2 = f_end - f_start;
  uint8_t *buffer = uu____7.f_value + f_start;
  memcpy(implicit_rejection_value.buffer,
    ((t_nonempty_Slice__uint8_t){ .buffer = buffer, .len = len2 }).buffer,
    implicit_rejection_value.len * sizeof (uint8_t));
  return uu____7.f_value;
}

static int32_t
**sample_vector_cbd_then_ntt(
  uint32_t v_K,
  uint32_t v_ETA,
  uint32_t v_ETA_RANDOMNESS_SIZE,
  uint8_t *prf_input,
  uint8_t domain_separator
)
{
  KRML_CHECK_SIZE(sizeof (int32_t *), v_K);
  int32_t *re_as_ntt[v_K];
  for (uint32_t _i = 0U; _i < v_K; ++_i)
    re_as_ntt[_i] = impl__PolynomialRingElement__ZERO;
  uint32_t start = 0U;
  uint32_t finish = v_K;
  for (uint32_t i = start; i < finish; i++)
  {
    uint32_t i1 = i;
    prf_input[32U] = domain_separator;
    update_domain_separator(domain_separator);
    uint8_t
    *prf_output =
      v_PRF(v_ETA_RANDOMNESS_SIZE,
        ((t_nonempty_Slice__uint8_t){ .buffer = prf_input, .len = 33U }));
    int32_t
    *r =
      sample_from_binomial_distribution(v_ETA,
        ((t_nonempty_Slice__uint8_t){ .buffer = prf_output, .len = v_ETA_RANDOMNESS_SIZE }));
    re_as_ntt[i1] = ntt_binomially_sampled_ring_element(r);
  }
  return re_as_ntt;
}

typedef struct
____Libcrux_Kem_Kyber_Arithmetic_t_PolynomialRingElement___Core_Option_t_Option__Libcrux_Kem_Kyber_Types_t_Error_s
{
  int32_t ***fst;
  t_Option__Libcrux_Kem_Kyber_Types_t_Error snd;
}
____Libcrux_Kem_Kyber_Arithmetic_t_PolynomialRingElement___Core_Option_t_Option__Libcrux_Kem_Kyber_Types_t_Error;

static ____Libcrux_Kem_Kyber_Arithmetic_t_PolynomialRingElement___Core_Option_t_Option__Libcrux_Kem_Kyber_Types_t_Error
sample_matrix_A(uint32_t v_K, uint8_t *seed, bool transpose)
{
  KRML_CHECK_SIZE(sizeof (int32_t *), v_K);
  int32_t *buf[v_K];
  for (uint32_t _i = 0U; _i < v_K; ++_i)
    buf[_i] = impl__PolynomialRingElement__ZERO;
  KRML_CHECK_SIZE(sizeof (int32_t **), v_K);
  int32_t **v_A_transpose[v_K];
  for (uint32_t _i = 0U; _i < v_K; ++_i)
    v_A_transpose[_i] = buf;
  t_Option__Libcrux_Kem_Kyber_Types_t_Error sampling_error = { .tag = Option_None };
  uint32_t start = 0U;
  uint32_t finish = v_K;
  for (uint32_t i0 = start; i0 < finish; i0++)
  {
    uint32_t i1 = i0;
    KRML_CHECK_SIZE(sizeof (uint8_t *), v_K);
    uint8_t *seeds[v_K];
    for (uint32_t _i = 0U; _i < v_K; ++_i)
      seeds[_i] = seed;
    uint32_t start10 = 0U;
    uint32_t finish10 = v_K;
    for (uint32_t i = start10; i < finish10; i++)
    {
      uint32_t j = i;
      uint32_t m = 8U;
      uint32_t pow2_bits0 = 256U;
      uint32_t pow2_bits_minus_one0 = 128U;
      uint32_t a2 = (i1 & ((1U << m) - 1U)) - pow2_bits_minus_one0;
      uint32_t mask = a2 >> 31U;
      uint32_t a30 = (i1 & ((1U << m) - 1U)) - pow2_bits0;
      uint32_t b = a30 + (mask & pow2_bits0);
      seeds[j][32U] = (uint8_t)b;
      uint32_t m0 = 8U;
      uint32_t pow2_bits = 256U;
      uint32_t pow2_bits_minus_one = 128U;
      uint32_t a20 = (j & ((1U << m0) - 1U)) - pow2_bits_minus_one;
      uint32_t mask0 = a20 >> 31U;
      uint32_t a3 = (j & ((1U << m0) - 1U)) - pow2_bits;
      uint32_t b0 = a3 + (mask0 & pow2_bits);
      seeds[j][33U] = (uint8_t)b0;
    }
    uint8_t **xof_bytes = v_XOFx4(840U, v_K, seeds);
    uint32_t start1 = 0U;
    uint32_t finish1 = v_K;
    for (uint32_t i = start1; i < finish1; i++)
    {
      uint32_t j = i;
      int32_t *sampled = sample_from_uniform_distribution(840U, xof_bytes[j]);
      if (transpose)
      {
        v_A_transpose[j][i1] = sampled;
      }
      else
      {
        v_A_transpose[i1][j] = sampled;
      }
    }
  }
  return
    (
      (____Libcrux_Kem_Kyber_Arithmetic_t_PolynomialRingElement___Core_Option_t_Option__Libcrux_Kem_Kyber_Types_t_Error){
        .fst = v_A_transpose,
        .snd = sampling_error
      }
    );
}

static uint8_t
*compress_then_encode_u(
  uint32_t v_K,
  uint32_t v_OUT_LEN,
  uint32_t v_COMPRESSION_FACTOR,
  uint32_t v_BLOCK_LEN,
  int32_t **input
)
{
  KRML_CHECK_SIZE(sizeof (uint8_t), v_OUT_LEN);
  uint8_t out[v_OUT_LEN];
  memset(out, 0U, v_OUT_LEN * sizeof (uint8_t));
  uint32_t start = 0U;
  uint32_t finish = v_K;
  for (uint32_t i = start; i < finish; i++)
  {
    uint32_t i1 = i;
    int32_t *re = input[i1];
    uint32_t f_start = i1 * (v_OUT_LEN / v_K);
    uint32_t f_end = (i1 + 1U) * (v_OUT_LEN / v_K);
    uint32_t len = f_end - f_start;
    uint8_t *buffer = out + f_start;
    t_nonempty_Slice__uint8_t uu____0 = { .buffer = buffer, .len = len };
    t_nonempty_Slice__uint8_t
    uu____1 =
      {
        .buffer = compress_then_serialize_ring_element_u(v_COMPRESSION_FACTOR, v_BLOCK_LEN, re),
        .len = v_BLOCK_LEN
      };
    memcpy(uu____1.buffer, uu____0.buffer, uu____1.len * sizeof (uint8_t));
  }
  return out;
}

static uint8_t *serialize_key(uint32_t v_K, uint32_t v_OUT_LEN, int32_t **key)
{
  KRML_CHECK_SIZE(sizeof (uint8_t), v_OUT_LEN);
  uint8_t out[v_OUT_LEN];
  memset(out, 0U, v_OUT_LEN * sizeof (uint8_t));
  uint32_t start = 0U;
  uint32_t finish = v_K;
  for (uint32_t i = start; i < finish; i++)
  {
    uint32_t i1 = i;
    int32_t *re = key[i1];
    uint32_t f_start = i1 * v_BYTES_PER_RING_ELEMENT;
    uint32_t f_end = (i1 + 1U) * v_BYTES_PER_RING_ELEMENT;
    uint32_t len = f_end - f_start;
    uint8_t *buffer = out + f_start;
    t_nonempty_Slice__uint8_t uu____0 = { .buffer = buffer, .len = len };
    t_nonempty_Slice__uint8_t
    uu____1 = { .buffer = serialize_uncompressed_ring_element(re), .len = 384U };
    memcpy(uu____1.buffer, uu____0.buffer, uu____1.len * sizeof (uint8_t));
  }
  return out;
}

static uint8_t
*decrypt(
  uint32_t v_K,
  uint32_t v_CIPHERTEXT_SIZE,
  uint32_t v_VECTOR_U_ENCODED_SIZE,
  uint32_t v_U_COMPRESSION_FACTOR,
  uint32_t v_V_COMPRESSION_FACTOR,
  t_nonempty_Slice__uint8_t secret_key,
  uint8_t *ciphertext
)
{
  KRML_CHECK_SIZE(sizeof (int32_t *), v_K);
  int32_t *u_as_ntt[v_K];
  for (uint32_t _i = 0U; _i < v_K; ++_i)
    u_as_ntt[_i] = impl__PolynomialRingElement__ZERO;
  KRML_CHECK_SIZE(sizeof (int32_t *), v_K);
  int32_t *secret_as_ntt[v_K];
  for (uint32_t _i = 0U; _i < v_K; ++_i)
    secret_as_ntt[_i] = impl__PolynomialRingElement__ZERO;
  uint32_t start0 = 0U;
  uint32_t
  finish0 =
    v_VECTOR_U_ENCODED_SIZE
    / (v_COEFFICIENTS_IN_RING_ELEMENT * v_U_COMPRESSION_FACTOR / 8U);
  for (uint32_t i = start0; i < finish0; i++)
  {
    uint32_t i1 = i;
    uint32_t len = v_COEFFICIENTS_IN_RING_ELEMENT * v_U_COMPRESSION_FACTOR / 8U;
    uint8_t
    *u_buf = ciphertext + i1 * (v_COEFFICIENTS_IN_RING_ELEMENT * v_U_COMPRESSION_FACTOR / 8U);
    t_nonempty_Slice__uint8_t u_bytes = { .buffer = u_buf, .len = len };
    int32_t *u = deserialize_then_decompress_ring_element_u(v_U_COMPRESSION_FACTOR, u_bytes);
    u_as_ntt[i1] = ntt_vector_u(u);
  }
  uint32_t len0 = v_CIPHERTEXT_SIZE - v_VECTOR_U_ENCODED_SIZE;
  uint8_t *subbuf0 = ciphertext + v_VECTOR_U_ENCODED_SIZE;
  int32_t
  *v =
    deserialize_then_decompress_ring_element_v(v_V_COMPRESSION_FACTOR,
      ((t_nonempty_Slice__uint8_t){ .buffer = subbuf0, .len = len0 }));
  uint32_t start = 0U;
  uint32_t finish = secret_key.len / v_BYTES_PER_RING_ELEMENT;
  for (uint32_t i = start; i < finish; i++)
  {
    uint32_t i1 = i;
    uint32_t
    len = i1 * v_BYTES_PER_RING_ELEMENT + v_BYTES_PER_RING_ELEMENT - i1 * v_BYTES_PER_RING_ELEMENT;
    uint8_t *subbuf = secret_key.buffer + i1 * v_BYTES_PER_RING_ELEMENT;
    t_nonempty_Slice__uint8_t secret_bytes = { .buffer = subbuf, .len = len };
    secret_as_ntt[i1] = deserialize_to_uncompressed_ring_element(secret_bytes);
  }
  int32_t *message = compute_message(v_K, v, secret_as_ntt, u_as_ntt);
  return compress_then_serialize_message(message);
}

typedef struct
__Libcrux_Kem_Kyber_Types_t_KyberCiphertext_Core_Option_t_Option__Libcrux_Kem_Kyber_Types_t_Error_s
{
  uint8_t *fst;
  t_Option__Libcrux_Kem_Kyber_Types_t_Error snd;
}
__Libcrux_Kem_Kyber_Types_t_KyberCiphertext_Core_Option_t_Option__Libcrux_Kem_Kyber_Types_t_Error;

static __Libcrux_Kem_Kyber_Types_t_KyberCiphertext_Core_Option_t_Option__Libcrux_Kem_Kyber_Types_t_Error
encrypt(
  uint32_t v_K,
  uint32_t v_CIPHERTEXT_SIZE,
  uint32_t v_T_AS_NTT_ENCODED_SIZE,
  uint32_t v_C1_LEN,
  uint32_t v_C2_LEN,
  uint32_t v_U_COMPRESSION_FACTOR,
  uint32_t v_V_COMPRESSION_FACTOR,
  uint32_t v_BLOCK_LEN,
  uint32_t v_ETA1,
  uint32_t v_ETA1_RANDOMNESS_SIZE,
  uint32_t v_ETA2,
  uint32_t v_ETA2_RANDOMNESS_SIZE,
  t_nonempty_Slice__uint8_t public_key,
  uint8_t *message,
  t_nonempty_Slice__uint8_t randomness
)
{
  KRML_CHECK_SIZE(sizeof (int32_t *), v_K);
  int32_t *tt_as_ntt[v_K];
  for (uint32_t _i = 0U; _i < v_K; ++_i)
    tt_as_ntt[_i] = impl__PolynomialRingElement__ZERO;
  uint32_t start0 = 0U;
  uint32_t finish0 = v_T_AS_NTT_ENCODED_SIZE / v_BYTES_PER_RING_ELEMENT;
  for (uint32_t i = start0; i < finish0; i++)
  {
    uint32_t i1 = i;
    t_nonempty_Slice__uint8_t pk = public_key;
    uint32_t
    len = i1 * v_BYTES_PER_RING_ELEMENT + v_BYTES_PER_RING_ELEMENT - i1 * v_BYTES_PER_RING_ELEMENT;
    uint8_t *subbuf = pk.buffer + i1 * v_BYTES_PER_RING_ELEMENT;
    t_nonempty_Slice__uint8_t tt_as_ntt_bytes = { .buffer = subbuf, .len = len };
    tt_as_ntt[i1] = deserialize_to_uncompressed_ring_element(tt_as_ntt_bytes);
  }
  uint32_t len = public_key.len - v_T_AS_NTT_ENCODED_SIZE;
  uint8_t *subbuf = public_key.buffer + v_T_AS_NTT_ENCODED_SIZE;
  t_nonempty_Slice__uint8_t seed = { .buffer = subbuf, .len = len };
  uint8_t out0[34U] = { 0U };
  t_Range__uint32_t uu____0 = { .f_start1 = 0U, .f_end1 = seed.len };
  uint32_t f_start0 = uu____0.f_start1;
  uint32_t f_end0 = uu____0.f_end1;
  uint32_t len0 = f_end0 - f_start0;
  uint8_t *buffer0 = out0 + f_start0;
  memcpy(seed.buffer,
    ((t_nonempty_Slice__uint8_t){ .buffer = buffer0, .len = len0 }).buffer,
    seed.len * sizeof (uint8_t));
  ____Libcrux_Kem_Kyber_Arithmetic_t_PolynomialRingElement___Core_Option_t_Option__Libcrux_Kem_Kyber_Types_t_Error
  scrut = sample_matrix_A(v_K, out0, false);
  int32_t ***v_A_transpose = scrut.fst;
  t_Option__Libcrux_Kem_Kyber_Types_t_Error sampling_A_error = scrut.snd;
  uint8_t out1[33U] = { 0U };
  t_Range__uint32_t uu____1 = { .f_start1 = 0U, .f_end1 = randomness.len };
  uint32_t f_start1 = uu____1.f_start1;
  uint32_t f_end1 = uu____1.f_end1;
  uint32_t len1 = f_end1 - f_start1;
  uint8_t *buffer1 = out1 + f_start1;
  memcpy(randomness.buffer,
    ((t_nonempty_Slice__uint8_t){ .buffer = buffer1, .len = len1 }).buffer,
    randomness.len * sizeof (uint8_t));
  uint8_t *prf_input = out1;
  uint8_t domain_separator = 0U;
  int32_t
  **r_as_ntt =
    sample_vector_cbd_then_ntt(v_K,
      v_ETA1,
      v_ETA1_RANDOMNESS_SIZE,
      prf_input,
      domain_separator);
  KRML_CHECK_SIZE(sizeof (int32_t *), v_K);
  int32_t *error_1_[v_K];
  for (uint32_t _i = 0U; _i < v_K; ++_i)
    error_1_[_i] = impl__PolynomialRingElement__ZERO;
  uint32_t start = 0U;
  uint32_t finish = v_K;
  for (uint32_t i = start; i < finish; i++)
  {
    uint32_t i1 = i;
    prf_input[32U] = domain_separator;
    update_domain_separator(domain_separator);
    uint8_t
    *prf_output =
      v_PRF(v_ETA2_RANDOMNESS_SIZE,
        ((t_nonempty_Slice__uint8_t){ .buffer = prf_input, .len = 33U }));
    error_1_[i1] =
      sample_from_binomial_distribution(v_ETA2,
        ((t_nonempty_Slice__uint8_t){ .buffer = prf_output, .len = v_ETA2_RANDOMNESS_SIZE }));
  }
  prf_input[32U] = domain_separator;
  uint8_t
  *prf_output =
    v_PRF(v_ETA2_RANDOMNESS_SIZE,
      ((t_nonempty_Slice__uint8_t){ .buffer = prf_input, .len = 33U }));
  int32_t
  *error_2_ =
    sample_from_binomial_distribution(v_ETA2,
      ((t_nonempty_Slice__uint8_t){ .buffer = prf_output, .len = v_ETA2_RANDOMNESS_SIZE }));
  int32_t **u = compute_vector_u(v_K, v_A_transpose, r_as_ntt, error_1_);
  int32_t *message_as_ring_element = deserialize_then_decompress_message(message);
  int32_t
  *v = compute_ring_element_v(v_K, tt_as_ntt, r_as_ntt, error_2_, message_as_ring_element);
  uint8_t *c1 = compress_then_encode_u(v_K, v_C1_LEN, v_U_COMPRESSION_FACTOR, v_BLOCK_LEN, u);
  uint8_t *c2 = compress_then_serialize_ring_element_v(v_V_COMPRESSION_FACTOR, v_C2_LEN, v);
  KRML_CHECK_SIZE(sizeof (uint8_t), v_CIPHERTEXT_SIZE);
  uint8_t out[v_CIPHERTEXT_SIZE];
  memset(out, 0U, v_CIPHERTEXT_SIZE * sizeof (uint8_t));
  uint32_t f_start2 = ((t_Range__uint32_t){ .f_start1 = 0U, .f_end1 = v_C1_LEN }).f_start1;
  memcpy(c1, out + f_start2, v_C1_LEN * sizeof (uint8_t));
  uint8_t *ciphertext = out;
  t_nonempty_Slice__uint8_t uu____2 = { .buffer = c2, .len = v_C2_LEN };
  uint32_t f_start = v_C1_LEN;
  uint32_t f_end = v_CIPHERTEXT_SIZE;
  uint32_t len2 = f_end - f_start;
  uint8_t *buffer = ciphertext + f_start;
  memcpy(uu____2.buffer,
    ((t_nonempty_Slice__uint8_t){ .buffer = buffer, .len = len2 }).buffer,
    uu____2.len * sizeof (uint8_t));
  return
    (
      (__Libcrux_Kem_Kyber_Types_t_KyberCiphertext_Core_Option_t_Option__Libcrux_Kem_Kyber_Types_t_Error){
        .fst = mk_ciphertext(ciphertext),
        .snd = sampling_A_error
      }
    );
}

static uint32_t v_KEY_GENERATION_SEED_SIZE = 64U;

static uint8_t
*decapsulate(
  uint32_t v_K,
  uint32_t v_SECRET_KEY_SIZE,
  uint32_t v_CPA_SECRET_KEY_SIZE,
  uint32_t v_PUBLIC_KEY_SIZE,
  uint32_t v_CIPHERTEXT_SIZE,
  uint32_t v_T_AS_NTT_ENCODED_SIZE,
  uint32_t v_C1_SIZE,
  uint32_t v_C2_SIZE,
  uint32_t v_VECTOR_U_COMPRESSION_FACTOR,
  uint32_t v_VECTOR_V_COMPRESSION_FACTOR,
  uint32_t v_C1_BLOCK_SIZE,
  uint32_t v_ETA1,
  uint32_t v_ETA1_RANDOMNESS_SIZE,
  uint32_t v_ETA2,
  uint32_t v_ETA2_RANDOMNESS_SIZE,
  uint32_t v_IMPLICIT_REJECTION_HASH_INPUT_SIZE,
  uint8_t *secret_key,
  uint8_t *ciphertext
)
{
  uint8_t *b10 = secret_key;
  uint32_t l20 = v_SECRET_KEY_SIZE - v_CPA_SECRET_KEY_SIZE;
  uint8_t *b20 = secret_key + v_CPA_SECRET_KEY_SIZE;
  t_nonempty_Slice__uint8_t s10 = { .buffer = b10, .len = v_CPA_SECRET_KEY_SIZE };
  t_nonempty_Slice__uint8_t s20 = { .buffer = b20, .len = l20 };
  t_nonempty_Slice__uint8_t ind_cpa_secret_key = s10;
  t_nonempty_Slice__uint8_t secret_key1 = s20;
  uint8_t *b11 = secret_key1.buffer;
  uint32_t l21 = secret_key1.len - v_PUBLIC_KEY_SIZE;
  uint8_t *b21 = secret_key1.buffer + v_PUBLIC_KEY_SIZE;
  t_nonempty_Slice__uint8_t s11 = { .buffer = b11, .len = v_PUBLIC_KEY_SIZE };
  t_nonempty_Slice__uint8_t s21 = { .buffer = b21, .len = l21 };
  t_nonempty_Slice__uint8_t ind_cpa_public_key = s11;
  t_nonempty_Slice__uint8_t secret_key2 = s21;
  uint8_t *b12 = secret_key2.buffer;
  uint32_t l22 = secret_key2.len - v_H_DIGEST_SIZE;
  uint8_t *b22 = secret_key2.buffer + v_H_DIGEST_SIZE;
  t_nonempty_Slice__uint8_t s12 = { .buffer = b12, .len = v_H_DIGEST_SIZE };
  t_nonempty_Slice__uint8_t s22 = { .buffer = b22, .len = l22 };
  t_nonempty_Slice__uint8_t ind_cpa_public_key_hash = s12;
  t_nonempty_Slice__uint8_t implicit_rejection_value = s22;
  uint8_t
  *decrypted =
    decrypt(v_K,
      v_CIPHERTEXT_SIZE,
      v_C1_SIZE,
      v_VECTOR_U_COMPRESSION_FACTOR,
      v_VECTOR_V_COMPRESSION_FACTOR,
      ind_cpa_secret_key,
      ciphertext);
  uint8_t out0[64U] = { 0U };
  uint32_t f_start0 = ((t_Range__uint32_t){ .f_start1 = 0U, .f_end1 = 32U }).f_start1;
  memcpy(decrypted, out0 + f_start0, 32U * sizeof (uint8_t));
  uint8_t *to_hash = out0;
  uint32_t f_start1 = v_SHARED_SECRET_SIZE;
  uint32_t f_end0 = v_SHARED_SECRET_SIZE + v_H_DIGEST_SIZE;
  uint32_t len = f_end0 - f_start1;
  uint8_t *buffer0 = to_hash + f_start1;
  memcpy(ind_cpa_public_key_hash.buffer,
    ((t_nonempty_Slice__uint8_t){ .buffer = buffer0, .len = len }).buffer,
    ind_cpa_public_key_hash.len * sizeof (uint8_t));
  uint8_t *hashed = v_G(((t_nonempty_Slice__uint8_t){ .buffer = to_hash, .len = 64U }));
  uint8_t *b1 = hashed;
  uint32_t l2 = 64U - v_SHARED_SECRET_SIZE;
  uint8_t *b2 = hashed + v_SHARED_SECRET_SIZE;
  t_nonempty_Slice__uint8_t s1 = { .buffer = b1, .len = v_SHARED_SECRET_SIZE };
  t_nonempty_Slice__uint8_t s2 = { .buffer = b2, .len = l2 };
  t_nonempty_Slice__uint8_t shared_secret = s1;
  t_nonempty_Slice__uint8_t pseudorandomness = s2;
  KRML_CHECK_SIZE(sizeof (uint8_t), v_IMPLICIT_REJECTION_HASH_INPUT_SIZE);
  uint8_t out[v_IMPLICIT_REJECTION_HASH_INPUT_SIZE];
  memset(out, 0U, v_IMPLICIT_REJECTION_HASH_INPUT_SIZE * sizeof (uint8_t));
  t_Range__uint32_t uu____0 = { .f_start1 = 0U, .f_end1 = implicit_rejection_value.len };
  uint32_t f_start2 = uu____0.f_start1;
  uint32_t f_end = uu____0.f_end1;
  uint32_t len0 = f_end - f_start2;
  uint8_t *buffer = out + f_start2;
  memcpy(implicit_rejection_value.buffer,
    ((t_nonempty_Slice__uint8_t){ .buffer = buffer, .len = len0 }).buffer,
    implicit_rejection_value.len * sizeof (uint8_t));
  uint8_t *to_hash1 = out;
  uint32_t f_start = v_SHARED_SECRET_SIZE;
  memcpy(ciphertext, to_hash1 + f_start, v_CIPHERTEXT_SIZE * sizeof (uint8_t));
  uint8_t
  *implicit_rejection_shared_secret =
    v_PRF(32U,
      (
        (t_nonempty_Slice__uint8_t){
          .buffer = to_hash1,
          .len = v_IMPLICIT_REJECTION_HASH_INPUT_SIZE
        }
      ));
  uint8_t
  *expected_ciphertext =
    encrypt(v_K,
      v_CIPHERTEXT_SIZE,
      v_T_AS_NTT_ENCODED_SIZE,
      v_C1_SIZE,
      v_C2_SIZE,
      v_VECTOR_U_COMPRESSION_FACTOR,
      v_VECTOR_V_COMPRESSION_FACTOR,
      v_C1_BLOCK_SIZE,
      v_ETA1,
      v_ETA1_RANDOMNESS_SIZE,
      v_ETA2,
      v_ETA2_RANDOMNESS_SIZE,
      ind_cpa_public_key,
      decrypted,
      pseudorandomness).fst;
  uint8_t r[1U] = { 0U };
  uint32_t start = 0U;
  uint32_t finish = v_CIPHERTEXT_SIZE;
  for (uint32_t i = start; i < finish; i++)
  {
    uint32_t i1 = i;
    r[0U] = (uint32_t)r[0U] | ((uint32_t)ciphertext[i1] ^ (uint32_t)expected_ciphertext[i1]);
  }
  uint8_t selector = is_non_zero(r[0U]);
  return
    select_shared_secret_in_constant_time(shared_secret,
      ((t_nonempty_Slice__uint8_t){ .buffer = implicit_rejection_shared_secret, .len = 32U }),
      selector);
}

typedef struct t_Result___uint8_t__Core_Array_t_TryFromSliceError_s
{
  Core_Result_t_Result___uint8_t__Core_Array_t_TryFromSliceError_tags tag;
  union {
    uint8_t *case_Result_Ok;
    t_TryFromSliceError case_Result_Err;
  }
  ;
}
t_Result___uint8_t__Core_Array_t_TryFromSliceError;

static uint8_t
*impl__unwrap__Core_Array_t_TryFromSliceError__uint8_t_(
  t_Result___uint8_t__Core_Array_t_TryFromSliceError x
)
{
  if (x.tag == Core_Result_Result_Ok)
  {
    return x.case_Result_Ok;
  }
  KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
    __FILE__,
    __LINE__,
    "unreachable (pattern matches are exhaustive in F*)");
  KRML_HOST_EXIT(255U);
}

static Core_Result_t_Result__Libcrux_Kem_Kyber_Types_t_KyberCiphertext____uint8_t__Libcrux_Kem_Kyber_Types_t_Error
encapsulate(
  uint32_t v_K,
  uint32_t v_CIPHERTEXT_SIZE,
  uint32_t v_PUBLIC_KEY_SIZE,
  uint32_t v_T_AS_NTT_ENCODED_SIZE,
  uint32_t v_C1_SIZE,
  uint32_t v_C2_SIZE,
  uint32_t v_VECTOR_U_COMPRESSION_FACTOR,
  uint32_t v_VECTOR_V_COMPRESSION_FACTOR,
  uint32_t v_VECTOR_U_BLOCK_LEN,
  uint32_t v_ETA1,
  uint32_t v_ETA1_RANDOMNESS_SIZE,
  uint32_t v_ETA2,
  uint32_t v_ETA2_RANDOMNESS_SIZE,
  uint8_t *public_key,
  uint8_t *randomness
)
{
  uint8_t out[64U] = { 0U };
  uint32_t f_start0 = ((t_Range__uint32_t){ .f_start1 = 0U, .f_end1 = 32U }).f_start1;
  memcpy(randomness, out + f_start0, 32U * sizeof (uint8_t));
  uint8_t *to_hash = out;
  uint32_t f_start = v_H_DIGEST_SIZE;
  uint32_t f_end = 2U * v_H_DIGEST_SIZE;
  uint32_t len = f_end - f_start;
  uint8_t *buffer = to_hash + f_start;
  t_nonempty_Slice__uint8_t uu____0 = { .buffer = buffer, .len = len };
  t_nonempty_Slice__uint8_t
  uu____1 =
    {
      .buffer = v_H(((t_nonempty_Slice__uint8_t){ .buffer = public_key, .len = v_PUBLIC_KEY_SIZE })),
      .len = 32U
    };
  memcpy(uu____1.buffer, uu____0.buffer, uu____1.len * sizeof (uint8_t));
  uint8_t *hashed = v_G(((t_nonempty_Slice__uint8_t){ .buffer = to_hash, .len = 64U }));
  uint8_t *b1 = hashed;
  uint32_t l2 = 64U - v_SHARED_SECRET_SIZE;
  uint8_t *b2 = hashed + v_SHARED_SECRET_SIZE;
  t_nonempty_Slice__uint8_t s1 = { .buffer = b1, .len = v_SHARED_SECRET_SIZE };
  t_nonempty_Slice__uint8_t s2 = { .buffer = b2, .len = l2 };
  t_nonempty_Slice__uint8_t shared_secret = s1;
  t_nonempty_Slice__uint8_t pseudorandomness = s2;
  __Libcrux_Kem_Kyber_Types_t_KyberCiphertext_Core_Option_t_Option__Libcrux_Kem_Kyber_Types_t_Error
  scrut =
    encrypt(v_K,
      v_CIPHERTEXT_SIZE,
      v_T_AS_NTT_ENCODED_SIZE,
      v_C1_SIZE,
      v_C2_SIZE,
      v_VECTOR_U_COMPRESSION_FACTOR,
      v_VECTOR_V_COMPRESSION_FACTOR,
      v_VECTOR_U_BLOCK_LEN,
      v_ETA1,
      v_ETA1_RANDOMNESS_SIZE,
      v_ETA2,
      v_ETA2_RANDOMNESS_SIZE,
      ((t_nonempty_Slice__uint8_t){ .buffer = public_key, .len = v_PUBLIC_KEY_SIZE }),
      randomness,
      pseudorandomness);
  uint8_t *ciphertext = scrut.fst;
  t_Option__Libcrux_Kem_Kyber_Types_t_Error sampling_a_error = scrut.snd;
  if (sampling_a_error.tag == Option_Some)
  {
    Libcrux_Kem_Kyber_Types_t_Error e = sampling_a_error._0;
    return
      (
        (Core_Result_t_Result__Libcrux_Kem_Kyber_Types_t_KyberCiphertext____uint8_t__Libcrux_Kem_Kyber_Types_t_Error){
          .tag = Core_Result_Result_Err,
          { .case_Result_Err = e }
        }
      );
  }
  if (sampling_a_error.tag == Option_None)
  {
    t_Result___uint8_t__Core_Array_t_TryFromSliceError ite;
    if (shared_secret.len == 32U)
    {
      ite =
        (
          (t_Result___uint8_t__Core_Array_t_TryFromSliceError){
            .tag = Core_Result_Result_Ok,
            { .case_Result_Ok = shared_secret.buffer }
          }
        );
    }
    else
    {
      ite =
        (
          (t_Result___uint8_t__Core_Array_t_TryFromSliceError){
            .tag = Core_Result_Result_Err,
            { .case_Result_Err = TryFromSliceError }
          }
        );
    }
    return
      (
        (Core_Result_t_Result__Libcrux_Kem_Kyber_Types_t_KyberCiphertext____uint8_t__Libcrux_Kem_Kyber_Types_t_Error){
          .tag = Core_Result_Result_Ok,
          {
            .case_Result_Ok = {
              .fst = ciphertext,
              .snd = impl__unwrap__Core_Array_t_TryFromSliceError__uint8_t_(ite)
            }
          }
        }
      );
  }
  KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n",
    __FILE__,
    __LINE__,
    "unreachable (pattern matches are exhaustive in F*)");
  KRML_HOST_EXIT(255U);
}

typedef struct
__Libcrux_Kem_Kyber_Types_t_PrivateKey_Libcrux_Kem_Kyber_Types_t_KyberPublicKey_s
{
  uint8_t *fst;
  uint8_t *snd;
}
__Libcrux_Kem_Kyber_Types_t_PrivateKey_Libcrux_Kem_Kyber_Types_t_KyberPublicKey;

typedef struct
__Libcrux_Kem_Kyber_Types_t_PrivateKey___Libcrux_Kem_Kyber_Types_t_KyberPublicKey_Core_Option_t_Option__Libcrux_Kem_Kyber_Types_t_Error_s
{
  __Libcrux_Kem_Kyber_Types_t_PrivateKey_Libcrux_Kem_Kyber_Types_t_KyberPublicKey fst;
  t_Option__Libcrux_Kem_Kyber_Types_t_Error snd;
}
__Libcrux_Kem_Kyber_Types_t_PrivateKey___Libcrux_Kem_Kyber_Types_t_KyberPublicKey_Core_Option_t_Option__Libcrux_Kem_Kyber_Types_t_Error;

static Core_Result_t_Result__Libcrux_Kem_Kyber_Types_t_KyberKeyPair_Libcrux_Kem_Kyber_Types_t_Error
generate_keypair(
  uint32_t v_K,
  uint32_t v_CPA_PRIVATE_KEY_SIZE,
  uint32_t v_PRIVATE_KEY_SIZE,
  uint32_t v_PUBLIC_KEY_SIZE,
  uint32_t v_BYTES_PER_RING_ELEMENT,
  uint32_t v_ETA1,
  uint32_t v_ETA1_RANDOMNESS_SIZE,
  uint8_t *randomness
)
{
  t_nonempty_Slice__uint8_t
  ind_cpa_keypair_randomness =
    { .buffer = randomness, .len = v_CPA_PKE_KEY_GENERATION_SEED_SIZE };
  uint32_t l = v_KEY_GENERATION_SEED_SIZE - v_CPA_PKE_KEY_GENERATION_SEED_SIZE;
  uint8_t *b = randomness + v_CPA_PKE_KEY_GENERATION_SEED_SIZE;
  t_nonempty_Slice__uint8_t implicit_rejection_value = { .buffer = b, .len = l };
  uint8_t *hashed = v_G(ind_cpa_keypair_randomness);
  uint8_t *b1 = hashed;
  uint32_t l2 = 32U;
  uint8_t *b2 = hashed + 32U;
  t_nonempty_Slice__uint8_t s1 = { .buffer = b1, .len = 32U };
  t_nonempty_Slice__uint8_t s2 = { .buffer = b2, .len = l2 };
  t_nonempty_Slice__uint8_t seed_for_A = s1;
  t_nonempty_Slice__uint8_t seed_for_secret_and_error = s2;
  uint8_t out0[34U] = { 0U };
  t_Range__uint32_t uu____0 = { .f_start1 = 0U, .f_end1 = seed_for_A.len };
  uint32_t f_start0 = uu____0.f_start1;
  uint32_t f_end0 = uu____0.f_end1;
  uint32_t len = f_end0 - f_start0;
  uint8_t *buffer0 = out0 + f_start0;
  memcpy(seed_for_A.buffer,
    ((t_nonempty_Slice__uint8_t){ .buffer = buffer0, .len = len }).buffer,
    seed_for_A.len * sizeof (uint8_t));
  ____Libcrux_Kem_Kyber_Arithmetic_t_PolynomialRingElement___Core_Option_t_Option__Libcrux_Kem_Kyber_Types_t_Error
  scrut = sample_matrix_A(v_K, out0, true);
  int32_t ***v_A_transpose = scrut.fst;
  t_Option__Libcrux_Kem_Kyber_Types_t_Error sampling_A_error = scrut.snd;
  uint8_t out[33U] = { 0U };
  t_Range__uint32_t uu____1 = { .f_start1 = 0U, .f_end1 = seed_for_secret_and_error.len };
  uint32_t f_start1 = uu____1.f_start1;
  uint32_t f_end1 = uu____1.f_end1;
  uint32_t len0 = f_end1 - f_start1;
  uint8_t *buffer1 = out + f_start1;
  memcpy(seed_for_secret_and_error.buffer,
    ((t_nonempty_Slice__uint8_t){ .buffer = buffer1, .len = len0 }).buffer,
    seed_for_secret_and_error.len * sizeof (uint8_t));
  uint8_t *prf_input = out;
  uint8_t domain_separator = 0U;
  int32_t
  **secret_as_ntt =
    sample_vector_cbd_then_ntt(v_K,
      v_ETA1,
      v_ETA1_RANDOMNESS_SIZE,
      prf_input,
      domain_separator);
  int32_t
  **error_as_ntt =
    sample_vector_cbd_then_ntt(v_K,
      v_ETA1,
      v_ETA1_RANDOMNESS_SIZE,
      prf_input,
      domain_separator);
  int32_t **tt_as_ntt = compute_As_plus_e(v_K, v_A_transpose, secret_as_ntt, error_as_ntt);
  KRML_CHECK_SIZE(sizeof (uint8_t), v_PUBLIC_KEY_SIZE);
  uint8_t buf[v_PUBLIC_KEY_SIZE];
  memset(buf, 0U, v_PUBLIC_KEY_SIZE * sizeof (uint8_t));
  t_UpdatableArray public_key_serialized = { .f_value = buf, .f_pointer = 0U };
  t_nonempty_Slice__uint8_t
  uu____2 =
    {
      .buffer = serialize_key(v_K, v_BYTES_PER_RING_ELEMENT, tt_as_ntt),
      .len = v_BYTES_PER_RING_ELEMENT
    };
  t_Range__uint32_t
  uu____3 =
    {
      .f_start1 = public_key_serialized.f_pointer,
      .f_end1 = public_key_serialized.f_pointer + uu____2.len
    };
  uint32_t f_start2 = uu____3.f_start1;
  uint32_t f_end2 = uu____3.f_end1;
  uint32_t len1 = f_end2 - f_start2;
  uint8_t *buffer2 = public_key_serialized.f_value + f_start2;
  memcpy(uu____2.buffer,
    ((t_nonempty_Slice__uint8_t){ .buffer = buffer2, .len = len1 }).buffer,
    uu____2.len * sizeof (uint8_t));
  t_UpdatableArray
  public_key_serialized1 =
    {
      .f_value = public_key_serialized.f_value,
      .f_pointer = public_key_serialized.f_pointer + uu____2.len
    };
  t_Range__uint32_t
  uu____4 =
    {
      .f_start1 = public_key_serialized1.f_pointer,
      .f_end1 = public_key_serialized1.f_pointer + seed_for_A.len
    };
  uint32_t f_start = uu____4.f_start1;
  uint32_t f_end = uu____4.f_end1;
  uint32_t len2 = f_end - f_start;
  uint8_t *buffer = public_key_serialized1.f_value + f_start;
  memcpy(seed_for_A.buffer,
    ((t_nonempty_Slice__uint8_t){ .buffer = buffer, .len = len2 }).buffer,
    seed_for_A.len * sizeof (uint8_t));
  uint8_t *public_key_serialized2 = public_key_serialized1.f_value;
  uint8_t *secret_key_serialized = serialize_key(v_K, v_CPA_PRIVATE_KEY_SIZE, secret_as_ntt);
  __Libcrux_Kem_Kyber_Types_t_PrivateKey___Libcrux_Kem_Kyber_Types_t_KyberPublicKey_Core_Option_t_Option__Libcrux_Kem_Kyber_Types_t_Error
  scrut0 =
    {
      .fst = {
        .fst = mk_privatekey(secret_key_serialized),
        .snd = mk_publickey(public_key_serialized2)
      },
      .snd = sampling_A_error
    };
  t_Option__Libcrux_Kem_Kyber_Types_t_Error sampling_a_error = scrut0.snd;
  uint8_t *public_key = scrut0.fst.snd;
  uint8_t *ind_cpa_private_key = scrut0.fst.fst;
  uint8_t
  *secret_key_serialized0 =
    serialize_secret_key(v_PRIVATE_KEY_SIZE,
      ((t_nonempty_Slice__uint8_t){ .buffer = ind_cpa_private_key, .len = v_CPA_PRIVATE_KEY_SIZE }),
      ((t_nonempty_Slice__uint8_t){ .buffer = public_key, .len = v_PUBLIC_KEY_SIZE }),
      implicit_rejection_value);
  if (sampling_a_error.tag == Option_Some)
  {
    Libcrux_Kem_Kyber_Types_t_Error error = sampling_a_error._0;
    return
      (
        (Core_Result_t_Result__Libcrux_Kem_Kyber_Types_t_KyberKeyPair_Libcrux_Kem_Kyber_Types_t_Error){
          .tag = Core_Result_Result_Err,
          { .case_Result_Err = error }
        }
      );
  }
  uint8_t *private_key = mk_kyberprivatekey(secret_key_serialized0);
  return
    (
      (Core_Result_t_Result__Libcrux_Kem_Kyber_Types_t_KyberKeyPair_Libcrux_Kem_Kyber_Types_t_Error){
        .tag = Core_Result_Result_Ok,
        { .case_Result_Ok = { .f_sk = private_key, .f_pk = public_key } }
      }
    );
}

uint32_t Libcrux_Kem_Kyber_Kyber768_v_ETA1 = 2U;

uint32_t Libcrux_Kem_Kyber_Kyber768_v_ETA1_RANDOMNESS_SIZE = 128U;

uint32_t Libcrux_Kem_Kyber_Kyber768_v_ETA2 = 2U;

uint32_t Libcrux_Kem_Kyber_Kyber768_v_ETA2_RANDOMNESS_SIZE = 128U;

uint32_t Libcrux_Kem_Kyber_Kyber768_v_RANK_768_ = 3U;

uint32_t Libcrux_Kem_Kyber_Kyber768_v_CPA_PKE_SECRET_KEY_SIZE_768_ = 1152U;

uint32_t Libcrux_Kem_Kyber_Kyber768_v_RANKED_BYTES_PER_RING_ELEMENT_768_ = 1152U;

uint32_t Libcrux_Kem_Kyber_Kyber768_v_T_AS_NTT_ENCODED_SIZE_768_ = 1152U;

uint32_t Libcrux_Kem_Kyber_Kyber768_v_CPA_PKE_PUBLIC_KEY_SIZE_768_ = 1184U;

uint32_t Libcrux_Kem_Kyber_Kyber768_v_SECRET_KEY_SIZE_768_ = 2400U;

uint32_t Libcrux_Kem_Kyber_Kyber768_v_VECTOR_U_COMPRESSION_FACTOR_768_ = 10U;

uint32_t Libcrux_Kem_Kyber_Kyber768_v_C1_BLOCK_SIZE_768_ = 320U;

uint32_t Libcrux_Kem_Kyber_Kyber768_v_C1_SIZE_768_ = 960U;

uint32_t Libcrux_Kem_Kyber_Kyber768_v_VECTOR_V_COMPRESSION_FACTOR_768_ = 4U;

uint32_t Libcrux_Kem_Kyber_Kyber768_v_C2_SIZE_768_ = 128U;

uint32_t Libcrux_Kem_Kyber_Kyber768_v_CPA_PKE_CIPHERTEXT_SIZE_768_ = 1088U;

uint32_t Libcrux_Kem_Kyber_Kyber768_v_IMPLICIT_REJECTION_HASH_INPUT_SIZE = 1120U;

uint8_t *Libcrux_Kem_Kyber_Kyber768_decapsulate_768_(uint8_t *secret_key, uint8_t *ciphertext)
{
  return
    decapsulate(3U,
      2400U,
      1152U,
      1184U,
      1088U,
      1152U,
      960U,
      128U,
      10U,
      4U,
      320U,
      2U,
      128U,
      2U,
      128U,
      1120U,
      secret_key,
      ciphertext);
}

Core_Result_t_Result__Libcrux_Kem_Kyber_Types_t_KyberCiphertext____uint8_t__Libcrux_Kem_Kyber_Types_t_Error
Libcrux_Kem_Kyber_Kyber768_encapsulate_768_(uint8_t *public_key, uint8_t *randomness)
{
  return
    encapsulate(3U,
      1088U,
      1184U,
      1152U,
      960U,
      128U,
      10U,
      4U,
      320U,
      2U,
      128U,
      2U,
      128U,
      public_key,
      randomness);
}

Core_Result_t_Result__Libcrux_Kem_Kyber_Types_t_KyberKeyPair_Libcrux_Kem_Kyber_Types_t_Error
Libcrux_Kem_Kyber_Kyber768_generate_key_pair_768_(uint8_t *randomness)
{
  return generate_keypair(3U, 1152U, 2400U, 1184U, 1152U, 2U, 128U, randomness);
}

