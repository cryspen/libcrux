diff -ruN extraction-edited/BitVecEq.fst extraction-secret-independent/BitVecEq.fst
--- extraction-edited/BitVecEq.fst	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/BitVecEq.fst	1970-01-01 01:00:00.000000000 +0100
@@ -1,12 +0,0 @@
-module BitVecEq
-
-open Core
-open FStar.Mul
-open FStar.FunctionalExtensionality
-
-let bit_vec_equal #n bv1 bv2 = forall i. bv1 i == bv2 i
-
-let bit_vec_equal_intro bv1 bv2 = ()
-let bit_vec_equal_elim bv1 bv2 = assert (feq bv1 bv2)
-
-
diff -ruN extraction-edited/BitVecEq.fsti extraction-secret-independent/BitVecEq.fsti
--- extraction-edited/BitVecEq.fsti	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/BitVecEq.fsti	1970-01-01 01:00:00.000000000 +0100
@@ -1,294 +0,0 @@
-module BitVecEq
-#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
-open Core
-open FStar.Mul
-open MkSeq
-open FStar.FunctionalExtensionality
-
-val bit_vec_equal (#n: nat) (bv1 bv2: bit_vec n): Type0
-val bit_vec_equal_intro (#n: nat) (bv1 bv2: bit_vec n)
-  : Lemma (requires forall i. bv1 i == bv2 i)
-          (ensures bit_vec_equal bv1 bv2)
-val bit_vec_equal_elim (#n: nat) (bv1 bv2: bit_vec n)
-  : Lemma (requires bit_vec_equal #n bv1 bv2)
-          (ensures bv1 == bv2)
-          [SMTPat (bit_vec_equal #n bv1 bv2)]
-
-let bit_vec_equal_intro_principle ()
-  : Lemma (forall n (bv1 bv2: bit_vec n). (forall i. bv1 i == bv2 i) ==> bit_vec_equal #n bv1 bv2)
-  = introduce forall n (bv1 bv2: bit_vec n). _
-    with introduce (forall i. bv1 i == bv2 i) ==> bit_vec_equal #n bv1 bv2
-         with _. bit_vec_equal_intro #n bv1 bv2
-  
-let bit_vec_equal_elim_principle ()
-  : Lemma (forall n (bv1 bv2: bit_vec n). bit_vec_equal #n bv1 bv2 ==> (forall i. bv1 i == bv2 i))
-  = introduce forall n (bv1 bv2: bit_vec n). _
-    with introduce bit_vec_equal #n bv1 bv2 ==> (forall i. bv1 i == bv2 i)
-         with _. bit_vec_equal_elim #n bv1 bv2
-
-let bit_vec_equal_trivial (bv1 bv2: bit_vec 0): Lemma (bv1 == bv2) 
-    [SMTPat (eq2 #(bit_vec 0) bv1 bv2)]
-  = bit_vec_equal_intro bv1 bv2
-
-let bit_vec_sub #n (bv: bit_vec n) (start: nat) (len: nat {start + len <= n})
-  : bit_vec len
-  = on (i: nat {i < len})
-       (fun i -> bv (start + i))
-
-let bit_vec_equal_trivial_sub_smtpat (bv1: bit_vec 'n)
-  : Lemma (forall (bv2: bit_vec 0). bit_vec_sub bv1 0 0 == bv2)
-    [SMTPat (bit_vec_sub bv1 0 0)]
-  = introduce forall (bv2: bit_vec 0). bit_vec_sub bv1 0 0 == bv2
-    with bit_vec_equal_trivial (bit_vec_sub bv1 0 0) bv2
-
-unfold let retype #a #b (#_:unit{a == b})
-  (x: a): b
-  = x
-
-let bit_vec_sub_all_lemma #n (bv: bit_vec n)
-  : Lemma (bit_vec_sub bv 0 n == bv)
-          [SMTPat (bit_vec_sub bv 0 n)]
-  = bit_vec_equal_intro (bit_vec_sub bv 0 n) bv
-
-let int_t_array_bitwise_eq'
-       #t1 #t2 #n1 #n2
-       (arr1: t_Array (int_t t1) n1) (d1: num_bits t1)
-       (arr2: t_Array (int_t t2) n2) (d2: num_bits t2 {v n1 * d1 == v n2 * d2})
-     = bit_vec_equal (bit_vec_of_int_t_array arr1 d1)
-                     (retype (bit_vec_of_int_t_array arr2 d2))
-
-let int_t_array_bitwise_eq
-       #t1 #t2 #n1 #n2
-       (arr1: t_Array (int_t t1) n1) (d1: num_bits t1)
-       (arr2: t_Array (int_t t2) n2) (d2: num_bits t2 {v n1 * d1 == v n2 * d2})
-     =  bit_vec_of_int_t_array arr1 d1
-     == bit_vec_of_int_t_array arr2 d2
-
-// let get_bit_intro ()
-//   : Lemma (forall (#n: inttype) (x: int_t n) (nth: usize {v nth < bits n}). 
-//              get_bit #n x nth == (  if v x >= 0 then get_bit_nat (v x) (v nth)
-//                                 else get_bit_nat (pow2 (bits n) + v x) (v nth)))
-//   = introduce forall (n: inttype) (x: int_t n) (nth: usize {v nth < bits n}). 
-//              get_bit #n x nth == (  if v x >= 0 then get_bit_nat (v x) (v nth)
-//                                 else get_bit_nat (pow2 (bits n) + v x) (v nth))
-//     with get_bit_intro #n x nth
-
-#push-options "--fuel 0 --ifuel 0 --z3rlimit 80"
-/// Rewrite a `bit_vec_of_int_t_array (Seq.slice arr ...)` into a `bit_vec_sub ...`
-let int_t_seq_slice_to_bv_sub_lemma #t #n 
-  (arr: t_Array (int_t t) n)
-  (start: nat) (len: usize {start + v len <= v n})
-  (d: num_bits t) 
-  : Lemma ( bit_vec_of_int_t_array (Seq.slice arr start (start + v len) <: t_Array _ len) d
-     `bit_vec_equal` bit_vec_sub (bit_vec_of_int_t_array arr d) (start * d) (v len * d))
-   [SMTPat (bit_vec_sub (bit_vec_of_int_t_array arr d) (start * d) (v len * d))]
-  = let bv1 = bit_vec_of_int_t_array #_ #len (Seq.slice arr start (start + v len)) d in
-    let bv2 = bit_vec_sub (bit_vec_of_int_t_array arr d) (start * d) (v len * d) in
-    introduce forall i. bv1 i == bv2 i 
-    with ( Seq.lemma_index_slice arr start (start + v len) (i / d);
-           Math.Lemmas.lemma_div_plus i start d;
-           Math.Lemmas.lemma_mod_plus i start d);
-    bit_vec_equal_intro bv1 bv2
-
-#push-options "--split_queries always"
-let int_t_eq_seq_slice_bv_sub_lemma #t #n1 #n2
-  (arr1: t_Array (int_t t) n1) (arr2: t_Array (int_t t) n2)  (d: num_bits t)
-  (start1 start2: nat) (len: nat {start1 + len <= v n1 /\ start2 + len <= v n2})
-  : Lemma (requires Seq.slice arr1 start1 (start1 + len) == Seq.slice arr2 start2 (start2 + len))
-          (ensures  bit_vec_equal
-                       (bit_vec_sub (bit_vec_of_int_t_array arr1 d) (start1 * d) (len * d))
-                       (bit_vec_sub (bit_vec_of_int_t_array arr2 d) (start2 * d) (len * d)))
-          [SMTPat ((bit_vec_sub (bit_vec_of_int_t_array arr1 d) (start1 * d) (len * d)) ==
-                       (bit_vec_sub (bit_vec_of_int_t_array arr2 d) (start2 * d) (len * d)))]
-  = let len = sz len in
-    int_t_seq_slice_to_bv_sub_lemma arr1 start1 len d;
-    int_t_seq_slice_to_bv_sub_lemma arr2 start2 len d;
-    // bit_vec_equal_elim_principle ();
-    bit_vec_equal_intro_principle ()
-#pop-options
-
-let bit_vec_equal_extend #n1 #n2
-  (bv1: bit_vec n1) (bv2: bit_vec n2) (start1 start2: nat)
-  (len1: nat)
-  (len2: nat { start1 + len1 + len2 <= n1 /\ start2 + len1 + len2 <= n2})
-  : Lemma 
-    (requires 
-       bit_vec_sub bv1 start1 len1 == bit_vec_sub bv2 start2 len1
-     /\ bit_vec_sub bv1 (start1 + len1) len2 == bit_vec_sub bv2 (start2 + len1) len2)
-    (ensures bit_vec_sub bv1 start1 (len1+len2) == bit_vec_sub bv2 start2 (len1+len2))
-    // [SMTPat (bit_vec_sub bv1 start1 len1 == bit_vec_sub bv2 start2 len1);
-    //  SMTPat ()
-    // ]
-     // SMTPat (bit_vec_sub bv1 (start1 + len1) len2 == bit_vec_sub bv2 (start2 + len1) len2)]
-  = let left1 = bit_vec_sub bv1 start1 len1 in
-    let left2 = bit_vec_sub bv2 start2 len1 in
-    let right1 = bit_vec_sub bv1 (start1 + len1) len2 in
-    let right2 = bit_vec_sub bv2 (start2 + len1) len2 in
-    // ()
-    // bit_vec_equal_elim left1  left2 ;
-    // bit_vec_equal_elim right1 right2;
-    let entire1 = bit_vec_sub bv1 start1 (len1 + len2) in
-    let entire2 = bit_vec_sub bv2 start2 (len1 + len2) in
-    assert (forall (i:nat). i < len1 ==> left1 i == left2 i);
-    assert (forall (i:nat). i < len2 ==> right1 i == right2 i);
-    introduce forall (i:nat). i < len1 + len2 ==> entire1 i == entire2 i
-    with introduce i < len1 + len2 ==> entire1 i == entire2 i
-         with _. if i < len1 then assert (left1 i == left2 i)
-                             else assert (entire1 i == right1 (i - len1));
-    bit_vec_equal_intro entire1 entire2
-#pop-options
-
-// let bit_vec_equal_trans (#n: nat) (bv1 bv2 bv3: bit_vec n)
-//   : Lemma (requires bv1 `bit_vec_equal` bv2 /\ bv2 `bit_vec_equal` bv3)
-//           (ensures  bv1 `bit_vec_equal` bv3)
-//   = bit_vec_equal_elim_principle ();
-//     bit_vec_equal_intro_principle ()
-
-(*
-let int_arr_bitwise_eq_range
-       #t1 #t2 #n1 #n2
-       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement1: int_t t1 -> Type0)
-       (arr1: t_Array (x: int_t t1 {refinement1 x}) n1)
-       (d1: num_bits t1)
-       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement2: int_t t2 -> Type0)
-       (arr2: t_Array (x: int_t t2 {refinement2 x}) n2)
-       (d2: num_bits t2)
-       (offset1 offset2: nat)
-       (bits: nat {
-           offset1 + bits <= v n1 * d1
-         /\ offset2 + bits <= v n2 * d2
-       })
-     = bit_vec_equal #bits (fun i -> bit_vec_of_int_t_array arr1 d1 (i + offset1))
-     = forall (k: nat). k < bits ==>
-          bit_vec_of_int_t_array arr1 d1 (offset1 + k) 
-       == bit_vec_of_int_t_array arr2 d2 (offset2 + k)
-
-let int_arr_bitwise_eq_range_comm
-       #t1 #t2 #n1 #n2
-       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement1: int_t t1 -> Type0)
-       (arr1: t_Array (x: int_t t1 {refinement1 x}) n1)
-       (d1: num_bits t1)
-       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement2: int_t t2 -> Type0)
-       (arr2: t_Array (x: int_t t2 {refinement2 x}) n2)
-       (d2: num_bits t2)
-       (offset1 offset2: nat)
-       (bits: nat {
-           offset1 + bits <= v n1 * d1
-         /\ offset2 + bits <= v n2 * d2
-       })
-    : Lemma (requires int_arr_bitwise_eq_range arr1 d1 arr2 d2 offset1 offset2 bits)
-            (ensures int_arr_bitwise_eq_range arr2 d2 arr1 d1 offset2 offset1 bits)
-    = ()
-
-// kill that function in favor of range
-let int_arr_bitwise_eq_up_to
-       #t1 #t2 #n1 #n2
-       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement1: int_t t1 -> Type0)
-       (arr1: t_Array (x: int_t t1 {refinement1 x}) n1)
-       (d1: num_bits t1)
-       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement: int_t t2 -> Type0)
-       (arr2: t_Array (x: int_t t2 {refinement x}) n2)
-       (d2: num_bits t2 {v n1 * d1 == v n2 * d2})
-       (max: nat {max <= v n1 * d1})
-     
-     = forall i. i < max
-       ==> bit_vec_of_int_t_array arr1 d1 i == bit_vec_of_int_t_array arr2 d2 i
-
-let int_arr_bitwise_eq_
-       #t1 #t2 #n1 #n2
-       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement1: int_t t1 -> Type0)
-       (arr1: t_Array (x: int_t t1 {refinement1 x}) n1)
-       (d1: num_bits t1)
-       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement: int_t t2 -> Type0)
-       (arr2: t_Array (x: int_t t2 {refinement x}) n2)
-       (d2: num_bits t2 {v n1 * d1 == v n2 * d2})
-     = int_arr_bitwise_eq_up_to arr1 d1 arr2 d2 (v n1 * d1)
-
-// move to fsti
-let bit_vec_equal #n (bv1 bv2: bit_vec n)
-  = forall i. i < n ==> bv1 i == bv2 i
-
-let int_arr_bitwise_eq
-       #t1 #t2 #n1 #n2
-       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement1: int_t t1 -> Type0)
-       (arr1: t_Array (x: int_t t1 {refinement1 x}) n1)
-       (d1: num_bits t1)
-       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement: int_t t2 -> Type0)
-       (arr2: t_Array (x: int_t t2 {refinement x}) n2)
-       (d2: num_bits t2 {v n1 * d1 == v n2 * d2})
-     = forall i. i < v n1 * d1
-       ==> bit_vec_of_int_t_array arr1 d1 i == bit_vec_of_int_t_array arr2 d2 i
-
-let int_arr_bitwise_eq_range_transitivity
-       #t1 #t2 #t3 #n1 #n2 #n3
-       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement1: int_t t1 -> Type0)
-       (arr1: t_Array (x: int_t t1 {refinement1 x}) n1)
-       (d1: num_bits t1)
-       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement2: int_t t2 -> Type0)
-       (arr2: t_Array (x: int_t t2 {refinement2 x}) n2)
-       (d2: num_bits t2)
-       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement3: int_t t3 -> Type0)
-       (arr3: t_Array (x: int_t t3 {refinement3 x}) n3)
-       (d3: num_bits t3)
-       (offset1 offset2 offset3: nat)
-       (bits: nat {
-           offset1 + bits <= v n1 * d1
-         /\ offset2 + bits <= v n2 * d2
-         /\ offset3 + bits <= v n3 * d3
-       })
-   : Lemma 
-     (requires int_arr_bitwise_eq_range #t1 #t2 #n1 #n2 arr1 d1 arr2 d2 offset1 offset2 bits
-             /\ int_arr_bitwise_eq_range #t2 #t3 #n2 #n3 arr2 d2 arr3 d3 offset2 offset3 bits)
-     (ensures  int_arr_bitwise_eq_range #t1 #t3 #n1 #n3 arr1 d1 arr3 d3 offset1 offset3 bits)
-   = ()
-
-
-let int_arr_bitwise_eq_range_intro
-       #t1 #t2 #n1 #n2
-       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement1: int_t t1 -> Type0)
-       (arr1: t_Array (x: int_t t1 {refinement1 x}) n1)
-       (d1: num_bits t1)
-       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement: int_t t2 -> Type0)
-       (arr2: t_Array (x: int_t t2 {refinement x}) n2)
-       (d2: num_bits t2 {v n1 * d1 == v n2 * d2})
-   : Lemma 
-     (requires int_arr_bitwise_eq arr1 d1 arr2 d2)
-     (ensures int_arr_bitwise_eq_range arr1 d1 arr2 d2 0 0 (v n1 * d1))
-   = admit ()
-
-let int_arr_bitwise_eq_range_intro_eq_slice
-       #t #n1 #n2
-       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement: int_t t -> Type0)
-       (arr1: t_Array (x: int_t t {refinement x}) n1)
-       (arr2: t_Array (x: int_t t {refinement x}) n2)
-       (d: num_bits t)
-       (offset1 offset2: nat)
-       (n: nat {offset1 + n < v n1 /\ offset2 + n < v n2})
-       (bits: nat {
-           offset1 + bits <= v n1 * d
-         /\ offset2 + bits <= v n2 * d
-         /\ bits <= n * d
-       })
-   : Lemma (requires Seq.slice arr1 offset1 (offset1 + n) == Seq.slice arr2 offset2 (offset2 + n))
-           (ensures int_arr_bitwise_eq_range arr1 d arr2 d offset1 offset2 bits)
- = admit ()
- 
-let int_arr_bitwise_eq_range_intro_eq
-       #t #n1 #n2
-       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement1: int_t t -> Type0)
-       (arr1: t_Array (x: int_t t {refinement1 x}) n1)
-       (#[FStar.Tactics.exact (`(fun _ -> True))]refinement2: int_t t -> Type0)
-       (arr2: t_Array (x: int_t t {refinement2 x}) n2)
-       (d: num_bits t)
-       (n_offset1 n_offset2: nat)
-       (n: nat {n_offset1 + n <= v n1 /\ n_offset2 + n <= v n2})
-       // (offset1 offset2: nat)
-       (bits: nat {
-           n_offset1 * d + bits <= v n1 * d
-         /\ n_offset2 * d + bits <= v n2 * d
-         /\ bits <= n * d
-       })
-   : Lemma (requires forall (i: nat). i < n ==> Seq.index arr1 (i + n_offset1) == Seq.index arr2 (i + n_offset2))
-           (ensures int_arr_bitwise_eq_range arr1 d arr2 d (n_offset1 * d) (n_offset2 * d) bits)
- = admit ()
-*)
diff -ruN extraction-edited/Libcrux.Digest.fsti extraction-secret-independent/Libcrux.Digest.fsti
--- extraction-edited/Libcrux.Digest.fsti	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Digest.fsti	1970-01-01 01:00:00.000000000 +0100
@@ -1,31 +1,41 @@
 module Libcrux.Digest
 #set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
+open Rust_primitives
 open Core
-open FStar.Mul
 
-val shake128x4_256_ (v_LEN: usize) (data0 data1 data2 data3: t_Slice u8)
-    : Prims.Pure (t_Array u8 v_LEN & t_Array u8 v_LEN & t_Array u8 v_LEN & t_Array u8 v_LEN)
-      Prims.l_True
-      (fun _ -> Prims.l_True)
-
-val sha3_256_ (payload: t_Slice u8)
-    : Prims.Pure (t_Array u8 (sz 32)) Prims.l_True (fun _ -> Prims.l_True)
-
-val sha3_512_ (payload: t_Slice u8)
-    : Prims.Pure (t_Array u8 (sz 64)) Prims.l_True (fun _ -> Prims.l_True)
-
-val shake128 (v_LEN: usize) (data: t_Slice u8)
-    : Prims.Pure (t_Array u8 v_LEN) Prims.l_True (fun _ -> Prims.l_True)
-
-val shake256 (v_LEN: usize) (data: t_Slice u8)
-    : Prims.Pure (t_Array u8 v_LEN) Prims.l_True (fun _ -> Prims.l_True)
-
-val shake128x4_portable (v_LEN: usize) (data0 data1 data2 data3: t_Slice u8)
-    : Prims.Pure (t_Array u8 v_LEN & t_Array u8 v_LEN & t_Array u8 v_LEN & t_Array u8 v_LEN)
-      Prims.l_True
-      (fun _ -> Prims.l_True)
-
-val shake128x4 (v_LEN: usize) (data0 data1 data2 data3: t_Slice u8)
-    : Prims.Pure (t_Array u8 v_LEN & t_Array u8 v_LEN & t_Array u8 v_LEN & t_Array u8 v_LEN)
-      Prims.l_True
-      (fun _ -> Prims.l_True)
+type t_Algorithm =
+  | Algorithm_Sha1 : t_Algorithm
+  | Algorithm_Sha224 : t_Algorithm
+  | Algorithm_Sha256 : t_Algorithm
+  | Algorithm_Sha384 : t_Algorithm
+  | Algorithm_Sha512 : t_Algorithm
+  | Algorithm_Blake2s : t_Algorithm
+  | Algorithm_Blake2b : t_Algorithm
+  | Algorithm_Sha3_224_ : t_Algorithm
+  | Algorithm_Sha3_256_ : t_Algorithm
+  | Algorithm_Sha3_384_ : t_Algorithm
+  | Algorithm_Sha3_512_ : t_Algorithm
+
+let digest_size (mode: t_Algorithm) : usize =
+  match mode with
+  | Algorithm_Sha1  -> sz 20
+  | Algorithm_Sha224  -> sz 28
+  | Algorithm_Sha256  -> sz 32
+  | Algorithm_Sha384  -> sz 48
+  | Algorithm_Sha512  -> sz 64
+  | Algorithm_Blake2s  -> sz 32
+  | Algorithm_Blake2b  -> sz 64
+  | Algorithm_Sha3_224_  -> sz 28
+  | Algorithm_Sha3_256_  -> sz 32
+  | Algorithm_Sha3_384_  -> sz 48
+  | Algorithm_Sha3_512_  -> sz 64
+
+val sha3_256_ (payload: t_Slice u8) : t_Array u8 (sz 32)
+
+val sha3_512_ (payload: t_Slice u8) : t_Array u8 (sz 64)
+
+val shake128 (v_LEN: usize) (data: t_Slice u8) : t_Array u8 v_LEN
+
+val shake128x4 (v_LEN: usize) (data0: t_Slice u8) (data1: t_Slice u8) (data2: t_Slice u8) (data3: t_Slice u8): (t_Array u8 v_LEN & t_Array u8 v_LEN & t_Array u8 v_LEN & t_Array u8 v_LEN)
+
+val shake256 (v_LEN: usize) (data: t_Slice u8) : t_Array u8 v_LEN
diff -ruN extraction-edited/Libcrux.Kem.Kyber.Arithmetic.fst extraction-secret-independent/Libcrux.Kem.Kyber.Arithmetic.fst
--- extraction-edited/Libcrux.Kem.Kyber.Arithmetic.fst	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.Arithmetic.fst	1970-01-01 01:00:00.000000000 +0100
@@ -1,364 +1,81 @@
 module Libcrux.Kem.Kyber.Arithmetic
-#set-options "--fuel 0 --ifuel 1 --z3rlimit 100"
+#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
 open Core
 open FStar.Mul
 
-
-let lemma_mul_i32_range (n1 n2: i32) (b1 b2: nat)
-    : Lemma (requires (i32_range n1 b1 /\ i32_range n2 b2 /\ b1 * b2 < pow2 31))
-      (ensures (range (v n1 * v n2) i32_inttype /\ i32_range (n1 *! n2) (b1 * b2))) =
-  if v n1 = 0 || v n2 = 0
-  then ()
-  else 
-    let open FStar.Math.Lemmas in
-    lemma_abs_bound (v n1) b1;
-    lemma_abs_bound (v n2) b2;
-    lemma_abs_mul (v n1) (v n2);
-    lemma_mult_le_left (abs (v n1)) (abs (v n2)) b2;
-    lemma_mult_le_right b2 (abs (v n1)) b1;
-    lemma_abs_bound (v n1 * v n2) (b1 * b2)
-
-let lemma_add_i32_range (n1 n2:i32) (b1 b2:nat):
-  Lemma (requires (i32_range n1 b1 /\ i32_range n2 b2 /\ b1 + b2 < pow2 31))
-        (ensures (range (v n1 + v n2) i32_inttype /\
-                  i32_range (n1 +! n2) (b1 + b2)))
-  = ()
-
-let mul_i32_b #b1 #b2 x y = 
-  lemma_mul_i32_range x y b1 b2;
-  x *! y
-
-let add_i32_b #b1 #b2 x y = 
-  lemma_add_i32_range x y b1 b2;
-  x +! y
-
-let sub_i32_b #b1 #b2 x y = 
-  x -! y
-
-let cast_i32_b #b1 #b2 x =
-  x <: i32_b b2 
-
-#push-options "--ifuel 0 --z3rlimit 250"
-let shr_i32_b #b #t x y =
-  let r = (x <: i32) >>! y in
-  assert (v r == v x / pow2 (v y));
-  Math.Lemmas.lemma_div_le (v x) b (pow2 (v y));
-  assert (v x / (pow2 (v y)) <= b / (pow2 (v y)));
-  Math.Lemmas.lemma_div_le (-b) (v x) (pow2 (v y));
-  assert (v x / (pow2 (v y)) >= (-b) / (pow2 (v y)));
-  if (b % pow2 (v y) = 0)  
-  then (Math.Lemmas.div_exact_r b (pow2 (v y));
-        assert (b = (b/pow2 (v y)) * pow2 (v y));
-        assert (-b = -((b/pow2 (v y)) * pow2 (v y)));
-        Math.Lemmas.neg_mul_left (b/pow2 (v y)) (pow2 (v y));
-        assert (-b = (-(b/pow2 (v y))) * pow2 (v y));
-        assert ((-b)/pow2(v y) = ((-(b/pow2 (v y))) * pow2 (v y)) / pow2 (v y));
-        Math.Lemmas.cancel_mul_div (-(b/pow2 (v y))) (pow2 (v y));
-        assert ((-b)/pow2(v y) = -(b/pow2 (v y)));
-        assert (nat_div_ceil b (pow2 (v y)) == b / pow2 (v y));
-        assert (i32_range r (b / pow2 ( v y)));
-        r <: i32_b (nat_div_ceil b (pow2 (v y))))
-  else (let rem = b % pow2 (v y) in
-        let quo = b / pow2 (v y) in
-        Math.Lemmas.lemma_div_mod b (pow2 (v y));        
-        assert (b = quo * pow2 (v y) + rem);
-        assert (-b = -(quo * pow2 (v y)) - rem);
-        Math.Lemmas.neg_mul_left quo (pow2 (v y));
-        assert (-b = (-quo) * pow2 (v y) - rem);
-        assert ((-b)/pow2(v y) = (-rem + (-quo) * pow2 (v y))/pow2 (v y));
-        Math.Lemmas.division_addition_lemma (-rem) (pow2 (v y)) (-quo);
-        assert ((-b)/pow2(v y) = ((-rem)/pow2 (v y) -quo));
-        Math.Lemmas.division_definition (-rem) (pow2 (v y)) (-1);
-        assert ((-rem)/pow2 (v y) == -1);
-        assert ((-b)/pow2(v y) = -1 -quo);
-        assert ((-b)/pow2(v y) = (-quo - 1));
-        assert ((-b)/pow2(v y) = -(quo + 1));
-        assert (nat_div_ceil b (pow2 (v y)) == quo + 1);
-        assert (i32_range r (quo+1));
-        r <: i32_b (nat_div_ceil b (pow2 (v y))))
-#pop-options
-
-let v_BARRETT_R: i64 =
-  let result = 1L <<! v_BARRETT_SHIFT in
-  assert_norm (result == mk_int (67108864 @%. Lib.IntTypes.S64));
-  result
-
-let v_MONTGOMERY_R =
-  let result: i32 = 1l <<! v_MONTGOMERY_SHIFT in
-  assert_norm (result == mk_int (65536 @%. Lib.IntTypes.S32));
-  result
-
-let v_MONTGOMERY_R_INV = 
-  assert_norm((v 169l * pow2 16) % 3329 == 1);
-  169l
-  
-#push-options "--fuel 0 --ifuel 1 --z3rlimit 100 --split_queries always"
-let get_n_least_significant_bits n value = 
+let get_n_least_significant_bits (n: pub_u8) (value: u32) =
   let _:Prims.unit = () <: Prims.unit in
-  let res = value &. ((1ul <<! n <: u32) -! 1ul <: u32) in
-  calc (==) {
-    v res;
-    (==) { }
-    v (logand value ((1ul <<! n) -! 1ul));
-    (==) {mk_int_equiv_lemma #u32_inttype 1} 
-    v (logand value (((mk_int 1) <<! n) -! (mk_int 1)));
-    (==) { }
-    v (logand value (mk_int ((1 * pow2 (v n)) % pow2 32) -! (mk_int 1)));
-    (==) {Math.Lemmas.small_mod (pow2 (v n)) (pow2 32); Math.Lemmas.pow2_lt_compat 32 (v n)}
-    v (logand value ((mk_int (pow2 (v n))) -! (mk_int 1)));
-    (==) {Math.Lemmas.pow2_lt_compat 32 (v n); logand_mask_lemma value (v n)}
-    v value % (pow2 (v n));
-  };
-  assert (v res < pow2 (v n));
-  res
-#pop-options 
+  value &. ((1ul <<! n <: u32) -! 1ul <: u32)
 
-#push-options "--z3rlimit 250"
-let barrett_reduce value = 
+let barrett_reduce (value: i32) =
   let _:Prims.unit = () <: Prims.unit in
-  let x : i32 = value in
   let t:i64 =
-    ((Core.Convert.f_from x <: i64) *! v_BARRETT_MULTIPLIER <: i64) +!
+    ((Core.Convert.f_from value <: i64) *! v_BARRETT_MULTIPLIER <: i64) +!
     (v_BARRETT_R >>! 1l <: i64)
   in
-  assert_norm (v v_BARRETT_MULTIPLIER == (pow2 27 + 3329) / (2*3329));
-  assert (v t = v x * v v_BARRETT_MULTIPLIER + pow2 25);
   let quotient:i32 = cast (t >>! v_BARRETT_SHIFT <: i64) <: i32 in
-  assert (v quotient = v t / pow2 26);
   let result:i32 = value -! (quotient *! Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS <: i32) in
-  calc (==) {
-    v result % 3329;
-    (==) { }
-    (v value - (v quotient * 3329)) % 3329;
-    (==) {Math.Lemmas.lemma_mod_sub_distr (v value) (v quotient * 3329) 3329}
-    (v value - (v quotient * 3329) % 3329) % 3329;
-    (==) {Math.Lemmas.cancel_mul_mod (v quotient) 3329}
-    (v value - 0) % 3329;    
-    (==) {}
-    (v value) % 3329;    
-  };
+  let _:Prims.unit = () <: Prims.unit in
   result
-#pop-options 
 
-#push-options "--ifuel 0 --z3rlimit 1600"
-let montgomery_reduce #b value = 
+let montgomery_reduce (value: i32) =
   let _:i32 = v_MONTGOMERY_R in
   let _:Prims.unit = () <: Prims.unit in
-  let v0 = (cast (value <: i32) <: u32) in
-  assert (v v0 == v value % pow2 32);
-  let t0 = (get_n_least_significant_bits v_MONTGOMERY_SHIFT v0 <: u32) in
-  assert (v t0 = (v value % pow2 32) % pow2 16);
-  Math.Lemmas.pow2_modulo_modulo_lemma_1 (v value) 16 32;
-  assert (v t0 = v value % pow2 16);
   let t:u32 =
-    t0 *!
+    (get_n_least_significant_bits v_MONTGOMERY_SHIFT (cast (value <: i32) <: u32) <: u32) *!
     v_INVERSE_OF_MODULUS_MOD_R
   in
-  assert (v t = (v value % pow2 16) * v v_INVERSE_OF_MODULUS_MOD_R);
-  let k0 = get_n_least_significant_bits v_MONTGOMERY_SHIFT t <: u32 in
-  let k:i32_b (pow2 15) = cast (cast k0 <: i16) <: i32 in
-  calc (==) {
-    v k % pow2 16;
-    == { }
-    v k0 % pow2 16;
-    == { }
-    v t % pow2 16;
-    == { }
-    ((v value % pow2 16) * v v_INVERSE_OF_MODULUS_MOD_R) % pow2 16;
-    == {Math.Lemmas.lemma_mod_mul_distr_l (v value) (v v_INVERSE_OF_MODULUS_MOD_R) (pow2 16)}
-    (v value * v v_INVERSE_OF_MODULUS_MOD_R) % pow2 16;
-  };
-  assert_norm((62209 * 3329) % pow2 16 == 1);
-  assert((v v_INVERSE_OF_MODULUS_MOD_R * 3329) % pow2 16 == 1);
-  calc (==) {
-    (v k * 3329) % pow2 16;
-    == {Math.Lemmas.lemma_mod_mul_distr_l (v k) 3329 (pow2 16)}
-    ((v k % pow2 16) * 3329) % pow2 16;
-    == { }
-    ((v value * v v_INVERSE_OF_MODULUS_MOD_R) % pow2 16 * 3329) % pow2 16;
-    == {Math.Lemmas.lemma_mod_mul_distr_l (v value * v v_INVERSE_OF_MODULUS_MOD_R) (3329) (pow2 16)}
-    (v value * v v_INVERSE_OF_MODULUS_MOD_R * 3329) % pow2 16;   
-    == {Math.Lemmas.paren_mul_right (v value) (v v_INVERSE_OF_MODULUS_MOD_R) 3329}
-    (v value * (v v_INVERSE_OF_MODULUS_MOD_R * 3329)) % pow2 16;   
-    == {Math.Lemmas.lemma_mod_mul_distr_r (v value) (v v_INVERSE_OF_MODULUS_MOD_R * 3329) (pow2 16)}
-    (v value * ((v v_INVERSE_OF_MODULUS_MOD_R * 3329) % pow2 16)) % pow2 16;   
-    == {Math.Lemmas.mul_one_right_is_same (v value)}
-    (v value) % pow2 16;   
-  };
-  Math.Lemmas.modulo_add (pow2 16) (- (v k * 3329)) (v value) (v k * 3329);
-  assert ((v value - v k * 3329) % pow2 16 == (v k * 3329 - v k * 3329) % pow2 16);
-  assert ((v value - v k * 3329) % v v_MONTGOMERY_R == 0);
-  let k_times_modulus:i32_b (pow2 15 * 3329) =
-      mul_i32_b k Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS
+  let k:i16 = cast (get_n_least_significant_bits v_MONTGOMERY_SHIFT t <: u32) <: i16 in
+  let k_times_modulus:i32 =
+    (cast (k <: i16) <: i32) *! Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS
   in
-  let c:i32_b 1665 = shr_i32_b k_times_modulus v_MONTGOMERY_SHIFT in
-  let value_high:i32_b (nat_div_ceil b (v v_MONTGOMERY_R)) = shr_i32_b value v_MONTGOMERY_SHIFT in
-  assert (v value_high = v value / v v_MONTGOMERY_R);
-  let res: i32_b (nat_div_ceil b (v v_MONTGOMERY_R) + 1665) = sub_i32_b value_high c in
-  calc (==) {
-    v res;
-    == { }
-    (v value_high - v c);
-    == { }
-    ((v value / v v_MONTGOMERY_R) - ((v k * 3329) / v v_MONTGOMERY_R));
-    == {Math.Lemmas.lemma_div_exact (v value - v k * 3329) (v v_MONTGOMERY_R)}
-    ((v value - (v k * 3329)) / v v_MONTGOMERY_R);
-  };
-  calc (==) {
-    v res % 3329;
-    == {Math.Lemmas.lemma_div_exact (v value - v k * 3329) (v v_MONTGOMERY_R)}
-    (((v value - (v k * 3329)) / v v_MONTGOMERY_R) * ((v v_MONTGOMERY_R * v v_MONTGOMERY_R_INV) % 3329)) % 3329 ;
-    == {Math.Lemmas.lemma_mod_mul_distr_r ((v value - (v k * 3329)) / v v_MONTGOMERY_R) (v v_MONTGOMERY_R * v v_MONTGOMERY_R_INV) 3329}
-    (((v value - (v k * 3329)) / v v_MONTGOMERY_R) * (v v_MONTGOMERY_R * v v_MONTGOMERY_R_INV)) % 3329 ;
-    == {Math.Lemmas.paren_mul_right ((v value - (v k * 3329)) / v v_MONTGOMERY_R) (v v_MONTGOMERY_R) (v v_MONTGOMERY_R_INV)}
-    ((((v value - (v k * 3329)) / v v_MONTGOMERY_R) * v v_MONTGOMERY_R) * v v_MONTGOMERY_R_INV) % 3329 ;
-    == {Math.Lemmas.lemma_div_exact (v value - v k * 3329) (v v_MONTGOMERY_R)}
-    ((v value - (v k * 3329)) * v v_MONTGOMERY_R_INV) % 3329 ;
-    == { }
-    ((v value * v v_MONTGOMERY_R_INV) - ((v k * 3329) * v v_MONTGOMERY_R_INV)) % 3329 ;
-    == {Math.Lemmas.paren_mul_right (v k) 3329 (v v_MONTGOMERY_R_INV)} 
-    ((v value * v v_MONTGOMERY_R_INV) - (v k * (3329 * v v_MONTGOMERY_R_INV))) % 3329 ;
-    == {Math.Lemmas.swap_mul 3329 (v v_MONTGOMERY_R_INV)} 
-    ((v value * v v_MONTGOMERY_R_INV) - (v k * (v v_MONTGOMERY_R_INV * 3329))) % 3329 ;
-    == {Math.Lemmas.paren_mul_right (v k) (v v_MONTGOMERY_R_INV) 3329} 
-    ((v value * v v_MONTGOMERY_R_INV) - ((v k * v v_MONTGOMERY_R_INV) * 3329)) % 3329 ;
-    == {Math.Lemmas.lemma_mod_sub (v value * v v_MONTGOMERY_R_INV) 3329 (v k * v v_MONTGOMERY_R_INV)}
-    (v value * v v_MONTGOMERY_R_INV) % 3329 ;
-  };
-  res
-#pop-options
-
-let montgomery_multiply_sfe_by_fer fe fer =
-  montgomery_reduce (mul_i32_b fe fer)
+  let c:i32 = k_times_modulus >>! v_MONTGOMERY_SHIFT in
+  let value_high:i32 = value >>! v_MONTGOMERY_SHIFT in
+  value_high -! c
 
+let montgomery_multiply_sfe_by_fer (fe fer: i32) = montgomery_reduce (fe *! fer <: i32)
 
-let to_standard_domain mfe =
-  montgomery_reduce (mul_i32_b mfe (v_MONTGOMERY_R_SQUARED_MOD_FIELD_MODULUS <: i32_b 1353))
+let to_standard_domain (mfe: i32) =
+  montgomery_reduce (mfe *! v_MONTGOMERY_R_SQUARED_MOD_FIELD_MODULUS <: i32)
 
-let to_unsigned_representative fe =
+let to_unsigned_representative (fe: i32) =
   let _:Prims.unit = () <: Prims.unit in
-  logand_lemma Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS (fe >>! 31l <: i32);
-  let res =  
-  cast (fe +! (Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS &. (fe >>! 31l <: i32) <: i32) <: i32) <: u16
-  in
-  assert (v fe < 0 ==> (Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS &. (fe >>! 31l <: i32) <: i32) == 3329l);
-  assert (v fe >= 0 ==> (Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS &. (fe >>! 31l <: i32) <: i32) == 0l);
-  assert (v fe + 3329 < pow2 16);
-  assert (v fe >= -3328);
-  assert (v fe < 0 ==> v fe + 3329 >= 0);
-  assert (v fe < 0 ==> v res == (v fe + 3329) % pow2 16);
-  Math.Lemmas.small_mod (v fe + 3329) (pow2 16);
-  assert (v fe < 0 ==> v res == v fe + 3329);
-  assert (v fe >= 0 ==> v res == v fe);
-  res <: int_t_d u16_inttype 12
-
-let derefine_poly_b #b x =
-  let r = createi (sz 256) (fun i -> (x.f_coefficients.[i] <: i32)) in
-  {f_coefficients = r}
-
-let derefine_vector_b #v_K #b x =
-  let r = createi v_K (fun i -> derefine_poly_b #b x.[i]) in
-  r
-
-let derefine_matrix_b #v_K #b x =
-  let r = createi v_K (fun i -> derefine_vector_b #v_K #b x.[i]) in
-  r
+  cast (fe +! (Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS &. (fe >>! 31l <: i32) <: i32) <: i32)
+  <:
+  u16
 
-let cast_poly_b #b1 #b2 x =
-  let r = createi (sz 256) (fun i -> (x.f_coefficients.[i] <: i32_b b2)) in
-  let res = {f_coefficients = r} in
-  let dx = (derefine_poly_b x).f_coefficients in
-  let dr = (derefine_poly_b res).f_coefficients in
-  assert (forall (i:usize). v i < 256 ==> 
-    (dx.[i] <: i32) == 
-    (dr.[i] <: i32));
-  assert (forall i. Seq.index dx i == (dx.[sz i] <: i32));
-  eq_intro dx dr;
-  assert(Seq.equal dx dr);
-  res
-
-let cast_vector_b #v_K #b1 #b2 x =
-  let r = createi v_K (fun i -> cast_poly_b #b1 #b2 x.[i]) in
-  let dx = derefine_vector_b x in
-  let dr = derefine_vector_b r in
-  assert (forall (i:usize). v i < v v_K ==>
-    dx.[i] == dr.[i]);
-  assert (forall i. Seq.index dx i == dx.[sz i]);
-  assert (forall i. Seq.index dr i == dr.[sz i]);
-  eq_intro dx dr;
-  r
-
-let down_cast_poly_b #b1 #b2 x =
-  let r = createi (sz 256) 
-      (fun i -> 
-        let xi:i32_b b2 = x.f_coefficients.[i] in
-        xi) in
-  let res = {f_coefficients = r} in
-  let dx = (derefine_poly_b x).f_coefficients in
-  let dr = (derefine_poly_b res).f_coefficients in
-  assert (forall (i:usize). v i < 256 ==> 
-    (dx.[i] <: i32) == 
-    (dr.[i] <: i32));
-  assert (forall i. Seq.index dx i == (dx.[sz i] <: i32));
-  eq_intro dx dr;
-  assert(Seq.equal dx dr);
-  res
-
-let down_cast_vector_b #v_K #b1 #b2 x =
-  let r = createi (v_K) 
-      (fun i -> down_cast_poly_b #b1 #b2 x.[i]) in
-  let dx = derefine_vector_b x in
-  let dr = derefine_vector_b r in
-  assert (forall (i:usize). v i < v v_K ==> 
-    dx.[i] == dr.[i]);
-  assert (forall i. Seq.index dx i == dx.[sz i]);
-  assert (forall i. Seq.index dr i == dr.[sz i]);
-  eq_intro dx dr;
-  assert(Seq.equal dx dr);
-  r
-
-
-let add_to_ring_element #b1 #b2 v_K lhs rhs =
+let add_to_ring_element (v_K: usize) (lhs rhs: t_PolynomialRingElement) =
   let _:Prims.unit = () <: Prims.unit in
   let _:Prims.unit = () <: Prims.unit in
-  let orig_lhs = lhs in
-  [@ inline_let]
-  let inv = fun (acc:t_PolynomialRingElement_b (b1+b2)) (i:usize) ->
-      (forall j. j <. i ==> acc.f_coefficients.[j] == lhs.f_coefficients.[j] +! rhs.f_coefficients.[j]) /\
-      (forall j. j >=. i ==> acc.f_coefficients.[j] == orig_lhs.f_coefficients.[j]) in
-  let lhs:t_PolynomialRingElement_b (b1 + b2) =
-    Rust_primitives.Iterators.foldi_range #_ #(t_PolynomialRingElement_b (b1+b2))  #inv {
+  let lhs:t_PolynomialRingElement =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
               Core.Ops.Range.f_start = sz 0;
-              Core.Ops.Range.f_end =
-              Core.Slice.impl__len (Rust_primitives.unsize lhs.f_coefficients <: t_Slice (i32_b b1))
+              Core.Ops.Range.f_end
+              =
+              Core.Slice.impl__len (Rust_primitives.unsize lhs.f_coefficients <: t_Slice i32)
+              <:
+              usize
             }
-      (cast_poly_b #b1 #(b1+b2) lhs)
+            <:
+            Core.Ops.Range.t_Range usize)
+        <:
+        Core.Ops.Range.t_Range usize)
+      lhs
       (fun lhs i ->
-          let lhs:t_PolynomialRingElement_b (b1+b2) = lhs in
+          let lhs:t_PolynomialRingElement = lhs in
           let i:usize = i in
-          assert (orig_lhs.f_coefficients.[i] == lhs.f_coefficients.[i]);
-          let lhsi: i32_b b1 = orig_lhs.f_coefficients.[i] in
-          let lhs = 
           {
             lhs with
             f_coefficients
             =
             Rust_primitives.Hax.Monomorphized_update_at.update_at_usize lhs.f_coefficients
               i
-              (add_i32_b #b1 #b2 (lhsi) (rhs.f_coefficients.[ i ]))
+              ((lhs.f_coefficients.[ i ] <: i32) +! (rhs.f_coefficients.[ i ] <: i32) <: i32)
             <:
-            t_Array (i32_b (b1 + b2)) (sz 256)
+            t_Array i32 (sz 256)
           }
           <:
-          t_PolynomialRingElement_b (b1 + b2)
-          in
-          assert (forall j. (j >. i /\ j <. sz 256) ==> lhs.f_coefficients.[j] == orig_lhs.f_coefficients.[j]);
-          lhs
-          )
+          t_PolynomialRingElement)
   in
   let _:Prims.unit = () <: Prims.unit in
-  assert (forall j. j <. sz 256 ==> lhs.f_coefficients.[j] == orig_lhs.f_coefficients.[j] +! rhs.f_coefficients.[j]);
   lhs
-  
-  
- 
diff -ruN extraction-edited/Libcrux.Kem.Kyber.Arithmetic.fsti extraction-secret-independent/Libcrux.Kem.Kyber.Arithmetic.fsti
--- extraction-edited/Libcrux.Kem.Kyber.Arithmetic.fsti	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.Arithmetic.fsti	1970-01-01 01:00:00.000000000 +0100
@@ -3,32 +3,10 @@
 open Core
 open FStar.Mul
 
-let pow2_31 = 2147483648
-let i32_range (n:i32) (b:nat) =
-  b < pow2_31 /\ v n <= b /\ v n >= -b
-
-type i32_b b = x:i32{i32_range x b}
-let nat_div_ceil (x:nat) (y:pos) : nat = if (x % y = 0) then x/y else (x/y)+1
-
-val mul_i32_b (#b1:nat) (#b2:nat{b1 * b2 < pow2_31}) (x:i32_b b1) (y: i32_b b2): r:i32_b (b1 * b2){v r == v x * v y}
-val add_i32_b (#b1:nat) (#b2:nat{b1 + b2 < pow2_31}) (x:i32_b b1) (y: i32_b b2): 
-  Pure (i32_b (b1 + b2))
-  (requires True)
-  (ensures fun r -> v r == v x + v y)
-val sub_i32_b (#b1:nat) (#b2:nat{b1 + b2 < pow2_31}) (x:i32_b b1) (y: i32_b b2): r:i32_b (b1 + b2){v r == v x - v y}
-val cast_i32_b (#b1:nat) (#b2:nat{b1 <= b2 /\ b2 < pow2_31}) (x:i32_b b1): r:i32_b b2{v r == v x}
-val shr_i32_b (#b:nat) (#t:inttype) (x:i32_b b) (y:int_t t{v y>0 /\ v y<32}): r:i32_b (nat_div_ceil b (pow2 (v y)))
-
 unfold
 let t_FieldElement = i32
 
 unfold
-let t_FieldElement_b b = i32_b b
-
-unfold
-let wfFieldElement = t_FieldElement_b 3328
-
-unfold
 let t_FieldElementTimesMontgomeryR = i32
 
 unfold
@@ -36,224 +14,122 @@
 
 let v_BARRETT_MULTIPLIER: i64 = 20159L
 
-let v_BARRETT_SHIFT: i64 = 26L
+let v_BARRETT_SHIFT: pub_i64 = 26L
 
-val v_BARRETT_R: x:i64{v x = pow2 26 /\ x = 67108864L}
+let v_BARRETT_R: i64 = 1L <<! v_BARRETT_SHIFT
 
 let v_INVERSE_OF_MODULUS_MOD_R: u32 = 62209ul
 
 let v_MONTGOMERY_R_SQUARED_MOD_FIELD_MODULUS: i32 = 1353l
 
-let v_MONTGOMERY_SHIFT: u8 = 16uy
-
-val v_MONTGOMERY_R: x:i32{v x = pow2 16 /\ x = 65536l}
+let v_MONTGOMERY_SHIFT: pub_u8 = 16uy
 
-val v_MONTGOMERY_R_INV: x:i32{v x >= 0 /\ v x < 3329 /\ (v x * v v_MONTGOMERY_R) % 3329 == 1 /\ x = 169l}
+let v_MONTGOMERY_R: i32 = 1l <<! v_MONTGOMERY_SHIFT
 
-let int_to_spec_fe (m:int) : Spec.Kyber.field_element = 
-    let m_v = m % v Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS in
-    assert (m_v > -  v Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS);
-    if m_v < 0 then
-      m_v + v Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS
-    else m_v
-
-let wf_fe_to_spec_fe (m: wfFieldElement): Spec.Kyber.field_element =
-  if v m < 0
-  then v m + v Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS
-  else v m
-
-let to_spec_fe (m:i32) : Spec.Kyber.field_element = 
-    int_to_spec_fe (v m)
-
-let to_spec_fe_b #b (m:i32_b b) : Spec.Kyber.field_element = to_spec_fe m
-
-let mont_to_spec_fe (m:t_FieldElement) : Spec.Kyber.field_element =
-    int_to_spec_fe (v m * v v_MONTGOMERY_R_INV)
-
-val get_n_least_significant_bits (n: u8 {v n > 0 /\ v n < 32}) (value: u32)
-    : Prims.Pure (int_t_d u32_inttype (v n))
-      (requires v n < 32)
+val get_n_least_significant_bits (n: u8) (value: u32)
+    : Prims.Pure u32
+      (requires n =. 4uy || n =. 5uy || n =. 10uy || n =. 11uy || n =. v_MONTGOMERY_SHIFT)
       (ensures
         fun result ->
           let result:u32 = result in
-          v result = v value % pow2 (v n))
-
-//let barrett_pre (value:i32) = 
-//    v value <= v v_BARRETT_R /\ v value >= - v v_BARRETT_R
-// Appears to work up to +/- 2^28, but not at +/- 2^29
+          v result < v (Core.Num.impl__u32__pow 2ul (Core.Convert.f_into n <: u32) <: u32))
 
-let barrett_post (value:i32) (result:i32) = 
-    v result % v Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS =
-    v value % v Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS
-
-val barrett_reduce (value: i32_b (v v_BARRETT_R))
-    : Prims.Pure wfFieldElement
-    (requires True)
-    (ensures fun r -> barrett_post value r)
-
-let montgomery_post (value:i32) (result:i32) =
-    v result % v Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS =
-    (v value * v v_MONTGOMERY_R_INV) % v Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS
-
-
-val montgomery_reduce #b (value: i32_b b)
-    : Prims.Pure (i32_b (nat_div_ceil b (v v_MONTGOMERY_R) + 1665))
-      (requires True)
+val barrett_reduce (value: i32)
+    : Prims.Pure i32
+      (requires
+        v (Core.Convert.f_from value <: i64) > v (Core.Ops.Arith.Neg.neg v_BARRETT_R <: i64) &&
+        v (Core.Convert.f_from value <: i64) < v v_BARRETT_R)
       (ensures
         fun result ->
           let result:i32 = result in
-          montgomery_post value result)
-
+          v result > v (Core.Ops.Arith.Neg.neg Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS <: i32) &&
+          v result < v Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS)
 
-val montgomery_multiply_sfe_by_fer #b1 #b2 (fe:i32_b b1) (fer: i32_b b2)
-    : Pure (i32_b (nat_div_ceil (b1 * b2) (v v_MONTGOMERY_R) + 1665))
-      (requires (b1 * b2 < pow2_31))
-      (ensures (fun result -> 
-          montgomery_post (mul_i32_b fe fer) (result)))
-      
-
-val to_standard_domain #b (mfe: i32_b b) 
-    : Pure (i32_b (nat_div_ceil (b * 1353) (v v_MONTGOMERY_R) + 1665))
-      (requires (b * 1353 < pow2_31))
-      (ensures (fun result -> 
-          montgomery_post (mul_i32_b mfe (1353l <: i32_b 1353)) result))
-
-
-val to_unsigned_representative (fe: wfFieldElement)
-    : Prims.Pure (int_t_d u16_inttype 12)
-      (requires True)
+val montgomery_reduce (value: i32)
+    : Prims.Pure i32
+      (requires
+       v value >=
+       v ((Core.Ops.Arith.Neg.neg Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS <: i32) *!
+          v_MONTGOMERY_R
+          <:
+          i32) &&
+        v value <= v (Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS *! v_MONTGOMERY_R <: i32))
+      (ensures
+        fun result ->
+          let result:i32 = result in
+          v result >=
+          v ((Core.Ops.Arith.Neg.neg (3l *! Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS <: i32) <: i32
+            ) /!
+            2l
+            <:
+            i32) &&
+          v result <= v ((3l *! Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS <: i32) /! 2l <: i32))
+
+val montgomery_multiply_sfe_by_fer (fe fer: i32)
+    : Prims.Pure i32 Prims.l_True (fun _ -> Prims.l_True)
+
+val to_standard_domain (mfe: i32) : Prims.Pure i32 Prims.l_True (fun _ -> Prims.l_True)
+
+val to_unsigned_representative (fe: i32)
+    : Prims.Pure u16
+      (requires
+        v fe >= v (Core.Ops.Arith.Neg.neg Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS <: i32) &&
+        v fe < v Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS)
       (ensures
         fun result ->
           let result:u16 = result in
-          v result == to_spec_fe fe /\
-          result >=. 0us &&
-          result <. (cast (Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS <: i32) <: u16))
-
-type t_PolynomialRingElement = { f_coefficients:t_Array (t_FieldElement) (sz 256) }
-
-type t_PolynomialRingElement_b b = { f_coefficients:t_Array (i32_b b) (sz 256) }
-
-type wfPolynomialRingElement = t_PolynomialRingElement_b (v Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS - 1)
-
-val derefine_poly_b (#b1:nat) (x:t_PolynomialRingElement_b b1):  
-    r:t_PolynomialRingElement{
-    forall (i:usize). v i < 256 ==> (r.f_coefficients.[i] <: i32) ==  (x.f_coefficients.[i] <: i32)}
-
-val derefine_vector_b (#v_K:usize) (#b:nat) (x:t_Array (t_PolynomialRingElement_b b) v_K):
-    r:t_Array t_PolynomialRingElement v_K{
-    forall (i:usize). (v i < v v_K) ==>
-     (let ri : t_PolynomialRingElement = r.[i] in
-      let xi : t_PolynomialRingElement_b b = x.[i] in
-      ri == derefine_poly_b xi)}
-
-val derefine_matrix_b (#v_K:usize) (#b:nat) 
-  (x:t_Array (t_Array (t_PolynomialRingElement_b b) v_K) v_K) :
-    r:t_Array (t_Array t_PolynomialRingElement v_K) v_K{
-    forall (i:usize). (v i < v v_K) ==>
-     (let ri : t_Array (t_PolynomialRingElement) v_K = r.[i] in
-      let xi : t_Array (t_PolynomialRingElement_b b) v_K = x.[i] in
-      ri == derefine_vector_b xi)}
-
-
-val cast_poly_b (#b1:nat) (#b2:nat{b1 <= b2 /\ b2 < pow2_31}) 
-  (x:t_PolynomialRingElement_b b1)
-  : Pure (t_PolynomialRingElement_b b2) 
-    (requires True)
-    (ensures fun r -> derefine_poly_b x == derefine_poly_b r)
-
-val cast_vector_b (#v_K:usize) (#b1:nat) (#b2:nat{b1 <= b2 /\ b2 < pow2_31}) 
-  (x:t_Array (t_PolynomialRingElement_b b1) v_K)
-  : Pure (t_Array (t_PolynomialRingElement_b b2) v_K)
-    (requires True)
-    (ensures fun r -> derefine_vector_b x == derefine_vector_b r)
-
-let poly_range (#b:nat) (x:t_PolynomialRingElement_b b) (b':nat) =
-  (forall (i:usize). v i < 256 ==> i32_range (x.f_coefficients.[i] <: i32) b')
-
-let vector_range (#v_K:usize) (#b:nat) (x:t_Array (t_PolynomialRingElement_b b) v_K) (b':nat) =
-  (forall (i:usize). v i < v v_K ==> poly_range #b x.[i] b')
-
-val down_cast_poly_b (#b1:nat) (#b2:nat{b2 <= b1 /\ b1 < pow2_31}) 
-  (x:t_PolynomialRingElement_b b1): 
-  Pure (t_PolynomialRingElement_b b2)
-  (requires (poly_range x b2))
-  (ensures fun r ->  derefine_poly_b x == derefine_poly_b r) 
-
-val down_cast_vector_b (#v_K:usize) (#b1:nat) (#b2:nat{b2 <= b1 /\ b1 < pow2_31}) 
-  (x:t_Array (t_PolynomialRingElement_b b1) v_K): 
-  Pure (t_Array (t_PolynomialRingElement_b b2) v_K)
-  (requires (vector_range x b2))
-  (ensures fun r ->  derefine_vector_b x == derefine_vector_b r) 
-
-let op_String_Access #t #l (a:t_Array t l) (i:usize{v i < v l}) : t = a.[i]
-
-let wf_poly_to_spec_poly (re: wfPolynomialRingElement): Spec.Kyber.polynomial =
-    let p = Spec.Kyber.map' (fun x -> wf_fe_to_spec_fe x <: nat) re.f_coefficients in
-    introduce forall i. Seq.index p i < v Spec.Kyber.v_FIELD_MODULUS
-    with assert (Seq.index p i == Seq.index p (v (sz i)));
-    p
-
-let to_spec_poly (m:t_PolynomialRingElement) : (Spec.Kyber.polynomial) =
-    let p = createi #nat (sz 256) (fun i -> to_spec_fe (m.f_coefficients.[i])) in
-    assert (forall i. Seq.index p i = to_spec_fe (m.f_coefficients.[sz i]));
-    assert (forall i. Seq.index p i < v Spec.Kyber.v_FIELD_MODULUS);
-    p
-
-let to_spec_poly_b #b (m:t_PolynomialRingElement_b b) : (Spec.Kyber.polynomial) =
-    to_spec_poly (derefine_poly_b m)
-
-let mont_to_spec_poly (m:t_PolynomialRingElement) : (Spec.Kyber.polynomial) =
-    let p = createi #nat (sz 256) (fun i -> mont_to_spec_fe (m.f_coefficients.[i])) in
-    assert (forall i. Seq.index p i = mont_to_spec_fe (m.f_coefficients.[sz i]));
-    assert (forall i. Seq.index p i < v Spec.Kyber.v_FIELD_MODULUS);
-    p
-
-
-let to_spec_vector (#p:Spec.Kyber.params)
-                   (m:t_Array (t_PolynomialRingElement) p.v_RANK)
-                   : (Spec.Kyber.vector p) =
-    createi p.v_RANK (fun i -> to_spec_poly (m.[i]))
-
-
-let to_spec_vector_b (#p:Spec.Kyber.params) (#b:nat)
-                   (m:t_Array (t_PolynomialRingElement_b b) p.v_RANK)
-                   : (Spec.Kyber.vector p) =
-    to_spec_vector (derefine_vector_b m)
-
-let mont_to_spec_vector (#p:Spec.Kyber.params)
-                   (m:t_Array (t_PolynomialRingElement) p.v_RANK)
-                   : (Spec.Kyber.vector p) =
-    createi p.v_RANK (fun i -> mont_to_spec_poly (m.[i]))
-
-let mont_to_spec_vector_b (#p:Spec.Kyber.params) (#b:nat)
-                   (m:t_Array (t_PolynomialRingElement_b b) p.v_RANK)
-                   : (Spec.Kyber.vector p) =
-    mont_to_spec_vector (derefine_vector_b m)
-
-let to_spec_matrix (#p:Spec.Kyber.params) 
-                   (m:(t_Array (t_Array (t_PolynomialRingElement) p.v_RANK) p.v_RANK))
-                   : (Spec.Kyber.matrix p) =
-    createi p.v_RANK (fun i -> to_spec_vector (m.[i]))
-
-let to_spec_matrix_b (#p:Spec.Kyber.params) (#b:nat)
-                   (m:(t_Array (t_Array (t_PolynomialRingElement_b b) p.v_RANK) p.v_RANK))
-                   : (Spec.Kyber.matrix p) =
-    to_spec_matrix (derefine_matrix_b m)
-
-let mont_to_spec_matrix (#p:Spec.Kyber.params) 
-                   (m:(t_Array (t_Array (t_PolynomialRingElement) p.v_RANK) p.v_RANK))
-                   : (Spec.Kyber.matrix p) =
-    createi p.v_RANK (fun i -> mont_to_spec_vector (m.[i]))
-
-let impl__PolynomialRingElement__ZERO: t_PolynomialRingElement_b 1 =
-  { f_coefficients = Rust_primitives.Hax.repeat (0l <: i32_b 1) (sz 256) } <: t_PolynomialRingElement_b 1
-
-val add_to_ring_element (#b1:nat) (#b2:nat{b1 + b2 < pow2_31}) (v_K: usize) (lhs: t_PolynomialRingElement_b b1) (rhs: t_PolynomialRingElement_b b2)
-    : Prims.Pure (t_PolynomialRingElement_b (b1 + b2))
-      (requires True) 
-      (ensures fun result ->
-        (forall i. v result.f_coefficients.[i] == v lhs.f_coefficients.[i] + v rhs.f_coefficients.[i]))
-
+          v result >= v 0us &&
+          v result < v (cast (Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS <: i32) <: u16))
 
+type t_PolynomialRingElement = { f_coefficients:t_Array i32 (sz 256) }
 
+let impl__PolynomialRingElement__ZERO: t_PolynomialRingElement =
+  { f_coefficients = Rust_primitives.Hax.repeat 0l (sz 256) } <: t_PolynomialRingElement
 
+val add_to_ring_element (v_K: usize) (lhs rhs: t_PolynomialRingElement)
+    : Prims.Pure t_PolynomialRingElement
+      (requires
+        Hax_lib.v_forall (fun i ->
+              let i:usize = i in
+              Hax_lib.implies (i <. Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
+                  <:
+                  bool)
+                (fun temp_0_ ->
+                    let _:Prims.unit = temp_0_ in
+                    let lhs_i = (lhs.f_coefficients.[ i ] <: i32) in
+                    (v (Core.Num.impl__i32__abs lhs_i <: i32) <=
+                      v (((cast (v_K <: usize) <: pub_i32) -! 1l <: i32) *!
+                        Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS
+                        <:
+                        i32)
+                      <:
+                      bool) &&
+                    (v (Core.Num.impl__i32__abs (rhs.f_coefficients.[ i ] <: i32) <: i32) <=
+                      v Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS
+                      <:
+                      bool))
+              <:
+              bool))
+      (ensures
+        fun result ->
+          let result:t_PolynomialRingElement = result in
+          Hax_lib.v_forall (fun i ->
+                let i:usize = i in
+                Hax_lib.implies (i <.
+                    (Core.Slice.impl__len (Rust_primitives.unsize result.f_coefficients
+                          <:
+                          t_Slice i32)
+                      <:
+                      usize)
+                    <:
+                    bool)
+                  (fun temp_0_ ->
+                      let _:Prims.unit = temp_0_ in
+                      v (Core.Num.impl__i32__abs (result.f_coefficients.[ i ] <: i32) <: i32) <=
+                      v ((cast (v_K <: usize) <: pub_i32) *! Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS
+                        <:
+                        i32)
+                      <:
+                      bool)
+                <:
+                bool))
diff -ruN extraction-edited/Libcrux.Kem.Kyber.Compress.fst extraction-secret-independent/Libcrux.Kem.Kyber.Compress.fst
--- extraction-edited/Libcrux.Kem.Kyber.Compress.fst	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.Compress.fst	1970-01-01 01:00:00.000000000 +0100
@@ -1,79 +1,39 @@
 module Libcrux.Kem.Kyber.Compress
-#set-options "--fuel 0 --ifuel 0 --z3rlimit 200"
+#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
 open Core
 open FStar.Mul
 
-let compress_message_coefficient fe =
-  let (shifted: i16):i16 = 1664s -! (cast (fe <: u16) <: i16) in
-  assert (v shifted == 1664 - v fe);
-  let mask:i16 = shifted >>! 15l in
-  assert (v mask = v shifted / pow2 15);
-  assert (if v shifted < 0 then mask = ones else mask = zero);
-  let shifted_to_positive:i16 = mask ^. shifted in
-  logxor_lemma shifted mask;
-  assert (v shifted < 0 ==> v shifted_to_positive = v (lognot shifted));
-  neg_equiv_lemma shifted;
-  assert (v (lognot shifted) = -(v shifted) -1);
-  assert (v shifted >= 0 ==> v shifted_to_positive = v (mask `logxor` shifted));
-  assert (v shifted >= 0 ==> mask = zero);
-  assert (v shifted >= 0 ==> mask ^. shifted = shifted);
-  assert (v shifted >= 0 ==> v shifted_to_positive = v shifted);
-  assert (shifted_to_positive >=. 0s);
-  let shifted_positive_in_range:i16 = shifted_to_positive -! 832s in
-  assert (1664 - v fe >= 0 ==> v shifted_positive_in_range == 832 - v fe);
-  assert (1664 - v fe < 0 ==> v shifted_positive_in_range == -2497 + v fe);
-  let r0 = shifted_positive_in_range >>! 15l in
-  let r1 = r0 &. 1s in
-  let res = cast (r1) <: u8 in
-  assert (v r0 = v shifted_positive_in_range / pow2 15);
-  assert (if v shifted_positive_in_range < 0 then r0 = ones else r0 = zero);
-  logand_lemma 1s r0; 
-  assert (if v shifted_positive_in_range < 0 then r1 = 1s else r1 = 0s);
-  assert ((v fe >= 833 && v fe <= 2496) ==> r1 = 1s);
-  assert (v fe < 833 ==> r1 = 0s);
-  assert (v fe > 2496 ==> r1 = 0s);
-  assert (v res = v r1);
-  res
-
-let compress_ciphertext_coefficient coefficient_bits fe =
+let compress_ciphertext_coefficient (coefficient_bits: pub_u8) (fe: u16) =
   let _:Prims.unit = () <: Prims.unit in
   let _:Prims.unit = () <: Prims.unit in
-  let compressed:u32 = (cast (fe <: u16) <: u32) <<! (coefficient_bits +! 1uy <: u8) in
-  let compressed:u32 =
-    compressed +! (cast (Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS <: i32) <: u32)
-  in
-  let compressed:u32 =
-    compressed /! (cast (Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS <<! 1l <: i32) <: u32)
-  in
-  let res = cast (Libcrux.Kem.Kyber.Arithmetic.get_n_least_significant_bits coefficient_bits compressed <: u32
-    )
+  let compressed:u64 = (cast (fe <: u16) <: u64) <<! coefficient_bits in
+  let compressed:u64 = compressed +! 1664uL in
+  let compressed:u64 = compressed *! 10321340uL in
+  let compressed:u64 = compressed >>! 35l in
+  cast (Libcrux.Kem.Kyber.Arithmetic.get_n_least_significant_bits coefficient_bits
+        (cast (compressed <: u64) <: u32)
+      <:
+      u32)
   <:
   i32
-  in
-  res
 
-#push-options "--z3rlimit 300"
-let decompress_ciphertext_coefficient coefficient_bits fe =
+let compress_message_coefficient (fe: u16) =
+  let (shifted: i16):i16 = 1664s -! (cast (fe <: u16) <: i16) in
+  let mask:i16 = shifted >>! 15l in
+  let shifted_to_positive:i16 = mask ^. shifted in
+  let shifted_positive_in_range:i16 = shifted_to_positive -! 832s in
+  cast ((shifted_positive_in_range >>! 15l <: i16) &. 1s <: i16) <: u8
+
+let decompress_ciphertext_coefficient (coefficient_bits: pub_u8) (fe: i32) =
   let _:Prims.unit = () <: Prims.unit in
   let _:Prims.unit = () <: Prims.unit in
-  assert (v (1ul <<! coefficient_bits) <= pow2 11);
-  assert (v fe < pow2 11);
   let decompressed:u32 =
     (cast (fe <: i32) <: u32) *! (cast (Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS <: i32) <: u32)
   in
   let decompressed:u32 = (decompressed <<! 1l <: u32) +! (1ul <<! coefficient_bits <: u32) in
-  let decompressed:u32 = decompressed >>! (coefficient_bits +! 1uy <: u8) in
-  let res = cast (decompressed <: u32) <: i32 in
-  let res : Libcrux.Kem.Kyber.Arithmetic.i32_b 3328 = res in
-  res
+  let decompressed:u32 = decompressed >>! (coefficient_bits +! 1uy <: pub_u8) in
+  cast (decompressed <: u32) <: i32
 
-let decompress_message_coefficient fe =
-  let res = (Core.Ops.Arith.Neg.neg fe <: i32) &.
-             ((Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS +! 1l <: i32) /! 2l <: i32) in
-  assert (v ((Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS +! 1l <: i32) /! 2l <: i32) == 1665);
-  assert (res == logand #i32_inttype (Core.Ops.Arith.Neg.neg fe) 1665l);
-  assert (v fe == 0 ==> Core.Ops.Arith.Neg.neg fe = zero);
-  logand_lemma 1665l zero;
-  assert (v fe == 0 ==> res == zero);
-  res <: Libcrux.Kem.Kyber.Arithmetic.i32_b 3328
-#pop-options
+let decompress_message_coefficient (fe: i32) =
+  (Core.Ops.Arith.Neg.neg fe <: i32) &.
+  ((Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS +! 1l <: i32) /! 2l <: i32)
diff -ruN extraction-edited/Libcrux.Kem.Kyber.Compress.fsti extraction-secret-independent/Libcrux.Kem.Kyber.Compress.fsti
--- extraction-edited/Libcrux.Kem.Kyber.Compress.fsti	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.Compress.fsti	1970-01-01 01:00:00.000000000 +0100
@@ -3,42 +3,44 @@
 open Core
 open FStar.Mul
 
+val compress_ciphertext_coefficient (coefficient_bits: u8) (fe: u16)
+    : Prims.Pure i32
+      (requires
+        (coefficient_bits =. 4uy || coefficient_bits =. 5uy || coefficient_bits =. 10uy ||
+        coefficient_bits =. 11uy) &&
+        v fe < v (cast (Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS <: i32) <: u16))
+      (ensures
+        fun result ->
+          let result:i32 = result in
+          v result >= v 0l &&
+          v result < v (Core.Num.impl__i32__pow 2l (cast (coefficient_bits <: u8) <: u32) <: i32))
+
 val compress_message_coefficient (fe: u16)
     : Prims.Pure u8
-      (requires v fe < 3329)
+      (requires v fe < v (cast (Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS <: i32) <: u16))
       (ensures
         fun result ->
           let result:u8 = result in
-          if 833 <= v fe && v fe <=  2496
-          then result =. 1uy
-          else result =. 0uy)
+          Hax_lib.implies ((833us <=. fe <: bool) && (fe <=. 2596us <: bool))
+            (fun temp_0_ ->
+                let _:Prims.unit = temp_0_ in
+                v result = v 1uy <: bool) &&
+          Hax_lib.implies (~.((833us <=. fe <: bool) && (fe <=. 2596us <: bool)) <: bool)
+            (fun temp_0_ ->
+                let _:Prims.unit = temp_0_ in
+                v result = v 0uy <: bool))
 
-
-val compress_ciphertext_coefficient (coefficient_bits: u8 {v coefficient_bits > 0 /\ v coefficient_bits <= 32}) (fe: u16)
-    : Prims.Pure (int_t_d i32_inttype (v coefficient_bits))
+val decompress_ciphertext_coefficient (coefficient_bits: u8) (fe: i32)
+    : Prims.Pure i32
       (requires
         (coefficient_bits =. 4uy || coefficient_bits =. 5uy || coefficient_bits =. 10uy ||
         coefficient_bits =. 11uy) &&
-        fe <. (cast (Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS <: i32) <: u16))
-      (ensures
-        fun result ->
-          let result:i32 = result in
-          result >=. 0l &&
-          result <. (Core.Num.impl__i32__pow 2l (cast (coefficient_bits <: u8) <: u32) <: i32))
-
-open Rust_primitives.Integers
-
-val decompress_ciphertext_coefficient
-    (coefficient_bits: u8 {coefficient_bits =. 4uy || coefficient_bits =. 5uy || coefficient_bits =. 10uy || coefficient_bits =. 11uy})
-    (fe: int_t_d i32_inttype (v coefficient_bits))
-    : Prims.Pure (Libcrux.Kem.Kyber.Arithmetic.i32_b (v Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS - 1))
-      (requires True)
+        v fe >= v 0l &&
+        v fe < v (Core.Num.impl__i32__pow 2l (cast (coefficient_bits <: u8) <: u32) <: i32))
       (ensures
         fun result ->
           let result:i32 = result in
-          result <. Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS)
+          v result < v Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS)
 
 val decompress_message_coefficient (fe: i32)
-    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.wfFieldElement
-      (requires fe =. 0l || fe =. 1l) 
-      (fun result -> v result >= 0 /\ v result < 3329)
+    : Prims.Pure i32 (requires fe =. 0l || fe =. 1l) (fun _ -> Prims.l_True)
diff -ruN extraction-edited/Libcrux.Kem.Kyber.Constant_time_ops.fst extraction-secret-independent/Libcrux.Kem.Kyber.Constant_time_ops.fst
--- extraction-edited/Libcrux.Kem.Kyber.Constant_time_ops.fst	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.Constant_time_ops.fst	1970-01-01 01:00:00.000000000 +0100
@@ -4,163 +4,61 @@
 open FStar.Mul
 
 let is_non_zero (value: u8) =
-  let orig_value = value in
   let value:u16 = cast (value <: u8) <: u16 in
-  let result:u8 = cast ((Core.Num.impl__u16__wrapping_add (~.value <: u16) 1us <: u16) >>! 8l <: u16) in
-  let res:u8 = result &. 1uy in
-  if v orig_value = 0 then  (
-    assert(value == zero);
-    lognot_lemma value;
-    assert((~.value +. 1us) == zero);
-    assert((Core.Num.impl__u16__wrapping_add (~.value <: u16) 1us <: u16) == zero);
-    logor_lemma value zero;
-    assert((value |. (Core.Num.impl__u16__wrapping_add (~.value <: u16) 1us <: u16) <: u16) == value);
-    assert (v result == v ((value >>! 8l)));
-    assert ((v value / pow2 8) == 0);
-    assert (result == 0uy);
-    logand_lemma 1uy result;
-    assert (res == 0uy);
-    res)
-  else (
-    assert (v value <> 0);
-    lognot_lemma value;
-    assert (v (~.value) = pow2 16 - 1 - v value);
-    assert (v (~.value) + 1 = pow2 16 - v value);
-    assert (v (value) <= pow2 8 - 1);
-    assert ((v (~.value) + 1) = (pow2 16 - pow2 8) + (pow2 8 - v value));
-    assert ((v (~.value) + 1) = (pow2 8 - 1) * pow2 8 + (pow2 8 - v value));
-    assert ((v (~.value) + 1)/pow2 8 = (pow2 8 - 1));
-    assert (v ((Core.Num.impl__u16__wrapping_add (~.value <: u16) 1us <: u16) >>! 8l) = pow2 8 - 1);
-    assert (result = ones);
-    logand_lemma 1uy result;
-    assert (res = 1uy);
-    res
-  )
+  let result:u16 =
+    ((value |. (Core.Num.impl__u16__wrapping_add (~.value <: u16) 1us <: u16) <: u16) >>! 8l <: u16) &.
+    1us
+  in
+  cast (result <: u16) <: u8
 
-let compare_ciphertexts_in_constant_time v_CIPHERTEXT_SIZE lhs rhs =
+let compare_ciphertexts_in_constant_time (v_CIPHERTEXT_SIZE: usize) (lhs rhs: t_Slice u8) =
   let _:Prims.unit = () <: Prims.unit in
   let _:Prims.unit = () <: Prims.unit in
   let (r: u8):u8 = 0uy in
-  [@ inline_let]
-  let inv = fun (acc:u8) (i:usize) ->
-    v i <= v v_CIPHERTEXT_SIZE /\
-   (if (Seq.slice lhs 0 (v i) = Seq.slice rhs 0 (v i)) then
-      acc == 0uy
-    else ~ (acc == 0uy))
-  in
   let r:u8 =
-    Rust_primitives.Iterators.foldi_range #_ #u8  #inv {
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
               Core.Ops.Range.f_start = sz 0;
               Core.Ops.Range.f_end = v_CIPHERTEXT_SIZE
             }
+            <:
+            Core.Ops.Range.t_Range usize)
+        <:
+        Core.Ops.Range.t_Range usize)
       r
       (fun r i ->
           let r:u8 = r in
           let i:usize = i in
-          let nr = r |. ((lhs.[ i ] <: u8) ^. (rhs.[ i ] <: u8) <: u8) <: u8 in
-          if r =. 0uy then (
-            if (Seq.index lhs (v i) = Seq.index rhs (v i)) then (
-               logxor_lemma (Seq.index lhs (v i)) (Seq.index rhs (v i));
-               assert (((lhs.[ i ] <: u8) ^. (rhs.[ i ] <: u8) <: u8) = zero);
-               logor_lemma r ((lhs.[ i ] <: u8) ^. (rhs.[ i ] <: u8) <: u8);
-               assert (nr = r);
-               assert (forall j. Seq.index (Seq.slice lhs 0 (v i)) j == Seq.index lhs j);
-               assert (forall j. Seq.index (Seq.slice rhs 0 (v i)) j == Seq.index rhs j);
-               eq_intro (Seq.slice lhs 0 (v i + 1)) (Seq.slice rhs 0 (v i + 1));
-               nr
-            )
-            else (
-               logxor_lemma (Seq.index lhs (v i)) (Seq.index rhs (v i));
-               assert (((lhs.[ i ] <: u8) ^. (rhs.[ i ] <: u8) <: u8) <>  zero);
-               logor_lemma r ((lhs.[ i ] <: u8) ^. (rhs.[ i ] <: u8) <: u8);
-               assert (v nr > 0);
-               assert (Seq.index (Seq.slice lhs 0 (v i+1)) (v i) <> 
-                       Seq.index (Seq.slice rhs 0 (v i+1)) (v i));
-               assert (Seq.slice lhs 0 (v i+1) <> Seq.slice rhs 0 (v i + 1));
-               nr
-            )
-          ) else (
-            logor_lemma r ((lhs.[ i ] <: u8) ^. (rhs.[ i ] <: u8) <: u8);
-            assert (v nr >= v r);
-            assert (Seq.slice lhs 0 (v i) <> Seq.slice rhs 0 (v i));
-            if (Seq.slice lhs 0 (v i+1) = Seq.slice rhs 0 (v i + 1)) then
-              (assert (forall j. j < v i + 1 ==> Seq.index (Seq.slice lhs 0 (v i+1)) j == Seq.index (Seq.slice rhs 0 (v i+1)) j);
-               eq_intro (Seq.slice lhs 0 (v i)) (Seq.slice rhs 0 (v i));
-               assert(False))
-            else nr
-          )
-     )
+          r |. ((lhs.[ i ] <: u8) ^. (rhs.[ i ] <: u8) <: u8) <: u8)
   in
-  let res = is_non_zero r in
-  res
+  is_non_zero r
 
-#push-options "--ifuel 0 --z3rlimit 50"
 let select_shared_secret_in_constant_time (lhs rhs: t_Slice u8) (selector: u8) =
   let _:Prims.unit = () <: Prims.unit in
   let _:Prims.unit = () <: Prims.unit in
   let mask:u8 = Core.Num.impl__u8__wrapping_sub (is_non_zero selector <: u8) 1uy in
-  assert (if selector = 0uy then mask = ones else mask = zero);
-  lognot_lemma mask;
-  assert (if selector = 0uy then ~.mask = zero else ~.mask = ones);
   let out:t_Array u8 (sz 32) = Rust_primitives.Hax.repeat 0uy (sz 32) in
-  [@ inline_let]
-  let inv = fun (acc:t_Array u8 (sz 32)) (i:usize) ->
-    v i <= 32 /\
-   (forall j. j < v i ==> (if (selector =. 0uy) then Seq.index acc j == Seq.index lhs j else Seq.index acc j == Seq.index rhs j)) /\
-   (forall j. j >= v i ==> Seq.index acc j == 0uy)
-  in
   let out:t_Array u8 (sz 32) =
-    Rust_primitives.Iterators.foldi_range #_ #(t_Array u8 (sz 32))  #inv {
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
               Core.Ops.Range.f_start = sz 0;
               Core.Ops.Range.f_end = Libcrux.Kem.Kyber.Constants.v_SHARED_SECRET_SIZE
             }
+            <:
+            Core.Ops.Range.t_Range usize)
+        <:
+        Core.Ops.Range.t_Range usize)
       out
       (fun out i ->
           let out:t_Array u8 (sz 32) = out in
-          assert ((out.[ i ] <: u8) = 0uy);
-          let outi = 
+          let i:usize = i in
+          Rust_primitives.Hax.Monomorphized_update_at.update_at_usize out
+            i
             ((out.[ i ] <: u8) |.
               (((lhs.[ i ] <: u8) &. mask <: u8) |. ((rhs.[ i ] <: u8) &. (~.mask <: u8) <: u8)
                 <:
                 u8)
               <:
-              u8) in
-          if (selector = 0uy) then (
-            logand_lemma (lhs.[ i ] <: u8) mask;
-            assert (((lhs.[ i ] <: u8) &. mask <: u8) == (lhs.[ i ] <: u8));
-            logand_lemma (rhs.[ i ] <: u8) (~.mask);
-            assert (((rhs.[ i ] <: u8) &. (~.mask <: u8) <: u8) == zero);
-            logor_lemma ((lhs.[ i ] <: u8) &. mask <: u8) ((rhs.[ i ] <: u8) &. (~.mask <: u8) <: u8);
-            assert ((((lhs.[ i ] <: u8) &. mask <: u8) |. ((rhs.[ i ] <: u8) &. (~.mask <: u8) <: u8) <: u8) == (lhs.[ i ] <: u8));
-            logor_lemma (out.[ i ] <: u8) (lhs.[ i ] <: u8);
-            assert (((out.[ i ] <: u8) |. (((lhs.[ i ] <: u8) &. mask <: u8) |. ((rhs.[ i ] <: u8) &. (~.mask <: u8) <: u8) <: u8) <: u8) == (lhs.[ i ] <: u8));
-            assert (outi = (lhs.[ i ] <: u8))
-          )
-          else (
-            logand_lemma (lhs.[ i ] <: u8) mask;
-            assert (((lhs.[ i ] <: u8) &. mask <: u8) == zero);
-            logand_lemma (rhs.[ i ] <: u8) (~.mask);
-            assert (((rhs.[ i ] <: u8) &. (~.mask <: u8) <: u8) == (rhs.[ i ] <: u8));
-            logor_lemma (rhs.[ i ] <: u8) zero;
-            assert ((logor zero (rhs.[ i ] <: u8)) == (rhs.[ i ] <: u8));
-            assert ((((lhs.[ i ] <: u8) &. mask <: u8) |. ((rhs.[ i ] <: u8) &. (~.mask <: u8) <: u8)) == (rhs.[ i ] <: u8));
-            logor_lemma (out.[ i ] <: u8) (rhs.[ i ] <: u8);
-            assert (((out.[ i ] <: u8) |. (((lhs.[ i ] <: u8) &. mask <: u8) |. ((rhs.[ i ] <: u8) &. (~.mask <: u8) <: u8) <: u8) <: u8) == (rhs.[ i ] <: u8));
-            assert (outi = (rhs.[ i ] <: u8))
-          );
-          let i:usize = i in
-          Rust_primitives.Hax.Monomorphized_update_at.update_at_usize out
-            i
-            outi
+              u8)
           <:
           t_Array u8 (sz 32))
   in
-  if (selector =. 0uy) then (
-    eq_intro out lhs;
-    out
-  )
-  else (
-    eq_intro out rhs;
-    out
-  )
-#pop-options
+  out
diff -ruN extraction-edited/Libcrux.Kem.Kyber.Constant_time_ops.fsti extraction-secret-independent/Libcrux.Kem.Kyber.Constant_time_ops.fsti
--- extraction-edited/Libcrux.Kem.Kyber.Constant_time_ops.fsti	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.Constant_time_ops.fsti	1970-01-01 01:00:00.000000000 +0100
@@ -20,26 +20,30 @@
 
 val compare_ciphertexts_in_constant_time (v_CIPHERTEXT_SIZE: usize) (lhs rhs: t_Slice u8)
     : Prims.Pure u8
-      (requires (length lhs == v_CIPHERTEXT_SIZE /\
-                 length rhs == v_CIPHERTEXT_SIZE))
+      Prims.l_True
       (ensures
         fun result ->
           let result:u8 = result in
-          Hax_lib.implies (lhs =. rhs <: bool)
+          Hax_lib.implies (lhs = rhs)
             (fun temp_0_ ->
                 let _:Prims.unit = temp_0_ in
-                result =. 0uy <: bool) &&
-          Hax_lib.implies (lhs <>. rhs <: bool)
+                v result = v 0uy <: bool) &&
+          Hax_lib.implies (lhs <> rhs)
             (fun temp_0_ ->
                 let _:Prims.unit = temp_0_ in
-                result =. 1uy <: bool))
+                v result = v 1uy <: bool))
 
 val select_shared_secret_in_constant_time (lhs rhs: t_Slice u8) (selector: u8)
     : Prims.Pure (t_Array u8 (sz 32))
-      (requires (length lhs == Libcrux.Kem.Kyber.Constants.v_SHARED_SECRET_SIZE /\
-                 length rhs == Libcrux.Kem.Kyber.Constants.v_SHARED_SECRET_SIZE))
+      Prims.l_True
       (ensures
         fun result ->
           let result:t_Array u8 (sz 32) = result in
-          Hax_lib.implies (selector =. 0uy <: bool) (fun _ -> result =. lhs <: bool) &&
-          Hax_lib.implies (selector <>. 0uy <: bool) (fun _ -> result =. rhs <: bool))
+          Hax_lib.implies (selector =. 0uy <: bool)
+            (fun temp_0_ ->
+                let _:Prims.unit = temp_0_ in
+                result = lhs <: bool) &&
+          Hax_lib.implies (selector <>. 0uy <: bool)
+            (fun temp_0_ ->
+                let _:Prims.unit = temp_0_ in
+                result = rhs <: bool))
diff -ruN extraction-edited/Libcrux.Kem.Kyber.Conversions.fst extraction-secret-independent/Libcrux.Kem.Kyber.Conversions.fst
--- extraction-edited/Libcrux.Kem.Kyber.Conversions.fst	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.Conversions.fst	1970-01-01 01:00:00.000000000 +0100
@@ -0,0 +1,87 @@
+module Libcrux.Kem.Kyber.Conversions
+#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
+open Core
+
+let into_padded_array (#v_LEN: usize) (slice: t_Slice u8) : t_Array u8 v_LEN =
+  let _:Prims.unit =
+    if true
+    then
+      let _:Prims.unit =
+        if ~.((Core.Slice.impl__len slice <: usize) <=. v_LEN <: bool)
+        then
+          Rust_primitives.Hax.never_to_any (Core.Panicking.panic "assertion failed: slice.len() <= LEN"
+
+              <:
+              Rust_primitives.Hax.t_Never)
+      in
+      ()
+  in
+  let out:t_Array u8 v_LEN = Rust_primitives.Hax.repeat 0uy v_LEN in
+  let out:t_Array u8 v_LEN =
+    Rust_primitives.Hax.update_at out
+      ({ Core.Ops.Range.f_start = sz 0; Core.Ops.Range.f_end = Core.Slice.impl__len slice <: usize }
+      )
+      (Core.Slice.impl__copy_from_slice (Core.Ops.Index.IndexMut.index_mut out
+              ({
+                  Core.Ops.Range.f_start = sz 0;
+                  Core.Ops.Range.f_end = Core.Slice.impl__len slice <: usize
+                })
+            <:
+            t_Slice u8)
+          slice
+        <:
+        t_Slice u8)
+  in
+  out
+
+class t_UpdatingArray (#v_Self: Type) = { f_push:v_Self -> t_Slice u8 -> v_Self }
+
+type t_UpdatableArray (v_LEN: usize) = {
+  f_value:t_Array u8 v_LEN;
+  f_pointer:usize
+}
+
+let impl__new (#v_LEN: usize) (value: t_Array u8 v_LEN) : t_UpdatableArray v_LEN =
+  { f_value = value; f_pointer = sz 0 }
+
+let impl__array (#v_LEN: usize) (self: t_UpdatableArray v_LEN) : t_Array u8 v_LEN = self.f_value
+
+let impl_1 (#v_LEN: usize) : t_UpdatingArray (t_UpdatableArray v_LEN) =
+  {
+    f_push
+    =
+    fun (self: t_UpdatableArray v_LEN) (other: t_Slice u8) ->
+      let self:t_UpdatableArray v_LEN =
+        {
+          self with
+          f_value
+          =
+          Rust_primitives.Hax.update_at (f_value self <: t_UpdatableArray v_LEN)
+            ({
+                Core.Ops.Range.f_start = self.f_pointer;
+                Core.Ops.Range.f_end
+                =
+                self.f_pointer +! (Core.Slice.impl__len other <: usize) <: usize
+              })
+            (Core.Slice.impl__copy_from_slice (Core.Ops.Index.IndexMut.index_mut self.f_value
+                    ({
+                        Core.Ops.Range.f_start = self.f_pointer;
+                        Core.Ops.Range.f_end
+                        =
+                        self.f_pointer +! (Core.Slice.impl__len other <: usize) <: usize
+                      })
+                  <:
+                  t_Slice u8)
+                other
+              <:
+              t_Slice u8)
+        }
+      in
+      let self:t_UpdatableArray v_LEN =
+        { self with f_pointer = self.f_pointer +! (Core.Slice.impl__len other <: usize) }
+      in
+      self
+  }
+
+let to_unsigned_representative (fe: i32) : u16 =
+  cast (fe +! ((fe >>! 15l <: i32) &. Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS <: i32)) <: u16
\ Pas de fin de ligne  la fin du fichier
diff -ruN extraction-edited/Libcrux.Kem.Kyber.fst extraction-secret-independent/Libcrux.Kem.Kyber.fst
--- extraction-edited/Libcrux.Kem.Kyber.fst	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.fst	1970-01-01 01:00:00.000000000 +0100
@@ -1,29 +1,12 @@
 module Libcrux.Kem.Kyber
-#set-options "--fuel 0 --ifuel 1 --z3rlimit 100"
+#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
 open Core
 open FStar.Mul
 
-let update_at_range_lemma #n
-  (s: t_Slice 't)
-  (i: Core.Ops.Range.t_Range (int_t n) {(Core.Ops.Range.impl_index_range_slice 't n).f_index_pre s i}) 
-  (x: t_Slice 't)
-  : Lemma
-    (requires (Seq.length x == v i.f_end - v i.f_start))
-    (ensures (
-      let s' = Rust_primitives.Hax.Monomorphized_update_at.update_at_range s i x in
-      let len = v i.f_start in
-      forall (i: nat). i < len ==> Seq.index s i == Seq.index s' i
-    ))
-    [SMTPat (Rust_primitives.Hax.Monomorphized_update_at.update_at_range s i x)]
-  = let s' = Rust_primitives.Hax.Monomorphized_update_at.update_at_range s i x in
-    let len = v i.f_start in
-    introduce forall (i:nat {i < len}). Seq.index s i == Seq.index s' i
-    with (assert ( Seq.index (Seq.slice s  0 len) i == Seq.index s  i 
-                 /\ Seq.index (Seq.slice s' 0 len) i == Seq.index s' i ))
-
-let serialize_kem_secret_key #p
+let serialize_kem_secret_key
       (v_SERIALIZED_KEY_LEN: usize)
-      (private_key public_key implicit_rejection_value: t_Slice u8) =
+      (private_key public_key implicit_rejection_value: t_Slice u8)
+     =
   let out:t_Array u8 v_SERIALIZED_KEY_LEN = Rust_primitives.Hax.repeat 0uy v_SERIALIZED_KEY_LEN in
   let pointer:usize = sz 0 in
   let out:t_Array u8 v_SERIALIZED_KEY_LEN =
@@ -72,8 +55,6 @@
         t_Slice u8)
   in
   let pointer:usize = pointer +! (Core.Slice.impl__len public_key <: usize) in
-  let h_public_key = (Rust_primitives.unsize (Libcrux.Kem.Kyber.Hash_functions.v_H public_key)
-                     <: t_Slice u8) in
   let out:t_Array u8 v_SERIALIZED_KEY_LEN =
     Rust_primitives.Hax.Monomorphized_update_at.update_at_range out
       ({
@@ -89,7 +70,16 @@
                 pointer +! Libcrux.Kem.Kyber.Constants.v_H_DIGEST_SIZE <: usize
               }
               <:
-              Core.Ops.Range.t_Range usize ]) h_public_key)
+              Core.Ops.Range.t_Range usize ]
+            <:
+            t_Slice u8)
+          (Rust_primitives.unsize (Libcrux.Kem.Kyber.Hash_functions.v_H public_key
+                <:
+                t_Array u8 (sz 32))
+            <:
+            t_Slice u8)
+        <:
+        t_Slice u8)
   in
   let pointer:usize = pointer +! Libcrux.Kem.Kyber.Constants.v_H_DIGEST_SIZE in
   let out:t_Array u8 v_SERIALIZED_KEY_LEN =
@@ -116,32 +106,14 @@
         <:
         t_Slice u8)
   in
-  assert (Seq.slice out 0 (v #usize_inttype (Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p)) `Seq.equal` private_key);
-  assert (Seq.slice out (v #usize_inttype (Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p))
-                        (v #usize_inttype (Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p +! Spec.Kyber.v_CPA_PKE_PUBLIC_KEY_SIZE p)) `Seq.equal` public_key);
-  assert (Seq.slice out (v #usize_inttype (Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p +!
-                                           Spec.Kyber.v_CPA_PKE_PUBLIC_KEY_SIZE p))
-                        (v #usize_inttype (Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p +!
-                                           Spec.Kyber.v_CPA_PKE_PUBLIC_KEY_SIZE p +!
-                                           Libcrux.Kem.Kyber.Constants.v_H_DIGEST_SIZE))
-          `Seq.equal` Libcrux.Kem.Kyber.Hash_functions.v_H public_key);
-  assert (Seq.slice out (v #usize_inttype (Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p +!
-                                           Spec.Kyber.v_CPA_PKE_PUBLIC_KEY_SIZE p +!
-                                           Libcrux.Kem.Kyber.Constants.v_H_DIGEST_SIZE))
-                        (v #usize_inttype (Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p +!
-                                           Spec.Kyber.v_CPA_PKE_PUBLIC_KEY_SIZE p +!
-                                           Libcrux.Kem.Kyber.Constants.v_H_DIGEST_SIZE +!
-                                           Spec.Kyber.v_SHARED_SECRET_SIZE))
-          == implicit_rejection_value);
-  lemma_slice_append_4 out private_key public_key (Libcrux.Kem.Kyber.Hash_functions.v_H public_key) implicit_rejection_value;
   out
 
-let decapsulate #p
+let decapsulate
       (v_K v_SECRET_KEY_SIZE v_CPA_SECRET_KEY_SIZE v_PUBLIC_KEY_SIZE v_CIPHERTEXT_SIZE v_T_AS_NTT_ENCODED_SIZE v_C1_SIZE v_C2_SIZE v_VECTOR_U_COMPRESSION_FACTOR v_VECTOR_V_COMPRESSION_FACTOR v_C1_BLOCK_SIZE v_ETA1 v_ETA1_RANDOMNESS_SIZE v_ETA2 v_ETA2_RANDOMNESS_SIZE v_IMPLICIT_REJECTION_HASH_INPUT_SIZE:
           usize)
-      (secret_key: Libcrux.Kem.Kyber.Types.t_MlKemPrivateKey v_SECRET_KEY_SIZE)
-      (ciphertext: Libcrux.Kem.Kyber.Types.t_MlKemCiphertext v_CIPHERTEXT_SIZE) =
-  let orig_secret_key = secret_key.f_value in
+      (secret_key: Libcrux.Kem.Kyber.Types.t_KyberPrivateKey v_SECRET_KEY_SIZE)
+      (ciphertext: Libcrux.Kem.Kyber.Types.t_KyberCiphertext v_CIPHERTEXT_SIZE)
+     =
   let ind_cpa_secret_key, secret_key:(t_Slice u8 & t_Slice u8) =
     Libcrux.Kem.Kyber.Types.impl_12__split_at v_SECRET_KEY_SIZE secret_key v_CPA_SECRET_KEY_SIZE
   in
@@ -151,12 +123,8 @@
   let ind_cpa_public_key_hash, implicit_rejection_value:(t_Slice u8 & t_Slice u8) =
     Core.Slice.impl__split_at secret_key Libcrux.Kem.Kyber.Constants.v_H_DIGEST_SIZE
   in
-  assert (ind_cpa_secret_key == slice orig_secret_key (sz 0) v_CPA_SECRET_KEY_SIZE);
-  assert (ind_cpa_public_key == slice orig_secret_key v_CPA_SECRET_KEY_SIZE (v_CPA_SECRET_KEY_SIZE +! v_PUBLIC_KEY_SIZE));
-  assert (ind_cpa_public_key_hash == slice orig_secret_key (v_CPA_SECRET_KEY_SIZE +! v_PUBLIC_KEY_SIZE) (v_CPA_SECRET_KEY_SIZE +! v_PUBLIC_KEY_SIZE +! Libcrux.Kem.Kyber.Constants.v_H_DIGEST_SIZE));
-  assert (implicit_rejection_value == slice orig_secret_key (v_CPA_SECRET_KEY_SIZE +! v_PUBLIC_KEY_SIZE +! Libcrux.Kem.Kyber.Constants.v_H_DIGEST_SIZE) (length orig_secret_key));
   let decrypted:t_Array u8 (sz 32) =
-    Libcrux.Kem.Kyber.Ind_cpa.decrypt #p v_K
+    Libcrux.Kem.Kyber.Ind_cpa.decrypt v_K
       v_CIPHERTEXT_SIZE
       v_C1_SIZE
       v_VECTOR_U_COMPRESSION_FACTOR
@@ -184,9 +152,6 @@
         <:
         t_Slice u8)
   in
-  lemma_slice_append to_hash decrypted ind_cpa_public_key_hash;
-  assert (decrypted == Spec.Kyber.ind_cpa_decrypt p ind_cpa_secret_key ciphertext.f_value);
-  assert (to_hash == concat decrypted ind_cpa_public_key_hash);
   let hashed:t_Array u8 (sz 64) =
     Libcrux.Kem.Kyber.Hash_functions.v_G (Rust_primitives.unsize to_hash <: t_Slice u8)
   in
@@ -194,10 +159,6 @@
     Core.Slice.impl__split_at (Rust_primitives.unsize hashed <: t_Slice u8)
       Libcrux.Kem.Kyber.Constants.v_SHARED_SECRET_SIZE
   in
-  assert ((shared_secret,pseudorandomness) == split hashed Libcrux.Kem.Kyber.Constants.v_SHARED_SECRET_SIZE);
-  assert (length implicit_rejection_value = v_SECRET_KEY_SIZE -! v_CPA_SECRET_KEY_SIZE -! v_PUBLIC_KEY_SIZE -! Libcrux.Kem.Kyber.Constants.v_H_DIGEST_SIZE);
-  assert (length implicit_rejection_value = Spec.Kyber.v_SHARED_SECRET_SIZE);
-  assert (Spec.Kyber.v_SHARED_SECRET_SIZE <=. Spec.Kyber.v_IMPLICIT_REJECTION_HASH_INPUT_SIZE p);
   let (to_hash: t_Array u8 v_IMPLICIT_REJECTION_HASH_INPUT_SIZE):t_Array u8
     v_IMPLICIT_REJECTION_HASH_INPUT_SIZE =
     Libcrux.Kem.Kyber.Ind_cpa.into_padded_array v_IMPLICIT_REJECTION_HASH_INPUT_SIZE
@@ -219,14 +180,11 @@
         <:
         t_Slice u8)
   in
-  lemma_slice_append to_hash implicit_rejection_value ciphertext.f_value;
   let (implicit_rejection_shared_secret: t_Array u8 (sz 32)):t_Array u8 (sz 32) =
     Libcrux.Kem.Kyber.Hash_functions.v_PRF (sz 32) (Rust_primitives.unsize to_hash <: t_Slice u8)
   in
-  assert (implicit_rejection_shared_secret == Spec.Kyber.v_J to_hash);
-  assert (Seq.length ind_cpa_public_key == v v_PUBLIC_KEY_SIZE);
   let expected_ciphertext:t_Array u8 v_CIPHERTEXT_SIZE =
-    Libcrux.Kem.Kyber.Ind_cpa.encrypt #p v_K v_CIPHERTEXT_SIZE v_T_AS_NTT_ENCODED_SIZE v_C1_SIZE
+    Libcrux.Kem.Kyber.Ind_cpa.encrypt v_K v_CIPHERTEXT_SIZE v_T_AS_NTT_ENCODED_SIZE v_C1_SIZE
       v_C2_SIZE v_VECTOR_U_COMPRESSION_FACTOR v_VECTOR_V_COMPRESSION_FACTOR v_C1_BLOCK_SIZE v_ETA1
       v_ETA1_RANDOMNESS_SIZE v_ETA2 v_ETA2_RANDOMNESS_SIZE ind_cpa_public_key decrypted
       pseudorandomness
@@ -236,18 +194,16 @@
       (Core.Convert.f_as_ref ciphertext <: t_Slice u8)
       (Rust_primitives.unsize expected_ciphertext <: t_Slice u8)
   in
-  let res = 
   Libcrux.Kem.Kyber.Constant_time_ops.select_shared_secret_in_constant_time shared_secret
     (Rust_primitives.unsize implicit_rejection_shared_secret <: t_Slice u8)
     selector
-  in
-  res
 
-let encapsulate #p
+let encapsulate
       (v_K v_CIPHERTEXT_SIZE v_PUBLIC_KEY_SIZE v_T_AS_NTT_ENCODED_SIZE v_C1_SIZE v_C2_SIZE v_VECTOR_U_COMPRESSION_FACTOR v_VECTOR_V_COMPRESSION_FACTOR v_VECTOR_U_BLOCK_LEN v_ETA1 v_ETA1_RANDOMNESS_SIZE v_ETA2 v_ETA2_RANDOMNESS_SIZE:
           usize)
-      (public_key: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey v_PUBLIC_KEY_SIZE)
-      (randomness: t_Array u8 (sz 32)) =
+      (public_key: Libcrux.Kem.Kyber.Types.t_KyberPublicKey v_PUBLIC_KEY_SIZE)
+      (randomness: t_Array u8 (sz 32))
+     =
   let (to_hash: t_Array u8 (sz 64)):t_Array u8 (sz 64) =
     Libcrux.Kem.Kyber.Ind_cpa.into_padded_array (sz 64)
       (Rust_primitives.unsize randomness <: t_Slice u8)
@@ -278,10 +234,6 @@
         <:
         t_Slice u8)
   in
-  assert (Seq.slice to_hash 0 (v Libcrux.Kem.Kyber.Constants.v_H_DIGEST_SIZE) == randomness);
-  lemma_slice_append to_hash randomness (Spec.Kyber.v_H public_key.f_value);
-  assert (to_hash == concat randomness (Spec.Kyber.v_H public_key.f_value));
-
   let hashed:t_Array u8 (sz 64) =
     Libcrux.Kem.Kyber.Hash_functions.v_G (Rust_primitives.unsize to_hash <: t_Slice u8)
   in
@@ -290,7 +242,7 @@
       Libcrux.Kem.Kyber.Constants.v_SHARED_SECRET_SIZE
   in
   let ciphertext:t_Array u8 v_CIPHERTEXT_SIZE =
-    Libcrux.Kem.Kyber.Ind_cpa.encrypt #p v_K v_CIPHERTEXT_SIZE v_T_AS_NTT_ENCODED_SIZE v_C1_SIZE
+    Libcrux.Kem.Kyber.Ind_cpa.encrypt v_K v_CIPHERTEXT_SIZE v_T_AS_NTT_ENCODED_SIZE v_C1_SIZE
       v_C2_SIZE v_VECTOR_U_COMPRESSION_FACTOR v_VECTOR_V_COMPRESSION_FACTOR v_VECTOR_U_BLOCK_LEN
       v_ETA1 v_ETA1_RANDOMNESS_SIZE v_ETA2 v_ETA2_RANDOMNESS_SIZE
       (Rust_primitives.unsize (Libcrux.Kem.Kyber.Types.impl_18__as_slice v_PUBLIC_KEY_SIZE
@@ -300,42 +252,23 @@
         <:
         t_Slice u8) randomness pseudorandomness
   in
-  Core.Convert.f_into ciphertext,
-  Core.Result.impl__unwrap (Core.Convert.f_try_into shared_secret
-      <:
-      Core.Result.t_Result (t_Array u8 (sz 32)) Core.Array.t_TryFromSliceError)
-  <:
-  (Libcrux.Kem.Kyber.Types.t_MlKemCiphertext v_CIPHERTEXT_SIZE & t_Array u8 (sz 32))
-
-#push-options "--z3rlimit 100"
-let validate_public_key #p
-      (v_K v_RANKED_BYTES_PER_RING_ELEMENT v_PUBLIC_KEY_SIZE: usize)
-      (public_key: t_Array u8 v_PUBLIC_KEY_SIZE)
-     =
-  let pk:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
-    Libcrux.Kem.Kyber.Ind_cpa.deserialize_public_key #p v_K
-      (public_key.[ { Core.Ops.Range.f_end = v_RANKED_BYTES_PER_RING_ELEMENT }
+  let shared_secret:t_Array u8 (sz 32) =
+    match Core.Convert.f_try_into shared_secret with
+    | Core.Result.Result_Ok shared_secret -> shared_secret
+    | Core.Result.Result_Err _ ->
+      Rust_primitives.Hax.never_to_any (Core.Panicking.panic "explicit panic"
           <:
-          Core.Ops.Range.t_RangeTo usize ])
+          Rust_primitives.Hax.t_Never)
   in
-  let public_key_serialized:t_Array u8 v_PUBLIC_KEY_SIZE =
-    Libcrux.Kem.Kyber.Ind_cpa.serialize_public_key #p v_K
-      v_RANKED_BYTES_PER_RING_ELEMENT
-      v_PUBLIC_KEY_SIZE
-      pk
-      (public_key.[ { Core.Ops.Range.f_start = v_RANKED_BYTES_PER_RING_ELEMENT }
-          <:
-          Core.Ops.Range.t_RangeFrom usize ]
-        <:
-        t_Slice u8)
-  in
-  public_key =. public_key_serialized
-#pop-options
+  Core.Convert.f_into ciphertext, shared_secret
+  <:
+  (Libcrux.Kem.Kyber.Types.t_KyberCiphertext v_CIPHERTEXT_SIZE & t_Array u8 (sz 32))
 
-let generate_keypair #p
+let generate_keypair
       (v_K v_CPA_PRIVATE_KEY_SIZE v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE v_BYTES_PER_RING_ELEMENT v_ETA1 v_ETA1_RANDOMNESS_SIZE:
           usize)
-      (randomness: t_Array u8 (sz 64)) =
+      (randomness: t_Array u8 (sz 64))
+     =
   let ind_cpa_keypair_randomness:t_Slice u8 =
     randomness.[ {
         Core.Ops.Range.f_start = sz 0;
@@ -353,7 +286,7 @@
   in
   let ind_cpa_private_key, public_key:(t_Array u8 v_CPA_PRIVATE_KEY_SIZE &
     t_Array u8 v_PUBLIC_KEY_SIZE) =
-    Libcrux.Kem.Kyber.Ind_cpa.generate_keypair #p v_K
+    Libcrux.Kem.Kyber.Ind_cpa.generate_keypair v_K
       v_CPA_PRIVATE_KEY_SIZE
       v_PUBLIC_KEY_SIZE
       v_BYTES_PER_RING_ELEMENT
@@ -362,17 +295,16 @@
       ind_cpa_keypair_randomness
   in
   let secret_key_serialized:t_Array u8 v_PRIVATE_KEY_SIZE =
-    serialize_kem_secret_key #p v_PRIVATE_KEY_SIZE
+    serialize_kem_secret_key v_PRIVATE_KEY_SIZE
       (Rust_primitives.unsize ind_cpa_private_key <: t_Slice u8)
       (Rust_primitives.unsize public_key <: t_Slice u8)
       implicit_rejection_value
   in
-  let (private_key: Libcrux.Kem.Kyber.Types.t_MlKemPrivateKey v_PRIVATE_KEY_SIZE):Libcrux.Kem.Kyber.Types.t_MlKemPrivateKey
+  let (private_key: Libcrux.Kem.Kyber.Types.t_KyberPrivateKey v_PRIVATE_KEY_SIZE):Libcrux.Kem.Kyber.Types.t_KyberPrivateKey
   v_PRIVATE_KEY_SIZE =
     Core.Convert.f_from secret_key_serialized
   in
   Libcrux.Kem.Kyber.Types.impl__from v_PRIVATE_KEY_SIZE
     v_PUBLIC_KEY_SIZE
     private_key
-    (Core.Convert.f_into public_key <: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey v_PUBLIC_KEY_SIZE)
-
+    (Core.Convert.f_into public_key <: Libcrux.Kem.Kyber.Types.t_KyberPublicKey v_PUBLIC_KEY_SIZE)
diff -ruN extraction-edited/Libcrux.Kem.Kyber.fsti extraction-secret-independent/Libcrux.Kem.Kyber.fsti
--- extraction-edited/Libcrux.Kem.Kyber.fsti	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.fsti	1970-01-01 01:00:00.000000000 +0100
@@ -4,90 +4,37 @@
 open FStar.Mul
 
 unfold
-let t_MlKemSharedSecret = t_Array u8 (sz 32)
+let t_KyberSharedSecret = t_Array u8 (sz 32)
 
 let v_KEY_GENERATION_SEED_SIZE: usize =
   Libcrux.Kem.Kyber.Constants.v_CPA_PKE_KEY_GENERATION_SEED_SIZE +!
   Libcrux.Kem.Kyber.Constants.v_SHARED_SECRET_SIZE
 
-val serialize_kem_secret_key (#p:Spec.Kyber.params)
+val serialize_kem_secret_key
       (v_SERIALIZED_KEY_LEN: usize)
       (private_key public_key implicit_rejection_value: t_Slice u8)
-    : Pure (t_Array u8 v_SERIALIZED_KEY_LEN)
-      (requires (length private_key == Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p /\
-                 length public_key == Spec.Kyber.v_CPA_PKE_PUBLIC_KEY_SIZE p /\
-                 length implicit_rejection_value == Spec.Kyber.v_SHARED_SECRET_SIZE /\
-                 v_SERIALIZED_KEY_LEN == Spec.Kyber.v_SECRET_KEY_SIZE p))
-      (ensures (fun res -> res ==
-                Seq.append private_key (
-                Seq.append public_key (
-                Seq.append (Libcrux.Kem.Kyber.Hash_functions.v_H public_key) implicit_rejection_value))))
+    : Prims.Pure (t_Array u8 v_SERIALIZED_KEY_LEN) Prims.l_True (fun _ -> Prims.l_True)
 
-val decapsulate (#p:Spec.Kyber.params)
+val decapsulate
       (v_K v_SECRET_KEY_SIZE v_CPA_SECRET_KEY_SIZE v_PUBLIC_KEY_SIZE v_CIPHERTEXT_SIZE v_T_AS_NTT_ENCODED_SIZE v_C1_SIZE v_C2_SIZE v_VECTOR_U_COMPRESSION_FACTOR v_VECTOR_V_COMPRESSION_FACTOR v_C1_BLOCK_SIZE v_ETA1 v_ETA1_RANDOMNESS_SIZE v_ETA2 v_ETA2_RANDOMNESS_SIZE v_IMPLICIT_REJECTION_HASH_INPUT_SIZE:
           usize)
-      (secret_key: Libcrux.Kem.Kyber.Types.t_MlKemPrivateKey v_SECRET_KEY_SIZE)
-      (ciphertext: Libcrux.Kem.Kyber.Types.t_MlKemCiphertext v_CIPHERTEXT_SIZE)
-    : Pure (t_Array u8 (sz 32))
-    (requires ( p == (let open Spec.Kyber in {v_RANK = v_K; v_ETA1; v_ETA2; v_VECTOR_U_COMPRESSION_FACTOR; v_VECTOR_V_COMPRESSION_FACTOR}) /\
-                Spec.Kyber.valid_params p /\
-                v_ETA1_RANDOMNESS_SIZE == Spec.Kyber.v_ETA1_RANDOMNESS_SIZE p /\
-                v_ETA2_RANDOMNESS_SIZE == Spec.Kyber.v_ETA2_RANDOMNESS_SIZE p /\
-                v_IMPLICIT_REJECTION_HASH_INPUT_SIZE == Spec.Kyber.v_IMPLICIT_REJECTION_HASH_INPUT_SIZE p /\
-                v_SECRET_KEY_SIZE == Spec.Kyber.v_SECRET_KEY_SIZE p /\
-                v_CPA_SECRET_KEY_SIZE == Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p /\
-                v_PUBLIC_KEY_SIZE == Spec.Kyber.v_CPA_PKE_PUBLIC_KEY_SIZE p /\
-                v_CIPHERTEXT_SIZE == Spec.Kyber.v_CPA_PKE_CIPHERTEXT_SIZE p /\
-                v_C1_SIZE == Spec.Kyber.v_C1_SIZE p /\
-                v_C1_BLOCK_SIZE == Spec.Kyber.v_C1_BLOCK_SIZE p /\
-                v_C2_SIZE == Spec.Kyber.v_C2_SIZE p /\
-                v_T_AS_NTT_ENCODED_SIZE = Spec.Kyber.v_T_AS_NTT_ENCODED_SIZE p
-               ))
-    (ensures (fun res ->
-                res == Spec.Kyber.ind_cca_decapsulate p secret_key.f_value ciphertext.f_value))
+      (secret_key: Libcrux.Kem.Kyber.Types.t_KyberPrivateKey v_SECRET_KEY_SIZE)
+      (ciphertext: Libcrux.Kem.Kyber.Types.t_KyberCiphertext v_CIPHERTEXT_SIZE)
+    : Prims.Pure (t_Array u8 (sz 32)) Prims.l_True (fun _ -> Prims.l_True)
 
-val encapsulate (#p:Spec.Kyber.params)
+val encapsulate
       (v_K v_CIPHERTEXT_SIZE v_PUBLIC_KEY_SIZE v_T_AS_NTT_ENCODED_SIZE v_C1_SIZE v_C2_SIZE v_VECTOR_U_COMPRESSION_FACTOR v_VECTOR_V_COMPRESSION_FACTOR v_VECTOR_U_BLOCK_LEN v_ETA1 v_ETA1_RANDOMNESS_SIZE v_ETA2 v_ETA2_RANDOMNESS_SIZE:
           usize)
-      (public_key: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey v_PUBLIC_KEY_SIZE)
+      (public_key: Libcrux.Kem.Kyber.Types.t_KyberPublicKey v_PUBLIC_KEY_SIZE)
       (randomness: t_Array u8 (sz 32))
-    : Pure (Libcrux.Kem.Kyber.Types.t_MlKemCiphertext v_CIPHERTEXT_SIZE & t_Array u8 (sz 32))
-     (requires (p == (let open Spec.Kyber in {v_RANK = v_K; v_ETA1; v_ETA2; v_VECTOR_U_COMPRESSION_FACTOR; v_VECTOR_V_COMPRESSION_FACTOR}) /\
-                Spec.Kyber.valid_params p /\
-                v_ETA1_RANDOMNESS_SIZE == Spec.Kyber.v_ETA1_RANDOMNESS_SIZE p /\
-                v_ETA2_RANDOMNESS_SIZE == Spec.Kyber.v_ETA2_RANDOMNESS_SIZE p /\
-                v_PUBLIC_KEY_SIZE == Spec.Kyber.v_CPA_PKE_PUBLIC_KEY_SIZE p /\
-                v_CIPHERTEXT_SIZE == Spec.Kyber.v_CPA_PKE_CIPHERTEXT_SIZE p /\
-                v_C1_SIZE == Spec.Kyber.v_C1_SIZE p /\
-                v_C2_SIZE == Spec.Kyber.v_C2_SIZE p /\
-                v_T_AS_NTT_ENCODED_SIZE = Spec.Kyber.v_T_AS_NTT_ENCODED_SIZE p /\
-                v_VECTOR_U_BLOCK_LEN == Spec.Kyber.v_C1_BLOCK_SIZE p
-                ))
-
-      (ensures (fun (ct,ss) ->
-                (ct.f_value,ss) == Spec.Kyber.ind_cca_encapsulate p public_key.f_value randomness))
-
-val validate_public_key (#p:Spec.Kyber.params)
-      (v_K v_RANKED_BYTES_PER_RING_ELEMENT v_PUBLIC_KEY_SIZE: usize)
-      (public_key: t_Array u8 v_PUBLIC_KEY_SIZE)
-    : Prims.Pure bool
-      (requires (v_K == p.v_RANK /\
-                 v_PUBLIC_KEY_SIZE == Spec.Kyber.v_CPA_PKE_PUBLIC_KEY_SIZE p /\
-                 v_RANKED_BYTES_PER_RING_ELEMENT == Spec.Kyber.v_RANKED_BYTES_PER_RING_ELEMENT p
-                 ))
-      (ensures (fun _ -> Prims.l_True))
+    : Prims.Pure (Libcrux.Kem.Kyber.Types.t_KyberCiphertext v_CIPHERTEXT_SIZE & t_Array u8 (sz 32))
+      Prims.l_True
+      (fun _ -> Prims.l_True)
 
-val generate_keypair (#p:Spec.Kyber.params)
+val generate_keypair
       (v_K v_CPA_PRIVATE_KEY_SIZE v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE v_BYTES_PER_RING_ELEMENT v_ETA1 v_ETA1_RANDOMNESS_SIZE:
           usize)
       (randomness: t_Array u8 (sz 64))
-    : Pure (Libcrux.Kem.Kyber.Types.t_MlKemKeyPair v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE)
-      (requires (v_K == p.v_RANK /\ v_ETA1 == p.v_ETA1 /\
-                 v_ETA1_RANDOMNESS_SIZE == Spec.Kyber.v_ETA1_RANDOMNESS_SIZE p /\
-                 v_PUBLIC_KEY_SIZE == Spec.Kyber.v_CPA_PKE_PUBLIC_KEY_SIZE p /\
-                 v_CPA_PRIVATE_KEY_SIZE == Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p /\
-                 v_PRIVATE_KEY_SIZE == Spec.Kyber.v_SECRET_KEY_SIZE p /\
-                 v_BYTES_PER_RING_ELEMENT == Spec.Kyber.v_RANKED_BYTES_PER_RING_ELEMENT p
-                 ))
-      (ensures (fun kp -> 
-                (kp.f_sk.f_value,kp.f_pk.f_value) == Spec.Kyber.ind_cca_generate_keypair p randomness))
+    : Prims.Pure (Libcrux.Kem.Kyber.Types.t_KyberKeyPair v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE)
+      Prims.l_True
+      (fun _ -> Prims.l_True)
diff -ruN extraction-edited/Libcrux.Kem.Kyber.Hash_functions.fst extraction-secret-independent/Libcrux.Kem.Kyber.Hash_functions.fst
--- extraction-edited/Libcrux.Kem.Kyber.Hash_functions.fst	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.Hash_functions.fst	1970-01-01 01:00:00.000000000 +0100
@@ -3,28 +3,18 @@
 open Core
 open FStar.Mul
 
-let v_G (input: t_Slice u8) =
-  let res = Libcrux.Digest.sha3_512_ input in
-  admit(); // We assume that sha3_512 correctly implements G
-  res
+let v_G (input: t_Slice u8) = Libcrux.Digest.sha3_512_ input
 
-let v_H (input: t_Slice u8) =
-  let res = Libcrux.Digest.sha3_256_ input in
-  admit(); // We assume that sha3_512 correctly implements H
-  res
+let v_H (input: t_Slice u8) = Libcrux.Digest.sha3_256_ input
 
-let v_PRF (v_LEN: usize) (input: t_Slice u8) =
-  let res = Libcrux.Digest.shake256 v_LEN input in
-  admit(); // We assume that sha3_512 correctly implements H
-  res
+let v_PRF (v_LEN: usize) (input: t_Slice u8) = Libcrux.Digest.shake256 v_LEN input
 
-let v_XOFx4 v_K (input: t_Array (t_Array u8 (sz 34)) v_K) =
-  assert (v v_K >= 2);
+let v_XOFx4 (v_K: usize) (input: t_Array (t_Array u8 (sz 34)) v_K) =
   let out:t_Array (t_Array u8 (sz 840)) v_K =
     Rust_primitives.Hax.repeat (Rust_primitives.Hax.repeat 0uy (sz 840) <: t_Array u8 (sz 840)) v_K
   in
   let out:t_Array (t_Array u8 (sz 840)) v_K =
-    if ~.(Libcrux_platform.Platform.simd256_support () <: bool)
+    if ~.(Libcrux_platform.simd256_support () <: bool) || ~.true
     then
       Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
                 Core.Ops.Range.f_start = sz 0;
@@ -48,7 +38,7 @@
             t_Array (t_Array u8 (sz 840)) v_K)
     else
       let out:t_Array (t_Array u8 (sz 840)) v_K =
-        match cast (v_K <: usize) <: u8 with
+        match cast (v_K <: usize) <: pub_u8 with
         | 2uy ->
           let d0, d1, _, _:(t_Array u8 (sz 840) & t_Array u8 (sz 840) & t_Array u8 (sz 840) &
             t_Array u8 (sz 840)) =
@@ -66,7 +56,6 @@
           in
           out
         | 3uy ->
-          assert (v (cast v_K <: u8) = 3);
           let d0, d1, d2, _:(t_Array u8 (sz 840) & t_Array u8 (sz 840) & t_Array u8 (sz 840) &
             t_Array u8 (sz 840)) =
             Libcrux.Digest.shake128x4 (sz 840)
@@ -86,7 +75,6 @@
           in
           out
         | 4uy ->
-          assert (v (cast v_K <: u8) = 4);
           let d0, d1, d2, d3:(t_Array u8 (sz 840) & t_Array u8 (sz 840) & t_Array u8 (sz 840) &
             t_Array u8 (sz 840)) =
             Libcrux.Digest.shake128x4 (sz 840)
@@ -112,5 +100,4 @@
       in
       out
   in
-  admit(); // We assume that shake128x4 correctly implements XOFx4
-  out 
+  out
diff -ruN extraction-edited/Libcrux.Kem.Kyber.Hash_functions.fsti extraction-secret-independent/Libcrux.Kem.Kyber.Hash_functions.fsti
--- extraction-edited/Libcrux.Kem.Kyber.Hash_functions.fsti	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.Hash_functions.fsti	1970-01-01 01:00:00.000000000 +0100
@@ -3,17 +3,12 @@
 open Core
 open FStar.Mul
 
-val v_G (input: t_Slice u8) : Prims.Pure (t_Array u8 (sz 64)) Prims.l_True
-          (ensures (fun res -> res == Spec.Kyber.v_G input))
+val v_G (input: t_Slice u8) : Prims.Pure (t_Array u8 (sz 64)) Prims.l_True (fun _ -> Prims.l_True)
 
-val v_H (input: t_Slice u8) : Prims.Pure (t_Array u8 (sz 32)) Prims.l_True
-          (ensures (fun res -> res == Spec.Kyber.v_H input))
+val v_H (input: t_Slice u8) : Prims.Pure (t_Array u8 (sz 32)) Prims.l_True (fun _ -> Prims.l_True)
 
 val v_PRF (v_LEN: usize) (input: t_Slice u8)
-    : Prims.Pure (t_Array u8 v_LEN) Prims.l_True
-          (ensures (fun res -> res == Spec.Kyber.v_PRF v_LEN input))
-          
-val v_XOFx4 (v_K: usize{v v_K >= 2 /\ v v_K <= 4}) (input: t_Array (t_Array u8 (sz 34)) v_K)
-    : Prims.Pure (t_Array (t_Array u8 (sz 840)) v_K) Prims.l_True
-          (ensures (fun res ->
-            (forall i. i < v v_K ==> Seq.index res i == Spec.Kyber.v_XOF (sz 840) (Seq.index input i))))
+    : Prims.Pure (t_Array u8 v_LEN) Prims.l_True (fun _ -> Prims.l_True)
+
+val v_XOFx4 (v_K: usize) (input: t_Array (t_Array u8 (sz 34)) v_K)
+    : Prims.Pure (t_Array (t_Array u8 (sz 840)) v_K) Prims.l_True (fun _ -> Prims.l_True)
diff -ruN extraction-edited/Libcrux.Kem.Kyber.Helper.fst extraction-secret-independent/Libcrux.Kem.Kyber.Helper.fst
--- extraction-edited/Libcrux.Kem.Kyber.Helper.fst	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.Helper.fst	1970-01-01 01:00:00.000000000 +0100
@@ -0,0 +1,6 @@
+module Libcrux.Kem.Kyber.Helper
+#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
+open Core
+open FStar.Mul
+
+
diff -ruN extraction-edited/Libcrux.Kem.Kyber.Ind_cpa.fst extraction-secret-independent/Libcrux.Kem.Kyber.Ind_cpa.fst
--- extraction-edited/Libcrux.Kem.Kyber.Ind_cpa.fst	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.Ind_cpa.fst	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +1,5 @@
 module Libcrux.Kem.Kyber.Ind_cpa
-#set-options "--fuel 0 --ifuel 1 --z3rlimit 100"
+#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
 open Core
 open FStar.Mul
 
@@ -37,37 +37,33 @@
   in
   out
 
-unfold let acc_t (v_K v_ETA:usize) = (u8 & t_Array u8 (sz 33) & t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (pow2 (v v_ETA) - 1)) v_K)
-unfold let inv_t v_K v_ETA = acc_t v_K v_ETA -> usize -> Type
-
-let wfZero: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
-  (Libcrux.Kem.Kyber.Arithmetic.cast_poly_b #1 #3328 Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO)  
-
-let etaZero (v_ETA:usize{v v_ETA >= 1 /\ v v_ETA < pow2 31}): Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_ETA) =
-  (Libcrux.Kem.Kyber.Arithmetic.cast_poly_b #1 #(v v_ETA) Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO)  
-
-let sample_vector_cbd (#p:Spec.Kyber.params)
+let sample_ring_element_cbd
       (v_K v_ETA2_RANDOMNESS_SIZE v_ETA2: usize)
-      (prf_input: t_Array u8 (sz 33)) domain_separator = 
-  let error_1_:t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (pow2 (v v_ETA2) - 1)) v_K =
-    Rust_primitives.Hax.repeat (etaZero (sz (pow2 (v v_ETA2) - 1))) v_K
-  in
-  let orig_domain_separator = domain_separator in
-  [@ inline_let]
-  let inv : inv_t v_K v_ETA2 = fun (acc:acc_t v_K v_ETA2) (i:usize) ->
-    let (domain_separator,prf_input,error_1_) = acc in
-    if (i >=. sz 0 && i <=. v_K)
-    then
-      domain_separator = orig_domain_separator +! (mk_int #u8_inttype (v i))
-    else true in
-  let (domain_separator, prf_input, error_1_):acc_t v_K (v_ETA2) = 
-    Rust_primitives.Iterators.foldi_range #_ #(acc_t v_K (v_ETA2)) #inv {
+      (prf_input: t_Array u8 (sz 33))
+      (domain_separator: u8)
+     =
+  let error_1_:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+    Rust_primitives.Hax.repeat Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO v_K
+  in
+  let domain_separator, error_1_, prf_input:(u8 &
+    t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
+    t_Array u8 (sz 33)) =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
               Core.Ops.Range.f_start = sz 0;
               Core.Ops.Range.f_end = v_K
             }
-      (domain_separator, prf_input, error_1_)
+            <:
+            Core.Ops.Range.t_Range usize)
+        <:
+        Core.Ops.Range.t_Range usize)
+      (domain_separator, error_1_, prf_input
+        <:
+        (u8 & t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K & t_Array u8 (sz 33))
+      )
       (fun temp_0_ i ->
-          let domain_separator, prf_input, error_1_:acc_t v_K (v_ETA2) =
+          let domain_separator, error_1_, prf_input:(u8 &
+            t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
+            t_Array u8 (sz 33)) =
             temp_0_
           in
           let i:usize = i in
@@ -81,46 +77,49 @@
             Libcrux.Kem.Kyber.Hash_functions.v_PRF v_ETA2_RANDOMNESS_SIZE
               (Rust_primitives.unsize prf_input <: t_Slice u8)
           in
-          let error_1_:t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (pow2 (v v_ETA2) - 1)) v_K =
+          let error_1_:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
             Rust_primitives.Hax.Monomorphized_update_at.update_at_usize error_1_
               i
-              (Libcrux.Kem.Kyber.Sampling.sample_from_binomial_distribution #p v_ETA2
+              (Libcrux.Kem.Kyber.Sampling.sample_from_binomial_distribution v_ETA2
                   (Rust_primitives.unsize prf_output <: t_Slice u8)
                 <:
-                Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (pow2 (v v_ETA2) - 1))
+                Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
           in
-          domain_separator, prf_input, error_1_)
+          domain_separator, error_1_, prf_input
+          <:
+          (u8 & t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
+            t_Array u8 (sz 33)))
   in
-  let hax_temp_output:t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (pow2 (v v_ETA2) - 1)) v_K = error_1_ in
-  admit(); //P-F
+  let hax_temp_output:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K = error_1_ in
   prf_input, domain_separator, hax_temp_output
   <:
-  (t_Array u8 (sz 33) & u8 & t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_ETA2)) v_K)
+  (t_Array u8 (sz 33) & u8 & t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
 
-#push-options "--split_queries no --z3rlimit 300"
-let sample_vector_cbd_then_ntt (#p:Spec.Kyber.params)
+let sample_vector_cbd_then_ntt
       (v_K v_ETA v_ETA_RANDOMNESS_SIZE: usize)
-      (prf_input: t_Array u8 (sz 33)) domain_separator =
-  let re_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
-    Rust_primitives.Hax.repeat (wfZero) v_K
-  in
-  let orig_domain_separator = domain_separator in
-  [@ inline_let]
-  let inv: (u8 & t_Array u8 (sz 33) & t_Array (Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement) v_K) -> usize -> Type = fun acc i ->
-    let (domain_separator,prf_input,re_as_ntt) = acc in
-    if (i >=. sz 0 && i <=. v_K)
-    then 
-      domain_separator = orig_domain_separator +! (mk_int #u8_inttype (v i))
-    else true in
-  let (domain_separator, prf_input, re_as_ntt):(u8 & t_Array u8 (sz 33) & t_Array (Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement) v_K)= 
-    Rust_primitives.Iterators.foldi_range #_ #_  #inv {
+      (prf_input: t_Array u8 (sz 33))
+      (domain_separator: u8)
+     =
+  let re_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+    Rust_primitives.Hax.repeat Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO v_K
+  in
+  let domain_separator, prf_input, re_as_ntt:(u8 & t_Array u8 (sz 33) &
+    t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
               Core.Ops.Range.f_start = sz 0;
               Core.Ops.Range.f_end = v_K
             }
-      (domain_separator, prf_input, re_as_ntt)
+            <:
+            Core.Ops.Range.t_Range usize)
+        <:
+        Core.Ops.Range.t_Range usize)
+      (domain_separator, prf_input, re_as_ntt
+        <:
+        (u8 & t_Array u8 (sz 33) & t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+      )
       (fun temp_0_ i ->
           let domain_separator, prf_input, re_as_ntt:(u8 & t_Array u8 (sz 33) &
-            t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) =
+            t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) =
             temp_0_
           in
           let i:usize = i in
@@ -134,74 +133,64 @@
             Libcrux.Kem.Kyber.Hash_functions.v_PRF v_ETA_RANDOMNESS_SIZE
               (Rust_primitives.unsize prf_input <: t_Slice u8)
           in
-          let r:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (pow2 (v v_ETA) - 1) =
-            Libcrux.Kem.Kyber.Sampling.sample_from_binomial_distribution #p v_ETA
+          let r:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+            Libcrux.Kem.Kyber.Sampling.sample_from_binomial_distribution v_ETA
               (Rust_primitives.unsize prf_output <: t_Slice u8)
           in
-          let r:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 7 =
-            Libcrux.Kem.Kyber.Arithmetic.cast_poly_b r in
-          let re_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
+          let re_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
             Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re_as_ntt
               i
               (Libcrux.Kem.Kyber.Ntt.ntt_binomially_sampled_ring_element r
                 <:
-                Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+                Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
           in
           domain_separator, prf_input, re_as_ntt
           <:
           (u8 & t_Array u8 (sz 33) &
-            t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K))
+            t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K))
   in
-  admit(); //P-F
   re_as_ntt, domain_separator
   <:
-  (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K & u8)
-
+  (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K & u8)
 
-let compress_then_serialize_u #p v_K v_OUT_LEN v_COMPRESSION_FACTOR v_BLOCK_LEN input = 
+let compress_then_serialize_u
+      (v_K v_OUT_LEN v_COMPRESSION_FACTOR v_BLOCK_LEN: usize)
+      (input: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+     =
   let out:t_Array u8 v_OUT_LEN = Rust_primitives.Hax.repeat 0uy v_OUT_LEN in
-  let orig_out = out in
-  let acc_t = t_Array u8 v_OUT_LEN in
-  [@ inline_let]
-  let inv = fun (acc:acc_t) (i:usize) -> True in
   let out:t_Array u8 v_OUT_LEN =
-    Rust_primitives.Iterators.foldi_slice #Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement  #acc_t #inv
-      input
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter (Core.Iter.Traits.Iterator.f_enumerate
+              (Core.Iter.Traits.Collect.f_into_iter input
+                <:
+                Core.Array.Iter.t_IntoIter Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+            <:
+            Core.Iter.Adapters.Enumerate.t_Enumerate
+            (Core.Array.Iter.t_IntoIter Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K))
+        <:
+        Core.Iter.Adapters.Enumerate.t_Enumerate
+        (Core.Array.Iter.t_IntoIter Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K))
       out
       (fun out temp_1_ ->
           let out:t_Array u8 v_OUT_LEN = out in
-          let i, re:(usize & Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement) = temp_1_ in
-          assert (i <. v_K);
-          assert (v i + 1  <=  v v_K);
-          assert (v i * (v v_OUT_LEN / v v_K) < v v_OUT_LEN);
-          assert (((v i + 1) * (v v_OUT_LEN / v v_K)) <= v v_OUT_LEN);
-          assert (v_OUT_LEN /! v_K == Spec.Kyber.v_C1_BLOCK_SIZE p);
-          assert (range (v i * v (Spec.Kyber.v_C1_BLOCK_SIZE p)) usize_inttype);
-          assert (range ((v i + 1) * v (Spec.Kyber.v_C1_BLOCK_SIZE p)) usize_inttype);
-          assert ((Core.Ops.Range.impl_index_range_slice u8 usize_inttype).f_index_pre out 
-                    {
-                      Core.Ops.Range.f_start = i *! Spec.Kyber.v_C1_BLOCK_SIZE p <: usize;
-                      Core.Ops.Range.f_end
-                      =
-                      (i +! sz 1 <: usize) *! Spec.Kyber.v_C1_BLOCK_SIZE p <: usize
-                    });
-          assert (((i +! sz 1 <: usize) *! Spec.Kyber.v_C1_BLOCK_SIZE p) -! (i *! Spec.Kyber.v_C1_BLOCK_SIZE p) == Spec.Kyber.v_C1_BLOCK_SIZE p);
+          let i, re:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) = temp_1_ in
           Rust_primitives.Hax.Monomorphized_update_at.update_at_range out
             ({
-                Core.Ops.Range.f_start = i *! Spec.Kyber.v_C1_BLOCK_SIZE p <: usize;
-                Core.Ops.Range.f_end = (i +! sz 1 <: usize) *! Spec.Kyber.v_C1_BLOCK_SIZE p <: usize
+                Core.Ops.Range.f_start = i *! (v_OUT_LEN /! v_K <: usize) <: usize;
+                Core.Ops.Range.f_end = (i +! sz 1 <: usize) *! (v_OUT_LEN /! v_K <: usize) <: usize
               }
               <:
               Core.Ops.Range.t_Range usize)
             (Core.Slice.impl__copy_from_slice (out.[ {
-                      Core.Ops.Range.f_start = i *! Spec.Kyber.v_C1_BLOCK_SIZE p <: usize;
+                      Core.Ops.Range.f_start = i *! (v_OUT_LEN /! v_K <: usize) <: usize;
                       Core.Ops.Range.f_end
                       =
-                      (i +! sz 1 <: usize) *! Spec.Kyber.v_C1_BLOCK_SIZE p <: usize
-                    } ]
+                      (i +! sz 1 <: usize) *! (v_OUT_LEN /! v_K <: usize) <: usize
+                    }
+                    <:
+                    Core.Ops.Range.t_Range usize ]
                   <:
                   t_Slice u8)
-                (Rust_primitives.unsize (Libcrux.Kem.Kyber.Serialize.compress_then_serialize_ring_element_u #p
+                (Rust_primitives.unsize (Libcrux.Kem.Kyber.Serialize.compress_then_serialize_ring_element_u
                         v_COMPRESSION_FACTOR
                         v_BLOCK_LEN
                         re
@@ -214,237 +203,201 @@
           <:
           t_Array u8 v_OUT_LEN)
   in
-  admit();//P-F
   out
 
-#push-options "--split_queries always"
-let deserialize_then_decompress_u (#p:Spec.Kyber.params)
-      (v_K v_CIPHERTEXT_SIZE v_VECTOR_U_ENCODED_SIZE v_U_COMPRESSION_FACTOR: usize)
-      (ciphertext: t_Array u8 v_CIPHERTEXT_SIZE) =
-  let u_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
-    Rust_primitives.Hax.repeat wfZero v_K
-  in
-  let acc_t1 = t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K in
-  [@ inline_let]
-  let inv = fun (acc:acc_t1) (i:usize) -> True in
-  let sl : t_Slice u8 = ciphertext.[ 
-                      { Core.Ops.Range.f_end = v_VECTOR_U_ENCODED_SIZE  } <: Core.Ops.Range.t_RangeTo usize ] in
-  assert (length sl == v_VECTOR_U_ENCODED_SIZE);
-  let chunk_len = ((Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT *!
+let deserialize_then_decompress_u
+      (v_K v_CIPHERTEXT_SIZE v_U_COMPRESSION_FACTOR: usize)
+      (ciphertext: t_Array u8 v_CIPHERTEXT_SIZE)
+     =
+  let u_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+    Rust_primitives.Hax.repeat Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO v_K
+  in
+  let u_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter (Core.Iter.Traits.Iterator.f_enumerate
+              (Core.Slice.impl__chunks_exact (Rust_primitives.unsize ciphertext <: t_Slice u8)
+                  ((Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT *!
                       v_U_COMPRESSION_FACTOR
                       <:
                       usize) /!
                     sz 8
                     <:
-                    usize) in
-  FStar.Math.Lemmas.cancel_mul_mod (v p.v_RANK) (v (Spec.Kyber.v_C1_BLOCK_SIZE p)) ;
-  assert (v chunk_len == v (Spec.Kyber.v_C1_BLOCK_SIZE p));
-  assert (Seq.length sl % v (Spec.Kyber.v_C1_BLOCK_SIZE p) = 0);
-  assert (Seq.length sl == v (Spec.Kyber.v_C1_SIZE p));
-  assert (Seq.length sl / v (Spec.Kyber.v_C1_BLOCK_SIZE p) == v v_K);
-  let u_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
-   Rust_primitives.Iterators.foldi_chunks_exact #u8 #acc_t1 #inv
-      sl
-      chunk_len
+                    usize)
+                <:
+                Core.Slice.Iter.t_ChunksExact u8)
+            <:
+            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
+        <:
+        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
       u_as_ntt
       (fun u_as_ntt temp_1_ ->
-          let u_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
+          let u_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
             u_as_ntt
           in
-          let i, u_bytes:(usize & t_Array u8 chunk_len) = temp_1_ in
-          let u:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+          let i, u_bytes:(usize & t_Slice u8) = temp_1_ in
+          let u:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             Libcrux.Kem.Kyber.Serialize.deserialize_then_decompress_ring_element_u v_U_COMPRESSION_FACTOR
               u_bytes
           in
-          assert (v i < v v_K);
-          let u_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
+          let u_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
             Rust_primitives.Hax.Monomorphized_update_at.update_at_usize u_as_ntt
               i
               (Libcrux.Kem.Kyber.Ntt.ntt_vector_u v_U_COMPRESSION_FACTOR u
                 <:
-                Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+                Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
           in
           u_as_ntt)
   in
-  admit(); //P-F
   u_as_ntt
-#pop-options
 
-#push-options "--z3rlimit 200"
-let deserialize_public_key (#p:Spec.Kyber.params) 
-    (v_K: usize) (public_key: t_Slice u8) =
-  let tt_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
-    Rust_primitives.Hax.repeat wfZero v_K
-  in
-  let acc_t = t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K in
-  [@ inline_let]
-  let inv = fun (acc:acc_t) (i:usize) -> True in
-  let chunk_len = Libcrux.Kem.Kyber.Constants.v_BYTES_PER_RING_ELEMENT in
-  let tt_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
-   Rust_primitives.Iterators.foldi_chunks_exact #u8 #acc_t #inv
-      public_key
-      chunk_len
+let deserialize_public_key (v_K: usize) (public_key: t_Slice u8) =
+  let tt_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+    Rust_primitives.Hax.repeat Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO v_K
+  in
+  let tt_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter (Core.Iter.Traits.Iterator.f_enumerate
+              (Core.Slice.impl__chunks_exact public_key
+                  Libcrux.Kem.Kyber.Constants.v_BYTES_PER_RING_ELEMENT
+                <:
+                Core.Slice.Iter.t_ChunksExact u8)
+            <:
+            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
+        <:
+        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
       tt_as_ntt
       (fun tt_as_ntt temp_1_ ->
-          let tt_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
+          let tt_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
             tt_as_ntt
           in
-          let i, tt_as_ntt_bytes:(usize & t_Array u8 chunk_len) = temp_1_ in
+          let i, tt_as_ntt_bytes:(usize & t_Slice u8) = temp_1_ in
           Rust_primitives.Hax.Monomorphized_update_at.update_at_usize tt_as_ntt
             i
             (Libcrux.Kem.Kyber.Serialize.deserialize_to_uncompressed_ring_element tt_as_ntt_bytes
               <:
-              Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+              Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
           <:
-          t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
+          t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
   in
-  admit(); //P-F
-  tt_as_ntt 
-#pop-options
-
-#push-options "--split_queries always"
-let deserialize_secret_key (#p:Spec.Kyber.params) (v_K: usize) (secret_key: t_Slice u8) =
-  let secret_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
-    Rust_primitives.Hax.repeat wfZero v_K
-  in
-  let acc_t = t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K in
-  [@ inline_let]
-  let inv = fun (acc:acc_t) (i:usize) -> True in
-  let sl : t_Slice u8 = secret_key in
-  let chunk_len = Libcrux.Kem.Kyber.Constants.v_BYTES_PER_RING_ELEMENT in
-  assert(v chunk_len == 384);
-  assert(Seq.length secret_key == v (Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p));
-  assert(Seq.length secret_key == (v v_K * 256 * 12)/8);
-  let secret_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
-   Rust_primitives.Iterators.foldi_chunks_exact #u8 #acc_t #inv
-      sl
-      chunk_len
+  tt_as_ntt
+
+let deserialize_secret_key (v_K: usize) (secret_key: t_Slice u8) =
+  let secret_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+    Rust_primitives.Hax.repeat Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO v_K
+  in
+  let secret_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter (Core.Iter.Traits.Iterator.f_enumerate
+              (Core.Slice.impl__chunks_exact secret_key
+                  Libcrux.Kem.Kyber.Constants.v_BYTES_PER_RING_ELEMENT
+                <:
+                Core.Slice.Iter.t_ChunksExact u8)
+            <:
+            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
+        <:
+        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
       secret_as_ntt
       (fun secret_as_ntt temp_1_ ->
-          let secret_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
+          let secret_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
             secret_as_ntt
           in
-          let i, secret_bytes:(usize & t_Array u8 chunk_len) = temp_1_ in
+          let i, secret_bytes:(usize & t_Slice u8) = temp_1_ in
           Rust_primitives.Hax.Monomorphized_update_at.update_at_usize secret_as_ntt
             i
             (Libcrux.Kem.Kyber.Serialize.deserialize_to_uncompressed_ring_element secret_bytes
               <:
-              Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+              Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
           <:
-          t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
+          t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
   in
-  admit(); //P-F
   secret_as_ntt
-#pop-options
 
-#push-options "--z3rlimit 400 --split_queries no"
-let decrypt #p
+let decrypt
       (v_K v_CIPHERTEXT_SIZE v_VECTOR_U_ENCODED_SIZE v_U_COMPRESSION_FACTOR v_V_COMPRESSION_FACTOR:
           usize)
       (secret_key: t_Slice u8)
-      (ciphertext: t_Array u8 v_CIPHERTEXT_SIZE) = 
-  let u_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
-    deserialize_then_decompress_u #p v_K
-      v_CIPHERTEXT_SIZE
-      v_VECTOR_U_ENCODED_SIZE
-      v_U_COMPRESSION_FACTOR
-      ciphertext
+      (ciphertext: t_Array u8 v_CIPHERTEXT_SIZE)
+     =
+  let u_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+    deserialize_then_decompress_u v_K v_CIPHERTEXT_SIZE v_U_COMPRESSION_FACTOR ciphertext
   in
-  let v:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
-    Libcrux.Kem.Kyber.Serialize.deserialize_then_decompress_ring_element_v #p v_V_COMPRESSION_FACTOR
+  let v:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+    Libcrux.Kem.Kyber.Serialize.deserialize_then_decompress_ring_element_v v_V_COMPRESSION_FACTOR
       (ciphertext.[ { Core.Ops.Range.f_start = v_VECTOR_U_ENCODED_SIZE }
           <:
           Core.Ops.Range.t_RangeFrom usize ]
         <:
         t_Slice u8)
   in
-  let secret_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
-    deserialize_secret_key #p v_K secret_key
+  let secret_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+    deserialize_secret_key v_K secret_key
   in
-  let message:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
-    Libcrux.Kem.Kyber.Matrix.compute_message #p v_K v secret_as_ntt u_as_ntt
+  let message:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+    Libcrux.Kem.Kyber.Matrix.compute_message v_K v secret_as_ntt u_as_ntt
   in
-  let res = Libcrux.Kem.Kyber.Serialize.compress_then_serialize_message message in
-  res
-#pop-options
-
-#push-options "--z3rlimit 200"
-let encrypt #p
-      v_K v_CIPHERTEXT_SIZE v_T_AS_NTT_ENCODED_SIZE v_C1_LEN v_C2_LEN v_U_COMPRESSION_FACTOR v_V_COMPRESSION_FACTOR v_BLOCK_LEN v_ETA1 v_ETA1_RANDOMNESS_SIZE v_ETA2 v_ETA2_RANDOMNESS_SIZE
-      public_key
+  Libcrux.Kem.Kyber.Serialize.compress_then_serialize_message message
+
+let encrypt
+      (v_K v_CIPHERTEXT_SIZE v_T_AS_NTT_ENCODED_SIZE v_C1_LEN v_C2_LEN v_U_COMPRESSION_FACTOR v_V_COMPRESSION_FACTOR v_BLOCK_LEN v_ETA1 v_ETA1_RANDOMNESS_SIZE v_ETA2 v_ETA2_RANDOMNESS_SIZE:
+          usize)
+      (public_key: t_Slice u8)
       (message: t_Array u8 (sz 32))
-      (randomness: t_Slice u8) =
-  let tt_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
-    deserialize_public_key #p v_K
-      (public_key.[ { Core.Ops.Range.f_end = v_T_AS_NTT_ENCODED_SIZE }
-          <:
-          Core.Ops.Range.t_RangeTo usize ]
-        <:
-        t_Slice u8)
+      (randomness: t_Slice u8)
+     =
+  let tt_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+    deserialize_public_key v_K public_key
   in
   let seed:t_Slice u8 =
     public_key.[ { Core.Ops.Range.f_start = v_T_AS_NTT_ENCODED_SIZE }
       <:
       Core.Ops.Range.t_RangeFrom usize ]
   in
-  let v_A_transpose:t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) v_K =
-    Libcrux.Kem.Kyber.Matrix.sample_matrix_A #p v_K
+  let v_A_transpose:t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K =
+    Libcrux.Kem.Kyber.Matrix.sample_matrix_A v_K
       (into_padded_array (sz 34) seed <: t_Array u8 (sz 34))
       false
   in
   let (prf_input: t_Array u8 (sz 33)):t_Array u8 (sz 33) = into_padded_array (sz 33) randomness in
-  let r_as_ntt, domain_separator:(t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K &
+  let r_as_ntt, domain_separator:(t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K &
     u8) =
-    sample_vector_cbd_then_ntt #p v_K v_ETA1 v_ETA1_RANDOMNESS_SIZE prf_input 0uy
+    sample_vector_cbd_then_ntt v_K v_ETA1 v_ETA1_RANDOMNESS_SIZE prf_input 0uy
   in
-  assert (v domain_separator == v v_K);
   let tmp0, tmp1, out:(t_Array u8 (sz 33) & u8 &
-    t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) =
-    sample_vector_cbd #p v_K v_ETA2_RANDOMNESS_SIZE v_ETA2 prf_input domain_separator
+    t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) =
+    sample_ring_element_cbd v_K v_ETA2_RANDOMNESS_SIZE v_ETA2 prf_input domain_separator
   in
   let prf_input:t_Array u8 (sz 33) = tmp0 in
   let domain_separator:u8 = tmp1 in
-  let error_1_:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K = out in
+  let error_1_:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K = out in
   let prf_input:t_Array u8 (sz 33) =
     Rust_primitives.Hax.Monomorphized_update_at.update_at_usize prf_input (sz 32) domain_separator
   in
-  assert (Seq.equal prf_input (Seq.append randomness (Seq.create 1 domain_separator)));
-  assert (prf_input == Seq.append randomness (Seq.create 1 domain_separator));
   let (prf_output: t_Array u8 v_ETA2_RANDOMNESS_SIZE):t_Array u8 v_ETA2_RANDOMNESS_SIZE =
     Libcrux.Kem.Kyber.Hash_functions.v_PRF v_ETA2_RANDOMNESS_SIZE
       (Rust_primitives.unsize prf_input <: t_Slice u8)
   in
-  let error_2_:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (pow2 (v v_ETA2) - 1) =
-    Libcrux.Kem.Kyber.Sampling.sample_from_binomial_distribution #p v_ETA2
+  let error_2_:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+    Libcrux.Kem.Kyber.Sampling.sample_from_binomial_distribution v_ETA2
       (Rust_primitives.unsize prf_output <: t_Slice u8)
   in
-  let error_2_:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 7 =
-    Libcrux.Kem.Kyber.Arithmetic.cast_poly_b error_2_ in
-  let u:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
-    Libcrux.Kem.Kyber.Matrix.compute_vector_u #p v_K v_A_transpose r_as_ntt error_1_
+  let u:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+    Libcrux.Kem.Kyber.Matrix.compute_vector_u v_K v_A_transpose r_as_ntt error_1_
   in
-  let message_as_ring_element:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+  let message_as_ring_element:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
     Libcrux.Kem.Kyber.Serialize.deserialize_then_decompress_message message
   in
-  let v:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
-    Libcrux.Kem.Kyber.Matrix.compute_ring_element_v #p v_K
+  let v:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+    Libcrux.Kem.Kyber.Matrix.compute_ring_element_v v_K
       tt_as_ntt
       r_as_ntt
       error_2_
       message_as_ring_element
   in
   let c1:t_Array u8 v_C1_LEN =
-    compress_then_serialize_u #p v_K v_C1_LEN v_U_COMPRESSION_FACTOR v_BLOCK_LEN u
+    compress_then_serialize_u v_K v_C1_LEN v_U_COMPRESSION_FACTOR v_BLOCK_LEN u
   in
   let c2:t_Array u8 v_C2_LEN =
-    Libcrux.Kem.Kyber.Serialize.compress_then_serialize_ring_element_v #p v_V_COMPRESSION_FACTOR
+    Libcrux.Kem.Kyber.Serialize.compress_then_serialize_ring_element_v v_V_COMPRESSION_FACTOR
       v_C2_LEN
       v
   in
-  assert (v_C1_LEN = Spec.Kyber.v_C1_SIZE p);
-  assert (v_C2_LEN = Spec.Kyber.v_C2_SIZE p);
-  assert (v_CIPHERTEXT_SIZE == v_C1_LEN +! v_C2_LEN);
-  assert (v_C1_LEN <=. v_CIPHERTEXT_SIZE);
   let (ciphertext: t_Array u8 v_CIPHERTEXT_SIZE):t_Array u8 v_CIPHERTEXT_SIZE =
     into_padded_array v_CIPHERTEXT_SIZE (Rust_primitives.unsize c1 <: t_Slice u8)
   in
@@ -460,25 +413,28 @@
         <:
         t_Slice u8)
   in
-  lemma_slice_append ciphertext c1 c2;
   ciphertext
-#pop-options
 
-let serialize_secret_key (#p:Spec.Kyber.params)
+let serialize_secret_key
       (v_K v_OUT_LEN: usize)
-      (key: t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) =
+      (key: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+     =
   let out:t_Array u8 v_OUT_LEN = Rust_primitives.Hax.repeat 0uy v_OUT_LEN in
-  let orig_out = out in
-  let acc_t = t_Array u8 v_OUT_LEN in
-  [@ inline_let]
-  let inv = fun (acc:acc_t) (i:usize) -> True in
   let out:t_Array u8 v_OUT_LEN =
-    Rust_primitives.Iterators.foldi_slice #Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement  #acc_t #inv
-      key
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter (Core.Iter.Traits.Iterator.f_enumerate
+              (Core.Iter.Traits.Collect.f_into_iter key
+                <:
+                Core.Array.Iter.t_IntoIter Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+            <:
+            Core.Iter.Adapters.Enumerate.t_Enumerate
+            (Core.Array.Iter.t_IntoIter Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K))
+        <:
+        Core.Iter.Adapters.Enumerate.t_Enumerate
+        (Core.Array.Iter.t_IntoIter Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K))
       out
       (fun out temp_1_ ->
           let out:t_Array u8 v_OUT_LEN = out in
-          let i, re:(usize & Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement) = temp_1_ in
+          let i, re:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) = temp_1_ in
           Rust_primitives.Hax.Monomorphized_update_at.update_at_range out
             ({
                 Core.Ops.Range.f_start
@@ -517,14 +473,13 @@
           <:
           t_Array u8 v_OUT_LEN)
   in
-  admit(); //P-F
   out
 
-
-let serialize_public_key (#p:Spec.Kyber.params)
+let serialize_public_key
       (v_K v_RANKED_BYTES_PER_RING_ELEMENT v_PUBLIC_KEY_SIZE: usize)
-      (tt_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
-      (seed_for_a: t_Slice u8) =
+      (tt_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+      (seed_for_a: t_Slice u8)
+     =
   let public_key_serialized:t_Array u8 v_PUBLIC_KEY_SIZE =
     Rust_primitives.Hax.repeat 0uy v_PUBLIC_KEY_SIZE
   in
@@ -541,7 +496,7 @@
               Core.Ops.Range.t_Range usize ]
             <:
             t_Slice u8)
-          (Rust_primitives.unsize (serialize_secret_key #p v_K
+          (Rust_primitives.unsize (serialize_secret_key v_K
                   v_RANKED_BYTES_PER_RING_ELEMENT
                   tt_as_ntt
                 <:
@@ -567,49 +522,42 @@
         <:
         t_Slice u8)
   in
-  lemma_slice_append public_key_serialized
-    (Spec.Kyber.vector_encode_12 (Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p tt_as_ntt))
-    seed_for_a;
   public_key_serialized
 
-
-let generate_keypair #p
+let generate_keypair
       (v_K v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE v_RANKED_BYTES_PER_RING_ELEMENT v_ETA1 v_ETA1_RANDOMNESS_SIZE:
           usize)
-      (key_generation_seed: t_Slice u8) =
+      (key_generation_seed: t_Slice u8)
+     =
   let hashed:t_Array u8 (sz 64) = Libcrux.Kem.Kyber.Hash_functions.v_G key_generation_seed in
   let seed_for_A, seed_for_secret_and_error:(t_Slice u8 & t_Slice u8) =
     Core.Slice.impl__split_at (Rust_primitives.unsize hashed <: t_Slice u8) (sz 32)
   in
-  let v_A_transpose:t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) v_K =
-    Libcrux.Kem.Kyber.Matrix.sample_matrix_A #p v_K
+  let v_A_transpose:t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K =
+    Libcrux.Kem.Kyber.Matrix.sample_matrix_A v_K
       (into_padded_array (sz 34) seed_for_A <: t_Array u8 (sz 34))
       true
   in
   let (prf_input: t_Array u8 (sz 33)):t_Array u8 (sz 33) =
     into_padded_array (sz 33) seed_for_secret_and_error
   in
-  let secret_as_ntt, domain_separator:(t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+  let secret_as_ntt, domain_separator:(t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
       v_K &
     u8) =
-    sample_vector_cbd_then_ntt #p v_K v_ETA1 v_ETA1_RANDOMNESS_SIZE prf_input 0uy
+    sample_vector_cbd_then_ntt v_K v_ETA1 v_ETA1_RANDOMNESS_SIZE prf_input 0uy
   in
-  let error_as_ntt, _:(t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K & u8) =
-    sample_vector_cbd_then_ntt #p v_K v_ETA1 v_ETA1_RANDOMNESS_SIZE prf_input domain_separator
+  let error_as_ntt, _:(t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K & u8) =
+    sample_vector_cbd_then_ntt v_K v_ETA1 v_ETA1_RANDOMNESS_SIZE prf_input domain_separator
   in
-  let tt_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
-    Libcrux.Kem.Kyber.Matrix.compute_As_plus_e #p v_K v_A_transpose secret_as_ntt error_as_ntt
+  let tt_as_ntt:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+    Libcrux.Kem.Kyber.Matrix.compute_As_plus_e v_K v_A_transpose secret_as_ntt error_as_ntt
   in
   let public_key_serialized:t_Array u8 v_PUBLIC_KEY_SIZE =
-    serialize_public_key #p v_K v_RANKED_BYTES_PER_RING_ELEMENT v_PUBLIC_KEY_SIZE tt_as_ntt seed_for_A
+    serialize_public_key v_K v_RANKED_BYTES_PER_RING_ELEMENT v_PUBLIC_KEY_SIZE tt_as_ntt seed_for_A
   in
   let secret_key_serialized:t_Array u8 v_PRIVATE_KEY_SIZE =
-    serialize_secret_key #p v_K v_PRIVATE_KEY_SIZE secret_as_ntt
+    serialize_secret_key v_K v_PRIVATE_KEY_SIZE secret_as_ntt
   in
-  let res = 
   secret_key_serialized, public_key_serialized
   <:
   (t_Array u8 v_PRIVATE_KEY_SIZE & t_Array u8 v_PUBLIC_KEY_SIZE)
-  in
-  res
- 
diff -ruN extraction-edited/Libcrux.Kem.Kyber.Ind_cpa.fsti extraction-secret-independent/Libcrux.Kem.Kyber.Ind_cpa.fsti
--- extraction-edited/Libcrux.Kem.Kyber.Ind_cpa.fsti	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.Ind_cpa.fsti	1970-01-01 01:00:00.000000000 +0100
@@ -1,151 +1,80 @@
 module Libcrux.Kem.Kyber.Ind_cpa
-#set-options "--fuel 0 --ifuel 1 --z3rlimit 100"
+#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
 open Core
 open FStar.Mul
 
-val into_padded_array (v_LEN: usize) (slice: t_Slice u8) :
-    Pure (t_Array u8 v_LEN)
-    (requires (length slice <=. v_LEN))
-    (ensures (fun res ->  Seq.slice res 0 (Seq.length slice) == slice))
+val into_padded_array (v_LEN: usize) (slice: t_Slice u8)
+    : Prims.Pure (t_Array u8 v_LEN) Prims.l_True (fun _ -> Prims.l_True)
 
-val sample_vector_cbd (#p:Spec.Kyber.params)
+val sample_ring_element_cbd
       (v_K v_ETA2_RANDOMNESS_SIZE v_ETA2: usize)
       (prf_input: t_Array u8 (sz 33))
       (domain_separator: u8)
-    : Pure (t_Array u8 (sz 33) & u8 & t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
-      (requires v domain_separator <= v v_K /\ v_K <=. sz 4 /\
-                v_K = p.v_RANK /\ v_ETA2 = p.v_ETA2 /\
-                v_ETA2_RANDOMNESS_SIZE = Spec.Kyber.v_ETA2_RANDOMNESS_SIZE p)
-      (ensures (fun (prf,ds,x) -> v ds == v domain_separator + v v_K /\
-                Seq.slice prf 0 32 == Seq.slice prf_input 0 32 /\
-                Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p x ==
-                Spec.Kyber.sample_vector_cbd #p (Seq.slice prf_input 0 32) (sz (v domain_separator))))
+    : Prims.Pure
+      (t_Array u8 (sz 33) & u8 & t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+      Prims.l_True
+      (fun _ -> Prims.l_True)
 
-
-val sample_vector_cbd_then_ntt (#p:Spec.Kyber.params)
+val sample_vector_cbd_then_ntt
       (v_K v_ETA v_ETA_RANDOMNESS_SIZE: usize)
       (prf_input: t_Array u8 (sz 33))
-      (domain_separator: u8{v domain_separator <= v v_K /\ v_K <=. sz 4})
-    : Pure (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K & u8) 
-      (requires (v_K == p.v_RANK /\ v_ETA == p.v_ETA1 /\ v_ETA_RANDOMNESS_SIZE == Spec.Kyber.v_ETA1_RANDOMNESS_SIZE p))
-      (ensures (fun (x,ds) -> v ds == v domain_separator + v v_K /\
-                Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p x ==
-                Spec.Kyber.sample_vector_cbd_then_ntt #p (Seq.slice prf_input 0 32) (sz (v domain_separator))))
+      (domain_separator: u8)
+    : Prims.Pure (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K & u8)
+      Prims.l_True
+      (fun _ -> Prims.l_True)
 
-val compress_then_serialize_u (#p:Spec.Kyber.params)
+val compress_then_serialize_u
       (v_K v_OUT_LEN v_COMPRESSION_FACTOR v_BLOCK_LEN: usize)
-      (input: t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
-    : Pure (t_Array u8 v_OUT_LEN)
-      (requires (v_K == p.v_RANK /\ v_OUT_LEN == Spec.Kyber.v_C1_SIZE p /\
-                 v_COMPRESSION_FACTOR == p.v_VECTOR_U_COMPRESSION_FACTOR /\
-                 v_BLOCK_LEN = Spec.Kyber.v_C1_BLOCK_SIZE p))
-      (ensures (fun res -> 
-        res == Spec.Kyber.compress_then_encode_u p 
-               (Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p input)))
+      (input: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+    : Prims.Pure (t_Array u8 v_OUT_LEN) Prims.l_True (fun _ -> Prims.l_True)
 
-val deserialize_then_decompress_u (#p:Spec.Kyber.params)
-      (v_K v_CIPHERTEXT_SIZE v_VECTOR_U_ENCODED_SIZE v_U_COMPRESSION_FACTOR: usize)
+val deserialize_then_decompress_u
+      (v_K v_CIPHERTEXT_SIZE v_U_COMPRESSION_FACTOR: usize)
       (ciphertext: t_Array u8 v_CIPHERTEXT_SIZE)
-    : Pure (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) 
-      (requires v_K == p.v_RANK /\
-                v_CIPHERTEXT_SIZE == Spec.Kyber.v_CPA_PKE_CIPHERTEXT_SIZE p /\
-                v_VECTOR_U_ENCODED_SIZE == Spec.Kyber.v_C1_SIZE p /\
-                v_U_COMPRESSION_FACTOR == p.v_VECTOR_U_COMPRESSION_FACTOR)
-      (ensures fun res ->
-        Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p res ==
-        Spec.Kyber.(vector_ntt (decode_then_decompress_u p (Seq.slice ciphertext 0 (v (Spec.Kyber.v_C1_SIZE p))))))
-
-val deserialize_public_key (#p:Spec.Kyber.params) 
-    (v_K: usize) (public_key: t_Array u8 (Spec.Kyber.v_T_AS_NTT_ENCODED_SIZE p))
-    : Pure (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
-      (requires v_K == p.v_RANK /\
-                length public_key == Spec.Kyber.v_RANKED_BYTES_PER_RING_ELEMENT p)
-      (ensures fun res -> 
-        Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b res ==
-        Spec.Kyber.vector_decode_12 #p public_key)
-   
-val deserialize_secret_key (#p:Spec.Kyber.params) (v_K: usize) (secret_key: t_Slice u8)
-    : Pure (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
-      (requires v_K == p.v_RANK /\
-                length secret_key == Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p)
-      (ensures fun res ->
-         Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p res ==
-         Spec.Kyber.vector_decode_12 #p secret_key)
-    
+    : Prims.Pure (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+      Prims.l_True
+      (fun _ -> Prims.l_True)
+
+val deserialize_public_key (v_K: usize) (public_key: t_Slice u8)
+    : Prims.Pure (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+      Prims.l_True
+      (fun _ -> Prims.l_True)
+
+val deserialize_secret_key (v_K: usize) (secret_key: t_Slice u8)
+    : Prims.Pure (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+      Prims.l_True
+      (fun _ -> Prims.l_True)
 
-val decrypt (#p:Spec.Kyber.params)
+val decrypt
       (v_K v_CIPHERTEXT_SIZE v_VECTOR_U_ENCODED_SIZE v_U_COMPRESSION_FACTOR v_V_COMPRESSION_FACTOR:
           usize)
       (secret_key: t_Slice u8)
       (ciphertext: t_Array u8 v_CIPHERTEXT_SIZE)
-    : Pure (t_Array u8 (sz 32))
-      (requires (v_K == p.v_RANK /\
-                 length secret_key == Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p /\
-                 v_CIPHERTEXT_SIZE == Spec.Kyber.v_CPA_PKE_CIPHERTEXT_SIZE p /\
-                 v_VECTOR_U_ENCODED_SIZE == Spec.Kyber.v_C1_SIZE p /\
-                 v_U_COMPRESSION_FACTOR == p.v_VECTOR_U_COMPRESSION_FACTOR /\
-                 v_V_COMPRESSION_FACTOR == p.v_VECTOR_V_COMPRESSION_FACTOR))
-      (ensures (fun res ->
-                res == Spec.Kyber.ind_cpa_decrypt p secret_key ciphertext))
-
+    : Prims.Pure (t_Array u8 (sz 32)) Prims.l_True (fun _ -> Prims.l_True)
 
-val encrypt (#p:Spec.Kyber.params)
+val encrypt
       (v_K v_CIPHERTEXT_SIZE v_T_AS_NTT_ENCODED_SIZE v_C1_LEN v_C2_LEN v_U_COMPRESSION_FACTOR v_V_COMPRESSION_FACTOR v_BLOCK_LEN v_ETA1 v_ETA1_RANDOMNESS_SIZE v_ETA2 v_ETA2_RANDOMNESS_SIZE:
           usize)
       (public_key: t_Slice u8)
       (message: t_Array u8 (sz 32))
-      (randomness: t_Slice u8{length randomness <. sz 33})
-    : Pure (t_Array u8 v_CIPHERTEXT_SIZE)
-      (requires (v_K == p.v_RANK /\
-                 v_ETA1 = p.v_ETA1 /\
-                 v_ETA1_RANDOMNESS_SIZE = Spec.Kyber.v_ETA1_RANDOMNESS_SIZE p /\
-                 v_ETA2 = p.v_ETA2 /\
-                 v_BLOCK_LEN == Spec.Kyber.v_C1_BLOCK_SIZE p /\
-                 v_ETA2_RANDOMNESS_SIZE = Spec.Kyber.v_ETA2_RANDOMNESS_SIZE p /\
-                 v_U_COMPRESSION_FACTOR == p.v_VECTOR_U_COMPRESSION_FACTOR /\
-                 v_V_COMPRESSION_FACTOR == p.v_VECTOR_V_COMPRESSION_FACTOR /\
-                 length public_key == Spec.Kyber.v_CPA_PKE_PUBLIC_KEY_SIZE p /\
-                 length randomness == Spec.Kyber.v_SHARED_SECRET_SIZE /\
-                 v_CIPHERTEXT_SIZE == Spec.Kyber.v_CPA_PKE_CIPHERTEXT_SIZE p /\
-                 v_T_AS_NTT_ENCODED_SIZE == Spec.Kyber.v_T_AS_NTT_ENCODED_SIZE p /\
-                 v_C1_LEN == Spec.Kyber.v_C1_SIZE p /\
-                 v_C2_LEN == Spec.Kyber.v_C2_SIZE p))
-      (ensures (fun ct -> ct == Spec.Kyber.ind_cpa_encrypt p public_key message randomness))
-               
-val serialize_secret_key (#p:Spec.Kyber.params)
+      (randomness: t_Slice u8)
+    : Prims.Pure (t_Array u8 v_CIPHERTEXT_SIZE) Prims.l_True (fun _ -> Prims.l_True)
+
+val serialize_secret_key
       (v_K v_OUT_LEN: usize)
-      (key: t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
-    : Pure (t_Array u8 v_OUT_LEN)
-      (requires (v_K == p.v_RANK /\ v_OUT_LEN == Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p))
-      (ensures (fun res -> 
-        res == Spec.Kyber.vector_encode_12 #p 
-          (Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p key)))
-      
-val serialize_public_key (#p:Spec.Kyber.params)
+      (key: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+    : Prims.Pure (t_Array u8 v_OUT_LEN) Prims.l_True (fun _ -> Prims.l_True)
+
+val serialize_public_key
       (v_K v_RANKED_BYTES_PER_RING_ELEMENT v_PUBLIC_KEY_SIZE: usize)
-      (tt_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
+      (tt_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
       (seed_for_a: t_Slice u8)
-      : Pure (t_Array u8 v_PUBLIC_KEY_SIZE)
-        (requires (v_K == p.v_RANK /\
-                   v_RANKED_BYTES_PER_RING_ELEMENT == Spec.Kyber.v_RANKED_BYTES_PER_RING_ELEMENT p /\
-                   v_PUBLIC_KEY_SIZE == Spec.Kyber.v_CPA_PKE_PUBLIC_KEY_SIZE p /\
-                   length seed_for_a == sz 32))
-        (ensures (fun res -> res == Seq.append (Spec.Kyber.vector_encode_12 
-                              (Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p tt_as_ntt))
-                            seed_for_a))
+    : Prims.Pure (t_Array u8 v_PUBLIC_KEY_SIZE) Prims.l_True (fun _ -> Prims.l_True)
 
-val generate_keypair (#p:Spec.Kyber.params)
+val generate_keypair
       (v_K v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE v_RANKED_BYTES_PER_RING_ELEMENT v_ETA1 v_ETA1_RANDOMNESS_SIZE:
           usize)
       (key_generation_seed: t_Slice u8)
-    : Pure (t_Array u8 v_PRIVATE_KEY_SIZE & t_Array u8 v_PUBLIC_KEY_SIZE)
-      (requires (v_K == p.v_RANK /\
-                 v_ETA1 == p.v_ETA1 /\
-                 v_ETA1_RANDOMNESS_SIZE == Spec.Kyber.v_ETA1_RANDOMNESS_SIZE p /\
-                 v_PUBLIC_KEY_SIZE == Spec.Kyber.v_CPA_PKE_PUBLIC_KEY_SIZE p /\
-                 v_PRIVATE_KEY_SIZE == Spec.Kyber.v_CPA_PKE_SECRET_KEY_SIZE p /\
-                 v_RANKED_BYTES_PER_RING_ELEMENT == Spec.Kyber.v_RANKED_BYTES_PER_RING_ELEMENT p /\
-                 length key_generation_seed == Spec.Kyber.v_CPA_PKE_KEY_GENERATION_SEED_SIZE))
-      (ensures (fun (sk,pk) -> (sk,pk) == Spec.Kyber.ind_cpa_generate_keypair p key_generation_seed))
- 
-    
+    : Prims.Pure (t_Array u8 v_PRIVATE_KEY_SIZE & t_Array u8 v_PUBLIC_KEY_SIZE)
+      Prims.l_True
+      (fun _ -> Prims.l_True)
diff -ruN extraction-edited/Libcrux.Kem.Kyber.Kyber1024.fst extraction-secret-independent/Libcrux.Kem.Kyber.Kyber1024.fst
--- extraction-edited/Libcrux.Kem.Kyber.Kyber1024.fst	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.Kyber1024.fst	1970-01-01 01:00:00.000000000 +0100
@@ -3,37 +3,22 @@
 open Core
 open FStar.Mul
 
-let decapsulate
-      (secret_key: Libcrux.Kem.Kyber.Types.t_MlKemPrivateKey (sz 3168))
-      (ciphertext: Libcrux.Kem.Kyber.Types.t_MlKemCiphertext (sz 1568))
+let decapsulate_1024_
+      (secret_key: Libcrux.Kem.Kyber.Types.t_KyberPrivateKey (sz 3168))
+      (ciphertext: Libcrux.Kem.Kyber.Types.t_KyberCiphertext (sz 1568))
      =
-  Libcrux.Kem.Kyber.decapsulate #Spec.Kyber.kyber1024_params (sz 4) (sz 3168) (sz 1536) (sz 1568) (sz 1568) (sz 1536) (sz 1408)
+  Libcrux.Kem.Kyber.decapsulate (sz 4) (sz 3168) (sz 1536) (sz 1568) (sz 1568) (sz 1536) (sz 1408)
     (sz 160) (sz 11) (sz 5) (sz 352) (sz 2) (sz 128) (sz 2) (sz 128) (sz 1600) secret_key ciphertext
 
-let encapsulate
-      (public_key: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1568))
+let encapsulate_1024_
+      (public_key: Libcrux.Kem.Kyber.Types.t_KyberPublicKey (sz 1568))
       (randomness: t_Array u8 (sz 32))
      =
-  Libcrux.Kem.Kyber.encapsulate #Spec.Kyber.kyber1024_params (sz 4) (sz 1568) (sz 1568) (sz 1536) (sz 1408) (sz 160) (sz 11)
+  Libcrux.Kem.Kyber.encapsulate (sz 4) (sz 1568) (sz 1568) (sz 1536) (sz 1408) (sz 160) (sz 11)
     (sz 5) (sz 352) (sz 2) (sz 128) (sz 2) (sz 128) public_key randomness
 
-let validate_public_key (public_key: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1568)) =
-  if
-    Libcrux.Kem.Kyber.validate_public_key #Spec.Kyber.kyber1024_params (sz 4)
-      (sz 1536)
-      (sz 1568)
-      public_key.Libcrux.Kem.Kyber.Types.f_value
-  then
-    Core.Option.Option_Some public_key
-    <:
-    Core.Option.t_Option (Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1568))
-  else
-    Core.Option.Option_None
-    <:
-    Core.Option.t_Option (Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1568))
-
-let generate_key_pair (randomness: t_Array u8 (sz 64)) =
-  Libcrux.Kem.Kyber.generate_keypair #Spec.Kyber.kyber1024_params (sz 4)
+let generate_key_pair_1024_ (randomness: t_Array u8 (sz 64)) =
+  Libcrux.Kem.Kyber.generate_keypair (sz 4)
     (sz 1536)
     (sz 3168)
     (sz 1568)
diff -ruN extraction-edited/Libcrux.Kem.Kyber.Kyber1024.fsti extraction-secret-independent/Libcrux.Kem.Kyber.Kyber1024.fsti
--- extraction-edited/Libcrux.Kem.Kyber.Kyber1024.fsti	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.Kyber1024.fsti	1970-01-01 01:00:00.000000000 +0100
@@ -63,32 +63,27 @@
   Libcrux.Kem.Kyber.Constants.v_SHARED_SECRET_SIZE +! v_CPA_PKE_CIPHERTEXT_SIZE_1024_
 
 unfold
-let t_MlKem1024Ciphertext = Libcrux.Kem.Kyber.Types.t_MlKemCiphertext (sz 1568)
+let t_Kyber1024Ciphertext = Libcrux.Kem.Kyber.Types.t_KyberCiphertext (sz 1568)
 
 unfold
-let t_MlKem1024PrivateKey = Libcrux.Kem.Kyber.Types.t_MlKemPrivateKey (sz 3168)
+let t_Kyber1024PrivateKey = Libcrux.Kem.Kyber.Types.t_KyberPrivateKey (sz 3168)
 
 unfold
-let t_MlKem1024PublicKey = Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1568)
+let t_Kyber1024PublicKey = Libcrux.Kem.Kyber.Types.t_KyberPublicKey (sz 1568)
 
-val decapsulate
-      (secret_key: Libcrux.Kem.Kyber.Types.t_MlKemPrivateKey (sz 3168))
-      (ciphertext: Libcrux.Kem.Kyber.Types.t_MlKemCiphertext (sz 1568))
+val decapsulate_1024_
+      (secret_key: Libcrux.Kem.Kyber.Types.t_KyberPrivateKey (sz 3168))
+      (ciphertext: Libcrux.Kem.Kyber.Types.t_KyberCiphertext (sz 1568))
     : Prims.Pure (t_Array u8 (sz 32)) Prims.l_True (fun _ -> Prims.l_True)
 
-val encapsulate
-      (public_key: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1568))
+val encapsulate_1024_
+      (public_key: Libcrux.Kem.Kyber.Types.t_KyberPublicKey (sz 1568))
       (randomness: t_Array u8 (sz 32))
-    : Prims.Pure (Libcrux.Kem.Kyber.Types.t_MlKemCiphertext (sz 1568) & t_Array u8 (sz 32))
+    : Prims.Pure (Libcrux.Kem.Kyber.Types.t_KyberCiphertext (sz 1568) & t_Array u8 (sz 32))
       Prims.l_True
       (fun _ -> Prims.l_True)
 
-val validate_public_key (public_key: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1568))
-    : Prims.Pure (Core.Option.t_Option (Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1568)))
-      Prims.l_True
-      (fun _ -> Prims.l_True)
-
-val generate_key_pair (randomness: t_Array u8 (sz 64))
-    : Prims.Pure (Libcrux.Kem.Kyber.Types.t_MlKemKeyPair (sz 3168) (sz 1568))
+val generate_key_pair_1024_ (randomness: t_Array u8 (sz 64))
+    : Prims.Pure (Libcrux.Kem.Kyber.Types.t_KyberKeyPair (sz 3168) (sz 1568))
       Prims.l_True
       (fun _ -> Prims.l_True)
diff -ruN extraction-edited/Libcrux.Kem.Kyber.Kyber512.fst extraction-secret-independent/Libcrux.Kem.Kyber.Kyber512.fst
--- extraction-edited/Libcrux.Kem.Kyber.Kyber512.fst	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.Kyber512.fst	1970-01-01 01:00:00.000000000 +0100
@@ -3,37 +3,22 @@
 open Core
 open FStar.Mul
 
-let decapsulate
-      (secret_key: Libcrux.Kem.Kyber.Types.t_MlKemPrivateKey (sz 1632))
-      (ciphertext: Libcrux.Kem.Kyber.Types.t_MlKemCiphertext (sz 768))
+let decapsulate_512_
+      (secret_key: Libcrux.Kem.Kyber.Types.t_KyberPrivateKey (sz 1632))
+      (ciphertext: Libcrux.Kem.Kyber.Types.t_KyberCiphertext (sz 768))
      =
-  Libcrux.Kem.Kyber.decapsulate #Spec.Kyber.kyber512_params (sz 2) (sz 1632) (sz 768) (sz 800) (sz 768) (sz 768) (sz 640)
+  Libcrux.Kem.Kyber.decapsulate (sz 2) (sz 1632) (sz 768) (sz 800) (sz 768) (sz 768) (sz 640)
     (sz 128) (sz 10) (sz 4) (sz 320) (sz 3) (sz 192) (sz 2) (sz 128) (sz 800) secret_key ciphertext
 
-let encapsulate
-      (public_key: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 800))
+let encapsulate_512_
+      (public_key: Libcrux.Kem.Kyber.Types.t_KyberPublicKey (sz 800))
       (randomness: t_Array u8 (sz 32))
      =
-  Libcrux.Kem.Kyber.encapsulate #Spec.Kyber.kyber512_params (sz 2) (sz 768) (sz 800) (sz 768) (sz 640) (sz 128) (sz 10) (sz 4)
+  Libcrux.Kem.Kyber.encapsulate (sz 2) (sz 768) (sz 800) (sz 768) (sz 640) (sz 128) (sz 10) (sz 4)
     (sz 320) (sz 3) (sz 192) (sz 2) (sz 128) public_key randomness
 
-let validate_public_key (public_key: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 800)) =
-  if
-    Libcrux.Kem.Kyber.validate_public_key #Spec.Kyber.kyber512_params (sz 2)
-      (sz 768)
-      (sz 800)
-      public_key.Libcrux.Kem.Kyber.Types.f_value
-  then
-    Core.Option.Option_Some public_key
-    <:
-    Core.Option.t_Option (Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 800))
-  else
-    Core.Option.Option_None
-    <:
-    Core.Option.t_Option (Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 800))
-
-let generate_key_pair (randomness: t_Array u8 (sz 64)) =
-  Libcrux.Kem.Kyber.generate_keypair #Spec.Kyber.kyber512_params (sz 2)
+let generate_key_pair_512_ (randomness: t_Array u8 (sz 64)) =
+  Libcrux.Kem.Kyber.generate_keypair (sz 2)
     (sz 768)
     (sz 1632)
     (sz 800)
diff -ruN extraction-edited/Libcrux.Kem.Kyber.Kyber512.fsti extraction-secret-independent/Libcrux.Kem.Kyber.Kyber512.fsti
--- extraction-edited/Libcrux.Kem.Kyber.Kyber512.fsti	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.Kyber512.fsti	1970-01-01 01:00:00.000000000 +0100
@@ -63,32 +63,27 @@
   Libcrux.Kem.Kyber.Constants.v_SHARED_SECRET_SIZE +! v_CPA_PKE_CIPHERTEXT_SIZE_512_
 
 unfold
-let t_MlKem512Ciphertext = Libcrux.Kem.Kyber.Types.t_MlKemCiphertext (sz 768)
+let t_Kyber512Ciphertext = Libcrux.Kem.Kyber.Types.t_KyberCiphertext (sz 768)
 
 unfold
-let t_MlKem512PrivateKey = Libcrux.Kem.Kyber.Types.t_MlKemPrivateKey (sz 1632)
+let t_Kyber512PrivateKey = Libcrux.Kem.Kyber.Types.t_KyberPrivateKey (sz 1632)
 
 unfold
-let t_MlKem512PublicKey = Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 800)
+let t_Kyber512PublicKey = Libcrux.Kem.Kyber.Types.t_KyberPublicKey (sz 800)
 
-val decapsulate
-      (secret_key: Libcrux.Kem.Kyber.Types.t_MlKemPrivateKey (sz 1632))
-      (ciphertext: Libcrux.Kem.Kyber.Types.t_MlKemCiphertext (sz 768))
+val decapsulate_512_
+      (secret_key: Libcrux.Kem.Kyber.Types.t_KyberPrivateKey (sz 1632))
+      (ciphertext: Libcrux.Kem.Kyber.Types.t_KyberCiphertext (sz 768))
     : Prims.Pure (t_Array u8 (sz 32)) Prims.l_True (fun _ -> Prims.l_True)
 
-val encapsulate
-      (public_key: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 800))
+val encapsulate_512_
+      (public_key: Libcrux.Kem.Kyber.Types.t_KyberPublicKey (sz 800))
       (randomness: t_Array u8 (sz 32))
-    : Prims.Pure (Libcrux.Kem.Kyber.Types.t_MlKemCiphertext (sz 768) & t_Array u8 (sz 32))
+    : Prims.Pure (Libcrux.Kem.Kyber.Types.t_KyberCiphertext (sz 768) & t_Array u8 (sz 32))
       Prims.l_True
       (fun _ -> Prims.l_True)
 
-val validate_public_key (public_key: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 800))
-    : Prims.Pure (Core.Option.t_Option (Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 800)))
-      Prims.l_True
-      (fun _ -> Prims.l_True)
-
-val generate_key_pair (randomness: t_Array u8 (sz 64))
-    : Prims.Pure (Libcrux.Kem.Kyber.Types.t_MlKemKeyPair (sz 1632) (sz 800))
+val generate_key_pair_512_ (randomness: t_Array u8 (sz 64))
+    : Prims.Pure (Libcrux.Kem.Kyber.Types.t_KyberKeyPair (sz 1632) (sz 800))
       Prims.l_True
       (fun _ -> Prims.l_True)
diff -ruN extraction-edited/Libcrux.Kem.Kyber.Kyber768.fst extraction-secret-independent/Libcrux.Kem.Kyber.Kyber768.fst
--- extraction-edited/Libcrux.Kem.Kyber.Kyber768.fst	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.Kyber768.fst	1970-01-01 01:00:00.000000000 +0100
@@ -3,37 +3,22 @@
 open Core
 open FStar.Mul
 
-let decapsulate
-      (secret_key: Libcrux.Kem.Kyber.Types.t_MlKemPrivateKey (sz 2400))
-      (ciphertext: Libcrux.Kem.Kyber.Types.t_MlKemCiphertext (sz 1088))
+let decapsulate_768_
+      (secret_key: Libcrux.Kem.Kyber.Types.t_KyberPrivateKey (sz 2400))
+      (ciphertext: Libcrux.Kem.Kyber.Types.t_KyberCiphertext (sz 1088))
      =
-    Libcrux.Kem.Kyber.decapsulate #Spec.Kyber.kyber768_params (sz 3) (sz 2400) (sz 1152) (sz 1184) (sz 1088) (sz 1152) (sz 960)
+  Libcrux.Kem.Kyber.decapsulate (sz 3) (sz 2400) (sz 1152) (sz 1184) (sz 1088) (sz 1152) (sz 960)
     (sz 128) (sz 10) (sz 4) (sz 320) (sz 2) (sz 128) (sz 2) (sz 128) (sz 1120) secret_key ciphertext
 
-let encapsulate
-      (public_key: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1184))
+let encapsulate_768_
+      (public_key: Libcrux.Kem.Kyber.Types.t_KyberPublicKey (sz 1184))
       (randomness: t_Array u8 (sz 32))
      =
-  Libcrux.Kem.Kyber.encapsulate #Spec.Kyber.kyber768_params (sz 3) (sz 1088) (sz 1184) (sz 1152) (sz 960) (sz 128) (sz 10)
+  Libcrux.Kem.Kyber.encapsulate (sz 3) (sz 1088) (sz 1184) (sz 1152) (sz 960) (sz 128) (sz 10)
     (sz 4) (sz 320) (sz 2) (sz 128) (sz 2) (sz 128) public_key randomness
 
-let validate_public_key (public_key: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1184)) =
-  if
-    Libcrux.Kem.Kyber.validate_public_key #Spec.Kyber.kyber768_params (sz 3)
-      (sz 1152)
-      (sz 1184)
-      public_key.Libcrux.Kem.Kyber.Types.f_value
-  then
-    Core.Option.Option_Some public_key
-    <:
-    Core.Option.t_Option (Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1184))
-  else
-    Core.Option.Option_None
-    <:
-    Core.Option.t_Option (Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1184))
-
-let generate_key_pair (randomness: t_Array u8 (sz 64)) =
-  Libcrux.Kem.Kyber.generate_keypair #Spec.Kyber.kyber768_params (sz 3)
+let generate_key_pair_768_ (randomness: t_Array u8 (sz 64)) =
+  Libcrux.Kem.Kyber.generate_keypair (sz 3)
     (sz 1152)
     (sz 2400)
     (sz 1184)
diff -ruN extraction-edited/Libcrux.Kem.Kyber.Kyber768.fsti extraction-secret-independent/Libcrux.Kem.Kyber.Kyber768.fsti
--- extraction-edited/Libcrux.Kem.Kyber.Kyber768.fsti	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.Kyber768.fsti	1970-01-01 01:00:00.000000000 +0100
@@ -63,33 +63,27 @@
   Libcrux.Kem.Kyber.Constants.v_SHARED_SECRET_SIZE +! v_CPA_PKE_CIPHERTEXT_SIZE_768_
 
 unfold
-let t_MlKem768Ciphertext = Libcrux.Kem.Kyber.Types.t_MlKemCiphertext (sz 1088)
+let t_Kyber768Ciphertext = Libcrux.Kem.Kyber.Types.t_KyberCiphertext (sz 1088)
 
 unfold
-let t_MlKem768PrivateKey = Libcrux.Kem.Kyber.Types.t_MlKemPrivateKey (sz 2400)
+let t_Kyber768PrivateKey = Libcrux.Kem.Kyber.Types.t_KyberPrivateKey (sz 2400)
 
 unfold
-let t_MlKem768PublicKey = Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1184)
+let t_Kyber768PublicKey = Libcrux.Kem.Kyber.Types.t_KyberPublicKey (sz 1184)
 
-val decapsulate
-      (secret_key: Libcrux.Kem.Kyber.Types.t_MlKemPrivateKey (sz 2400))
-      (ciphertext: Libcrux.Kem.Kyber.Types.t_MlKemCiphertext (sz 1088))
-    : Prims.Pure (t_Array u8 (sz 32)) Prims.l_True
-      (ensures (fun res -> res == Spec.Kyber.kyber768_decapsulate secret_key.f_value ciphertext.f_value))
+val decapsulate_768_
+      (secret_key: Libcrux.Kem.Kyber.Types.t_KyberPrivateKey (sz 2400))
+      (ciphertext: Libcrux.Kem.Kyber.Types.t_KyberCiphertext (sz 1088))
+    : Prims.Pure (t_Array u8 (sz 32)) Prims.l_True (fun _ -> Prims.l_True)
 
-val encapsulate
-      (public_key: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1184))
+val encapsulate_768_
+      (public_key: Libcrux.Kem.Kyber.Types.t_KyberPublicKey (sz 1184))
       (randomness: t_Array u8 (sz 32))
-    : Prims.Pure (Libcrux.Kem.Kyber.Types.t_MlKemCiphertext (sz 1088) & t_Array u8 (sz 32))
-      Prims.l_True
-      (ensures (fun (ct,ss)-> (ct.f_value,ss) == Spec.Kyber.kyber768_encapsulate public_key.f_value randomness))
-
-val validate_public_key (public_key: Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1184))
-    : Prims.Pure (Core.Option.t_Option (Libcrux.Kem.Kyber.Types.t_MlKemPublicKey (sz 1184)))
+    : Prims.Pure (Libcrux.Kem.Kyber.Types.t_KyberCiphertext (sz 1088) & t_Array u8 (sz 32))
       Prims.l_True
       (fun _ -> Prims.l_True)
 
-val generate_key_pair (randomness: t_Array u8 (sz 64))
-    : Prims.Pure (Libcrux.Kem.Kyber.Types.t_MlKemKeyPair (sz 2400) (sz 1184))
+val generate_key_pair_768_ (randomness: t_Array u8 (sz 64))
+    : Prims.Pure (Libcrux.Kem.Kyber.Types.t_KyberKeyPair (sz 2400) (sz 1184))
       Prims.l_True
-      (ensures (fun kp -> (kp.f_sk.f_value,kp.f_pk.f_value) == Spec.Kyber.kyber768_generate_keypair randomness))
+      (fun _ -> Prims.l_True)
diff -ruN extraction-edited/Libcrux.Kem.Kyber.Matrix.fst extraction-secret-independent/Libcrux.Kem.Kyber.Matrix.fst
--- extraction-edited/Libcrux.Kem.Kyber.Matrix.fst	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.Matrix.fst	1970-01-01 01:00:00.000000000 +0100
@@ -3,418 +3,432 @@
 open Core
 open FStar.Mul
 
-open Libcrux.Kem.Kyber.Arithmetic
-
-let op_Array_Access (x:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement) (i:usize{v i < 256}): i32  =
-    x.f_coefficients.[i]
-    
-
-#push-options "--ifuel 0 --z3rlimit 700"
-let compute_As_plus_e v_K matrix_A s_as_ntt error_as_ntt =
-  let wfZero: wfPolynomialRingElement = (Libcrux.Kem.Kyber.Arithmetic.cast_poly_b #1 #3328 Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO) in
-  let result:t_Array wfPolynomialRingElement v_K =
-    Rust_primitives.Hax.repeat wfZero v_K
-  in
-  [@ inline_let]
-  let inv0 = fun (acc:t_Array wfPolynomialRingElement v_K) (i:usize) -> 
-   (v i <= v v_K) /\
-   (forall (j:usize). (v j >= v i /\ v j < v v_K) ==> (acc.[j] <: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement) == wfZero)
-  in
-  assert (inv0 result (sz 0));
-  let result:t_Array wfPolynomialRingElement v_K =
-    Rust_primitives.Iterators.foldi_slice #(t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) #(t_Array wfPolynomialRingElement v_K) #inv0
-      matrix_A
+let compute_As_plus_e
+      (v_K: usize)
+      (matrix_A: t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K)
+      (s_as_ntt error_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+     =
+  let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+    Rust_primitives.Hax.repeat Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO v_K
+  in
+  let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter (Core.Iter.Traits.Iterator.f_enumerate
+              (Core.Slice.impl__iter (Rust_primitives.unsize matrix_A
+                    <:
+                    t_Slice (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K))
+                <:
+                Core.Slice.Iter.t_Iter
+                (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K))
+            <:
+            Core.Iter.Adapters.Enumerate.t_Enumerate
+            (Core.Slice.Iter.t_Iter
+              (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)))
+        <:
+        Core.Iter.Adapters.Enumerate.t_Enumerate
+        (Core.Slice.Iter.t_Iter (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)))
       result
       (fun result temp_1_ ->
-          let orig_result = result in
-          let orig_result_cast = (cast_vector_b #v_K #3328 #(v v_K * 3328) orig_result) in
-          let i, row:(usize & t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) =
+          let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K = result in
+          let i, row:(usize & t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) =
             temp_1_
           in
-          [@ inline_let]
-          let inv1 = fun (acc:t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328)) v_K) (inner:usize) ->
-             (v inner <= v v_K) /\
-             (forall (j:usize). (v j < v i /\ v j < v v_K) ==> acc.[j] == orig_result_cast.[j]) /\
-             (forall (j:usize). (v j > v i /\ v j < v v_K) ==> acc.[j] == orig_result_cast.[j]) /\
-             (poly_range (acc.[i] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328)) (v inner * 3328))
-          in
-          assert (forall (k:usize). (v k < 256) ==> v (result.[i] <: wfPolynomialRingElement).f_coefficients.[k] == 0);
-          assert(inv1 orig_result_cast (sz 0));
-          let result:t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328)) v_K =
-            Rust_primitives.Iterators.foldi_slice #Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement #(t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328)) v_K) #inv1
-              row
-              orig_result_cast
+          let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+            Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter (Core.Iter.Traits.Iterator.f_enumerate
+                      (Core.Slice.impl__iter (Rust_primitives.unsize row
+                            <:
+                            t_Slice Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+                        <:
+                        Core.Slice.Iter.t_Iter Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+                    <:
+                    Core.Iter.Adapters.Enumerate.t_Enumerate
+                    (Core.Slice.Iter.t_Iter Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement))
+                <:
+                Core.Iter.Adapters.Enumerate.t_Enumerate
+                (Core.Slice.Iter.t_Iter Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement))
+              result
               (fun result temp_1_ ->
+                  let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+                    result
+                  in
                   let j, matrix_element:(usize &
-                    Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement) =
+                    Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
                     temp_1_
                   in
-                  let resulti = down_cast_poly_b #(v v_K * 3328) #(v j * 3328) result.[i] in
-                  let product:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+                  let product:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
                     Libcrux.Kem.Kyber.Ntt.ntt_multiply matrix_element
-                      (s_as_ntt.[ j ] <: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+                      (s_as_ntt.[ j ] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
                   in
-                  let product_sum:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b ((v j + 1) * 3328)  =
-                      (Libcrux.Kem.Kyber.Arithmetic.add_to_ring_element #(v j * 3328) #3328 v_K
-                          resulti
-                          product) in
-                  let product_sum:(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328)) = cast_poly_b #((v j+1)* 3328) #(v v_K * 3328) product_sum in 
-                  let result:t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328)) v_K =
+                  let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
                     Rust_primitives.Hax.Monomorphized_update_at.update_at_usize result
                       i
-                      product_sum
+                      (Libcrux.Kem.Kyber.Arithmetic.add_to_ring_element v_K
+                          (result.[ i ] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+                          product
+                        <:
+                        Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
                   in
                   result)
           in
-          let result1 = result in
-          [@ inline_let]
-          let inv2 = fun (acc:t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328)) v_K) (inner:usize) -> 
-             (v inner <= 256) /\
-             (forall (j:usize). (v j < v i /\ v j < v v_K) ==> acc.[j] == orig_result_cast.[j]) /\
-             (forall (j:usize). (v j > v i /\ v j < v v_K) ==> acc.[j] == orig_result_cast.[j]) /\
-             (forall (j:usize). (v j < v inner) ==> (i32_range (acc.[i] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328)).f_coefficients.[j] 3328))
-             // And all indexes above v inner are unchanged from result1
-          in
-          assert (inv2 result1 (sz 0));
-          let result:t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328)) v_K =
-            Rust_primitives.Iterators.foldi_range #_ #(t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328)) v_K) #inv2 {
-              Core.Ops.Range.f_start = sz 0;
-              Core.Ops.Range.f_end = Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
-            }
+          Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
+                    Core.Ops.Range.f_start = sz 0;
+                    Core.Ops.Range.f_end
+                    =
+                    Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
+                  }
+                  <:
+                  Core.Ops.Range.t_Range usize)
+              <:
+              Core.Ops.Range.t_Range usize)
             result
-            (fun result j -> 
-                let result: t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328)) v_K = result in
+            (fun result j ->
+                let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+                  result
+                in
                 let j:usize = j in
-                let resulti:(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328)) = result.[ i ]  <:  (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328)) in
-                let coefficient_normal_form: i32_b ((nat_div_ceil (v v_K * 3328 * 1353) (pow2 16)) + 1665) =
-                  Libcrux.Kem.Kyber.Arithmetic.to_standard_domain #(v v_K * 3328) (resulti
-                        .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ])
+                let coefficient_normal_form:i32 =
+                  Libcrux.Kem.Kyber.Arithmetic.to_standard_domain ((result.[ i ]
+                        <:
+                        Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+                        .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ]
+                      <:
+                      i32)
                 in
-                assert ((nat_div_ceil (v v_K * 3328 * 1353) (pow2 16)) + 1665 <= 1940);
-                let coefficient_normal_form: i32_b 1940 = cast_i32_b #((nat_div_ceil (v v_K * 3328 * 1353) (pow2 16)) + 1665)  #1940 coefficient_normal_form in
-                let x1: i32_b 3328 = (error_as_ntt.[ i ]
-                                  <:
-                                  Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
-                                  .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ] in
-                let x2: i32_b 5268 = add_i32_b coefficient_normal_form x1 in
-                assert (5268 <= v v_BARRETT_R /\ v v_BARRETT_R < pow2 31);
-                let x3: i32_b (v v_BARRETT_R) = cast_i32_b #5268 #(v v_BARRETT_R) x2 in
-                let resultij: i32_b 3328 =  Libcrux.Kem.Kyber.Arithmetic.barrett_reduce x3 in
-                let resultij: i32_b (v v_K * 3328) =  cast_i32_b #3328 #(v v_K * 3328) resultij in
-                let resulti_coeffs =
-                  Rust_primitives.Hax.Monomorphized_update_at.update_at_usize
-                   (resulti.Libcrux.Kem.Kyber.Arithmetic.f_coefficients)
-                    j resultij in
-                let result = 
                 Rust_primitives.Hax.Monomorphized_update_at.update_at_usize result
                   i
                   ({
-                      resulti with
+                      (result.[ i ] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) with
                       Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                      = resulti_coeffs
+                      =
+                      Rust_primitives.Hax.Monomorphized_update_at.update_at_usize (result.[ i ]
+                          <:
+                          Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+                          .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
+                        j
+                        (Libcrux.Kem.Kyber.Arithmetic.barrett_reduce (coefficient_normal_form +!
+                              ((error_as_ntt.[ i ]
+                                  <:
+                                  Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+                                  .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ]
+                                <:
+                                i32)
+                              <:
+                              i32)
+                          <:
+                          i32)
+                      <:
+                      t_Array i32 (sz 256)
                     }
                     <:
-                    Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K*3328)) in
-                assert ((result.[i]).f_coefficients.[j] == resultij);
-                assert(inv2 result (j +! sz 1));
-                let result: x:t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328)) v_K{inv2 x (j +! mk_int 1)} = result in
-                result) in
-      assert (v i + 1 < v v_K ==> result.[i +! sz 1] == orig_result_cast.[i +! sz 1]);
-      let result: t_Array wfPolynomialRingElement v_K =
-        down_cast_vector_b #v_K #(v v_K * 3328) #3328 result in
-      assert (forall (j:usize). (v j >= v i + 1 /\ v j < v v_K) ==> derefine_poly_b result.[j] == derefine_poly_b orig_result.[j]); 
-      assume (inv0 result (i +! sz 1));
-      result)
-  in
-  admit(); //P-F
-  result  
-#pop-options 
+                    Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)))
+  in
+  result
 
-#push-options "--ifuel 0 --z3rlimit 100"
-let compute_message #p v_K m_v secret_as_ntt u_as_ntt = 
-  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328) =
-    Libcrux.Kem.Kyber.Arithmetic.cast_poly_b Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
-  in
-  let acc_t = Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328) in
-  [@ inline_let]
-  let inv = fun (acc:acc_t) (i:usize) -> 
-             (v i <= v v_K) /\
-             (poly_range #(v v_K * 3328) acc (v i * 3328))
+let compute_message
+      (v_K: usize)
+      (v: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+      (secret_as_ntt u_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+     =
+  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+    Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
   in
-  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328) =
-    Rust_primitives.Iterators.foldi_range #_ #acc_t #inv {
+  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
               Core.Ops.Range.f_start = sz 0;
               Core.Ops.Range.f_end = v_K
             }
-      result 
+            <:
+            Core.Ops.Range.t_Range usize)
+        <:
+        Core.Ops.Range.t_Range usize)
+      result
       (fun result i ->
+          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = result in
           let i:usize = i in
-          let result:t_PolynomialRingElement_b (v i * 3328) = 
-            down_cast_poly_b #(v v_K * 3328) #(v i * 3328) result in
-          let product:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+          let product:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             Libcrux.Kem.Kyber.Ntt.ntt_multiply (secret_as_ntt.[ i ]
                 <:
-                Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
-              (u_as_ntt.[ i ] <: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+                Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+              (u_as_ntt.[ i ] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
           in
-          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b ((v i+1) * 3328)  =
+          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             Libcrux.Kem.Kyber.Arithmetic.add_to_ring_element v_K result product
           in
-          let result = cast_poly_b #((v i + 1) * 3328) #(v v_K * 3328) result in
-          assert(inv result (i +! sz 1));
           result)
   in
-  let acc_t = t_PolynomialRingElement_b (64*v v_K*3328) in
-  let result:acc_t = Libcrux.Kem.Kyber.Ntt.invert_ntt_montgomery v_K result
+  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+    Libcrux.Kem.Kyber.Ntt.invert_ntt_montgomery v_K result
   in
-  [@ inline_let]
-  let inv = fun (acc:acc_t) (i:usize) ->
-    (v i <= 256) /\
-    (forall (j:usize). (v j < v i) ==> i32_range ((acc <: t_PolynomialRingElement_b (64* v v_K * 3328)).f_coefficients.[j]) 3328) in
-  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64*v v_K*3328) =
-    Rust_primitives.Iterators.foldi_range #_ #_ #inv {
+  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
               Core.Ops.Range.f_start = sz 0;
               Core.Ops.Range.f_end = Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
             }
-      result 
+            <:
+            Core.Ops.Range.t_Range usize)
+        <:
+        Core.Ops.Range.t_Range usize)
+      result
       (fun result i ->
+          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = result in
           let i:usize = i in
-          let coefficient_normal_form: i32_b (nat_div_ceil (306921472*v v_K) 65536 + 1665) = 
-              Libcrux.Kem.Kyber.Arithmetic.montgomery_reduce 
-                           (Libcrux.Kem.Kyber.Arithmetic.mul_i32_b #(64 * v v_K * 3328) #1441
-                           result.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ] 
-                           (1441l <: Libcrux.Kem.Kyber.Arithmetic.i32_b 1441)) in
-          let resulti : i32_b 3328 = (Libcrux.Kem.Kyber.Arithmetic.barrett_reduce ((m_v
-                          .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ]
-                        <:
-                        i32) -!
-                      coefficient_normal_form
-                      <:
-                      i32)
+          let coefficient_normal_form:i32 =
+            Libcrux.Kem.Kyber.Arithmetic.montgomery_reduce ((result
+                    .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ]
                   <:
-                  i32) in
-          let resulti = cast_i32_b #3328 #(64*v v_K*3328) resulti in
-          let result =
+                  i32) *!
+                1441l
+                <:
+                i32)
+          in
+          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               result with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
               =
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize result
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                i resulti
+                i
+                (Libcrux.Kem.Kyber.Arithmetic.barrett_reduce ((v
+                          .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ]
+                        <:
+                        i32) -!
+                      coefficient_normal_form
+                      <:
+                      i32)
+                  <:
+                  i32)
             }
+            <:
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
-          assert (inv result (i +! sz 1));
           result)
   in
-  admit(); //P-F
   result
-#pop-options
 
-#push-options "--ifuel 0 --z3rlimit 100"
-let compute_ring_element_v v_K tt_as_ntt r_as_ntt error_2_ message =
-  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328) =
-    Libcrux.Kem.Kyber.Arithmetic.cast_poly_b Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
-  in
-  [@ inline_let]
-  let inv = fun (acc:t_PolynomialRingElement_b (v v_K * 3328)) (i:usize) ->
-    (v i <= 256) /\
-    (poly_range acc (v i * 3328)) in
-  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328) =
-    Rust_primitives.Iterators.foldi_range #_ #_ #inv ({
+let compute_ring_element_v
+      (v_K: usize)
+      (tt_as_ntt r_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+      (error_2_ message: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+     =
+  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+    Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
+  in
+  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
               Core.Ops.Range.f_start = sz 0;
               Core.Ops.Range.f_end = v_K
             }
+            <:
+            Core.Ops.Range.t_Range usize)
         <:
         Core.Ops.Range.t_Range usize)
       result
       (fun result i ->
-          let product:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = result in
+          let i:usize = i in
+          let product:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             Libcrux.Kem.Kyber.Ntt.ntt_multiply (tt_as_ntt.[ i ]
                 <:
-                Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
-              (r_as_ntt.[ i ] <: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+                Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+              (r_as_ntt.[ i ] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
           in
-          let result:t_PolynomialRingElement_b (v i * 3328) = 
-            down_cast_poly_b #(v v_K * 3328) #(v i * 3328) result in
-          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b ((v i + 1) * 3328) =
+          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             Libcrux.Kem.Kyber.Arithmetic.add_to_ring_element v_K result product
           in
-          cast_poly_b result)
+          result)
   in
-  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64 * v v_K * 3328) =
+  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
     Libcrux.Kem.Kyber.Ntt.invert_ntt_montgomery v_K result
   in
-  [@ inline_let]
-  let inv = fun (acc:t_PolynomialRingElement_b (64 * v v_K * 3328)) (i:usize) -> 
-    (v i <= 256) /\
-    (forall (j:usize). (v j < v i) ==> i32_range ((acc <: t_PolynomialRingElement_b (64* v v_K * 3328)).f_coefficients.[j]) 3328) in
-  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64 * v v_K * 3328) =
-    Rust_primitives.Iterators.foldi_range #_ #_ #inv {
+  let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
               Core.Ops.Range.f_start = sz 0;
               Core.Ops.Range.f_end = Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
             }
-      result 
+            <:
+            Core.Ops.Range.t_Range usize)
+        <:
+        Core.Ops.Range.t_Range usize)
+      result
       (fun result i ->
-          let coefficient_normal_form: i32_b (nat_div_ceil (306921472*v v_K) 65536 + 1665) = 
-              Libcrux.Kem.Kyber.Arithmetic.montgomery_reduce 
-                           (Libcrux.Kem.Kyber.Arithmetic.mul_i32_b #(64 * v v_K * 3328) #1441
-                           result.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ] 
-                           (1441l <: Libcrux.Kem.Kyber.Arithmetic.i32_b 1441)) in
-          let resulti : i32_b 3328 = 
-            (Libcrux.Kem.Kyber.Arithmetic.barrett_reduce ((coefficient_normal_form +!
-                        (error_2_.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ] <: i32)
-                        <:
-                        i32) +!
-                      (message.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ] <: i32)
-                      <:
-                      i32)
+          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = result in
+          let i:usize = i in
+          let coefficient_normal_form:i32 =
+            Libcrux.Kem.Kyber.Arithmetic.montgomery_reduce ((result
+                    .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ]
                   <:
-                  i32) in
-          let resulti = cast_i32_b #3328 #(64*v v_K*3328) resulti in
-          let result =
+                  i32) *!
+                1441l
+                <:
+                i32)
+          in
+          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               result with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
               =
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize result
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-                i resulti
+                i
+                (Libcrux.Kem.Kyber.Arithmetic.barrett_reduce ((coefficient_normal_form +!
+                        (error_2_.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ] <: i32)
+                        <:
+                        i32) +!
+                      (message.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ] <: i32)
+                      <:
+                      i32)
+                  <:
+                  i32)
             }
+            <:
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
           result)
   in
-  admit(); //P-F
   result
-#pop-options
 
-#push-options "--ifuel 0 --z3rlimit 300"
 let compute_vector_u
       (v_K: usize)
-      (a_as_ntt: t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) v_K)
-      (r_as_ntt error_1_: t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) =
-  let wfZero: wfPolynomialRingElement = (Libcrux.Kem.Kyber.Arithmetic.cast_poly_b #1 #3328 Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO) in
-  let result:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
-    Rust_primitives.Hax.repeat wfZero v_K
-  in
-  let acc_t = t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K in
-  [@ inline_let]
-  let inv0 = fun (acc:t_Array wfPolynomialRingElement v_K) (i:usize) -> 
-   (v i <= v v_K) /\
-   (forall (j:usize). (v j >= v i /\ v j < v v_K) ==> (acc.[j] <: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement) == wfZero)
-  in
-  let result:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K =
-    Rust_primitives.Iterators.foldi_slice #(t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) #acc_t #inv0
-      a_as_ntt
+      (a_as_ntt: t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K)
+      (r_as_ntt error_1_: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+     =
+  let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+    Rust_primitives.Hax.repeat Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO v_K
+  in
+  let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter (Core.Iter.Traits.Iterator.f_enumerate
+              (Core.Slice.impl__iter (Rust_primitives.unsize a_as_ntt
+                    <:
+                    t_Slice (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K))
+                <:
+                Core.Slice.Iter.t_Iter
+                (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K))
+            <:
+            Core.Iter.Adapters.Enumerate.t_Enumerate
+            (Core.Slice.Iter.t_Iter
+              (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)))
+        <:
+        Core.Iter.Adapters.Enumerate.t_Enumerate
+        (Core.Slice.Iter.t_Iter (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)))
       result
       (fun result temp_1_ ->
-          let result:t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K = result in
-          let orig_result = result in
-          let orig_result_cast = (cast_vector_b #v_K #3328 #(64 * v v_K * 3328) orig_result) in
-          let i, row:(usize & t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) =
+          let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K = result in
+          let i, row:(usize & t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) =
             temp_1_
           in
-          [@ inline_let]
-          let inv1 = fun (acc:t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64 * v v_K * 3328)) v_K) (inner:usize) ->
-             (v inner <= v v_K) /\
-             (forall (j:usize). (v j < v i /\ v j < v v_K) ==> acc.[j] == orig_result_cast.[j]) /\
-             (forall (j:usize). (v j > v i /\ v j < v v_K) ==> acc.[j] == orig_result_cast.[j]) /\
-             (poly_range (acc.[i] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64 * v v_K * 3328)) (v inner * 3328))
-          in
-          assert (forall (k:usize). (v k < 256) ==> v (result.[i] <: wfPolynomialRingElement).f_coefficients.[k] == 0);
-          assert(inv1 orig_result_cast (sz 0));
-          let result:t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64 * v v_K * 3328)) v_K =
-            Rust_primitives.Iterators.foldi_slice #Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement #(t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64 * v v_K * 3328)) v_K) #inv1
-              row
-              orig_result_cast
+          let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+            Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter (Core.Iter.Traits.Iterator.f_enumerate
+                      (Core.Slice.impl__iter (Rust_primitives.unsize row
+                            <:
+                            t_Slice Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+                        <:
+                        Core.Slice.Iter.t_Iter Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+                    <:
+                    Core.Iter.Adapters.Enumerate.t_Enumerate
+                    (Core.Slice.Iter.t_Iter Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement))
+                <:
+                Core.Iter.Adapters.Enumerate.t_Enumerate
+                (Core.Slice.Iter.t_Iter Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement))
+              result
               (fun result temp_1_ ->
-                  let j, a_element:(usize & Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement) =
+                  let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+                    result
+                  in
+                  let j, a_element:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
                     temp_1_
                   in
-                  let resulti = down_cast_poly_b #(64 * v v_K * 3328) #(v j * 3328) result.[i] in
-                  let product:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+                  let product:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
                     Libcrux.Kem.Kyber.Ntt.ntt_multiply a_element
-                      (r_as_ntt.[ j ] <: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+                      (r_as_ntt.[ j ] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
                   in
-                  let product_sum:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b ((v j + 1) * 3328)  =
-                      (Libcrux.Kem.Kyber.Arithmetic.add_to_ring_element #(v j * 3328) #3328 v_K
-                          resulti
-                          product) in
-                  let product_sum:(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64 * v v_K * 3328)) = cast_poly_b #((v j+1)* 3328) #(64 * v v_K * 3328) product_sum in 
-                  let result:t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64 * v v_K * 3328)) v_K =
+                  let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
                     Rust_primitives.Hax.Monomorphized_update_at.update_at_usize result
                       i
-                      product_sum
+                      (Libcrux.Kem.Kyber.Arithmetic.add_to_ring_element v_K
+                          (result.[ i ] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+                          product
+                        <:
+                        Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
                   in
                   result)
           in
-          assert (forall (j:usize). (v j < v i /\ v j < v v_K) ==> result.[j] == orig_result_cast.[j]);
-          assert (forall (j:usize). (v j > v i /\ v j < v v_K) ==> result.[j] == orig_result_cast.[j]);
-          let resulti : t_PolynomialRingElement_b (v v_K * 3328) = down_cast_poly_b result.[i] in
-          let result =
+          let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
             Rust_primitives.Hax.Monomorphized_update_at.update_at_usize result
               i
-              (Libcrux.Kem.Kyber.Ntt.invert_ntt_montgomery v_K resulti)
-           in
-          [@ inline_let]
-          let inv2 = fun (acc:t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64*v v_K * 3328)) v_K) (inner:usize) -> 
-             (v inner <= 256) /\
-             (forall (j:usize). (v j < v i /\ v j < v v_K) ==> acc.[j] == orig_result_cast.[j]) /\
-             (forall (j:usize). (v j > v i /\ v j < v v_K) ==> acc.[j] == orig_result_cast.[j]) /\
-             (forall (j:usize). (v j < v inner) ==> (i32_range (acc.[i] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64*v v_K * 3328)).f_coefficients.[j] 3328))
-             // And all indexes above v inner are unchanged from result1
-          in
-          assert (forall (j:usize). (v j < v i /\ v j < v v_K) ==> result.[j] == orig_result_cast.[j]);
-          assert (forall (j:usize). (v j > v i /\ v j < v v_K) ==> result.[j] == orig_result_cast.[j]);
-          assert (inv2 result (sz 0));
-          let result:t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64*v v_K * 3328)) v_K =
-            Rust_primitives.Iterators.foldi_range #_ #(t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64*v v_K * 3328)) v_K) #inv2 {
-              Core.Ops.Range.f_start = sz 0;
-              Core.Ops.Range.f_end = Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
-            }
+              (Libcrux.Kem.Kyber.Ntt.invert_ntt_montgomery v_K
+                  (result.[ i ] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+                <:
+                Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+          in
+          Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
+                    Core.Ops.Range.f_start = sz 0;
+                    Core.Ops.Range.f_end
+                    =
+                    Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
+                  }
+                  <:
+                  Core.Ops.Range.t_Range usize)
+              <:
+              Core.Ops.Range.t_Range usize)
             result
             (fun result j ->
-                let result: t_Array (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64*v v_K * 3328)) v_K = result in
-                let resulti:(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64*v v_K * 3328)) = result.[ i ]  <:  (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64*v v_K * 3328)) in
-                let coefficient_normal_form: i32_b (nat_div_ceil (306921472*v v_K) 65536 + 1665) = 
-              Libcrux.Kem.Kyber.Arithmetic.montgomery_reduce 
-                           (Libcrux.Kem.Kyber.Arithmetic.mul_i32_b #(64 * v v_K * 3328) #1441
-                           (resulti <: t_PolynomialRingElement_b (64*v v_K * 3328)).f_coefficients.[j] (1441l <: Libcrux.Kem.Kyber.Arithmetic.i32_b 1441)) in
-                let resultij: i32_b 3328 = (Libcrux.Kem.Kyber.Arithmetic.barrett_reduce 
-                                    (add_i32_b coefficient_normal_form ((error_1_.[ i ]
-                                    <:
-                                    Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
-                                    .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ]))) in
-                let result =
+                let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
+                  result
+                in
+                let j:usize = j in
+                let coefficient_normal_form:i32 =
+                  Libcrux.Kem.Kyber.Arithmetic.montgomery_reduce (((result.[ i ]
+                          <:
+                          Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+                          .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ]
+                        <:
+                        i32) *!
+                      1441l
+                      <:
+                      i32)
+                in
+                let result:t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K =
                   Rust_primitives.Hax.Monomorphized_update_at.update_at_usize result
                     i
                     ({
-                        resulti with
+                        (result.[ i ] <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) with
                         Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                         =
-                        Rust_primitives.Hax.Monomorphized_update_at.update_at_usize (resulti
-                            .Libcrux.Kem.Kyber.Arithmetic.f_coefficients)
+                        Rust_primitives.Hax.Monomorphized_update_at.update_at_usize (result.[ i ]
+                            <:
+                            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+                            .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                           j
-                          (cast_i32_b #3328 #(64 * v v_K * 3328) resultij)
-                      }) in
-                result)
-        in
-        let result: t_Array wfPolynomialRingElement v_K =
-          down_cast_vector_b #v_K #(64 * v v_K * 3328) #3328 result in
-        assert (forall (j:usize). (v j >= v i + 1 /\ v j < v v_K) ==> derefine_poly_b result.[j] == derefine_poly_b orig_result.[j]); 
-        assume (inv0 result (i +! sz 1));
-        result)
+                          (Libcrux.Kem.Kyber.Arithmetic.barrett_reduce (coefficient_normal_form +!
+                                ((error_1_.[ i ]
+                                    <:
+                                    Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+                                    .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ]
+                                  <:
+                                  i32)
+                                <:
+                                i32)
+                            <:
+                            i32)
+                        <:
+                        t_Array i32 (sz 256)
+                      }
+                      <:
+                      Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+                in
+                result))
   in
-  admit(); //P-F
   result
-#pop-options
 
 let sample_matrix_A (v_K: usize) (seed: t_Array u8 (sz 34)) (transpose: bool) =
-  let wfZero: wfPolynomialRingElement = (Libcrux.Kem.Kyber.Arithmetic.cast_poly_b #1 #3328 Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO) in
-  let v_A_transpose:t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) v_K =
-    Rust_primitives.Hax.repeat (Rust_primitives.Hax.repeat wfZero v_K) v_K
+  let v_A_transpose:t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K =
+    Rust_primitives.Hax.repeat (Rust_primitives.Hax.repeat Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
+          v_K
+        <:
+        t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+      v_K
   in
-  let v_A_transpose:t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) v_K =
+  let v_A_transpose:t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K =
     Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
               Core.Ops.Range.f_start = sz 0;
               Core.Ops.Range.f_end = v_K
@@ -426,7 +440,7 @@
       v_A_transpose
       (fun v_A_transpose i ->
           let v_A_transpose:t_Array
-            (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) v_K =
+            (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K =
             v_A_transpose
           in
           let i:usize = i in
@@ -451,7 +465,7 @@
                             <:
                             t_Array u8 (sz 34))
                           (sz 32)
-                          (cast (i <: usize) <: u8)
+                          (classify (cast (i <: usize) <: pub_u8))
                         <:
                         t_Array u8 (sz 34))
                   in
@@ -462,7 +476,7 @@
                             <:
                             t_Array u8 (sz 34))
                           (sz 33)
-                          (cast (j <: usize) <: u8)
+                          (classify (cast (j <: usize) <: pub_u8))
                         <:
                         t_Array u8 (sz 34))
                   in
@@ -482,11 +496,11 @@
             v_A_transpose
             (fun v_A_transpose j ->
                 let v_A_transpose:t_Array
-                  (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) v_K =
+                  (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K =
                   v_A_transpose
                 in
                 let j:usize = j in
-                let sampled:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+                let sampled:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
                   Libcrux.Kem.Kyber.Sampling.sample_from_uniform_distribution (xof_bytes.[ j ]
                       <:
                       t_Array u8 (sz 840))
@@ -494,34 +508,33 @@
                 if transpose
                 then
                   let v_A_transpose:t_Array
-                    (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) v_K =
+                    (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K =
                     Rust_primitives.Hax.Monomorphized_update_at.update_at_usize v_A_transpose
                       j
                       (Rust_primitives.Hax.Monomorphized_update_at.update_at_usize (v_A_transpose.[ j
                             ]
                             <:
-                            t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
+                            t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
                           i
                           sampled
                         <:
-                        t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
+                        t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
                   in
                   v_A_transpose
                 else
                   let v_A_transpose:t_Array
-                    (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) v_K =
+                    (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K =
                     Rust_primitives.Hax.Monomorphized_update_at.update_at_usize v_A_transpose
                       i
                       (Rust_primitives.Hax.Monomorphized_update_at.update_at_usize (v_A_transpose.[ i
                             ]
                             <:
-                            t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
+                            t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
                           j
                           sampled
                         <:
-                        t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
+                        t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
                   in
                   v_A_transpose))
   in
-  admit(); //P-F
   v_A_transpose
diff -ruN extraction-edited/Libcrux.Kem.Kyber.Matrix.fsti extraction-secret-independent/Libcrux.Kem.Kyber.Matrix.fsti
--- extraction-edited/Libcrux.Kem.Kyber.Matrix.fsti	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.Matrix.fsti	1970-01-01 01:00:00.000000000 +0100
@@ -3,71 +3,39 @@
 open Core
 open FStar.Mul
 
-
-val compute_As_plus_e (#p:Spec.Kyber.params)
+val compute_As_plus_e
       (v_K: usize)
-      (matrix_A: t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) v_K)
-      (s_as_ntt error_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
-    : Pure (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) 
-           (requires (v_K == p.v_RANK))
-           (ensures fun res ->
-             let open Libcrux.Kem.Kyber.Arithmetic in
-             v_K == p.v_RANK /\
-             to_spec_vector_b #p res =
-             Spec.Kyber.compute_As_plus_e #p
-               (to_spec_matrix_b #p matrix_A) 
-               (to_spec_vector_b #p s_as_ntt) 
-               (to_spec_vector_b #p error_as_ntt))
-
+      (matrix_A: t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K)
+      (s_as_ntt error_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+    : Prims.Pure (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+      Prims.l_True
+      (fun _ -> Prims.l_True)
 
-val compute_message (#p:Spec.Kyber.params)
+val compute_message
       (v_K: usize)
-      (poly_v: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
-      (secret_as_ntt u_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
-    : Pure (Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
-      (requires (v_K == p.v_RANK))
-      (ensures (fun res -> 
-        let secret_spec = Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p secret_as_ntt in
-        let u_spec = Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p u_as_ntt in
-        let v_spec = Libcrux.Kem.Kyber.Arithmetic.to_spec_poly_b poly_v in
-        Libcrux.Kem.Kyber.Arithmetic.to_spec_poly_b res ==
-        Spec.Kyber.(poly_sub v_spec (poly_inv_ntt #p (vector_dot_product secret_spec u_spec)))))
+      (v: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+      (secret_as_ntt u_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+      Prims.l_True
+      (fun _ -> Prims.l_True)
 
-// TODO: error_2_ changed from `t_PolynomialRingElement_b 3` to `t_PolynomialRingElement_b 7`
-val compute_ring_element_v (#p:Spec.Kyber.params)
+val compute_ring_element_v
       (v_K: usize)
-      (tt_as_ntt r_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
-      (error_2_: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 7)
-      (message: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
-    : Pure (Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
-      (requires (v_K == p.v_RANK))
-      (ensures fun res ->
-        let tt_spec = Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p tt_as_ntt in
-        let r_spec = Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p r_as_ntt in
-        let e2_spec = Libcrux.Kem.Kyber.Arithmetic.to_spec_poly_b error_2_ in
-        let m_spec = Libcrux.Kem.Kyber.Arithmetic.to_spec_poly_b message in
-        let res_spec = Libcrux.Kem.Kyber.Arithmetic.to_spec_poly_b res in
-        res_spec == Spec.Kyber.(poly_add (poly_add (vector_dot_product tt_spec r_spec) e2_spec) m_spec))
+      (tt_as_ntt r_as_ntt: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+      (error_2_ message: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+      Prims.l_True
+      (fun _ -> Prims.l_True)
 
-val compute_vector_u (#p:Spec.Kyber.params)
+val compute_vector_u
       (v_K: usize)
-      (a_as_ntt: t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) v_K)
-      (r_as_ntt error_1_: t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
-    : Pure (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K)
-      (requires (v_K == p.v_RANK))
-      (ensures fun res ->
-        let a_spec = Libcrux.Kem.Kyber.Arithmetic.to_spec_matrix_b #p a_as_ntt in
-        let r_spec = Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p r_as_ntt in
-        let e_spec = Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p error_1_ in
-        let res_spec = Libcrux.Kem.Kyber.Arithmetic.to_spec_vector_b #p res in
-        res_spec == Spec.Kyber.(vector_add (vector_inv_ntt (matrix_vector_mul a_spec r_spec)) e_spec))
-
-
-
-val sample_matrix_A (#p:Spec.Kyber.params) (v_K: usize) (seed: t_Array u8 (sz 34)) (transpose: bool)
-    : Pure (t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement v_K) v_K)
-      (requires (v_K == p.v_RANK))
-      (ensures fun res ->
-        let matrix_A = Spec.Kyber.sample_matrix_A #p (Seq.slice seed 0 32) in
-        if transpose then Libcrux.Kem.Kyber.Arithmetic.to_spec_matrix_b #p res == matrix_A
-        else Libcrux.Kem.Kyber.Arithmetic.to_spec_matrix_b #p res == Spec.Kyber.matrix_transpose matrix_A)
+      (a_as_ntt: t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K)
+      (r_as_ntt error_1_: t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+    : Prims.Pure (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K)
+      Prims.l_True
+      (fun _ -> Prims.l_True)
+
+val sample_matrix_A (v_K: usize) (seed: t_Array u8 (sz 34)) (transpose: bool)
+    : Prims.Pure (t_Array (t_Array Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement v_K) v_K)
+      Prims.l_True
+      (fun _ -> Prims.l_True)
diff -ruN extraction-edited/Libcrux.Kem.Kyber.Ntt.fst extraction-secret-independent/Libcrux.Kem.Kyber.Ntt.fst
--- extraction-edited/Libcrux.Kem.Kyber.Ntt.fst	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.Ntt.fst	1970-01-01 01:00:00.000000000 +0100
@@ -1,130 +1,56 @@
 module Libcrux.Kem.Kyber.Ntt
-#set-options "--fuel 0 --ifuel 1 --z3rlimit 100"
+#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
 open Core
 open FStar.Mul
 
-
-let v_ZETAS_TIMES_MONTGOMERY_R =
-  let list : list (i32_b 1664) =
-    [
-      (-1044l); (-758l); (-359l); (-1517l); 1493l; 1422l; 287l; 202l; (-171l); 622l; 1577l; 182l;
-      962l; (-1202l); (-1474l); 1468l; 573l; (-1325l); 264l; 383l; (-829l); 1458l; (-1602l); (-130l);
-      (-681l); 1017l; 732l; 608l; (-1542l); 411l; (-205l); (-1571l); 1223l; 652l; (-552l); 1015l;
-      (-1293l); 1491l; (-282l); (-1544l); 516l; (-8l); (-320l); (-666l); (-1618l); (-1162l); 126l;
-      1469l; (-853l); (-90l); (-271l); 830l; 107l; (-1421l); (-247l); (-951l); (-398l); 961l;
-      (-1508l); (-725l); 448l; (-1065l); 677l; (-1275l); (-1103l); 430l; 555l; 843l; (-1251l); 871l;
-      1550l; 105l; 422l; 587l; 177l; (-235l); (-291l); (-460l); 1574l; 1653l; (-246l); 778l; 1159l;
-      (-147l); (-777l); 1483l; (-602l); 1119l; (-1590l); 644l; (-872l); 349l; 418l; 329l; (-156l);
-      (-75l); 817l; 1097l; 603l; 610l; 1322l; (-1285l); (-1465l); 384l; (-1215l); (-136l); 1218l;
-      (-1335l); (-874l); 220l; (-1187l); (-1659l); (-1185l); (-1530l); (-1278l); 794l; (-1510l);
-      (-854l); (-870l); 478l; (-108l); (-308l); 996l; 991l; 958l; (-1460l); 1522l; 1628l
-    ]
-  in
-  FStar.Pervasives.assert_norm (Prims.eq2 (List.Tot.length list) 128);
-  FStar.Pervasives.assert_norm (List.Tot.index list 1 == -758l);
-  Seq.of_list list
-  
-open Libcrux.Kem.Kyber.Arithmetic
-
-#push-options "--z3rlimit 50"
-let ntt_multiply_binomials (a0,a1) (b0,b1) zeta =
-  let r0 = montgomery_reduce (mul_i32_b a1 b1) in
-  let res = 
-  montgomery_reduce (add_i32_b (mul_i32_b a0 b0) (mul_i32_b r0 zeta)),
-  montgomery_reduce (add_i32_b (mul_i32_b a0 b1) (mul_i32_b a1 b0)) in
-  res
-#pop-options
-
-val mul_zeta_red   (#v_K:usize{v v_K >= 1 /\ v v_K <= 4})
-                   (#b:nat{b <= v v_K * 3328 * 64}) 
-                   (zeta_i:usize{v zeta_i > 0 /\ v zeta_i <= 128} )
-                   (layer:usize{v layer > 0 /\ 
-                                v layer <= 7 /\ 
-                                v zeta_i == pow2 (8 - v layer) /\ 
-                                b == v v_K * 3328 * pow2(v layer - 1)})
-                   (x:i32_b (2*b))
-                   (i:usize{v i < 128 / pow2 (v layer)}) :
-                   i32_b (2*b)
-let mul_zeta_red #v_K #b zeta_i layer x i = 
-    let zeta_i = zeta_i -! sz 1 -! i in
-    let zeta:i32_b 1664 = v_ZETAS_TIMES_MONTGOMERY_R.[ zeta_i ] in
-    if layer <=. sz 6 then (
-      assert (b <= 4 * 3328 * 32);
-      assert (2*b*1664 < pow2 31);
-      let product:i32_b (2 * b * 1664) = mul_i32_b x zeta in
-      let res = montgomery_reduce product in
-      res
-    ) else (
-      assert (v i  < 1);
-      assert (zeta_i = sz 1);
-      assert (zeta = -758l);
-      let zeta:i32_b 758 = zeta in
-      let product:i32_b (2 * b * 758) = mul_i32_b x zeta in
-      let res = montgomery_reduce product in
-      res
-    )
-
-
-val lemma_zeta_decr: orig:usize -> fin:usize -> layer:usize{v layer <= 7} ->
-  Lemma (v fin == v orig - 128/(pow2 (v layer)) /\
-         v orig == pow2 (8 - v layer) ==>
-         v fin == pow2 (7 - v layer))
-let lemma_zeta_decr orig fin layer = ()
-
-#push-options "--ifuel 0 --z3rlimit 1200"
-let invert_ntt_at_layer #v_K #b zeta_i re layer =
+let ntt_multiply_binomials (a0, a1: (i32 & i32)) (b0, b1: (i32 & i32)) (zeta: i32) =
+  Libcrux.Kem.Kyber.Arithmetic.montgomery_reduce ((a0 *! b0 <: i32) +!
+      ((Libcrux.Kem.Kyber.Arithmetic.montgomery_reduce (a1 *! b1 <: i32) <: i32) *! zeta <: i32)
+      <:
+      i32),
+  Libcrux.Kem.Kyber.Arithmetic.montgomery_reduce ((a0 *! b1 <: i32) +! (a1 *! b0 <: i32) <: i32)
+  <:
+  (i32 & i32)
+
+let invert_ntt_at_layer
+      (zeta_i: usize)
+      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+      (layer: usize)
+     =
   let step:usize = sz 1 <<! layer in
-  assert (v step > 0);
-  assert (v step == pow2 (v layer));
-  let orig_re = re in
-  let orig_zeta_i = zeta_i in
-  [@ inline_let]
-  let inv = fun (acc:t_PolynomialRingElement_b (2*b) & usize) (i:usize) ->
-    let (re,zeta_i) = acc in 
-    v zeta_i == v orig_zeta_i - v i /\
-    (forall k. (v k >= 2 * v i * v step (* + 2 * v step *)) ==> re.f_coefficients.[k] == orig_re.f_coefficients.[k]) 
-  in
-  let re, zeta_i: (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (2*b) & usize) =
-    Rust_primitives.Iterators.foldi_range #_ #(t_PolynomialRingElement_b (2*b) & usize) #inv {
+  let re, zeta_i:(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement & usize) =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
               Core.Ops.Range.f_start = sz 0;
-              Core.Ops.Range.f_end = sz 128 /! step
+              Core.Ops.Range.f_end = sz 128 >>! layer <: usize
             }
-      (cast_poly_b #b #(2*b) re, zeta_i <: (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (2*b) & usize))
+            <:
+            Core.Ops.Range.t_Range usize)
+        <:
+        Core.Ops.Range.t_Range usize)
+      (re, zeta_i <: (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement & usize))
       (fun temp_0_ round ->
-          let re, zeta_i:(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (2*b) & usize) = temp_0_ in
+          let re, zeta_i:(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement & usize) = temp_0_ in
           let round:usize = round in
-          let orig_re_round = re in
           let zeta_i:usize = zeta_i -! sz 1 in
-          assert(v round * v step < 128);
-          assert(v round * v step + v step <= 128);
-          assert(v round * v step * 2 <= 254);
-          assert(v round * v step * 2 + 2 * v step <= 256);
-          let offset:usize = (round *! step) *! sz 2 in
-          assert (v offset + 2 * v step <= 256);
-          assert (v offset + v step <= 256);
-          assert (forall k. v k >= v offset ==> re.f_coefficients.[k] == orig_re.f_coefficients.[k]);
-          [@ inline_let]
-          let inv = fun (acc:t_PolynomialRingElement_b (2 * b)) (i:usize) ->
-            (forall k. (v k >= v i /\ v k < v offset + v step) ==> acc.f_coefficients.[k] == orig_re.f_coefficients.[k]) /\
-            (forall k. (v k >= v i + v step) ==> acc.f_coefficients.[k] == orig_re.f_coefficients.[k])
-          in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (2 * b) =
-            Rust_primitives.Iterators.foldi_range #_ #_  #inv {
+          let offset:usize = (round *! step <: usize) *! sz 2 in
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+            Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
                       Core.Ops.Range.f_start = offset;
                       Core.Ops.Range.f_end = offset +! step <: usize
-            }
+                    }
+                    <:
+                    Core.Ops.Range.t_Range usize)
+                <:
+                Core.Ops.Range.t_Range usize)
               re
               (fun re j ->
-                  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (2 * b) = re in
-                  assert (re.f_coefficients.[j] == orig_re_round.f_coefficients.[j]);
-                  assert (re.f_coefficients.[j +! step] == orig_re_round.f_coefficients.[j +! step]);
-                  assert (re.f_coefficients.[j] == orig_re.f_coefficients.[j]);
-                  assert (re.f_coefficients.[j +! step] == orig_re.f_coefficients.[j +! step]);
-                  let re_j:i32_b b = orig_re.f_coefficients.[j] in
-                  let re_j_step:i32_b b = orig_re.f_coefficients.[j +! step] in
+                  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
                   let j:usize = j in
-                  let a_minus_b:i32_b (2*b) = sub_i32_b re_j_step re_j in
-                  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (2 * b) =
+                  let a_minus_b:i32 =
+                    (re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j +! step <: usize ] <: i32) -!
+                    (re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ] <: i32)
+                  in
+                  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
                     {
                       re with
                       Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -132,13 +58,17 @@
                       Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                           .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                         j
-                        (add_i32_b re_j re_j_step)
+                        ((re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ] <: i32) +!
+                          (re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j +! step <: usize ]
+                            <:
+                            i32)
+                          <:
+                          i32)
                     }
                     <:
-                    Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (2 * b)
+                    Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
                   in
-                  let red = mul_zeta_red #v_K #b orig_zeta_i layer a_minus_b round in
-                  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (2*b) =
+                  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
                     {
                       re with
                       Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -146,69 +76,74 @@
                       Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                           .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                         (j +! step <: usize)
-                        red
+                        (Libcrux.Kem.Kyber.Arithmetic.montgomery_reduce (a_minus_b *!
+                              (v_ZETAS_TIMES_MONTGOMERY_R.[ zeta_i ] <: i32)
+                              <:
+                              i32)
+                          <:
+                          i32)
                     }
                     <:
-                    Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (2*b)
+                    Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
                   in
                   re)
           in
-          re, zeta_i <: t_PolynomialRingElement_b (2*b) & usize)
+          re, zeta_i <: (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement & usize))
   in
-  let hax_temp_output:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (2*b) = re in
-  lemma_zeta_decr orig_zeta_i zeta_i layer;
-  zeta_i, hax_temp_output <: (usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (2*b))  
-#pop-options
+  let hax_temp_output:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
+  zeta_i, hax_temp_output <: (usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
 
-#push-options "--z3rlimit 500"
-let invert_ntt_montgomery v_K re =
+let invert_ntt_montgomery (v_K: usize) (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
   let _:Prims.unit = () <: Prims.unit in
-  let b = v v_K * 3328 in
-  assert (v v_K <= 4);
-  assert (b <= 4 * 3328);
   let zeta_i:usize = Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT /! sz 2 in
-  assert (v zeta_i == pow2 (8 - 1));
-  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (2*b)) =
-    invert_ntt_at_layer #v_K #b zeta_i re (sz 1)
+  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+    invert_ntt_at_layer zeta_i re (sz 1)
   in
   let zeta_i:usize = tmp0 in
-  let hoist1 = out in
-  let re = hoist1 in
-  let tmp0, re:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (4*b)) =
-    invert_ntt_at_layer #v_K zeta_i re (sz 2)
+  let hoist1:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = hoist1 in
+  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+    invert_ntt_at_layer zeta_i re (sz 2)
   in
   let zeta_i:usize = tmp0 in
-  let tmp0, re:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (8*b)) =
-    invert_ntt_at_layer #v_K zeta_i re (sz 3)
+  let hoist2:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = hoist2 in
+  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+    invert_ntt_at_layer zeta_i re (sz 3)
   in
   let zeta_i:usize = tmp0 in
-  assert (8*b = v v_K * 3328 * pow2 (4 - 1));
-  let tmp0, re:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (16*b)) =
-    invert_ntt_at_layer #v_K zeta_i re (sz 4)
+  let hoist3:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = hoist3 in
+  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+    invert_ntt_at_layer zeta_i re (sz 4)
   in
   let zeta_i:usize = tmp0 in
-  assert (16*b == v v_K * 3328 * pow2 (5 - 1));
-  let tmp0, re:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (32*b)) =
-    invert_ntt_at_layer #v_K zeta_i re (sz 5)
+  let hoist4:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = hoist4 in
+  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+    invert_ntt_at_layer zeta_i re (sz 5)
   in
   let zeta_i:usize = tmp0 in
-  assert (32*b = v v_K * 3328 * pow2 (6 - 1));
-  let tmp0, re:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64*b)) =
-    invert_ntt_at_layer #v_K zeta_i re (sz 6)
+  let hoist5:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = hoist5 in
+  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+    invert_ntt_at_layer zeta_i re (sz 6)
   in
   let zeta_i:usize = tmp0 in
-  assert (64*b = v v_K * 3328 * pow2 (7 - 1));
-  let tmp0, re:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (128*b)) =
-    invert_ntt_at_layer #v_K zeta_i re (sz 7)
+  let hoist6:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = hoist6 in
+  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+    invert_ntt_at_layer zeta_i re (sz 7)
   in
   let zeta_i:usize = tmp0 in
+  let hoist7:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = hoist7 in
   let _:Prims.unit = () <: Prims.unit in
   let _:Prims.unit = () <: Prims.unit in
-  admit();
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64*b) =
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
     Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
               Core.Ops.Range.f_start = sz 0;
-              Core.Ops.Range.f_end = sz 8
+              Core.Ops.Range.f_end = sz 2
             }
             <:
             Core.Ops.Range.t_Range usize)
@@ -216,7 +151,7 @@
         Core.Ops.Range.t_Range usize)
       re
       (fun re i ->
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (128*b) = re in
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
           let i:usize = i in
           {
             re with
@@ -235,84 +170,52 @@
             t_Array i32 (sz 256)
           }
           <:
-          Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64*b))
+          Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
   in
-  re 
-#pop-options
-
-#push-options "--z3rlimit 500"
-val mul_zeta_red2   (#b:nat{b <= 31175}) 
-                   (zeta_i:usize{v zeta_i >= 0 /\ v zeta_i <= 63} )
-                   (layer:usize{v layer > 0 /\ 
-                                v layer <= 7 /\ 
-                                v zeta_i == pow2 (7 - v layer) - 1})
-                   (x:i32_b b)
-                   (i:usize{v i < 128/(pow2 (v layer))})
-                   : i32_b 3328
-let mul_zeta_red2 #b zeta_i layer x i = 
-    let zeta_i = zeta_i +! sz 1 +! i in
-    let zeta = v_ZETAS_TIMES_MONTGOMERY_R.[ zeta_i ] in
-    assert (b * 1664 < 65536 * 3328);
-    let red = Libcrux.Kem.Kyber.Arithmetic.montgomery_multiply_sfe_by_fer #(3328+b) #1664 x
-                             (v_ZETAS_TIMES_MONTGOMERY_R.[ zeta_i ] <: i32) in
-    red
-#pop-options
+  re
 
-#push-options "--ifuel 0 --z3rlimit 5000"
-let ntt_at_layer #b zeta_i re layer initial_coefficient_bound =
-  let step = sz 1 <<! layer in
-  let loop_end = sz 128 /! step in
-  assert (v loop_end == pow2 (7 - v layer));
-  let orig_re = re in
-  let orig_zeta_i = zeta_i in
-  [@ inline_let]
-  let inv = fun (acc:t_PolynomialRingElement_b (3328+b) & usize) (i:usize) ->
-    let (re,zeta_i) = acc in 
-    v zeta_i == v orig_zeta_i + v i /\
-    (forall k. v k >= 2 * v i * v step  ==> re.f_coefficients.[k] == orig_re.f_coefficients.[k]) 
-  in
-  let re, zeta_i: (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (3328+b) & usize) =
-    Rust_primitives.Iterators.foldi_range #_ #(t_PolynomialRingElement_b (3328+b) & usize) #inv {
+let ntt_at_layer
+      (zeta_i: usize)
+      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+      (layer initial_coefficient_bound: usize)
+     =
+  let step:usize = sz 1 <<! layer in
+  let re, zeta_i:(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement & usize) =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
               Core.Ops.Range.f_start = sz 0;
-              Core.Ops.Range.f_end = loop_end
+              Core.Ops.Range.f_end = sz 128 >>! layer <: usize
             }
-      (cast_poly_b #b #(3328+b) re, zeta_i)
+            <:
+            Core.Ops.Range.t_Range usize)
+        <:
+        Core.Ops.Range.t_Range usize)
+      (re, zeta_i <: (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement & usize))
       (fun temp_0_ round ->
-          let re, zeta_i:(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (3328+b) & usize) = temp_0_ in
+          let re, zeta_i:(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement & usize) = temp_0_ in
           let round:usize = round in
           let zeta_i:usize = zeta_i +! sz 1 in
-          assert(v round * v step < 128);
-          assert(v round * v step + v step <= 128);
-          assert(v round * v step * 2 <= 254);
-          assert(v round * v step * 2 + 2 * v step <= 256);
-          let offset:usize = (round *! step) *! sz 2 in
-          assert (v offset + 2 * v step <= 256);
-          assert (v offset + v step <= 256);
-          [@ inline_let]
-          let inv: t_PolynomialRingElement_b (3328+b) -> int_t usize_inttype -> Type0 = 
-            fun (acc:t_PolynomialRingElement_b (3328+b)) (i:usize) ->
-            (forall k. (v k >= v i /\ v k < v offset + v step) ==> acc.f_coefficients.[k] == orig_re.f_coefficients.[k]) /\
-            (forall k. (v k >= v i + v step) ==> acc.f_coefficients.[k] == orig_re.f_coefficients.[k])
-          in
-          assert (forall k. (v k >= v offset /\ v k < v offset + v step) ==> re.f_coefficients.[k] == orig_re.f_coefficients.[k]);
-          assert (forall k. (v k >= v offset + v step) ==> re.f_coefficients.[k] == orig_re.f_coefficients.[k]);
-          assert (inv re offset);
-      let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (3328+ b) =
-            Rust_primitives.Iterators.foldi_range #usize_inttype #(t_PolynomialRingElement_b (3328+b))  #inv {
+          let offset:usize = (round *! step <: usize) *! sz 2 in
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+            Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
                       Core.Ops.Range.f_start = offset;
                       Core.Ops.Range.f_end = offset +! step <: usize
-            }
+                    }
+                    <:
+                    Core.Ops.Range.t_Range usize)
+                <:
+                Core.Ops.Range.t_Range usize)
               re
               (fun re j ->
-                  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (3328+b) = re in
+                  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
                   let j:usize = j in
-                  assert (re.f_coefficients.[j] == orig_re.f_coefficients.[j]);
-                  assert (re.f_coefficients.[j +! step] == orig_re.f_coefficients.[j +! step]);                      
-                  let re_j:i32_b b = orig_re.f_coefficients.[j] in
-                  let re_j_step:i32_b b = orig_re.f_coefficients.[j +! step] in
-                  let t:i32_b 3328 = mul_zeta_red2 #b orig_zeta_i layer 
-                                     re_j_step round in
-                  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (3328+b) =
+                  let t:i32 =
+                    Libcrux.Kem.Kyber.Arithmetic.montgomery_multiply_sfe_by_fer (re
+                          .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j +! step <: usize ]
+                        <:
+                        i32)
+                      (v_ZETAS_TIMES_MONTGOMERY_R.[ zeta_i ] <: i32)
+                  in
+                  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
                     {
                       re with
                       Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -320,12 +223,12 @@
                       Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                           .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                         (j +! step <: usize)
-                        (sub_i32_b #b #3328 re_j_step t)
+                        ((re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ] <: i32) -! t <: i32)
                     }
                     <:
-                    Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (3328+b)
+                    Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
                   in
-                  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (3328+b) =
+                  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
                     {
                       re with
                       Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -333,70 +236,64 @@
                       Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                           .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                         j
-                        (add_i32_b #b #3328 re_j t)
+                        ((re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ] <: i32) +! t <: i32)
                     }
                     <:
-                    Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (3328+b)
+                    Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
                   in
                   re)
           in
-          re, zeta_i <: (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (3328+b) & usize))
+          re, zeta_i <: (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement & usize))
   in
   let _:Prims.unit = () <: Prims.unit in
-  let hax_temp_output:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (3328+b) = re in
-  assert (v zeta_i = v orig_zeta_i + 128/v step);
-  assert (v zeta_i = v orig_zeta_i + pow2(7 - v layer));
-  assert (v zeta_i = pow2(8 - v layer) - 1);
-  zeta_i, hax_temp_output
-#pop-options
+  let hax_temp_output:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
+  zeta_i, hax_temp_output <: (usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
 
-let ntt_at_layer_3_ #b zeta_i re layer = 
-  let tmp0, out =
-    ntt_at_layer zeta_i re layer (sz 7879)
+let ntt_at_layer_3_
+      (zeta_i: usize)
+      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+      (layer: usize)
+     =
+  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+    ntt_at_layer zeta_i re layer (sz 3)
   in
   let zeta_i:usize = tmp0 in
-  let hax_temp_output = out in
-  zeta_i, hax_temp_output
- 
-let ntt_at_layer_3328_ zeta_i re layer = 
-  let tmp0, out =
+  let hax_temp_output:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
+  zeta_i, hax_temp_output <: (usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+
+let ntt_at_layer_3328_
+      (zeta_i: usize)
+      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+      (layer: usize)
+     =
+  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
     ntt_at_layer zeta_i re layer (sz 3328)
   in
   let zeta_i:usize = tmp0 in
-  let hax_temp_output = out in
-  zeta_i, hax_temp_output
+  let hax_temp_output:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
+  zeta_i, hax_temp_output <: (usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
 
-#push-options "--ifuel 0 --z3rlimit 1500"
-#restart-solver
-let ntt_binomially_sampled_ring_element re =
+let ntt_binomially_sampled_ring_element (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
   let _:Prims.unit = () <: Prims.unit in
   let zeta_i:usize = sz 1 in
-  [@ inline_let]
-  let inv = fun (acc:(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 11207)) (i:usize) -> 
-             (v i <= 128) /\
-             (forall (j:usize). (v j >= v i /\ v j < 128) ==>
-                i32_range (acc <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 11207).f_coefficients.[j] 7) /\ 
-             (forall (j:usize). (v j >= v i + 128 /\ v j < 256) ==>
-                i32_range (acc <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 11207).f_coefficients.[j] 7)
-          in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 11207 = cast_poly_b re in
-  assert (inv re (sz 0));
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 11207 =
-      Rust_primitives.Iterators.foldi_range #_ #(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 11207) #inv ({
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
               Core.Ops.Range.f_start = sz 0;
               Core.Ops.Range.f_end = sz 128
             }
             <:
             Core.Ops.Range.t_Range usize)
-      (cast_poly_b re)
+        <:
+        Core.Ops.Range.t_Range usize)
+      re
       (fun re j ->
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 11207 = cast_poly_b re in
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
           let j:usize = j in
-          let t:i32_b (7*1600) =
-            mul_i32_b (re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j +! sz 128 <: usize ])
-                      (-1600l <: i32_b 1600)
+          let t:i32 =
+            (re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j +! sz 128 <: usize ] <: i32) *!
+            (-1600l)
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (11207) =
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -404,10 +301,12 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 (j +! sz 128 <: usize)
-                (sub_i32_b #7 #11200 (re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ] <: i32_b 7) t)
+                ((re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ] <: i32) -! t <: i32)
             }
+            <:
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (11207) =
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -415,76 +314,90 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 j
-                (add_i32_b (re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ]) t)
+                ((re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ j ] <: i32) +! t <: i32)
             }
+            <:
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
           re)
   in
   let _:Prims.unit = () <: Prims.unit in
-  assert (v zeta_i = pow2 (7 - 6) - 1);
-  let zeta_i, re =
+  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
     ntt_at_layer_3_ zeta_i re (sz 6)
   in
-  let zeta_i, re =
+  let zeta_i:usize = tmp0 in
+  let hoist8:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = hoist8 in
+  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
     ntt_at_layer_3_ zeta_i re (sz 5)
   in
-  let zeta_i, re =
+  let zeta_i:usize = tmp0 in
+  let hoist9:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = hoist9 in
+  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
     ntt_at_layer_3_ zeta_i re (sz 4)
   in
-  let zeta_i, re =
+  let zeta_i:usize = tmp0 in
+  let hoist10:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = hoist10 in
+  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
     ntt_at_layer_3_ zeta_i re (sz 3)
   in
-  let zeta_i, re =
+  let zeta_i:usize = tmp0 in
+  let hoist11:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = hoist11 in
+  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
     ntt_at_layer_3_ zeta_i re (sz 2)
   in
-  let zeta_i, re =
+  let zeta_i:usize = tmp0 in
+  let hoist12:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = hoist12 in
+  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
     ntt_at_layer_3_ zeta_i re (sz 1)
   in
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (6*3328+11207) = re in
-  [@ inline_let]
-  let inv = fun (acc:(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (6*3328+11207))) (i:usize) -> 
-             (v i <= 256) /\
-             (forall (j:usize). (v j < v i) ==>
-                i32_range (acc <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (6*3328+11207)).f_coefficients.[j] 3328)
-  in
-  assert (inv re (sz 0));
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (6*3328+11207) =
-      Rust_primitives.Iterators.foldi_range #_ #(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (6*3328+11207)) #inv ({
+  let zeta_i:usize = tmp0 in
+  let hoist13:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = hoist13 in
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
               Core.Ops.Range.f_start = sz 0;
               Core.Ops.Range.f_end = Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
             }
             <:
             Core.Ops.Range.t_Range usize)
+        <:
+        Core.Ops.Range.t_Range usize)
       re
       (fun re i ->
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (6*3328+11207) = re in
-          let rei:i32_b (v v_BARRETT_R) = cast_i32_b #(6*3328+11207) #(v v_BARRETT_R) (re
-                      .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ]) in
-          let rei: i32_b (6*3328+11207) = cast_i32_b #3328 #(6*3328+11207) (
-            Libcrux.Kem.Kyber.Arithmetic.barrett_reduce rei) in
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
           let i:usize = i in
-          let re_coeffs:t_Array (i32_b (6*3328+11207)) (sz 256) =
-            Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
-                .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-              i rei in
           {
             re with
             Libcrux.Kem.Kyber.Arithmetic.f_coefficients
-            = re_coeffs
-          })
+            =
+            Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
+                .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
+              i
+              (Libcrux.Kem.Kyber.Arithmetic.barrett_reduce (re
+                      .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ]
+                    <:
+                    i32)
+                <:
+                i32)
+            <:
+            t_Array i32 (sz 256)
+          }
+          <:
+          Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
   in
-  let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement = down_cast_poly_b #(6*3328+11207) #3328 re in
-  re 
-#pop-options
-
+  re
 
-#push-options "--z3rlimit 100"
-let ntt_multiply lhs rhs =
+let ntt_multiply (lhs rhs: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
   let _:Prims.unit = () <: Prims.unit in
-  let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 1 =
+  let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
     Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
   in
-  let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3328 =
+  let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
     Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
               Core.Ops.Range.f_start = sz 0;
               Core.Ops.Range.f_end
@@ -495,31 +408,34 @@
             Core.Ops.Range.t_Range usize)
         <:
         Core.Ops.Range.t_Range usize)
-      (cast_poly_b out)
+      out
       (fun out i ->
-          let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3328 = out in
+          let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
           let i:usize = i in
-          assert (v i * 4 + 4 <= 256);
-          let product =
+          let product:(i32 & i32) =
             ntt_multiply_binomials ((lhs.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ sz 4 *! i
                     <:
                     usize ]
                   <:
-                  i32_b 3328),
+                  i32),
                 (lhs.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ (sz 4 *! i <: usize) +! sz 1
                     <:
                     usize ]
                   <:
-                  i32_b 3328))
-              ((rhs.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ sz 4 *! i <: usize ] <: i32_b 3328),
+                  i32)
+                <:
+                (i32 & i32))
+              ((rhs.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ sz 4 *! i <: usize ] <: i32),
                 (rhs.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ (sz 4 *! i <: usize) +! sz 1
                     <:
                     usize ]
                   <:
-                  i32_b 3328))
-              (v_ZETAS_TIMES_MONTGOMERY_R.[ sz 64 +! i <: usize ] <: i32_b 1664)
+                  i32)
+                <:
+                (i32 & i32))
+              (v_ZETAS_TIMES_MONTGOMERY_R.[ sz 64 +! i <: usize ] <: i32)
           in
-          let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3328 =
+          let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               out with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -530,9 +446,9 @@
                 product._1
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3328
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
-          let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3328 =
+          let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               out with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -543,29 +459,41 @@
                 product._2
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3328
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
-          let product =
+          let product:(i32 & i32) =
             ntt_multiply_binomials ((lhs.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ (sz 4 *! i
                       <:
                       usize) +!
                     sz 2
                     <:
-                    usize ]),
+                    usize ]
+                  <:
+                  i32),
                 (lhs.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ (sz 4 *! i <: usize) +! sz 3
                     <:
-                    usize ]))
-
+                    usize ]
+                  <:
+                  i32)
+                <:
+                (i32 & i32))
               ((rhs.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ (sz 4 *! i <: usize) +! sz 2
                     <:
-                    usize ]),
+                    usize ]
+                  <:
+                  i32),
                 (rhs.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ (sz 4 *! i <: usize) +! sz 3
                     <:
-                    usize ]))
-              (Core.Ops.Arith.Neg.neg (v_ZETAS_TIMES_MONTGOMERY_R.[ sz 64 +! i <: usize ]) <: i32_b 1664)
-
+                    usize ]
+                  <:
+                  i32)
+                <:
+                (i32 & i32))
+              (Core.Ops.Arith.Neg.neg (v_ZETAS_TIMES_MONTGOMERY_R.[ sz 64 +! i <: usize ] <: i32)
+                <:
+                i32)
           in
-          let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3328 =
+          let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               out with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -576,9 +504,9 @@
                 product._1
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3328
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
-          let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3328 =
+          let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               out with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -589,55 +517,72 @@
                 product._2
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3328
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
           out)
   in
   out
-#pop-options
 
-#push-options "--ifuel 0 --z3rlimit 200"
-let ntt_vector_u v_VECTOR_U_COMPRESSION_FACTOR re =
+let ntt_vector_u
+      (v_VECTOR_U_COMPRESSION_FACTOR: usize)
+      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+     =
   let _:Prims.unit = () <: Prims.unit in
   let zeta_i:usize = sz 0 in
-  let zeta_i, re =
+  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
     ntt_at_layer_3328_ zeta_i re (sz 7)
   in
-  let zeta_i, re =
+  let zeta_i:usize = tmp0 in
+  let hoist14:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = hoist14 in
+  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
     ntt_at_layer_3328_ zeta_i re (sz 6)
   in
-  let zeta_i, re =
+  let zeta_i:usize = tmp0 in
+  let hoist15:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = hoist15 in
+  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
     ntt_at_layer_3328_ zeta_i re (sz 5)
   in
-  let zeta_i, re =
+  let zeta_i:usize = tmp0 in
+  let hoist16:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = hoist16 in
+  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
     ntt_at_layer_3328_ zeta_i re (sz 4)
   in
-  let zeta_i, re =
+  let zeta_i:usize = tmp0 in
+  let hoist17:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = hoist17 in
+  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
     ntt_at_layer_3328_ zeta_i re (sz 3)
   in
-  let zeta_i, re =
+  let zeta_i:usize = tmp0 in
+  let hoist18:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = hoist18 in
+  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
     ntt_at_layer_3328_ zeta_i re (sz 2)
   in
-  let zeta_i, re =
+  let zeta_i:usize = tmp0 in
+  let hoist19:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = hoist19 in
+  let tmp0, out:(usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
     ntt_at_layer_3328_ zeta_i re (sz 1)
   in
-  [@ inline_let]
-  let inv = fun (acc:(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (8*3328))) (i:usize) -> 
-             (v i <= 256) /\
-             (forall (j:usize). (v j < v i) ==>
-                i32_range (acc <: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (8*3328)).f_coefficients.[j] 3328)
-  in
-  assert (inv re (sz 0));
-  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (8*3328) =
-      Rust_primitives.Iterators.foldi_range #_ #(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (8*3328)) #inv ({
+  let zeta_i:usize = tmp0 in
+  let hoist20:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = out in
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = hoist20 in
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
               Core.Ops.Range.f_start = sz 0;
               Core.Ops.Range.f_end = Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
             }
             <:
             Core.Ops.Range.t_Range usize)
+        <:
+        Core.Ops.Range.t_Range usize)
       re
       (fun re i ->
-          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (8*3328) = re in
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
           let i:usize = i in
           {
             re with
@@ -647,10 +592,15 @@
                 .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
               i
               (Libcrux.Kem.Kyber.Arithmetic.barrett_reduce (re
-                      .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ]))
+                      .Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ]
+                    <:
+                    i32)
+                <:
+                i32)
+            <:
+            t_Array i32 (sz 256)
           }
           <:
-          Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (8*3328))
+          Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
   in
-  down_cast_poly_b #(8*3328) #3328 re 
-#pop-options
+  re
diff -ruN extraction-edited/Libcrux.Kem.Kyber.Ntt.fsti extraction-secret-independent/Libcrux.Kem.Kyber.Ntt.fsti
--- extraction-edited/Libcrux.Kem.Kyber.Ntt.fsti	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.Ntt.fsti	1970-01-01 01:00:00.000000000 +0100
@@ -2,80 +2,224 @@
 #set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
 open Core
 open FStar.Mul
-open Libcrux.Kem.Kyber.Arithmetic
 
-val v_ZETAS_TIMES_MONTGOMERY_R: x:t_Array (i32_b 1664) (sz 128){v (x.[sz 1] <: i32) == -758}
+let v_ZETAS_TIMES_MONTGOMERY_R: t_Array i32 (sz 128) =
+  let list =
+    [
+      (-1044l); (-758l); (-359l); (-1517l); 1493l; 1422l; 287l; 202l; (-171l); 622l; 1577l; 182l;
+      962l; (-1202l); (-1474l); 1468l; 573l; (-1325l); 264l; 383l; (-829l); 1458l; (-1602l); (-130l);
+      (-681l); 1017l; 732l; 608l; (-1542l); 411l; (-205l); (-1571l); 1223l; 652l; (-552l); 1015l;
+      (-1293l); 1491l; (-282l); (-1544l); 516l; (-8l); (-320l); (-666l); (-1618l); (-1162l); 126l;
+      1469l; (-853l); (-90l); (-271l); 830l; 107l; (-1421l); (-247l); (-951l); (-398l); 961l;
+      (-1508l); (-725l); 448l; (-1065l); 677l; (-1275l); (-1103l); 430l; 555l; 843l; (-1251l); 871l;
+      1550l; 105l; 422l; 587l; 177l; (-235l); (-291l); (-460l); 1574l; 1653l; (-246l); 778l; 1159l;
+      (-147l); (-777l); 1483l; (-602l); 1119l; (-1590l); 644l; (-872l); 349l; 418l; 329l; (-156l);
+      (-75l); 817l; 1097l; 603l; 610l; 1322l; (-1285l); (-1465l); 384l; (-1215l); (-136l); 1218l;
+      (-1335l); (-874l); 220l; (-1187l); (-1659l); (-1185l); (-1530l); (-1278l); 794l; (-1510l);
+      (-854l); (-870l); 478l; (-108l); (-308l); 996l; 991l; 958l; (-1460l); 1522l; 1628l
+    ]
+  in
+  FStar.Pervasives.assert_norm (Prims.eq2 (List.Tot.length list) 128);
+  Rust_primitives.Hax.array_of_list list
+
+val ntt_multiply_binomials: (i32 & i32) -> (i32 & i32) -> zeta: i32
+  -> Prims.Pure (i32 & i32) Prims.l_True (fun _ -> Prims.l_True)
+
+val invert_ntt_at_layer
+      (zeta_i: usize)
+      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+      (layer: usize)
+    : Prims.Pure (usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+      Prims.l_True
+      (fun _ -> Prims.l_True)
+
+val invert_ntt_montgomery (v_K: usize) (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+      Prims.l_True
+      (fun _ -> Prims.l_True)
 
-val ntt_multiply_binomials (a:wfFieldElement&wfFieldElement) (b: wfFieldElement&wfFieldElement) (zeta: i32_b 1664) :
-    Pure (wfFieldElement & wfFieldElement)
-    (requires True)
-    (ensures (fun _ -> True))
-
-val invert_ntt_at_layer (#v_K:usize{v v_K >= 1 /\ v v_K <= 4})
-      (#b:nat{b <= v v_K * 3328 * 64})
-      (zeta_i: usize{v zeta_i >= 1 /\ v zeta_i <= 128})
-      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b b)
-      (layer: usize{v layer > 0 /\ 
-                    v layer <= 7 /\ 
-                    v zeta_i == pow2 (8 - v layer) /\ 
-                    b == v v_K * 3328 * pow2(v layer - 1)})
-    : Prims.Pure (usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (2*b))
+val ntt_at_layer
+      (zeta_i: usize)
+      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+      (layer initial_coefficient_bound: usize)
+    : Prims.Pure (usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
       Prims.l_True
-      (fun x -> let (zeta_fin,re) = x in v zeta_fin == pow2 (7 - v layer))
+      (fun _ -> Prims.l_True)
 
-val invert_ntt_montgomery (v_K: usize{v v_K >= 1 /\ v v_K <= 4}) 
-      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (v v_K * 3328))
-    : Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (64 * v v_K * 3328)
-
-val ntt_at_layer 
-      (#b:nat{b <= 31175})
-      (zeta_i: usize{v zeta_i < 128})
-      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b b)
-      (layer: usize{v layer > 0 /\ 
-                    v layer <= 7 /\ 
-                    v zeta_i == pow2 (7 - v layer) - 1})
-      (initial_coefficient_bound: usize{b == (7 - v layer) * 3328 + v initial_coefficient_bound})
-    : Pure (usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (3328+b))
-      (requires True)
-      (ensures fun (zeta_i, result) -> v zeta_i == pow2 (8 - v layer) - 1)
-
-val ntt_at_layer_3_ (#b:nat)
-      (zeta_i: usize{v zeta_i < 128})
-      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b b)
-      (layer: usize{v layer > 0 /\ 
-                    v layer <= 6 /\ 
-                    v zeta_i == pow2 (7 - v layer) - 1 /\
-                    b == (6 - v layer) * 3328 + 11207})
-    : Prims.Pure (usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (3328+b))
+val ntt_at_layer_3_
+      (zeta_i: usize)
+      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+      (layer: usize)
+    : Prims.Pure (usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
       Prims.l_True
-      (ensures fun (zeta_i,result) -> v zeta_i == pow2 (8 - v layer) - 1)
+      (fun _ -> Prims.l_True)
 
-val ntt_at_layer_3328_ (#b:nat{b <= 7*3328})
-      (zeta_i: usize{v zeta_i < 128})
-      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b b)
-      (layer: usize{v layer > 0 /\ 
-                    v layer <= 7 /\ 
-                    v zeta_i == pow2 (7 - v layer) - 1  /\
-                    b == (7 - v layer) * 3328 + 3328})
-    : Prims.Pure (usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (3328+b))
+val ntt_at_layer_3328_
+      (zeta_i: usize)
+      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+      (layer: usize)
+    : Prims.Pure (usize & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
       Prims.l_True
-      (ensures fun (zeta_i,result) -> v zeta_i == pow2 (8 - v layer) - 1)
+      (fun _ -> Prims.l_True)
+
+val ntt_binomially_sampled_ring_element (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+      (requires
+        Hax_lib.v_forall (fun i ->
+              let i:usize = i in
+              Hax_lib.implies (i <.
+                  (Core.Slice.impl__len (Rust_primitives.unsize re
+                            .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
+                        <:
+                        t_Slice i32)
+                    <:
+                    usize)
+                  <:
+                  bool)
+                (fun temp_0_ ->
+                    let _:Prims.unit = temp_0_ in
+                    (Core.Num.impl__i32__abs (re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ]
+                          <:
+                          i32)
+                      <:
+                      i32) <=.
+                    3l
+                    <:
+                    bool)
+              <:
+              bool))
+      (ensures
+        fun result ->
+          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = result in
+          Hax_lib.v_forall (fun i ->
+                let i:usize = i in
+                Hax_lib.implies (i <.
+                    (Core.Slice.impl__len (Rust_primitives.unsize result
+                              .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
+                          <:
+                          t_Slice i32)
+                      <:
+                      usize)
+                    <:
+                    bool)
+                  (fun temp_0_ ->
+                      let _:Prims.unit = temp_0_ in
+                      v (Core.Num.impl__i32__abs (result.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[
+                              i ]
+                            <:
+                            i32)
+                        <:
+                        i32) <
+                      v Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS
+                      <:
+                      bool)
+                <:
+                bool))
+
+val ntt_multiply (lhs rhs: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+      (requires
+        Hax_lib.v_forall (fun i ->
+              let i:usize = i in
+              Hax_lib.implies (i <. Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
+                  <:
+                  bool)
+                (fun temp_0_ ->
+                    let _:Prims.unit = temp_0_ in
+                    let lhs_i = (lhs.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ] <: i32) in
+                    (lhs_i >=. 0l <: bool) &&
+                    (lhs_i <. 4096l <: bool
+                    ) &&
+                    (v (Core.Num.impl__i32__abs (rhs.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ]
+                            <:
+                            i32)
+                        <:
+                        i32) <=
+                      v Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS
+                      <:
+                      bool))
+              <:
+              bool))
+      (ensures
+        fun result ->
+          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = result in
+          Hax_lib.v_forall (fun i ->
+                let i:usize = i in
+                Hax_lib.implies (i <.
+                    (Core.Slice.impl__len (Rust_primitives.unsize result
+                              .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
+                          <:
+                          t_Slice i32)
+                      <:
+                      usize)
+                    <:
+                    bool)
+                  (fun temp_0_ ->
+                      let _:Prims.unit = temp_0_ in
+                      v (Core.Num.impl__i32__abs (result.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[
+                              i ]
+                            <:
+                            i32)
+                        <:
+                        i32) <=
+                      v Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS
+                      <:
+                      bool)
+                <:
+                bool))
 
-val ntt_binomially_sampled_ring_element (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 7)
-    : Prims.Pure (Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
-      (requires True)
-      (ensures (fun _ -> True))
-
-val ntt_multiply (lhs: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3328)
-                 (rhs: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3328)
-    : Prims.Pure (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3328)
-      (requires True)
-      (ensures (fun _ -> True))
-    
 val ntt_vector_u
       (v_VECTOR_U_COMPRESSION_FACTOR: usize)
-      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3328)
-    : Prims.Pure (Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
-      (requires True)
-      (ensures fun _ -> True)
-
+      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+      (requires
+        Hax_lib.v_forall (fun i ->
+              let i:usize = i in
+              Hax_lib.implies (i <.
+                  (Core.Slice.impl__len (Rust_primitives.unsize re
+                            .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
+                        <:
+                        t_Slice i32)
+                    <:
+                    usize)
+                  <:
+                  bool)
+                (fun temp_0_ ->
+                    let _:Prims.unit = temp_0_ in
+                    (Core.Num.impl__i32__abs (re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[ i ]
+                          <:
+                          i32)
+                      <:
+                      i32) <=.
+                    3328l
+                    <:
+                    bool)
+              <:
+              bool))
+      (ensures
+        fun result ->
+          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = result in
+          Hax_lib.v_forall (fun i ->
+                let i:usize = i in
+                Hax_lib.implies (i <.
+                    (Core.Slice.impl__len (Rust_primitives.unsize result
+                              .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
+                          <:
+                          t_Slice i32)
+                      <:
+                      usize)
+                    <:
+                    bool)
+                  (fun temp_0_ ->
+                      let _:Prims.unit = temp_0_ in
+                      v (Core.Num.impl__i32__abs (result.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[
+                              i ]
+                            <:
+                            i32)
+                        <:
+                        i32) <
+                      v Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS
+                      <:
+                      bool)
+                <:
+                bool))
diff -ruN extraction-edited/Libcrux.Kem.Kyber.Sampling.fst extraction-secret-independent/Libcrux.Kem.Kyber.Sampling.fst
--- extraction-edited/Libcrux.Kem.Kyber.Sampling.fst	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.Sampling.fst	1970-01-01 01:00:00.000000000 +0100
@@ -3,34 +3,27 @@
 open Core
 open FStar.Mul
 
-let rejection_sampling_panic_with_diagnostic () : Prims.unit =
-  admit(); // This should never be reachable
+let rejection_sampling_panic_with_diagnostic (_: Prims.unit) =
   Rust_primitives.Hax.never_to_any (Core.Panicking.panic "explicit panic"
       <:
       Rust_primitives.Hax.t_Never)
 
-#push-options "--ifuel 0 --z3rlimit 100"
 let sample_from_binomial_distribution_2_ (randomness: t_Slice u8) =
-  let sampled: t_PolynomialRingElement_b 3 = 
-    cast_poly_b Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
+  let (sampled: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement):Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+  =
+    Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
   in
-
-  let acc_t = Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3 in
-  [@ inline_let]
-  let inv = fun (acc:acc_t) (i:usize) -> True in
-  let sl : t_Slice u8 = randomness in
-  let chunk_len = sz 4 in
-  assert (v (length sl) == 128);
-  assert (Seq.length sl == 128);
-  assert_norm (128 % 4 == 0);
-  let sampled =
-   Rust_primitives.Iterators.foldi_chunks_exact #u8 #acc_t #inv
-      sl
-      chunk_len
+  let sampled:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter (Core.Iter.Traits.Iterator.f_enumerate
+              (Core.Slice.impl__chunks_exact randomness (sz 4) <: Core.Slice.Iter.t_ChunksExact u8)
+            <:
+            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
+        <:
+        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
       sampled
       (fun sampled temp_1_ ->
-          let chunk_number, byte_chunk:(usize & t_Array u8 chunk_len) = temp_1_ in
-          assert(chunk_number <. sz 32);
+          let sampled:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = sampled in
+          let chunk_number, byte_chunk:(usize & t_Slice u8) = temp_1_ in
           let (random_bits_as_u32: u32):u32 =
             (((cast (byte_chunk.[ sz 0 ] <: u8) <: u32) |.
                 ((cast (byte_chunk.[ sz 1 ] <: u8) <: u32) <<! 8l <: u32)
@@ -42,58 +35,34 @@
             ((cast (byte_chunk.[ sz 3 ] <: u8) <: u32) <<! 24l <: u32)
           in
           let even_bits:u32 = random_bits_as_u32 &. 1431655765ul in
-          logand_lemma random_bits_as_u32 1431655765ul;
-          assert(even_bits <=. 1431655765ul);
           let odd_bits:u32 = (random_bits_as_u32 >>! 1l <: u32) &. 1431655765ul in
-          logand_lemma (random_bits_as_u32 >>! 1l <: u32) 1431655765ul;
-          assert(odd_bits <=. 1431655765ul);
           let coin_toss_outcomes:u32 = even_bits +! odd_bits in
-          let acc_t = Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3 in
-          [@ inline_let]
-          let inv : acc_t -> u32 -> Type = fun acc i -> True in
-            Rust_primitives.Iterators.foldi_range_step_by #u32_inttype #(acc_t) #inv ({
+          Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter (Core.Iter.Traits.Iterator.f_step_by
+                    ({
                         Core.Ops.Range.f_start = 0ul;
                         Core.Ops.Range.f_end = Core.Num.impl__u32__BITS
-                        }
-                        <:
-                        Core.Ops.Range.t_Range u32)
-            (sz 4)
+                      }
+                      <:
+                      Core.Ops.Range.t_Range pub_u32)
+                    (sz 4)
+                  <:
+                  Core.Iter.Adapters.Step_by.t_StepBy (Core.Ops.Range.t_Range pub_u32))
+              <:
+              Core.Iter.Adapters.Step_by.t_StepBy (Core.Ops.Range.t_Range pub_u32))
             sampled
             (fun sampled outcome_set ->
-                let outcome_set:u32 = outcome_set in
-                assert (v outcome_set + 4 <= 32);
-                let out_1 = ((coin_toss_outcomes >>! outcome_set <: u32) &. 3ul <: u32) in
+                let sampled:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = sampled in
+                let outcome_set:pub_u32 = outcome_set in
                 let outcome_1_:i32 =
-                  cast out_1  <: i32
+                  cast ((coin_toss_outcomes >>! outcome_set <: u32) &. 3ul <: u32) <: i32
                 in
-                let out_2 = ((coin_toss_outcomes >>! (outcome_set +! 2ul <: u32) <: u32) &. 3ul <: u32) in
                 let outcome_2_:i32 =
-                  cast out_2  <: i32
+                  cast ((coin_toss_outcomes >>! (outcome_set +! 2ul <: pub_u32) <: u32) &. 3ul <: u32)
+                  <:
+                  i32
                 in
-                logand_lemma (coin_toss_outcomes >>! outcome_set <: u32) 3ul;
-                assert (v out_1 >= 0);
-                assert (v out_1 <= 3);
-                assert (v outcome_1_ == v out_1 @% pow2 32);
-                Math.Lemmas.small_modulo_lemma_1 (v out_1) (pow2 32);
-                assert (v outcome_1_ == v out_1);
-                assert (v outcome_1_ >= 0 /\ v outcome_1_ <= 3);
-                logand_lemma (coin_toss_outcomes >>! (outcome_set +! 2ul <: u32) <: u32) 3ul;
-                assert (v out_2 >= 0);
-                assert (v out_2 <= 3);
-                assert (v outcome_2_ == v out_2 @% pow2 32);
-                Math.Lemmas.small_modulo_lemma_1 (v out_2) (pow2 32);
-                assert (v outcome_2_ == v out_2);
-                assert (v outcome_2_ >= 0 /\ v outcome_2_ <= 3);
-                let offset:usize = cast (outcome_set >>! 2l <: u32) <: usize in
-                assert (outcome_set <. 32ul);
-                assert (v (outcome_set >>! 2l <: u32) = v outcome_set / 4);
-                assert (v (outcome_set >>! 2l <: u32) < 8);
-                Math.Lemmas.small_modulo_lemma_1 (v (outcome_set >>! 2l <: u32)) (pow2 32);
-                Math.Lemmas.small_modulo_lemma_1 (v (outcome_set >>! 2l <: u32)) (pow2 64);
-                assert (v offset < 8);
-                assert (8 * v chunk_number + 8 <= 256);
-                assert (8 * v chunk_number + v offset < 256);
-                let sampled:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3 =
+                let offset:usize = cast (outcome_set >>! 2l <: pub_u32) <: usize in
+                let sampled:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
                   {
                     sampled with
                     Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -104,36 +73,29 @@
                       (outcome_1_ -! outcome_2_ <: i32)
                   }
                   <:
-                  Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 3
+                  Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
                 in
                 sampled))
-  in 
-  let _:Prims.unit = () <: Prims.unit in 
-  admit(); // P-F
-  sampled 
-#pop-options
+  in
+  let _:Prims.unit = () <: Prims.unit in
+  sampled
 
-#push-options "--ifuel 0 --z3rlimit 200"
 let sample_from_binomial_distribution_3_ (randomness: t_Slice u8) =
-  let sampled:t_PolynomialRingElement_b 7 =
-    (Libcrux.Kem.Kyber.Arithmetic.cast_poly_b Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO)
+  let (sampled: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement):Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+  =
+    Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
   in
-  let acc_t = Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 7 in
-  [@ inline_let]
-  let inv = fun (acc:acc_t) (i:usize) -> True in
-  let sl : t_Slice u8 = randomness in
-  let chunk_len = sz 3 in
-  assert (v (length sl) == 192);
-  assert (Seq.length sl == 192);
-  assert_norm (192 % 3 == 0);
-  let sampled:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 7 =
-   Rust_primitives.Iterators.foldi_chunks_exact #u8 #acc_t #inv
-      sl
-      chunk_len
+  let sampled:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter (Core.Iter.Traits.Iterator.f_enumerate
+              (Core.Slice.impl__chunks_exact randomness (sz 3) <: Core.Slice.Iter.t_ChunksExact u8)
+            <:
+            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
+        <:
+        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
       sampled
       (fun sampled temp_1_ ->
-          let sampled:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 7 = sampled in
-          let chunk_number, byte_chunk:(usize & t_Array u8 chunk_len) = temp_1_ in
+          let sampled:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = sampled in
+          let chunk_number, byte_chunk:(usize & t_Slice u8) = temp_1_ in
           let (random_bits_as_u24: u32):u32 =
             ((cast (byte_chunk.[ sz 0 ] <: u8) <: u32) |.
               ((cast (byte_chunk.[ sz 1 ] <: u8) <: u32) <<! 8l <: u32)
@@ -142,53 +104,32 @@
             ((cast (byte_chunk.[ sz 2 ] <: u8) <: u32) <<! 16l <: u32)
           in
           let first_bits:u32 = random_bits_as_u24 &. 2396745ul in
-          logand_lemma random_bits_as_u24 2396745ul;
-          assert (first_bits <=. 2396745ul);
           let second_bits:u32 = (random_bits_as_u24 >>! 1l <: u32) &. 2396745ul in
-          logand_lemma (random_bits_as_u24 >>! 1l <: u32) 2396745ul;
-          assert (second_bits <=. 2396745ul);
           let third_bits:u32 = (random_bits_as_u24 >>! 2l <: u32) &. 2396745ul in
-          logand_lemma (random_bits_as_u24 >>! 2l <: u32) 2396745ul;
-          assert (third_bits <=. 2396745ul);
           let coin_toss_outcomes:u32 = (first_bits +! second_bits <: u32) +! third_bits in
-          let acc_t = Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 7 in
-          [@ inline_let]
-          let inv : acc_t -> i32 -> Type = fun acc i -> True in
-            Rust_primitives.Iterators.foldi_range_step_by #i32_inttype #(acc_t) #inv ({
-                        Core.Ops.Range.f_start = 0l;
-                        Core.Ops.Range.f_end = 24l
-                        }
-                        <:
-                        Core.Ops.Range.t_Range i32)
-            (sz 6)
+          Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter (Core.Iter.Traits.Iterator.f_step_by
+                    ({ Core.Ops.Range.f_start = 0l; Core.Ops.Range.f_end = 24l }
+                      <:
+                      Core.Ops.Range.t_Range pub_i32)
+                    (sz 6)
+                  <:
+                  Core.Iter.Adapters.Step_by.t_StepBy (Core.Ops.Range.t_Range pub_i32))
+              <:
+              Core.Iter.Adapters.Step_by.t_StepBy (Core.Ops.Range.t_Range pub_i32))
             sampled
             (fun sampled outcome_set ->
-                let sampled:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 7 = sampled in
-                let outcome_set:i32 = outcome_set in
+                let sampled:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = sampled in
+                let outcome_set:pub_i32 = outcome_set in
                 let outcome_1_:i32 =
-                  cast ((coin_toss_outcomes >>! outcome_set <: u32) &. 7ul <: u32) <: i32
+                  cast ((coin_toss_outcomes >>! outcome_set <: pub_u32) &. 7ul <: u32) <: i32
                 in
                 let outcome_2_:i32 =
-                  cast ((coin_toss_outcomes >>! (outcome_set +! 3l <: i32) <: u32) &. 7ul <: u32)
+                  cast ((coin_toss_outcomes >>! (outcome_set +! 3l <: pub_i32) <: u32) &. 7ul <: u32)
                   <:
                   i32
                 in
-                logand_lemma (coin_toss_outcomes >>! outcome_set <: u32) 7ul;
-                Math.Lemmas.small_modulo_lemma_1 (v ((coin_toss_outcomes >>! outcome_set <: u32) &. 7ul <: u32)) (pow2 32);
-                assert (v outcome_1_ >= 0 /\ v outcome_1_ <= 7);
-                logand_lemma (coin_toss_outcomes >>! (outcome_set +! 3l <: i32) <: u32) 7ul;
-                Math.Lemmas.small_modulo_lemma_1 (v ((coin_toss_outcomes >>! (outcome_set +! 3l <: i32) <: u32) &. 7ul <: u32)) (pow2 32);
-                assert (v outcome_2_ >= 0 /\ v outcome_2_ <= 7);
-                let offset:usize = cast (outcome_set /! 6l <: i32) <: usize in
-                assert (outcome_set <. 24l);
-                assert (v (outcome_set /! 6l <: i32) = v outcome_set / 6);
-                assert (v (outcome_set /! 6l <: i32) < 4);
-                Math.Lemmas.small_modulo_lemma_1 (v (outcome_set /! 6l <: i32)) (pow2 32);
-                Math.Lemmas.small_modulo_lemma_1 (v (outcome_set /! 6l <: i32)) (pow2 64);
-                assert (v offset < 4);
-                assert (4 * v chunk_number + 4 <= 256);
-                assert (4 * v chunk_number + v offset < 256);
-                let sampled:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 7 =
+                let offset:usize = cast (outcome_set /! 6l <: pub_i32) <: usize in
+                let sampled:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
                   {
                     sampled with
                     Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -199,19 +140,16 @@
                       (outcome_1_ -! outcome_2_ <: i32)
                   }
                   <:
-                  Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b 7
+                  Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
                 in
                 sampled))
   in
   let _:Prims.unit = () <: Prims.unit in
-  admit();
   sampled
-#pop-options
 
 let sample_from_binomial_distribution (v_ETA: usize) (randomness: t_Slice u8) =
   let _:Prims.unit = () <: Prims.unit in
-  Rust_primitives.Integers.mk_int_equiv_lemma #u32_inttype (v v_ETA);
-  match cast (v_ETA <: usize) <: u32 with
+  match cast (v_ETA <: usize) <: pub_u32 with
   | 2ul -> sample_from_binomial_distribution_2_ randomness
   | 3ul -> sample_from_binomial_distribution_3_ randomness
   | _ ->
@@ -220,62 +158,52 @@
         <:
         Rust_primitives.Hax.t_Never)
 
-#push-options "--z3rlimit 50"
 let sample_from_uniform_distribution (randomness: t_Array u8 (sz 840)) =
   let (sampled_coefficients: usize):usize = sz 0 in
-  let (out: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement):Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+  let (out: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement):Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
   =
-    Libcrux.Kem.Kyber.Arithmetic.cast_poly_b Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
+    Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
   in
   let done:bool = false in
-  let acc_t = (bool & Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement & usize) in
-  [@ inline_let]
-  let inv = fun (acc:acc_t) -> True in
-  let sl : t_Slice u8 = randomness in
-  let chunk_len = sz 3 in
-  let done, out, sampled_coefficients:(bool & Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement &
+  let done, out, sampled_coefficients:(bool & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement &
     usize) =
-   Rust_primitives.Iterators.fold_chunks_exact #u8 #acc_t #inv
-      sl
-      chunk_len
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter (Core.Slice.impl__chunks (
+                Rust_primitives.unsize randomness <: t_Slice u8)
+              (sz 3)
+            <:
+            Core.Slice.Iter.t_Chunks u8)
+        <:
+        Core.Slice.Iter.t_Chunks u8)
       (done, out, sampled_coefficients
         <:
-        (bool & Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement & usize))
+        (bool & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement & usize))
       (fun temp_0_ bytes ->
           let done, out, sampled_coefficients:(bool &
-            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement &
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement &
             usize) =
             temp_0_
           in
-          let bytes:t_Array u8 chunk_len = bytes in
+          let bytes:t_Slice u8 = bytes in
           if ~.done <: bool
           then
             let b1:i32 = cast (bytes.[ sz 0 ] <: u8) <: i32 in
             let b2:i32 = cast (bytes.[ sz 1 ] <: u8) <: i32 in
             let b3:i32 = cast (bytes.[ sz 2 ] <: u8) <: i32 in
-            assert(v b1 >= 0 /\ v b1 < pow2 8);
-            assert(v b2 >= 0 /\ v b2 < pow2 8);
-            assert(v b3 >= 0 /\ v b3 < pow2 8);
             let d1:i32 = ((b2 &. 15l <: i32) <<! 8l <: i32) |. b1 in
-            assert (15 = pow2 4 - 1);
-            mk_int_equiv_lemma #i32_inttype 15;
-            assert (15l = mk_int (pow2 4) -! mk_int 1);
-            logand_mask_lemma b2 4;
-            assert (v ((b2 &. 15l <: i32) <<! 8l <: i32) == (v b2 % 16) * pow2 8);
-            logor_lemma ((b2 &. 15l <: i32) <<! 8l <: i32) b1;
-            assert (v d1 >= v b1);
-            assert (v d1 >= 0);
             let d2:i32 = (b3 <<! 4l <: i32) |. (b2 >>! 4l <: i32) in
-            logor_lemma (b3 <<! 4l <: i32) (b2 >>! 4l <: i32);
-            assert (v d2 >= v b3 * pow2 4);
-            assert (v d2 >= 0);
-            let out, sampled_coefficients:(Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement &
+            let out, sampled_coefficients:(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement &
               usize) =
               if
-                d1 <. Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS &&
+                // NOTE: We declassify d1 here, and this should be carefully reviewed.
+                //       We believe this is safe because d1 is derived from b1 and b2, 
+                //       both of which are fresh random inputs, not used anywhere else.
+                //       The comparison between d1 and 3329 tells the adversary whether d1
+                //       is in the field. This is not secret information, since the
+                //       failure of this comparison leads to d1 being discarded,
+                declassify d1 <. Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS &&
                 sampled_coefficients <. Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
               then
-                let out:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+                let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
                   {
                     out with
                     Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -286,23 +214,29 @@
                       d1
                   }
                   <:
-                  Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+                  Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
                 in
                 out, sampled_coefficients +! sz 1
                 <:
-                (Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement & usize)
+                (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement & usize)
               else
                 out, sampled_coefficients
                 <:
-                (Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement & usize)
+                (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement & usize)
             in
-            let out, sampled_coefficients:(Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement &
+            let out, sampled_coefficients:(Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement &
               usize) =
               if
-                d2 <. Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS &&
+                // NOTE: We declassify d2 here, and this should be carefully reviewed.
+                //       We believe this is safe because d2 is derived from b2 and b3, 
+                //       both of which are fresh random inputs, not used anywhere else.
+                //       The comparison between d2 and 3329 tells the adversary whether d2
+                //       is in the field. This is not secret information, since the
+                //       failure of this comparison leads to d2 being discarded,
+                declassify d2 <. Libcrux.Kem.Kyber.Constants.v_FIELD_MODULUS &&
                 sampled_coefficients <. Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
               then
-                let out:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+                let out:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
                   {
                     out with
                     Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -313,31 +247,31 @@
                       d2
                   }
                   <:
-                  Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+                  Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
                 in
                 let sampled_coefficients:usize = sampled_coefficients +! sz 1 in
                 out, sampled_coefficients
                 <:
-                (Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement & usize)
+                (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement & usize)
               else
                 out, sampled_coefficients
                 <:
-                (Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement & usize)
+                (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement & usize)
             in
             if sampled_coefficients =. Libcrux.Kem.Kyber.Constants.v_COEFFICIENTS_IN_RING_ELEMENT
             then
               let done:bool = true in
               done, out, sampled_coefficients
               <:
-              (bool & Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement & usize)
+              (bool & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement & usize)
             else
               done, out, sampled_coefficients
               <:
-              (bool & Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement & usize)
+              (bool & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement & usize)
           else
             done, out, sampled_coefficients
             <:
-            (bool & Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement & usize))
+            (bool & Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement & usize))
   in
   let _:Prims.unit =
     if ~.done
@@ -346,5 +280,4 @@
       ()
   in
   let _:Prims.unit = () <: Prims.unit in
-  out 
-#pop-options
+  out
diff -ruN extraction-edited/Libcrux.Kem.Kyber.Sampling.fsti extraction-secret-independent/Libcrux.Kem.Kyber.Sampling.fsti
--- extraction-edited/Libcrux.Kem.Kyber.Sampling.fsti	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.Sampling.fsti	1970-01-01 01:00:00.000000000 +0100
@@ -3,37 +3,77 @@
 open Core
 open FStar.Mul
 
-open Libcrux.Kem.Kyber.Arithmetic
+val rejection_sampling_panic_with_diagnostic: Prims.unit
+  -> Prims.Pure Prims.unit Prims.l_True (fun _ -> Prims.l_True)
 
 val sample_from_binomial_distribution_2_ (randomness: t_Slice u8)
-    : Prims.Pure (t_PolynomialRingElement_b 3)
+    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
       (requires (Core.Slice.impl__len randomness <: usize) =. (sz 2 *! sz 64 <: usize))
       (ensures
         fun result ->
-          Libcrux.Kem.Kyber.Arithmetic.to_spec_poly_b result == 
-          Spec.Kyber.sample_poly_binomial (sz 2) randomness)
+          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = result in
+          Hax_lib.v_forall (fun i ->
+                let i:usize = i in
+                Hax_lib.implies (i <.
+                    (Core.Slice.impl__len (Rust_primitives.unsize result
+                              .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
+                          <:
+                          t_Slice i32)
+                      <:
+                      usize)
+                    <:
+                    bool)
+                  (fun temp_0_ ->
+                      let _:Prims.unit = temp_0_ in
+                      (Core.Num.impl__i32__abs (result.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[
+                              i ]
+                            <:
+                            i32)
+                        <:
+                        i32) <=.
+                      2l
+                      <:
+                      bool)
+                <:
+                bool))
 
 val sample_from_binomial_distribution_3_ (randomness: t_Slice u8)
-    : Prims.Pure (t_PolynomialRingElement_b 7)
+    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
       (requires (Core.Slice.impl__len randomness <: usize) =. (sz 3 *! sz 64 <: usize))
       (ensures
         fun result ->
-          Libcrux.Kem.Kyber.Arithmetic.to_spec_poly_b result == 
-          Spec.Kyber.sample_poly_binomial (sz 3) randomness)
+          let result:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = result in
+          Hax_lib.v_forall (fun i ->
+                let i:usize = i in
+                Hax_lib.implies (i <.
+                    (Core.Slice.impl__len (Rust_primitives.unsize result
+                              .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
+                          <:
+                          t_Slice i32)
+                      <:
+                      usize)
+                    <:
+                    bool)
+                  (fun temp_0_ ->
+                      let _:Prims.unit = temp_0_ in
+                      (Core.Num.impl__i32__abs (result.Libcrux.Kem.Kyber.Arithmetic.f_coefficients.[
+                              i ]
+                            <:
+                            i32)
+                        <:
+                        i32) <=.
+                      3l
+                      <:
+                      bool)
+                <:
+                bool))
 
-val sample_from_binomial_distribution (#p:Spec.Kyber.params)
-    (v_ETA: usize) (randomness: t_Slice u8) 
-    : Pure (Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement_b (pow2 (v v_ETA) - 1))
-      (requires (v_ETA = p.v_ETA1 \/ v_ETA = p.v_ETA2) /\
-                (Core.Slice.impl__len randomness <: usize) =. (v_ETA *! sz 64 <: usize))
-      (ensures
-        fun result ->
-          Libcrux.Kem.Kyber.Arithmetic.to_spec_poly_b result == 
-          Spec.Kyber.sample_poly_binomial v_ETA randomness)
+val sample_from_binomial_distribution (v_ETA: usize) (randomness: t_Slice u8)
+    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+      Prims.l_True
+      (fun _ -> Prims.l_True)
 
 val sample_from_uniform_distribution (randomness: t_Array u8 (sz 840))
-    : Pure Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
-      (requires True)
-      (ensures fun _ -> True)
-//      (ensures fun result -> (forall i. v (result.f_coefficients.[i]) >= 0))
-      
+    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+      Prims.l_True
+      (fun _ -> Prims.l_True)
diff -ruN extraction-edited/Libcrux.Kem.Kyber.Serialize.fst extraction-secret-independent/Libcrux.Kem.Kyber.Serialize.fst
--- extraction-edited/Libcrux.Kem.Kyber.Serialize.fst	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.Serialize.fst	1970-01-01 01:00:00.000000000 +0100
@@ -1,15 +1,8 @@
 module Libcrux.Kem.Kyber.Serialize
-#set-options "--fuel 0 --ifuel 0 --z3rlimit 50 --retry 3"
+#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
 open Core
 open FStar.Mul
 
-open Libcrux.Kem.Kyber.Arithmetic
-
-open MkSeq
-open BitVecEq
-
-#push-options "--z3rlimit 480  --split_queries always"
-[@@"opaque_to_smt"]
 let compress_coefficients_10_ (coefficient1 coefficient2 coefficient3 coefficient4: i32) =
   let coef1:u8 = cast (coefficient1 &. 255l <: i32) <: u8 in
   let coef2:u8 =
@@ -25,14 +18,12 @@
     (cast ((coefficient3 >>! 4l <: i32) &. 63l <: i32) <: u8)
   in
   let coef5:u8 = cast ((coefficient4 >>! 2l <: i32) &. 255l <: i32) <: u8 in
-  bit_vec_equal_intro_principle ();
   coef1, coef2, coef3, coef4, coef5 <: (u8 & u8 & u8 & u8 & u8)
-#pop-options
 
-#push-options "--ifuel 1 --z3rlimit 600 --split_queries always"
-[@@"opaque_to_smt"]
 let compress_coefficients_11_
-      coefficient1 coefficient2 coefficient3 coefficient4 coefficient5 coefficient6 coefficient7 coefficient8 =
+      (coefficient1 coefficient2 coefficient3 coefficient4 coefficient5 coefficient6 coefficient7 coefficient8:
+          i32)
+     =
   let coef1:u8 = cast (coefficient1 <: i32) <: u8 in
   let coef2:u8 =
     ((cast (coefficient2 &. 31l <: i32) <: u8) <<! 3l <: u8) |.
@@ -65,32 +56,24 @@
     (cast (coefficient7 >>! 6l <: i32) <: u8)
   in
   let coef11:u8 = cast (coefficient8 >>! 3l <: i32) <: u8 in
-  bit_vec_equal_intro_principle ();
   coef1, coef2, coef3, coef4, coef5, coef6, coef7, coef8, coef9, coef10, coef11
   <:
   (u8 & u8 & u8 & u8 & u8 & u8 & u8 & u8 & u8 & u8 & u8)
-#pop-options
 
-#push-options "--z3rlimit 20"
-[@@"opaque_to_smt"]
-let compress_coefficients_3_ coefficient1 coefficient2 =
+let compress_coefficients_3_ (coefficient1 coefficient2: u16) =
   let coef1:u8 = cast (coefficient1 &. 255us <: u16) <: u8 in
-  get_bit_pow2_minus_one_u16 255 (sz 0);
   let coef2:u8 =
     cast ((coefficient1 >>! 8l <: u16) |. ((coefficient2 &. 15us <: u16) <<! 4l <: u16) <: u16)
     <:
     u8
   in
   let coef3:u8 = cast ((coefficient2 >>! 4l <: u16) &. 255us <: u16) <: u8 in
-  bit_vec_equal_intro_principle ();
-  coef1, coef2, coef3 <: (u8 & u8 & u8) 
-#pop-options
+  coef1, coef2, coef3 <: (u8 & u8 & u8)
 
-#push-options "--z3rlimit 160 --split_queries always"
-[@@"opaque_to_smt"]
 let compress_coefficients_5_
-      coefficient2 coefficient1 coefficient4 coefficient3 coefficient5 coefficient7 coefficient6 coefficient8
-  =
+      (coefficient2 coefficient1 coefficient4 coefficient3 coefficient5 coefficient7 coefficient6 coefficient8:
+          u8)
+     =
   let coef1:u8 = ((coefficient2 &. 7uy <: u8) <<! 5l <: u8) |. coefficient1 in
   let coef2:u8 =
     (((coefficient4 &. 1uy <: u8) <<! 7l <: u8) |. (coefficient3 <<! 2l <: u8) <: u8) |.
@@ -102,29 +85,18 @@
     (coefficient5 >>! 4l <: u8)
   in
   let coef5:u8 = (coefficient8 <<! 3l <: u8) |. (coefficient7 >>! 2l <: u8) in
-  bit_vec_equal_intro_principle ();
   coef1, coef2, coef3, coef4, coef5 <: (u8 & u8 & u8 & u8 & u8)
-#pop-options
 
-#push-options "--z3rlimit 500"
-[@@"opaque_to_smt"]
-let decompress_coefficients_10_ byte2 byte1 byte3 byte4 byte5 =
+let decompress_coefficients_10_ (byte2 byte1 byte3 byte4 byte5: i32) =
   let coefficient1:i32 = ((byte2 &. 3l <: i32) <<! 8l <: i32) |. (byte1 &. 255l <: i32) in
   let coefficient2:i32 = ((byte3 &. 15l <: i32) <<! 6l <: i32) |. (byte2 >>! 2l <: i32) in
   let coefficient3:i32 = ((byte4 &. 63l <: i32) <<! 4l <: i32) |. (byte3 >>! 4l <: i32) in
   let coefficient4:i32 = (byte5 <<! 2l <: i32) |. (byte4 >>! 6l <: i32) in
-  lemma_get_bit_bounded' coefficient1 10;
-  lemma_get_bit_bounded' coefficient2 10;
-  lemma_get_bit_bounded' coefficient3 10;
-  lemma_get_bit_bounded' coefficient4 10;
-  bit_vec_equal_intro_principle ();
-  coefficient1, coefficient2, coefficient3, coefficient4
-#pop-options
+  coefficient1, coefficient2, coefficient3, coefficient4 <: (i32 & i32 & i32 & i32)
 
-#push-options "--z3rlimit 300"
-[@@"opaque_to_smt"]
 let decompress_coefficients_11_
-      byte2 byte1 byte3 byte5 byte4 byte6 byte7 byte9 byte8 byte10 byte11 =
+      (byte2 byte1 byte3 byte5 byte4 byte6 byte7 byte9 byte8 byte10 byte11: i32)
+     =
   let coefficient1:i32 = ((byte2 &. 7l <: i32) <<! 8l <: i32) |. byte1 in
   let coefficient2:i32 = ((byte3 &. 63l <: i32) <<! 5l <: i32) |. (byte2 >>! 3l <: i32) in
   let coefficient3:i32 =
@@ -137,15 +109,6 @@
   in
   let coefficient7:i32 = ((byte10 &. 31l <: i32) <<! 6l <: i32) |. (byte9 >>! 2l <: i32) in
   let coefficient8:i32 = (byte11 <<! 3l <: i32) |. (byte10 >>! 5l <: i32) in
-  bit_vec_equal_intro_principle ();
-  lemma_get_bit_bounded' coefficient1 11;
-  lemma_get_bit_bounded' coefficient2 11;
-  lemma_get_bit_bounded' coefficient3 11;
-  lemma_get_bit_bounded' coefficient4 11;
-  lemma_get_bit_bounded' coefficient5 11;
-  lemma_get_bit_bounded' coefficient6 11;
-  lemma_get_bit_bounded' coefficient7 11;
-  lemma_get_bit_bounded' coefficient8 11;
   coefficient1,
   coefficient2,
   coefficient3,
@@ -154,22 +117,15 @@
   coefficient6,
   coefficient7,
   coefficient8
-#pop-options
+  <:
+  (i32 & i32 & i32 & i32 & i32 & i32 & i32 & i32)
 
-#push-options "--z3rlimit 50"
-[@@"opaque_to_smt"]
-let decompress_coefficients_4_ byte =
+let decompress_coefficients_4_ (byte: u8) =
   let coefficient1:i32 = cast (byte &. 15uy <: u8) <: i32 in
   let coefficient2:i32 = cast ((byte >>! 4l <: u8) &. 15uy <: u8) <: i32 in
-  lemma_get_bit_bounded' coefficient1 4;
-  lemma_get_bit_bounded' coefficient2 4;
-  bit_vec_equal_intro_principle ();
-  coefficient1, coefficient2
-#pop-options
-
-#push-options "--z3rlimit 400"
-[@@"opaque_to_smt"]
-let decompress_coefficients_5_ byte1 byte2 byte3 byte4 byte5 =
+  coefficient1, coefficient2 <: (i32 & i32)
+
+let decompress_coefficients_5_ (byte1 byte2 byte3 byte4 byte5: i32) =
   let coefficient1:i32 = byte1 &. 31l in
   let coefficient2:i32 = ((byte2 &. 3l <: i32) <<! 3l <: i32) |. (byte1 >>! 5l <: i32) in
   let coefficient3:i32 = (byte2 >>! 2l <: i32) &. 31l in
@@ -178,15 +134,6 @@
   let coefficient6:i32 = (byte4 >>! 1l <: i32) &. 31l in
   let coefficient7:i32 = ((byte5 &. 7l <: i32) <<! 2l <: i32) |. (byte4 >>! 6l <: i32) in
   let coefficient8:i32 = byte5 >>! 3l in
-  bit_vec_equal_intro_principle ();
-  lemma_get_bit_bounded' coefficient1 5;
-  lemma_get_bit_bounded' coefficient2 5;
-  lemma_get_bit_bounded' coefficient3 5;
-  lemma_get_bit_bounded' coefficient4 5;
-  lemma_get_bit_bounded' coefficient5 5;
-  lemma_get_bit_bounded' coefficient6 5;
-  lemma_get_bit_bounded' coefficient7 5;
-  lemma_get_bit_bounded' coefficient8 5;
   coefficient1,
   coefficient2,
   coefficient3,
@@ -195,54 +142,31 @@
   coefficient6,
   coefficient7,
   coefficient8
-#pop-options
-
-let cast_bound_lemma 
-  #t #u
-  (n: int_t t) 
-  (d: num_bits t)
-  : Lemma (requires bounded n d /\ d <= bits u /\ unsigned u /\ v n >= 0)
-          (ensures  bounded (cast #(int_t t) #(int_t u) n) d)
-          [SMTPat (bounded n d); SMTPat (cast #(int_t t) #(int_t u) n)]
-  = ()
-
-#push-options "--z3rlimit 90"
-[@@"opaque_to_smt"]
-let int_t_d_cast_lemma #t #u d (n: int_t_d t d)
-  : Lemma (requires bits t < bits u /\ v n >= 0)
-          (ensures bounded (cast #(int_t t) #(int_t u) n) d)
-          [SMTPat (bounded (cast #(int_t t) #(int_t u) n) d)]
-  = Math.Lemmas.pow2_double_mult (bits u - 1);
-    Math.Lemmas.small_mod (v n) (modulus u)
-let mul_in_range (n m: nat)
-  : Lemma
-    (requires n <= 256 /\ m <= 256)
-    (ensures range (n * m) usize_inttype)
-  = Math.Lemmas.pow2_plus 8 8;
-    Math.Lemmas.pow2_le_compat 32 16
-#pop-options
-
-#restart-solver
+  <:
+  (i32 & i32 & i32 & i32 & i32 & i32 & i32 & i32)
 
-#push-options "--fuel 0 --ifuel 1 --query_stats --z3rlimit 100"
-[@@"opaque_to_smt"]
 let compress_then_serialize_10_
-      v_OUT_LEN
-      re
-    =
-  let accT = t_Array u8 v_OUT_LEN in
-  let inv = fun (acc: t_Array u8 v_OUT_LEN) (i: usize) -> 
-    True
-  in
+      (v_OUT_LEN: usize)
+      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+     =
   let serialized:t_Array u8 v_OUT_LEN = Rust_primitives.Hax.repeat 0uy v_OUT_LEN in
   let serialized:t_Array u8 v_OUT_LEN =
-    Rust_primitives.Iterators.foldi_chunks_exact #_ #accT #inv
-      (re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients)
-      (sz 4)
-      (serialized)
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter (Core.Iter.Traits.Iterator.f_enumerate
+              (Core.Slice.impl__chunks_exact (Rust_primitives.unsize re
+                        .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
+                    <:
+                    t_Slice i32)
+                  (sz 4)
+                <:
+                Core.Slice.Iter.t_ChunksExact i32)
+            <:
+            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact i32))
+        <:
+        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact i32))
+      serialized
       (fun serialized temp_1_ ->
           let serialized:t_Array u8 v_OUT_LEN = serialized in
-          let i, coefficients:(usize & _) = temp_1_ in
+          let i, coefficients:(usize & t_Slice i32) = temp_1_ in
           let coefficient1:i32 =
             Libcrux.Kem.Kyber.Compress.compress_ciphertext_coefficient 10uy
               (Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 0 ] <: i32
@@ -302,96 +226,79 @@
           serialized)
   in
   serialized
-#pop-options
 
-#push-options "--fuel 0 --ifuel 0 --z3rlimit 30"
-[@@"opaque_to_smt"]
-let update5
-  #n
-  (s: t_Array 't n)
-  (offset: usize {v offset + 5 <= v n})
-  (i0 i1 i2 i3 i4: 't)
-  : s': t_Array 't n {
-     Seq.index s' (v offset +  0) == i0  /\
-     Seq.index s' (v offset +  1) == i1  /\
-     Seq.index s' (v offset +  2) == i2  /\
-     Seq.index s' (v offset +  3) == i3  /\
-     Seq.index s' (v offset +  4) == i4  /\
-     (forall i. (i < v offset \/ i >= v offset + 5) ==> Seq.index s' i == Seq.index s i)
-    }
- = let open Rust_primitives.Hax.Monomorphized_update_at in
-    let s = update_at_usize s  offset          i0 in
-    let s = update_at_usize s (offset +! sz  1) i1  in
-    let s = update_at_usize s (offset +! sz  2) i2  in
-    let s = update_at_usize s (offset +! sz  3) i3  in
-    let s = update_at_usize s (offset +! sz  4) i4  in
-    s
-#pop-options
-
-#push-options "--fuel 0 --ifuel 1 --z3rlimit 100 --query_stats --split_queries no"
 let compress_then_serialize_11_
-      v_OUT_LEN re
-  =
-  let inv = fun (acc: t_Array u8 v_OUT_LEN) (i: usize) -> True in
+      (v_OUT_LEN: usize)
+      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+     =
   let serialized:t_Array u8 v_OUT_LEN = Rust_primitives.Hax.repeat 0uy v_OUT_LEN in
   let serialized:t_Array u8 v_OUT_LEN =
-    Rust_primitives.Iterators.foldi_chunks_exact #_ #_ #inv
-      (Rust_primitives.unsize re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients)
-      (sz 8)
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter (Core.Iter.Traits.Iterator.f_enumerate
+              (Core.Slice.impl__chunks_exact (Rust_primitives.unsize re
+                        .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
+                    <:
+                    t_Slice i32)
+                  (sz 8)
+                <:
+                Core.Slice.Iter.t_ChunksExact i32)
+            <:
+            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact i32))
+        <:
+        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact i32))
       serialized
       (fun serialized temp_1_ ->
           let serialized:t_Array u8 v_OUT_LEN = serialized in
-          let i, coefficients:(usize & t_Array Libcrux.Kem.Kyber.Arithmetic.wfFieldElement (sz 8)) = temp_1_ in
-          let coefficient1 =
+          let i, coefficients:(usize & t_Slice i32) = temp_1_ in
+          let coefficient1:i32 =
             Libcrux.Kem.Kyber.Compress.compress_ciphertext_coefficient 11uy
               (Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 0 ] <: i32
                   )
                 <:
                 u16)
           in
-          let coefficient2 =
+          let coefficient2:i32 =
             Libcrux.Kem.Kyber.Compress.compress_ciphertext_coefficient 11uy
               (Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 1 ] <: i32
                   )
                 <:
                 u16)
           in
-          let coefficient3 =
+          let coefficient3:i32 =
             Libcrux.Kem.Kyber.Compress.compress_ciphertext_coefficient 11uy
               (Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 2 ] <: i32
                   )
                 <:
                 u16)
           in
-          let coefficient4 =
+          let coefficient4:i32 =
             Libcrux.Kem.Kyber.Compress.compress_ciphertext_coefficient 11uy
               (Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 3 ] <: i32
                   )
                 <:
                 u16)
           in
-          let coefficient5 =
+          let coefficient5:i32 =
             Libcrux.Kem.Kyber.Compress.compress_ciphertext_coefficient 11uy
               (Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 4 ] <: i32
                   )
                 <:
                 u16)
           in
-          let coefficient6 =
+          let coefficient6:i32 =
             Libcrux.Kem.Kyber.Compress.compress_ciphertext_coefficient 11uy
               (Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 5 ] <: i32
                   )
                 <:
                 u16)
           in
-          let coefficient7 =
+          let coefficient7:i32 =
             Libcrux.Kem.Kyber.Compress.compress_ciphertext_coefficient 11uy
               (Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 6 ] <: i32
                   )
                 <:
                 u16)
           in
-          let coefficient8 =
+          let coefficient8:i32 =
             Libcrux.Kem.Kyber.Compress.compress_ciphertext_coefficient 11uy
               (Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 7 ] <: i32
                   )
@@ -417,8 +324,6 @@
               coefficient7
               coefficient8
           in
-          assert_spinoff (v i < 32 ==> 11 * v i + 11 <= 32 * 11);
-          assert_spinoff (v i < 32 ==> range (v (sz 11) * v i) usize_inttype);
           let serialized:t_Array u8 v_OUT_LEN =
             Rust_primitives.Hax.Monomorphized_update_at.update_at_usize serialized
               (sz 11 *! i <: usize)
@@ -477,20 +382,29 @@
           serialized)
   in
   serialized
-#pop-options
 
-let compress_then_serialize_4_ v_OUT_LEN re =
+let compress_then_serialize_4_
+      (v_OUT_LEN: usize)
+      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+     =
   let serialized:t_Array u8 v_OUT_LEN = Rust_primitives.Hax.repeat 0uy v_OUT_LEN in
-  let accT = t_Array u8 v_OUT_LEN in
-  let inv (acc: accT) (i: usize) = True in
   let serialized:t_Array u8 v_OUT_LEN =
-    Rust_primitives.Iterators.foldi_chunks_exact #_ #_ #inv
-      (Rust_primitives.unsize re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients)
-      (sz 2)
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter (Core.Iter.Traits.Iterator.f_enumerate
+              (Core.Slice.impl__chunks_exact (Rust_primitives.unsize re
+                        .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
+                    <:
+                    t_Slice i32)
+                  (sz 2)
+                <:
+                Core.Slice.Iter.t_ChunksExact i32)
+            <:
+            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact i32))
+        <:
+        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact i32))
       serialized
       (fun serialized temp_1_ ->
           let serialized:t_Array u8 v_OUT_LEN = serialized in
-          let i, coefficients:(usize & t_Array Libcrux.Kem.Kyber.Arithmetic.wfFieldElement (sz 2)) = temp_1_ in
+          let i, coefficients:(usize & t_Slice i32) = temp_1_ in
           let coefficient1:u8 =
             cast (Libcrux.Kem.Kyber.Compress.compress_ciphertext_coefficient 4uy
                   (Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 0 ]
@@ -525,20 +439,27 @@
   serialized
 
 let compress_then_serialize_5_
-      v_OUT_LEN
-      re
-  =
+      (v_OUT_LEN: usize)
+      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+     =
   let serialized:t_Array u8 v_OUT_LEN = Rust_primitives.Hax.repeat 0uy v_OUT_LEN in
-  let accT = t_Array u8 v_OUT_LEN in
-  let inv (acc: accT) (i: usize) = True in
   let serialized:t_Array u8 v_OUT_LEN =
-    Rust_primitives.Iterators.foldi_chunks_exact #_ #_ #inv
-      (Rust_primitives.unsize re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients)
-      (sz 8)
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter (Core.Iter.Traits.Iterator.f_enumerate
+              (Core.Slice.impl__chunks_exact (Rust_primitives.unsize re
+                        .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
+                    <:
+                    t_Slice i32)
+                  (sz 8)
+                <:
+                Core.Slice.Iter.t_ChunksExact i32)
+            <:
+            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact i32))
+        <:
+        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact i32))
       serialized
       (fun serialized temp_1_ ->
           let serialized:t_Array u8 v_OUT_LEN = serialized in
-          let i, coefficients:(usize & t_Array Libcrux.Kem.Kyber.Arithmetic.wfFieldElement (sz 8)) = temp_1_ in
+          let i, coefficients:(usize & t_Slice i32) = temp_1_ in
           let coefficient1:u8 =
             cast (Libcrux.Kem.Kyber.Compress.compress_ciphertext_coefficient 5uy
                   (Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 0 ]
@@ -623,14 +544,6 @@
             <:
             u8
           in
-          let coefficient8' = Libcrux.Kem.Kyber.Compress.compress_ciphertext_coefficient 5uy
-                  (Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 7 ]
-                        <:
-                        i32)
-                    <:
-                    u16)
-                <:
-                i32 in
           let coefficient8:u8 =
             cast (Libcrux.Kem.Kyber.Compress.compress_ciphertext_coefficient 5uy
                   (Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 7 ]
@@ -653,8 +566,6 @@
               coefficient6
               coefficient8
           in
-          assert_spinoff (v i < 32 ==> 5 * v i + 5 <= 32 * 5);
-          assert_spinoff (v i < 32 ==> range (v (sz 5) * v i) usize_inttype);
           let serialized:t_Array u8 v_OUT_LEN =
             Rust_primitives.Hax.Monomorphized_update_at.update_at_usize serialized
               (sz 5 *! i <: usize)
@@ -684,24 +595,35 @@
   in
   serialized
 
-let compress_then_serialize_message re =
+let compress_then_serialize_message (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
   let serialized:t_Array u8 (sz 32) = Rust_primitives.Hax.repeat 0uy (sz 32) in
-  let accT = t_Array u8 (sz 32) in
-  let inv (acc: accT) (i: usize) = True in
   let serialized:t_Array u8 (sz 32) =
-    Rust_primitives.Iterators.foldi_chunks_exact #_ #_ #inv
-      (re.Libcrux.Kem.Kyber.Arithmetic.f_coefficients)
-      (sz 8)
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter (Core.Iter.Traits.Iterator.f_enumerate
+              (Core.Slice.impl__chunks_exact (Rust_primitives.unsize re
+                        .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
+                    <:
+                    t_Slice i32)
+                  (sz 8)
+                <:
+                Core.Slice.Iter.t_ChunksExact i32)
+            <:
+            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact i32))
+        <:
+        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact i32))
       serialized
       (fun serialized temp_1_ ->
           let serialized:t_Array u8 (sz 32) = serialized in
-          let i, coefficients:(usize & t_Array Libcrux.Kem.Kyber.Arithmetic.wfFieldElement _) = temp_1_ in
-          Rust_primitives.Iterators.foldi_slice #_ #_ #(fun _ _ -> True) 
-            coefficients
+          let i, coefficients:(usize & t_Slice i32) = temp_1_ in
+          Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter (Core.Iter.Traits.Iterator.f_enumerate
+                    (Core.Slice.impl__iter coefficients <: Core.Slice.Iter.t_Iter i32)
+                  <:
+                  Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_Iter i32))
+              <:
+              Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_Iter i32))
             serialized
             (fun serialized temp_1_ ->
                 let serialized:t_Array u8 (sz 32) = serialized in
-                let j, coefficient:(usize & Libcrux.Kem.Kyber.Arithmetic.wfFieldElement) = temp_1_ in
+                let j, coefficient:(usize & i32) = temp_1_ in
                 let coefficient:u16 =
                   Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative coefficient
                 in
@@ -714,36 +636,28 @@
           <:
           t_Array u8 (sz 32))
   in
-  admit (); // P-F 
   serialized
 
-let compress_then_serialize_ring_element_u #p
-      v_COMPRESSION_FACTOR
-      v_OUT_LEN
-      (re: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement) =
+let compress_then_serialize_ring_element_u
+      (v_COMPRESSION_FACTOR v_OUT_LEN: usize)
+      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+     =
   let _:Prims.unit = () <: Prims.unit in
-  assert (
-    (v (cast (v_COMPRESSION_FACTOR <: usize) <: u32) == 11) \/
-    (v (cast (v_COMPRESSION_FACTOR <: usize) <: u32) == 10)
-  );
-  Rust_primitives.Integers.mk_int_equiv_lemma #usize_inttype (v v_COMPRESSION_FACTOR);
-  match cast (v_COMPRESSION_FACTOR <: usize) <: u32 with
+  match cast (v_COMPRESSION_FACTOR <: usize) <: pub_u32 with
   | 10ul -> compress_then_serialize_10_ v_OUT_LEN re
   | 11ul -> compress_then_serialize_11_ v_OUT_LEN re
   | _ ->
     Rust_primitives.Hax.never_to_any (Core.Panicking.panic "internal error: entered unreachable code"
+
         <:
         Rust_primitives.Hax.t_Never)
 
-let compress_then_serialize_ring_element_v #p v_COMPRESSION_FACTOR v_OUT_LEN re =
+let compress_then_serialize_ring_element_v
+      (v_COMPRESSION_FACTOR v_OUT_LEN: usize)
+      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+     =
   let _:Prims.unit = () <: Prims.unit in
-  Rust_primitives.Integers.mk_int_equiv_lemma #usize_inttype (v v_COMPRESSION_FACTOR);
-  let res = 
-  assert (
-    (v (cast (v_COMPRESSION_FACTOR <: usize) <: u32) == 4) \/
-    (v (cast (v_COMPRESSION_FACTOR <: usize) <: u32) == 5)
-  );
-  match cast (v_COMPRESSION_FACTOR <: usize) <: u32 with
+  match cast (v_COMPRESSION_FACTOR <: usize) <: pub_u32 with
   | 4ul -> compress_then_serialize_4_ v_OUT_LEN re
   | 5ul -> compress_then_serialize_5_ v_OUT_LEN re
   | _ ->
@@ -751,49 +665,32 @@
 
         <:
         Rust_primitives.Hax.t_Never)
-  in
-  admit (); // P-F
-  res
 
-#push-options "--z3rlimit 160"
-let deserialize_then_decompress_10_ serialized =
+let deserialize_then_decompress_10_ (serialized: t_Slice u8) =
   let _:Prims.unit = () <: Prims.unit in
-  let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
-    Libcrux.Kem.Kyber.Arithmetic.cast_poly_b Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+    Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
   in
-  let accT = Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement in
-  let inv (acc: accT) (i: usize) = True in
-  let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
-    Rust_primitives.Iterators.foldi_chunks_exact #_ #_ #inv
-      serialized
-      (sz 5)
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter (Core.Iter.Traits.Iterator.f_enumerate
+              (Core.Slice.impl__chunks_exact serialized (sz 5) <: Core.Slice.Iter.t_ChunksExact u8)
+            <:
+            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
+        <:
+        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
       re
       (fun re temp_1_ ->
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement = re in
-          let i, bytes:(usize & t_Array u8 (sz 5)) = temp_1_ in
-          let byte1: int_t_d i32_inttype 8 = cast (bytes.[ sz 0 ] <: u8) <: i32 in
-          let byte2: int_t_d i32_inttype 8 = cast (bytes.[ sz 1 ] <: u8) <: i32 in
-          let byte3: int_t_d i32_inttype 8 = cast (bytes.[ sz 2 ] <: u8) <: i32 in
-          let byte4: int_t_d i32_inttype 8 = cast (bytes.[ sz 3 ] <: u8) <: i32 in
-          let byte5: int_t_d i32_inttype 8 = cast (bytes.[ sz 4 ] <: u8) <: i32 in
-          let coefficient1, coefficient2, coefficient3, coefficient4 =
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
+          let i, bytes:(usize & t_Slice u8) = temp_1_ in
+          let byte1:i32 = cast (bytes.[ sz 0 ] <: u8) <: i32 in
+          let byte2:i32 = cast (bytes.[ sz 1 ] <: u8) <: i32 in
+          let byte3:i32 = cast (bytes.[ sz 2 ] <: u8) <: i32 in
+          let byte4:i32 = cast (bytes.[ sz 3 ] <: u8) <: i32 in
+          let byte5:i32 = cast (bytes.[ sz 4 ] <: u8) <: i32 in
+          let coefficient1, coefficient2, coefficient3, coefficient4:(i32 & i32 & i32 & i32) =
             decompress_coefficients_10_ byte2 byte1 byte3 byte4 byte5
           in
-          let coefficient1 = (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 10uy coefficient1
-                           <:
-                           i32) in
-          let coefficient2 = (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 10uy coefficient2
-                           <:
-                           i32) in
-          let coefficient3 = (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 10uy coefficient3
-                           <:
-                           i32) in
-          let coefficient4 = (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 10uy coefficient4
-                           <:
-                           i32) in
-          assert_spinoff (v i < 64 ==> 4 * v i + 4 <= 256);
-          assert_spinoff (v i < 64 ==> range (v (sz 4) * v i) usize_inttype);
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -801,12 +698,14 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 (sz 4 *! i <: usize)
-                coefficient1 
+                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 10uy coefficient1
+                  <:
+                  i32)
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -814,12 +713,14 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 4 *! i <: usize) +! sz 1 <: usize)
-                coefficient2 
+                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 10uy coefficient2
+                  <:
+                  i32)
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -827,12 +728,14 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 4 *! i <: usize) +! sz 2 <: usize)
-                coefficient3
+                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 10uy coefficient3
+                  <:
+                  i32)
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -840,43 +743,44 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 4 *! i <: usize) +! sz 3 <: usize)
-                coefficient4
+                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 10uy coefficient4
+                  <:
+                  i32)
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
           re)
   in
   re
-#pop-options
 
-#push-options "--z3rlimit 100 --ifuel 0"
-let deserialize_then_decompress_11_ serialized
-    : Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+let deserialize_then_decompress_11_ (serialized: t_Slice u8) =
   let _:Prims.unit = () <: Prims.unit in
-  let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
-    Libcrux.Kem.Kyber.Arithmetic.cast_poly_b Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+    Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
   in
-  let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
-    Rust_primitives.Iterators.foldi_chunks_exact #_ #_ #(fun _ _ -> True)
-      serialized
-      (sz 11)
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter (Core.Iter.Traits.Iterator.f_enumerate
+              (Core.Slice.impl__chunks_exact serialized (sz 11) <: Core.Slice.Iter.t_ChunksExact u8)
+            <:
+            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
+        <:
+        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
       re
       (fun re temp_1_ ->
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement = re in
-          let i, bytes:(usize & t_Array u8 (sz 11)) = temp_1_ in
-          assert (v i < 32);
-          let byte1: int_t_d i32_inttype 8 = cast (bytes.[ sz 0 ] <: u8) <: i32 in
-          let byte2: int_t_d i32_inttype 8 = cast (bytes.[ sz 1 ] <: u8) <: i32 in
-          let byte3: int_t_d i32_inttype 8 = cast (bytes.[ sz 2 ] <: u8) <: i32 in
-          let byte4: int_t_d i32_inttype 8 = cast (bytes.[ sz 3 ] <: u8) <: i32 in
-          let byte5: int_t_d i32_inttype 8 = cast (bytes.[ sz 4 ] <: u8) <: i32 in
-          let byte6: int_t_d i32_inttype 8 = cast (bytes.[ sz 5 ] <: u8) <: i32 in
-          let byte7: int_t_d i32_inttype 8 = cast (bytes.[ sz 6 ] <: u8) <: i32 in
-          let byte8: int_t_d i32_inttype 8 = cast (bytes.[ sz 7 ] <: u8) <: i32 in
-          let byte9: int_t_d i32_inttype 8 = cast (bytes.[ sz 8 ] <: u8) <: i32 in
-          let byte10: int_t_d i32_inttype 8 = cast (bytes.[ sz 9 ] <: u8) <: i32 in
-          let byte11: int_t_d i32_inttype 8 = cast (bytes.[ sz 10 ] <: u8) <: i32 in
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
+          let i, bytes:(usize & t_Slice u8) = temp_1_ in
+          let byte1:i32 = cast (bytes.[ sz 0 ] <: u8) <: i32 in
+          let byte2:i32 = cast (bytes.[ sz 1 ] <: u8) <: i32 in
+          let byte3:i32 = cast (bytes.[ sz 2 ] <: u8) <: i32 in
+          let byte4:i32 = cast (bytes.[ sz 3 ] <: u8) <: i32 in
+          let byte5:i32 = cast (bytes.[ sz 4 ] <: u8) <: i32 in
+          let byte6:i32 = cast (bytes.[ sz 5 ] <: u8) <: i32 in
+          let byte7:i32 = cast (bytes.[ sz 6 ] <: u8) <: i32 in
+          let byte8:i32 = cast (bytes.[ sz 7 ] <: u8) <: i32 in
+          let byte9:i32 = cast (bytes.[ sz 8 ] <: u8) <: i32 in
+          let byte10:i32 = cast (bytes.[ sz 9 ] <: u8) <: i32 in
+          let byte11:i32 = cast (bytes.[ sz 10 ] <: u8) <: i32 in
           let
           coefficient1,
           coefficient2,
@@ -885,21 +789,11 @@
           coefficient5,
           coefficient6,
           coefficient7,
-          coefficient8 =
+          coefficient8:(i32 & i32 & i32 & i32 & i32 & i32 & i32 & i32) =
             decompress_coefficients_11_ byte2 byte1 byte3 byte5 byte4 byte6 byte7 byte9 byte8 byte10
               byte11
           in
-          let coefficient1 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient1 in
-          let coefficient2 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient2 in
-          let coefficient3 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient3 in
-          let coefficient4 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient4 in
-          let coefficient5 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient5 in
-          let coefficient6 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient6 in
-          let coefficient7 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient7 in
-          let coefficient8 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient8 in
-          assert_spinoff (8 * v i + 8 <= 256);
-          assert_spinoff (range (v (sz 8) * v i) usize_inttype);
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -907,12 +801,14 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 (sz 8 *! i <: usize)
-                coefficient1
+                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient1
+                  <:
+                  i32)
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -920,12 +816,14 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 8 *! i <: usize) +! sz 1 <: usize)
-                coefficient2
+                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient2
+                  <:
+                  i32)
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -933,12 +831,14 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 8 *! i <: usize) +! sz 2 <: usize)
-                coefficient3
+                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient3
+                  <:
+                  i32)
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -946,12 +846,14 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 8 *! i <: usize) +! sz 3 <: usize)
-                coefficient4
+                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient4
+                  <:
+                  i32)
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -959,12 +861,14 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 8 *! i <: usize) +! sz 4 <: usize)
-                coefficient5
+                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient5
+                  <:
+                  i32)
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -972,12 +876,14 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 8 *! i <: usize) +! sz 5 <: usize)
-                coefficient6
+                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient6
+                  <:
+                  i32)
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -985,12 +891,14 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 8 *! i <: usize) +! sz 6 <: usize)
-                coefficient7
+                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient7
+                  <:
+                  i32)
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -998,33 +906,35 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 8 *! i <: usize) +! sz 7 <: usize)
-                coefficient8
+                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 11uy coefficient8
+                  <:
+                  i32)
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
           re)
   in
   re
-#pop-options
 
-#push-options "--z3rlimit 100"
-let deserialize_then_decompress_4_ serialized =
+let deserialize_then_decompress_4_ (serialized: t_Slice u8) =
   let _:Prims.unit = () <: Prims.unit in
-  let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
-    Libcrux.Kem.Kyber.Arithmetic.cast_poly_b Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+    Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
   in
-  let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
-    Rust_primitives.Iterators.foldi_slice #_ #_ #(fun _ _ -> True)
-      serialized
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter (Core.Iter.Traits.Iterator.f_enumerate
+              (Core.Slice.impl__iter serialized <: Core.Slice.Iter.t_Iter u8)
+            <:
+            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_Iter u8))
+        <:
+        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_Iter u8))
       re
       (fun re temp_1_ ->
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement = re in
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
           let i, byte:(usize & u8) = temp_1_ in
-          let coefficient1, coefficient2 = decompress_coefficients_4_ byte in
-          assert_spinoff (v i < 128 ==> 2 * v i + 1 < 256);
-          assert_spinoff (v i < 128 ==> range (v (sz 2) * v i) usize_inttype);
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+          let coefficient1, coefficient2:(i32 & i32) = decompress_coefficients_4_ byte in
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -1037,9 +947,9 @@
                   i32)
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -1052,32 +962,33 @@
                   i32)
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
           re)
   in
   re
-#pop-options
 
-#push-options "--z3rlimit 150"
-let deserialize_then_decompress_5_ serialized =
+let deserialize_then_decompress_5_ (serialized: t_Slice u8) =
   let _:Prims.unit = () <: Prims.unit in
-  let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
-    Libcrux.Kem.Kyber.Arithmetic.cast_poly_b Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+    Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
   in
-  let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
-     Rust_primitives.Iterators.foldi_chunks_exact #_ #_ #(fun _ _ -> True)
-      serialized (sz 5)
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter (Core.Iter.Traits.Iterator.f_enumerate
+              (Core.Slice.impl__chunks_exact serialized (sz 5) <: Core.Slice.Iter.t_ChunksExact u8)
+            <:
+            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
+        <:
+        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
       re
       (fun re temp_1_ ->
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement = re in
-          let i, bytes:(usize & t_Array u8 (sz 5)) = temp_1_ in
-          assert (v i < 32);
-          let byte1 = cast (bytes.[ sz 0 ] <: u8) <: i32 in
-          let byte2 = cast (bytes.[ sz 1 ] <: u8) <: i32 in
-          let byte3 = cast (bytes.[ sz 2 ] <: u8) <: i32 in
-          let byte4 = cast (bytes.[ sz 3 ] <: u8) <: i32 in
-          let byte5 = cast (bytes.[ sz 4 ] <: u8) <: i32 in
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
+          let i, bytes:(usize & t_Slice u8) = temp_1_ in
+          let byte1:i32 = cast (bytes.[ sz 0 ] <: u8) <: i32 in
+          let byte2:i32 = cast (bytes.[ sz 1 ] <: u8) <: i32 in
+          let byte3:i32 = cast (bytes.[ sz 2 ] <: u8) <: i32 in
+          let byte4:i32 = cast (bytes.[ sz 3 ] <: u8) <: i32 in
+          let byte5:i32 = cast (bytes.[ sz 4 ] <: u8) <: i32 in
           let
           coefficient1,
           coefficient2,
@@ -1086,25 +997,10 @@
           coefficient5,
           coefficient6,
           coefficient7,
-          coefficient8 =
+          coefficient8:(i32 & i32 & i32 & i32 & i32 & i32 & i32 & i32) =
             decompress_coefficients_5_ byte1 byte2 byte3 byte4 byte5
           in
-          let coefficient1 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient1 in
-          let coefficient2 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient2 in
-          let coefficient3 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient3 in
-          let coefficient4 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient4 in
-          let coefficient5 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient5 in
-          let coefficient6 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient6 in
-          let coefficient7 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient7 in
-          let coefficient8 = Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient8 in
-          // assert (Seq.length serialized == 160);
-          // // assert_norm (160 / 5 == 32);
-          // assert_spinoff (v i < Seq.length serialized);
-          // assert (v i < 32);
-          assert_spinoff (v i < 32 ==> 8 * v i + 8 <= 256);
-          mul_in_range 8 (v i);
-          assert_spinoff (v i < 32 ==> range (v (sz 8) * v i) usize_inttype);
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -1112,12 +1008,14 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 (sz 8 *! i <: usize)
-                coefficient1
+                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient1
+                  <:
+                  i32)
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -1125,12 +1023,14 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 8 *! i <: usize) +! sz 1 <: usize)
-                coefficient2
+                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient2
+                  <:
+                  i32)
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -1138,12 +1038,14 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 8 *! i <: usize) +! sz 2 <: usize)
-                coefficient3
+                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient3
+                  <:
+                  i32)
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -1151,12 +1053,14 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 8 *! i <: usize) +! sz 3 <: usize)
-                coefficient4
+                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient4
+                  <:
+                  i32)
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -1164,12 +1068,14 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 8 *! i <: usize) +! sz 4 <: usize)
-                coefficient5
+                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient5
+                  <:
+                  i32)
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -1177,12 +1083,14 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 8 *! i <: usize) +! sz 5 <: usize)
-                coefficient6
+                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient6
+                  <:
+                  i32)
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -1190,12 +1098,14 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 8 *! i <: usize) +! sz 6 <: usize)
-                coefficient7
+                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient7
+                  <:
+                  i32)
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -1203,27 +1113,33 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 8 *! i <: usize) +! sz 7 <: usize)
-                coefficient8
+                (Libcrux.Kem.Kyber.Compress.decompress_ciphertext_coefficient 5uy coefficient8
+                  <:
+                  i32)
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
           re)
   in
   re
-#pop-options
 
-#push-options "--z3rlimit 60"
 let deserialize_then_decompress_message (serialized: t_Array u8 (sz 32)) =
-  let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
-   Libcrux.Kem.Kyber.Arithmetic.cast_poly_b Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+    Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
   in
-  let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
-    Rust_primitives.Iterators.foldi_slice #_ #_ #(fun _ _ -> True)
-      serialized
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter (Core.Iter.Traits.Iterator.f_enumerate
+              (Core.Iter.Traits.Collect.f_into_iter serialized
+                <:
+                Core.Array.Iter.t_IntoIter u8 (sz 32))
+            <:
+            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Array.Iter.t_IntoIter u8 (sz 32)))
+        <:
+        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Array.Iter.t_IntoIter u8 (sz 32)))
       re
       (fun re temp_1_ ->
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement = re in
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
           let i, byte:(usize & u8) = temp_1_ in
           Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter ({
                     Core.Ops.Range.f_start = sz 0;
@@ -1235,11 +1151,10 @@
               Core.Ops.Range.t_Range usize)
             re
             (fun re j ->
-                let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement = re in
+                let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
                 let j:usize = j in
                 let coefficient_compressed:i32 = cast ((byte >>! j <: u8) &. 1uy <: u8) <: i32 in
-                lemma_get_bit_bounded' coefficient_compressed 1;
-                let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+                let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
                   {
                     re with
                     Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -1253,21 +1168,20 @@
                         i32)
                   }
                   <:
-                  Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+                  Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
                 in
                 re)
           <:
-          Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+          Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
   in
-  admit(); //P-F
   re
-#pop-options
 
-let deserialize_then_decompress_ring_element_u v_COMPRESSION_FACTOR serialized = 
+let deserialize_then_decompress_ring_element_u
+      (v_COMPRESSION_FACTOR: usize)
+      (serialized: t_Slice u8)
+     =
   let _:Prims.unit = () <: Prims.unit in
-  mk_int_equiv_lemma #usize_inttype (v v_COMPRESSION_FACTOR);
-  assert (v (cast (v_COMPRESSION_FACTOR <: usize) <: u32) == 10 \/ v (cast (v_COMPRESSION_FACTOR <: usize) <: u32) == 11);
-  match cast (v_COMPRESSION_FACTOR <: usize) <: u32 with
+  match cast (v_COMPRESSION_FACTOR <: usize) <: pub_u32 with
   | 10ul -> deserialize_then_decompress_10_ serialized
   | 11ul -> deserialize_then_decompress_11_ serialized
   | _ ->
@@ -1276,12 +1190,12 @@
         <:
         Rust_primitives.Hax.t_Never)
 
-let deserialize_then_decompress_ring_element_v v_COMPRESSION_FACTOR serialized =
+let deserialize_then_decompress_ring_element_v
+      (v_COMPRESSION_FACTOR: usize)
+      (serialized: t_Slice u8)
+     =
   let _:Prims.unit = () <: Prims.unit in
-  mk_int_equiv_lemma #u32_inttype (v v_COMPRESSION_FACTOR);
-  assert (v (cast (v_COMPRESSION_FACTOR <: usize) <: u32) == 4 \/ v (cast (v_COMPRESSION_FACTOR <: usize) <: u32) == 5);
-  let res = 
-  match cast (v_COMPRESSION_FACTOR <: usize) <: u32 with
+  match cast (v_COMPRESSION_FACTOR <: usize) <: pub_u32 with
   | 4ul -> deserialize_then_decompress_4_ serialized
   | 5ul -> deserialize_then_decompress_5_ serialized
   | _ ->
@@ -1289,32 +1203,27 @@
 
         <:
         Rust_primitives.Hax.t_Never)
-  in
-  admit(); //P-F
-  res
 
-#push-options "--z3rlimit 220"
-let deserialize_to_uncompressed_ring_element (serialized: t_Slice u8) = 
+let deserialize_to_uncompressed_ring_element (serialized: t_Slice u8) =
   let _:Prims.unit = () <: Prims.unit in
-  let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
-   Libcrux.Kem.Kyber.Arithmetic.cast_poly_b Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+    Libcrux.Kem.Kyber.Arithmetic.impl__PolynomialRingElement__ZERO
   in
-  let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
-    Rust_primitives.Iterators.foldi_chunks_exact #_ #_ #(fun _ _ -> True)
-      serialized
-      (sz 3)
+  let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter (Core.Iter.Traits.Iterator.f_enumerate
+              (Core.Slice.impl__chunks_exact serialized (sz 3) <: Core.Slice.Iter.t_ChunksExact u8)
+            <:
+            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
+        <:
+        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact u8))
       re
       (fun re temp_1_ ->
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement = re in
-          let i, bytes:(usize & t_Array u8 (sz 3)) = temp_1_ in
-          let byte1:int_t_d i32_inttype 8 = cast (bytes.[ sz 0 ] <: u8) <: i32 in
-          let byte2:int_t_d i32_inttype 8 = cast (bytes.[ sz 1 ] <: u8) <: i32 in
-          let byte3:int_t_d i32_inttype 8 = cast (bytes.[ sz 2 ] <: u8) <: i32 in
-          let coef1 = (((byte2 &. 15l <: i32) <<! 8l <: i32) |. (byte1 &. 255l <: i32) <: i32) in
-          let coef2 = ((byte3 <<! 4l <: i32) |. ((byte2 >>! 4l <: i32) &. 15l <: i32) <: i32) in
-          lemma_get_bit_bounded' coef1 11;
-          lemma_get_bit_bounded' coef2 11;
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement = re in
+          let i, bytes:(usize & t_Slice u8) = temp_1_ in
+          let byte1:i32 = cast (bytes.[ sz 0 ] <: u8) <: i32 in
+          let byte2:i32 = cast (bytes.[ sz 1 ] <: u8) <: i32 in
+          let byte3:i32 = cast (bytes.[ sz 2 ] <: u8) <: i32 in
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -1322,12 +1231,12 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 (sz 2 *! i <: usize)
-                coef1
+                (((byte2 &. 15l <: i32) <<! 8l <: i32) |. (byte1 &. 255l <: i32) <: i32)
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
-          let re:Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement =
+          let re:Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement =
             {
               re with
               Libcrux.Kem.Kyber.Arithmetic.f_coefficients
@@ -1335,89 +1244,58 @@
               Rust_primitives.Hax.Monomorphized_update_at.update_at_usize re
                   .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
                 ((sz 2 *! i <: usize) +! sz 1 <: usize)
-                coef2
+                ((byte3 <<! 4l <: i32) |. ((byte2 >>! 4l <: i32) &. 15l <: i32) <: i32)
             }
             <:
-            Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+            Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
           in
           re)
   in
   re
-#pop-options
 
-module A = Libcrux.Kem.Kyber.Arithmetic
-
-[@@"opaque_to_smt"]
-let update3 #n (s: t_Array 't n) (offset: usize {v offset + 3 <= v n}) (i0 i1 i2: 't)
-  : s': t_Array 't n { Seq.index s' (v offset +  0) == i0
-                    /\ Seq.index s' (v offset +  1) == i1
-                    /\ Seq.index s' (v offset +  2) == i2
-                    /\ (forall i. (i < v offset \/ i >= v offset + 3) ==> Seq.index s' i == Seq.index s i) }
- = let open Rust_primitives.Hax.Monomorphized_update_at in
-    let s = update_at_usize s  offset           i0 in
-    let s = update_at_usize s (offset +! sz  1) i1 in
-    update_at_usize s (offset +! sz  2) i2
-
-let slice_map_lemma #t #u #n (f: t -> u) (arr: t_Array t n)
-  (start: nat) (len: nat {start + len <= v n})
-  : Lemma (  Seq.slice (Spec.Kyber.map' f arr) start (start + len)
-          == Spec.Kyber.map' f (Seq.slice arr start (start + len))
-          )
-  = let f_arr = Spec.Kyber.map' f arr in
-    let lhs = Seq.slice f_arr start (start + len) in
-    let rhs = Spec.Kyber.map' f (Seq.slice arr start (start + len)) in
-    introduce forall i. Seq.index lhs i == Seq.index rhs i
-    with (
-      Seq.lemma_index_slice f_arr start (start + len) i;
-      Seq.lemma_index_slice   arr start (start + len) i;
-      let sz_i_start, sz_i = sz (i + start), sz i in
-      assert (Seq.index f_arr (v sz_i_start) == f (Seq.index arr (v (sz_i_start))));
-      assert (Seq.index rhs (v sz_i) == f (Seq.index (Seq.slice arr start (start + len)) (v sz_i)))
-    );
-    assert (Seq.equal lhs rhs)
-
-#push-options "--z3rlimit 2800 --fuel 0 --ifuel 0 --retry 0 --split_queries no"
-let serialize_uncompressed_ring_element re =
-  let serialized: t_Array u8 (sz 384) = Rust_primitives.Hax.repeat 0uy (sz 384) in
-  let max = v (sz 384) * 8 in
-  assert (max == 256 * 12 /\ max == 384 * 8 /\ 128 * 2 * 12 == max);
-  assert (128 == v (length re.f_coefficients /! (sz 2)));
-  let serialized =
-    Rust_primitives.Iterators.foldi_chunks_exact #_ #_ 
-      #(fun serialized i -> 
-        let i = v i in
-        i <= 128 /\ (
-            let limit = i * 2 * 12 in
-            let coefficients: t_Array _ (sz 256) = Spec.Kyber.map' to_unsigned_representative re.f_coefficients in
-            bit_vec_sub (bit_vec_of_int_t_array serialized   8 ) 0 limit
-         == bit_vec_sub (bit_vec_of_int_t_array coefficients 12) 0 limit)
-      )
-      (re.A.f_coefficients <: t_Array _ (sz 256))
-      (sz 2)
+let serialize_uncompressed_ring_element (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement) =
+  let serialized:t_Array u8 (sz 384) = Rust_primitives.Hax.repeat 0uy (sz 384) in
+  let serialized:t_Array u8 (sz 384) =
+    Core.Iter.Traits.Iterator.f_fold (Core.Iter.Traits.Collect.f_into_iter (Core.Iter.Traits.Iterator.f_enumerate
+              (Core.Slice.impl__chunks_exact (Rust_primitives.unsize re
+                        .Libcrux.Kem.Kyber.Arithmetic.f_coefficients
+                    <:
+                    t_Slice i32)
+                  (sz 2)
+                <:
+                Core.Slice.Iter.t_ChunksExact i32)
+            <:
+            Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact i32))
+        <:
+        Core.Iter.Adapters.Enumerate.t_Enumerate (Core.Slice.Iter.t_ChunksExact i32))
       serialized
-      (fun serialized it -> let i, coefficients = it in
-
-    let coefficient1 = A.to_unsigned_representative (coefficients.[ sz 0 ] <: i32) in
-    let coefficient2 = A.to_unsigned_representative (coefficients.[ sz 1 ] <: i32) in
-    let (coef1, coef2, coef3) = compress_coefficients_3_ coefficient1 coefficient2 in
-    let j = sz 3 *! i in
-    let serialized' = update3 serialized j coef1 coef2 coef3 in
-    assert (      Seq.slice serialized' (v j) (v j + 3)
-      `Seq.equal` Seq.slice (create3 (coef1, coef2, coef3)) 0 3);
-    bit_vec_equal_intro 
-        (let coefficients: t_Array _ (sz 2) = Spec.Kyber.map' to_unsigned_representative coefficients in
-         bit_vec_of_int_t_array coefficients 12)
-        (retype (bit_vec_sub (bit_vec_of_int_t_array serialized'   8) (3 * v i * 8) (3 * 8)));
-    let full_coefficients: t_Array u16 (sz 256) = Spec.Kyber.map' to_unsigned_representative re.f_coefficients in
-    slice_map_lemma #_ #u16 to_unsigned_representative re.f_coefficients (v i * 2) 2;
-    bit_vec_equal_intro
-        (bit_vec_sub (bit_vec_of_int_t_array serialized'   8) 0 (v i * 2 * 12))
-        (bit_vec_sub (bit_vec_of_int_t_array serialized   8 ) 0 (v i * 2 * 12));
-    bit_vec_equal_extend (bit_vec_of_int_t_array serialized' 8)
-                         (bit_vec_of_int_t_array full_coefficients 12)
-                         0 0 (v i * 2 * 12) (3 * 8);
-    serialized' <: t_Array u8 (sz 384))
+      (fun serialized temp_1_ ->
+          let serialized:t_Array u8 (sz 384) = serialized in
+          let i, coefficients:(usize & t_Slice i32) = temp_1_ in
+          let coefficient1:u16 =
+            Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 0 ] <: i32)
+          in
+          let coefficient2:u16 =
+            Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative (coefficients.[ sz 1 ] <: i32)
+          in
+          let coef1, coef2, coef3:(u8 & u8 & u8) =
+            compress_coefficients_3_ coefficient1 coefficient2
+          in
+          let serialized:t_Array u8 (sz 384) =
+            Rust_primitives.Hax.Monomorphized_update_at.update_at_usize serialized
+              (sz 3 *! i <: usize)
+              coef1
+          in
+          let serialized:t_Array u8 (sz 384) =
+            Rust_primitives.Hax.Monomorphized_update_at.update_at_usize serialized
+              ((sz 3 *! i <: usize) +! sz 1 <: usize)
+              coef2
+          in
+          let serialized:t_Array u8 (sz 384) =
+            Rust_primitives.Hax.Monomorphized_update_at.update_at_usize serialized
+              ((sz 3 *! i <: usize) +! sz 2 <: usize)
+              coef3
+          in
+          serialized)
   in
   serialized
-#pop-options
-
diff -ruN extraction-edited/Libcrux.Kem.Kyber.Serialize.fsti extraction-secret-independent/Libcrux.Kem.Kyber.Serialize.fsti
--- extraction-edited/Libcrux.Kem.Kyber.Serialize.fsti	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.Serialize.fsti	1970-01-01 01:00:00.000000000 +0100
@@ -2,188 +2,118 @@
 #set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
 open Core
 open FStar.Mul
-open MkSeq
-open BitVecEq
 
 val compress_coefficients_10_ (coefficient1 coefficient2 coefficient3 coefficient4: i32)
-    : Prims.Pure (u8 & u8 & u8 & u8 & u8)
-      (requires True)
-      (ensures fun tuple ->
-         int_t_array_bitwise_eq'
-                (create4 (coefficient1, coefficient2, coefficient3, coefficient4)) 10
-                (create5 tuple) 8
-      )
+    : Prims.Pure (u8 & u8 & u8 & u8 & u8) Prims.l_True (fun _ -> Prims.l_True)
 
 val compress_coefficients_11_
       (coefficient1 coefficient2 coefficient3 coefficient4 coefficient5 coefficient6 coefficient7 coefficient8:
-          int_t_d i32_inttype 11)
+          i32)
     : Prims.Pure (u8 & u8 & u8 & u8 & u8 & u8 & u8 & u8 & u8 & u8 & u8)
-      (requires True)
-      (ensures fun tuple ->
-         int_t_array_bitwise_eq'
-                (create8 (coefficient1, coefficient2, coefficient3, coefficient4, coefficient5, coefficient6, coefficient7, coefficient8)) 11
-                (create11 tuple) 8
-      )
-
-val compress_coefficients_3_ (coefficient1 coefficient2: int_t_d u16_inttype 12)
-    : Prims.Pure (u8 & u8 & u8)
-    (requires True)
-    (ensures fun tuple ->
-       int_t_array_bitwise_eq'
-              (create2 (coefficient1, coefficient2)) 12
-              (create3 tuple) 8
-    )
+      Prims.l_True
+      (fun _ -> Prims.l_True)
+
+val compress_coefficients_3_ (coefficient1 coefficient2: u16)
+    : Prims.Pure (u8 & u8 & u8) Prims.l_True (fun _ -> Prims.l_True)
 
 val compress_coefficients_5_
-      (coefficient2 coefficient1 coefficient4 coefficient3 coefficient5 coefficient7 coefficient6 coefficient8: int_t_d u8_inttype 5)
-    : Prims.Pure (u8 & u8 & u8 & u8 & u8)
-      (requires True)
-      (ensures fun tuple ->
-         int_t_array_bitwise_eq'
-                (create8 (coefficient1, coefficient2, coefficient3, coefficient4, coefficient5, coefficient6, coefficient7, coefficient8)) 5
-                (create5 tuple) 8
-      )
-
-private unfold type i32_d = int_t_d i32_inttype
-val decompress_coefficients_10_ (byte2 byte1 byte3 byte4 byte5: int_t_d i32_inttype 8)
-    : Prims.Pure (i32_d 10 & i32_d 10 & i32_d 10 & i32_d 10)
-      (requires True)
-      (ensures fun (r1, r2, r3, r4) ->
-         int_t_array_bitwise_eq'
-                (create5 (byte1, byte2, byte3, byte4, byte5)) 8
-                (create4 #i32 (r1, r2, r3, r4)) 10
-      )
+      (coefficient2 coefficient1 coefficient4 coefficient3 coefficient5 coefficient7 coefficient6 coefficient8:
+          u8)
+    : Prims.Pure (u8 & u8 & u8 & u8 & u8) Prims.l_True (fun _ -> Prims.l_True)
+
+val decompress_coefficients_10_ (byte2 byte1 byte3 byte4 byte5: i32)
+    : Prims.Pure (i32 & i32 & i32 & i32) Prims.l_True (fun _ -> Prims.l_True)
 
 val decompress_coefficients_11_
-      (byte2 byte1 byte3 byte5 byte4 byte6 byte7 byte9 byte8 byte10 byte11: int_t_d i32_inttype 8)
-    : Prims.Pure (i32_d 11 & i32_d 11 & i32_d 11 & i32_d 11 & i32_d 11 & i32_d 11 & i32_d 11 & i32_d 11)
-      (requires True)
-      (ensures fun (r1, r2, r3, r4, r5, r6, r7, r8) ->
-         int_t_array_bitwise_eq'
-                (create11 #i32 (byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8, byte9, byte10, byte11)) 8
-                (create8 #i32 (r1, r2, r3, r4, r5, r6, r7, r8)) 11
-      )
+      (byte2 byte1 byte3 byte5 byte4 byte6 byte7 byte9 byte8 byte10 byte11: i32)
+    : Prims.Pure (i32 & i32 & i32 & i32 & i32 & i32 & i32 & i32)
+      Prims.l_True
+      (fun _ -> Prims.l_True)
 
 val decompress_coefficients_4_ (byte: u8)
-    : Prims.Pure (i32_d 4 & i32_d 4)
-      (requires True)
-      (ensures fun (r1, r2) ->
-         int_t_array_bitwise_eq'
-                (create1 byte) 8
-                (create2 #i32 (r1, r2)) 4
-      )
-
-val decompress_coefficients_5_ (byte1 byte2 byte3 byte4 byte5: int_t_d i32_inttype 8)
-    : Prims.Pure (i32_d 5 & i32_d 5 & i32_d 5 & i32_d 5 & i32_d 5 & i32_d 5 & i32_d 5 & i32_d 5)
-      (requires True)
-      (ensures fun (r1, r2, r3, r4, r5, r6, r7, r8) ->
-         int_t_array_bitwise_eq'
-                (create5 #i32 (byte1, byte2, byte3, byte4, byte5)) 8
-                (create8 #i32 (r1, r2, r3, r4, r5, r6, r7, r8)) 5
-      )
+    : Prims.Pure (i32 & i32) Prims.l_True (fun _ -> Prims.l_True)
+
+val decompress_coefficients_5_ (byte1 byte2 byte3 byte4 byte5: i32)
+    : Prims.Pure (i32 & i32 & i32 & i32 & i32 & i32 & i32 & i32)
+      Prims.l_True
+      (fun _ -> Prims.l_True)
 
 val compress_then_serialize_10_
-      (v_OUT_LEN: usize {v v_OUT_LEN >= 320})
-      (re: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+      (v_OUT_LEN: usize)
+      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
     : Prims.Pure (t_Array u8 v_OUT_LEN) Prims.l_True (fun _ -> Prims.l_True)
 
 val compress_then_serialize_11_
-      (v_OUT_LEN: usize {v v_OUT_LEN >= 352})
-      (re: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+      (v_OUT_LEN: usize)
+      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
     : Prims.Pure (t_Array u8 v_OUT_LEN) Prims.l_True (fun _ -> Prims.l_True)
 
 val compress_then_serialize_4_
-      (v_OUT_LEN: usize {v v_OUT_LEN >= 128})
-      (re: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+      (v_OUT_LEN: usize)
+      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
     : Prims.Pure (t_Array u8 v_OUT_LEN) Prims.l_True (fun _ -> Prims.l_True)
 
 val compress_then_serialize_5_
-      (v_OUT_LEN: usize {v v_OUT_LEN >= 160})
-      (re: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
+      (v_OUT_LEN: usize)
+      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
     : Prims.Pure (t_Array u8 v_OUT_LEN) Prims.l_True (fun _ -> Prims.l_True)
 
-val compress_then_serialize_message (re: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
-    : Pure (t_Array u8 (sz 32))
-      (requires True)
-      (ensures (fun res ->
-        res == Spec.Kyber.compress_then_encode_message (Libcrux.Kem.Kyber.Arithmetic.to_spec_poly_b re)))
+val compress_then_serialize_message (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+    : Prims.Pure (t_Array u8 (sz 32)) Prims.l_True (fun _ -> Prims.l_True)
 
 val compress_then_serialize_ring_element_u
-      (#p:Spec.Kyber.params)
-      (v_COMPRESSION_FACTOR: usize {v v_COMPRESSION_FACTOR == 10 \/ v v_COMPRESSION_FACTOR == 11})
-      (v_OUT_LEN: usize { v v_OUT_LEN = 32 * v v_COMPRESSION_FACTOR })
-      (re: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
-    : t_Array u8 v_OUT_LEN
-      
-val compress_then_serialize_ring_element_v (#p:Spec.Kyber.params)
-      (v_COMPRESSION_FACTOR: usize {v_COMPRESSION_FACTOR = sz 4 || v_COMPRESSION_FACTOR = sz 5})
-      (v_OUT_LEN: usize {v v_OUT_LEN = 32 * v v_COMPRESSION_FACTOR})
-      (re: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
-    : Pure (t_Array u8 v_OUT_LEN)
-      (requires True)
-      (ensures (fun res -> 
-        res == 
-        Spec.Kyber.compress_then_encode_v p 
-          (Libcrux.Kem.Kyber.Arithmetic.to_spec_poly_b re)))
+      (v_COMPRESSION_FACTOR v_OUT_LEN: usize)
+      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+    : Prims.Pure (t_Array u8 v_OUT_LEN) Prims.l_True (fun _ -> Prims.l_True)
+
+val compress_then_serialize_ring_element_v
+      (v_COMPRESSION_FACTOR v_OUT_LEN: usize)
+      (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+    : Prims.Pure (t_Array u8 v_OUT_LEN) Prims.l_True (fun _ -> Prims.l_True)
 
-val deserialize_then_decompress_10_ (serialized: t_Slice u8 {Seq.length serialized == 320})
-    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+val deserialize_then_decompress_10_ (serialized: t_Slice u8)
+    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
       Prims.l_True
       (fun _ -> Prims.l_True)
 
-val deserialize_then_decompress_11_ (serialized: t_Slice u8 {Seq.length serialized == 352})
-    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+val deserialize_then_decompress_11_ (serialized: t_Slice u8)
+    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
       Prims.l_True
       (fun _ -> Prims.l_True)
 
-val deserialize_then_decompress_4_ (serialized: t_Slice u8 {Seq.length serialized == 128})
-    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+val deserialize_then_decompress_4_ (serialized: t_Slice u8)
+    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
       Prims.l_True
       (fun _ -> Prims.l_True)
 
-val deserialize_then_decompress_5_ 
-  (serialized: t_Slice u8 {Seq.length serialized == 160})
-    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement
+val deserialize_then_decompress_5_ (serialized: t_Slice u8)
+    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
       Prims.l_True
       (fun _ -> Prims.l_True)
 
 val deserialize_then_decompress_message (serialized: t_Array u8 (sz 32))
-    : Pure (Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
-      (requires True)
-      (ensures fun res ->
-        Libcrux.Kem.Kyber.Arithmetic.to_spec_poly_b res == 
-        Spec.Kyber.decode_then_decompress_message serialized)
+    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+      Prims.l_True
+      (fun _ -> Prims.l_True)
 
 val deserialize_then_decompress_ring_element_u
       (v_COMPRESSION_FACTOR: usize)
-      (serialized: t_Slice u8 {
-        match v v_COMPRESSION_FACTOR with
-        | 10 -> Seq.length serialized == 320
-        | 11 -> Seq.length serialized == 352
-        | _ -> False
-      })
-    : Pure (Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
-      (requires v_COMPRESSION_FACTOR = sz 10 || v_COMPRESSION_FACTOR = sz 11)
-      (ensures fun _ -> True)
+      (serialized: t_Slice u8)
+    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+      Prims.l_True
+      (fun _ -> Prims.l_True)
 
-val deserialize_then_decompress_ring_element_v (#p:Spec.Kyber.params)
-      (v_COMPRESSION_FACTOR: usize {v v_COMPRESSION_FACTOR == 4 \/ v v_COMPRESSION_FACTOR == 5})
+val deserialize_then_decompress_ring_element_v
+      (v_COMPRESSION_FACTOR: usize)
       (serialized: t_Slice u8)
-    : Pure (Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
-      (requires (p.v_VECTOR_V_COMPRESSION_FACTOR == v_COMPRESSION_FACTOR /\
-                 length serialized == Spec.Kyber.v_C2_SIZE p))
-      (ensures fun res -> Libcrux.Kem.Kyber.Arithmetic.to_spec_poly_b res
-                    == Spec.Kyber.decode_then_decompress_v p serialized)
+    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+      Prims.l_True
+      (fun _ -> Prims.l_True)
 
 val deserialize_to_uncompressed_ring_element (serialized: t_Slice u8)
-    : Pure (Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
-      (requires (length serialized == Spec.Kyber.v_BYTES_PER_RING_ELEMENT))
-      (ensures fun _ -> True)
-
-val serialize_uncompressed_ring_element (re: Libcrux.Kem.Kyber.Arithmetic.wfPolynomialRingElement)
-    : Pure (t_Array u8 (sz 384))
-      (requires True)
-      (ensures (fun res ->
-        let coefficients: t_Array _ (sz 256) = Spec.Kyber.map' Libcrux.Kem.Kyber.Arithmetic.to_unsigned_representative re.f_coefficients in
-        int_t_array_bitwise_eq res 8 coefficients 12
-      ))
+    : Prims.Pure Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement
+      Prims.l_True
+      (fun _ -> Prims.l_True)
+
+val serialize_uncompressed_ring_element (re: Libcrux.Kem.Kyber.Arithmetic.t_PolynomialRingElement)
+    : Prims.Pure (t_Array u8 (sz 384)) Prims.l_True (fun _ -> Prims.l_True)
diff -ruN extraction-edited/Libcrux.Kem.Kyber.Types.fst extraction-secret-independent/Libcrux.Kem.Kyber.Types.fst
--- extraction-edited/Libcrux.Kem.Kyber.Types.fst	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux.Kem.Kyber.Types.fst	1970-01-01 01:00:00.000000000 +0100
@@ -3,275 +3,193 @@
 open Core
 open FStar.Mul
 
-type t_MlKemCiphertext (v_SIZE: usize) = { f_value:t_Array u8 v_SIZE }
+type t_KyberCiphertext (v_SIZE: usize) = { f_value:t_Array u8 v_SIZE }
 
 [@@ FStar.Tactics.Typeclasses.tcinstance]
-let impl_1 (v_SIZE: usize) : Core.Convert.t_AsRef (t_MlKemCiphertext v_SIZE) (t_Slice u8) =
-  {
-    f_as_ref_pre = (fun (self: t_MlKemCiphertext v_SIZE) -> true);
-    f_as_ref_post = (fun (self: t_MlKemCiphertext v_SIZE) (out: t_Slice u8) -> true);
-    f_as_ref = fun (self: t_MlKemCiphertext v_SIZE) -> Rust_primitives.unsize self.f_value
-  }
+let impl_1 (v_SIZE: usize) : Core.Convert.t_AsRef (t_KyberCiphertext v_SIZE) (t_Slice u8) =
+  { f_as_ref = fun (self: t_KyberCiphertext v_SIZE) -> Rust_primitives.unsize self.f_value }
 
 [@@ FStar.Tactics.Typeclasses.tcinstance]
-let impl_2 (v_SIZE: usize) : Core.Convert.t_From (t_MlKemCiphertext v_SIZE) (t_Array u8 v_SIZE) =
-  {
-    f_from_pre = (fun (value: t_Array u8 v_SIZE) -> true);
-    f_from_post = (fun (value: t_Array u8 v_SIZE) (out: t_MlKemCiphertext v_SIZE) -> true);
-    f_from = fun (value: t_Array u8 v_SIZE) -> { f_value = value } <: t_MlKemCiphertext v_SIZE
-  }
+let impl_2 (v_SIZE: usize) : Core.Convert.t_From (t_KyberCiphertext v_SIZE) (t_Array u8 v_SIZE) =
+  { f_from = fun (value: t_Array u8 v_SIZE) -> { f_value = value } <: t_KyberCiphertext v_SIZE }
 
 [@@ FStar.Tactics.Typeclasses.tcinstance]
-let impl_3 (v_SIZE: usize) : Core.Convert.t_From (t_MlKemCiphertext v_SIZE) (t_Array u8 v_SIZE) =
+let impl_3 (v_SIZE: usize) : Core.Convert.t_From (t_KyberCiphertext v_SIZE) (t_Array u8 v_SIZE) =
   {
-    f_from_pre = (fun (value: t_Array u8 v_SIZE) -> true);
-    f_from_post = (fun (value: t_Array u8 v_SIZE) (out: t_MlKemCiphertext v_SIZE) -> true);
     f_from
     =
     fun (value: t_Array u8 v_SIZE) ->
-      { f_value = Core.Clone.f_clone value } <: t_MlKemCiphertext v_SIZE
+      { f_value = Core.Clone.f_clone value } <: t_KyberCiphertext v_SIZE
   }
 
 [@@ FStar.Tactics.Typeclasses.tcinstance]
-let impl_4 (v_SIZE: usize) : Core.Convert.t_From (t_Array u8 v_SIZE) (t_MlKemCiphertext v_SIZE) =
-  {
-    f_from_pre = (fun (value: t_MlKemCiphertext v_SIZE) -> true);
-    f_from_post = (fun (value: t_MlKemCiphertext v_SIZE) (out: t_Array u8 v_SIZE) -> true);
-    f_from = fun (value: t_MlKemCiphertext v_SIZE) -> value.f_value
-  }
+let impl_4 (v_SIZE: usize) : Core.Convert.t_From (t_Array u8 v_SIZE) (t_KyberCiphertext v_SIZE) =
+  { f_from = fun (value: t_KyberCiphertext v_SIZE) -> value.f_value }
 
 [@@ FStar.Tactics.Typeclasses.tcinstance]
-let impl_5 (v_SIZE: usize) : Core.Convert.t_TryFrom (t_MlKemCiphertext v_SIZE) (t_Slice u8) =
+let impl_5 (v_SIZE: usize) : Core.Convert.t_TryFrom (t_KyberCiphertext v_SIZE) (t_Slice u8) =
   {
     f_Error = Core.Array.t_TryFromSliceError;
-    f_try_from_pre = (fun (value: t_Slice u8) -> true);
-    f_try_from_post
-    =
-    (fun
-        (value: t_Slice u8)
-        (out: Core.Result.t_Result (t_MlKemCiphertext v_SIZE) Core.Array.t_TryFromSliceError)
-        ->
-        true);
     f_try_from
     =
     fun (value: t_Slice u8) ->
       match Core.Convert.f_try_into value with
       | Core.Result.Result_Ok value ->
-        Core.Result.Result_Ok ({ f_value = value } <: t_MlKemCiphertext v_SIZE)
+        Core.Result.Result_Ok ({ f_value = value } <: t_KyberCiphertext v_SIZE)
         <:
-        Core.Result.t_Result (t_MlKemCiphertext v_SIZE) Core.Array.t_TryFromSliceError
+        Core.Result.t_Result (t_KyberCiphertext v_SIZE) Core.Array.t_TryFromSliceError
       | Core.Result.Result_Err e ->
         Core.Result.Result_Err e
         <:
-        Core.Result.t_Result (t_MlKemCiphertext v_SIZE) Core.Array.t_TryFromSliceError
+        Core.Result.t_Result (t_KyberCiphertext v_SIZE) Core.Array.t_TryFromSliceError
   }
 
-let impl_6__as_slice (v_SIZE: usize) (self: t_MlKemCiphertext v_SIZE) : t_Array u8 v_SIZE =
+let impl_6__as_slice (v_SIZE: usize) (self: t_KyberCiphertext v_SIZE) : t_Array u8 v_SIZE =
   self.f_value
 
-let impl_6__len (v_SIZE: usize) (self: t_MlKemCiphertext v_SIZE) : usize = v_SIZE
+let impl_6__len (v_SIZE: usize) (self: t_KyberCiphertext v_SIZE) : usize = v_SIZE
 
-let impl_6__split_at (v_SIZE: usize) (self: t_MlKemCiphertext v_SIZE) (mid: usize)
-    : Pure (t_Slice u8 & t_Slice u8)
-      (requires (mid <=. v_SIZE))
-      (ensures (fun (x,y) -> Seq.length x == v mid /\ Seq.length y == v (v_SIZE -! mid))) =
+let impl_6__split_at (v_SIZE: usize) (self: t_KyberCiphertext v_SIZE) (mid: usize)
+    : (t_Slice u8 & t_Slice u8) =
   Core.Slice.impl__split_at (Rust_primitives.unsize self.f_value <: t_Slice u8) mid
 
-type t_MlKemPrivateKey (v_SIZE: usize) = { f_value:t_Array u8 v_SIZE }
+type t_KyberPrivateKey (v_SIZE: usize) = { f_value:t_Array u8 v_SIZE }
 
 [@@ FStar.Tactics.Typeclasses.tcinstance]
-let impl_7 (v_SIZE: usize) : Core.Convert.t_AsRef (t_MlKemPrivateKey v_SIZE) (t_Slice u8) =
-  {
-    f_as_ref_pre = (fun (self: t_MlKemPrivateKey v_SIZE) -> true);
-    f_as_ref_post = (fun (self: t_MlKemPrivateKey v_SIZE) (out: t_Slice u8) -> true);
-    f_as_ref = fun (self: t_MlKemPrivateKey v_SIZE) -> Rust_primitives.unsize self.f_value
-  }
+let impl_7 (v_SIZE: usize) : Core.Convert.t_AsRef (t_KyberPrivateKey v_SIZE) (t_Slice u8) =
+  { f_as_ref = fun (self: t_KyberPrivateKey v_SIZE) -> Rust_primitives.unsize self.f_value }
 
 [@@ FStar.Tactics.Typeclasses.tcinstance]
-let impl_8 (v_SIZE: usize) : Core.Convert.t_From (t_MlKemPrivateKey v_SIZE) (t_Array u8 v_SIZE) =
-  {
-    f_from_pre = (fun (value: t_Array u8 v_SIZE) -> true);
-    f_from_post = (fun (value: t_Array u8 v_SIZE) (out: t_MlKemPrivateKey v_SIZE) -> true);
-    f_from = fun (value: t_Array u8 v_SIZE) -> { f_value = value } <: t_MlKemPrivateKey v_SIZE
-  }
+let impl_8 (v_SIZE: usize) : Core.Convert.t_From (t_KyberPrivateKey v_SIZE) (t_Array u8 v_SIZE) =
+  { f_from = fun (value: t_Array u8 v_SIZE) -> { f_value = value } <: t_KyberPrivateKey v_SIZE }
 
 [@@ FStar.Tactics.Typeclasses.tcinstance]
-let impl_9 (v_SIZE: usize) : Core.Convert.t_From (t_MlKemPrivateKey v_SIZE) (t_Array u8 v_SIZE) =
+let impl_9 (v_SIZE: usize) : Core.Convert.t_From (t_KyberPrivateKey v_SIZE) (t_Array u8 v_SIZE) =
   {
-    f_from_pre = (fun (value: t_Array u8 v_SIZE) -> true);
-    f_from_post = (fun (value: t_Array u8 v_SIZE) (out: t_MlKemPrivateKey v_SIZE) -> true);
     f_from
     =
     fun (value: t_Array u8 v_SIZE) ->
-      { f_value = Core.Clone.f_clone value } <: t_MlKemPrivateKey v_SIZE
+      { f_value = Core.Clone.f_clone value } <: t_KyberPrivateKey v_SIZE
   }
 
 [@@ FStar.Tactics.Typeclasses.tcinstance]
-let impl_10 (v_SIZE: usize) : Core.Convert.t_From (t_Array u8 v_SIZE) (t_MlKemPrivateKey v_SIZE) =
-  {
-    f_from_pre = (fun (value: t_MlKemPrivateKey v_SIZE) -> true);
-    f_from_post = (fun (value: t_MlKemPrivateKey v_SIZE) (out: t_Array u8 v_SIZE) -> true);
-    f_from = fun (value: t_MlKemPrivateKey v_SIZE) -> value.f_value
-  }
+let impl_10 (v_SIZE: usize) : Core.Convert.t_From (t_Array u8 v_SIZE) (t_KyberPrivateKey v_SIZE) =
+  { f_from = fun (value: t_KyberPrivateKey v_SIZE) -> value.f_value }
 
 [@@ FStar.Tactics.Typeclasses.tcinstance]
-let impl_11 (v_SIZE: usize) : Core.Convert.t_TryFrom (t_MlKemPrivateKey v_SIZE) (t_Slice u8) =
+let impl_11 (v_SIZE: usize) : Core.Convert.t_TryFrom (t_KyberPrivateKey v_SIZE) (t_Slice u8) =
   {
     f_Error = Core.Array.t_TryFromSliceError;
-    f_try_from_pre = (fun (value: t_Slice u8) -> true);
-    f_try_from_post
-    =
-    (fun
-        (value: t_Slice u8)
-        (out: Core.Result.t_Result (t_MlKemPrivateKey v_SIZE) Core.Array.t_TryFromSliceError)
-        ->
-        true);
     f_try_from
     =
     fun (value: t_Slice u8) ->
       match Core.Convert.f_try_into value with
       | Core.Result.Result_Ok value ->
-        Core.Result.Result_Ok ({ f_value = value } <: t_MlKemPrivateKey v_SIZE)
+        Core.Result.Result_Ok ({ f_value = value } <: t_KyberPrivateKey v_SIZE)
         <:
-        Core.Result.t_Result (t_MlKemPrivateKey v_SIZE) Core.Array.t_TryFromSliceError
+        Core.Result.t_Result (t_KyberPrivateKey v_SIZE) Core.Array.t_TryFromSliceError
       | Core.Result.Result_Err e ->
         Core.Result.Result_Err e
         <:
-        Core.Result.t_Result (t_MlKemPrivateKey v_SIZE) Core.Array.t_TryFromSliceError
+        Core.Result.t_Result (t_KyberPrivateKey v_SIZE) Core.Array.t_TryFromSliceError
   }
 
-let impl_12__as_slice (v_SIZE: usize) (self: t_MlKemPrivateKey v_SIZE) : t_Array u8 v_SIZE =
+let impl_12__as_slice (v_SIZE: usize) (self: t_KyberPrivateKey v_SIZE) : t_Array u8 v_SIZE =
   self.f_value
 
-let impl_12__len (v_SIZE: usize) (self: t_MlKemPrivateKey v_SIZE) : usize = v_SIZE
+let impl_12__len (v_SIZE: usize) (self: t_KyberPrivateKey v_SIZE) : usize = v_SIZE
 
-let impl_12__split_at (v_SIZE: usize) (self: t_MlKemPrivateKey v_SIZE) (mid: usize)
-    : Pure (t_Slice u8 & t_Slice u8)
-      (requires (mid <=. v_SIZE))
-      (ensures (fun (x,y) -> Seq.length x == v mid /\ Seq.length y == v (v_SIZE -! mid))) =
+let impl_12__split_at (v_SIZE: usize) (self: t_KyberPrivateKey v_SIZE) (mid: usize)
+    : (t_Slice u8 & t_Slice u8) =
   Core.Slice.impl__split_at (Rust_primitives.unsize self.f_value <: t_Slice u8) mid
 
-
-
-
-
-
-
-
-
-
-
-type t_MlKemPublicKey (v_SIZE: usize) = { f_value:t_Array u8 v_SIZE }
+type t_KyberPublicKey (v_SIZE: usize) = { f_value:t_Array u8 v_SIZE }
 
 [@@ FStar.Tactics.Typeclasses.tcinstance]
-let impl_13 (v_SIZE: usize) : Core.Convert.t_AsRef (t_MlKemPublicKey v_SIZE) (t_Slice u8) =
-  {
-    f_as_ref_pre = (fun (self: t_MlKemPublicKey v_SIZE) -> true);
-    f_as_ref_post = (fun (self: t_MlKemPublicKey v_SIZE) (out: t_Slice u8) -> true);
-    f_as_ref = fun (self: t_MlKemPublicKey v_SIZE) -> Rust_primitives.unsize self.f_value
-  }
+let impl_13 (v_SIZE: usize) : Core.Convert.t_AsRef (t_KyberPublicKey v_SIZE) (t_Slice u8) =
+  { f_as_ref = fun (self: t_KyberPublicKey v_SIZE) -> Rust_primitives.unsize self.f_value }
 
 [@@ FStar.Tactics.Typeclasses.tcinstance]
-let impl_14 (v_SIZE: usize) : Core.Convert.t_From (t_MlKemPublicKey v_SIZE) (t_Array u8 v_SIZE) =
-  {
-    f_from_pre = (fun (value: t_Array u8 v_SIZE) -> true);
-    f_from_post = (fun (value: t_Array u8 v_SIZE) (out: t_MlKemPublicKey v_SIZE) -> true);
-    f_from = fun (value: t_Array u8 v_SIZE) -> { f_value = value } <: t_MlKemPublicKey v_SIZE
-  }
+let impl_14 (v_SIZE: usize) : Core.Convert.t_From (t_KyberPublicKey v_SIZE) (t_Array u8 v_SIZE) =
+  { f_from = fun (value: t_Array u8 v_SIZE) -> { f_value = value } <: t_KyberPublicKey v_SIZE }
 
 [@@ FStar.Tactics.Typeclasses.tcinstance]
-let impl_15 (v_SIZE: usize) : Core.Convert.t_From (t_MlKemPublicKey v_SIZE) (t_Array u8 v_SIZE) =
+let impl_15 (v_SIZE: usize) : Core.Convert.t_From (t_KyberPublicKey v_SIZE) (t_Array u8 v_SIZE) =
   {
-    f_from_pre = (fun (value: t_Array u8 v_SIZE) -> true);
-    f_from_post = (fun (value: t_Array u8 v_SIZE) (out: t_MlKemPublicKey v_SIZE) -> true);
     f_from
     =
     fun (value: t_Array u8 v_SIZE) ->
-      { f_value = Core.Clone.f_clone value } <: t_MlKemPublicKey v_SIZE
+      { f_value = Core.Clone.f_clone value } <: t_KyberPublicKey v_SIZE
   }
 
 [@@ FStar.Tactics.Typeclasses.tcinstance]
-let impl_16 (v_SIZE: usize) : Core.Convert.t_From (t_Array u8 v_SIZE) (t_MlKemPublicKey v_SIZE) =
-  {
-    f_from_pre = (fun (value: t_MlKemPublicKey v_SIZE) -> true);
-    f_from_post = (fun (value: t_MlKemPublicKey v_SIZE) (out: t_Array u8 v_SIZE) -> true);
-    f_from = fun (value: t_MlKemPublicKey v_SIZE) -> value.f_value
-  }
+let impl_16 (v_SIZE: usize) : Core.Convert.t_From (t_Array u8 v_SIZE) (t_KyberPublicKey v_SIZE) =
+  { f_from = fun (value: t_KyberPublicKey v_SIZE) -> value.f_value }
 
 [@@ FStar.Tactics.Typeclasses.tcinstance]
-let impl_17 (v_SIZE: usize) : Core.Convert.t_TryFrom (t_MlKemPublicKey v_SIZE) (t_Slice u8) =
+let impl_17 (v_SIZE: usize) : Core.Convert.t_TryFrom (t_KyberPublicKey v_SIZE) (t_Slice u8) =
   {
     f_Error = Core.Array.t_TryFromSliceError;
-    f_try_from_pre = (fun (value: t_Slice u8) -> true);
-    f_try_from_post
-    =
-    (fun
-        (value: t_Slice u8)
-        (out: Core.Result.t_Result (t_MlKemPublicKey v_SIZE) Core.Array.t_TryFromSliceError)
-        ->
-        true);
     f_try_from
     =
     fun (value: t_Slice u8) ->
       match Core.Convert.f_try_into value with
       | Core.Result.Result_Ok value ->
-        Core.Result.Result_Ok ({ f_value = value } <: t_MlKemPublicKey v_SIZE)
+        Core.Result.Result_Ok ({ f_value = value } <: t_KyberPublicKey v_SIZE)
         <:
-        Core.Result.t_Result (t_MlKemPublicKey v_SIZE) Core.Array.t_TryFromSliceError
+        Core.Result.t_Result (t_KyberPublicKey v_SIZE) Core.Array.t_TryFromSliceError
       | Core.Result.Result_Err e ->
         Core.Result.Result_Err e
         <:
-        Core.Result.t_Result (t_MlKemPublicKey v_SIZE) Core.Array.t_TryFromSliceError
+        Core.Result.t_Result (t_KyberPublicKey v_SIZE) Core.Array.t_TryFromSliceError
   }
 
-let impl_18__as_slice (v_SIZE: usize) (self: t_MlKemPublicKey v_SIZE) : t_Array u8 v_SIZE =
+let impl_18__as_slice (v_SIZE: usize) (self: t_KyberPublicKey v_SIZE) : t_Array u8 v_SIZE =
   self.f_value
 
-let impl_18__len (v_SIZE: usize) (self: t_MlKemPublicKey v_SIZE) : usize = v_SIZE
+let impl_18__len (v_SIZE: usize) (self: t_KyberPublicKey v_SIZE) : usize = v_SIZE
 
-let impl_18__split_at (v_SIZE: usize) (self: t_MlKemPublicKey v_SIZE) (mid: usize)
-    : Pure (t_Slice u8 & t_Slice u8)
-      (requires (mid <=. v_SIZE))
-      (ensures (fun (x,y) -> Seq.length x == v mid /\ Seq.length y == v (v_SIZE -! mid))) =
+let impl_18__split_at (v_SIZE: usize) (self: t_KyberPublicKey v_SIZE) (mid: usize)
+    : (t_Slice u8 & t_Slice u8) =
   Core.Slice.impl__split_at (Rust_primitives.unsize self.f_value <: t_Slice u8) mid
 
-type t_MlKemKeyPair (v_PRIVATE_KEY_SIZE: usize) (v_PUBLIC_KEY_SIZE: usize) = {
-  f_sk:t_MlKemPrivateKey v_PRIVATE_KEY_SIZE;
-  f_pk:t_MlKemPublicKey v_PUBLIC_KEY_SIZE
+type t_KyberKeyPair (v_PRIVATE_KEY_SIZE: usize) (v_PUBLIC_KEY_SIZE: usize) = {
+  f_sk:t_KyberPrivateKey v_PRIVATE_KEY_SIZE;
+  f_pk:t_KyberPublicKey v_PUBLIC_KEY_SIZE
 }
 
 let impl__from
       (v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE: usize)
-      (sk: t_MlKemPrivateKey v_PRIVATE_KEY_SIZE)
-      (pk: t_MlKemPublicKey v_PUBLIC_KEY_SIZE)
-    : t_MlKemKeyPair v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE =
-  { f_sk = sk; f_pk = pk } <: t_MlKemKeyPair v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE
+      (sk: t_KyberPrivateKey v_PRIVATE_KEY_SIZE)
+      (pk: t_KyberPublicKey v_PUBLIC_KEY_SIZE)
+    : t_KyberKeyPair v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE =
+  { f_sk = sk; f_pk = pk } <: t_KyberKeyPair v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE
 
 let impl__new
       (v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE: usize)
       (sk: t_Array u8 v_PRIVATE_KEY_SIZE)
       (pk: t_Array u8 v_PUBLIC_KEY_SIZE)
-    : t_MlKemKeyPair v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE =
+    : t_KyberKeyPair v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE =
   { f_sk = Core.Convert.f_into sk; f_pk = Core.Convert.f_into pk }
   <:
-  t_MlKemKeyPair v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE
+  t_KyberKeyPair v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE
 
 let impl__pk
       (v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE: usize)
-      (self: t_MlKemKeyPair v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE)
+      (self: t_KyberKeyPair v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE)
     : t_Array u8 v_PUBLIC_KEY_SIZE = impl_18__as_slice v_PUBLIC_KEY_SIZE self.f_pk
 
 let impl__private_key
       (v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE: usize)
-      (self: t_MlKemKeyPair v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE)
-    : t_MlKemPrivateKey v_PRIVATE_KEY_SIZE = self.f_sk
+      (self: t_KyberKeyPair v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE)
+    : t_KyberPrivateKey v_PRIVATE_KEY_SIZE = self.f_sk
 
 let impl__public_key
       (v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE: usize)
-      (self: t_MlKemKeyPair v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE)
-    : t_MlKemPublicKey v_PUBLIC_KEY_SIZE = self.f_pk
+      (self: t_KyberKeyPair v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE)
+    : t_KyberPublicKey v_PUBLIC_KEY_SIZE = self.f_pk
 
 let impl__sk
       (v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE: usize)
-      (self: t_MlKemKeyPair v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE)
+      (self: t_KyberKeyPair v_PRIVATE_KEY_SIZE v_PUBLIC_KEY_SIZE)
     : t_Array u8 v_PRIVATE_KEY_SIZE = impl_12__as_slice v_PRIVATE_KEY_SIZE self.f_sk
diff -ruN extraction-edited/Libcrux_platform.fsti extraction-secret-independent/Libcrux_platform.fsti
--- extraction-edited/Libcrux_platform.fsti	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux_platform.fsti	1970-01-01 01:00:00.000000000 +0100
@@ -0,0 +1,4 @@
+module Libcrux_platform
+#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
+
+val simd256_support : unit -> bool
diff -ruN extraction-edited/Libcrux_platform.Platform.fsti extraction-secret-independent/Libcrux_platform.Platform.fsti
--- extraction-edited/Libcrux_platform.Platform.fsti	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Libcrux_platform.Platform.fsti	1970-01-01 01:00:00.000000000 +0100
@@ -1,20 +0,0 @@
-module Libcrux_platform.Platform
-#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
-open Core
-open FStar.Mul
-
-val bmi2_adx_support: Prims.unit -> Prims.Pure bool Prims.l_True (fun _ -> Prims.l_True)
-
-val simd256_support: Prims.unit -> Prims.Pure bool Prims.l_True (fun _ -> Prims.l_True)
-
-val x25519_support: Prims.unit -> Prims.Pure bool Prims.l_True (fun _ -> Prims.l_True)
-
-val adv_simd_support: Prims.unit -> Prims.Pure bool Prims.l_True (fun _ -> Prims.l_True)
-
-val aes_ni_support: Prims.unit -> Prims.Pure bool Prims.l_True (fun _ -> Prims.l_True)
-
-val pmull_support: Prims.unit -> Prims.Pure bool Prims.l_True (fun _ -> Prims.l_True)
-
-val sha256_support: Prims.unit -> Prims.Pure bool Prims.l_True (fun _ -> Prims.l_True)
-
-val simd128_support: Prims.unit -> Prims.Pure bool Prims.l_True (fun _ -> Prims.l_True)
diff -ruN extraction-edited/MkSeq.fst extraction-secret-independent/MkSeq.fst
--- extraction-edited/MkSeq.fst	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/MkSeq.fst	1970-01-01 01:00:00.000000000 +0100
@@ -1,91 +0,0 @@
-module MkSeq
-open Core
-
-open FStar.Tactics.V2
-
-private let init (len: nat) (f: (i:nat{i < len}) -> Tac 'a): Tac (list 'a)
-  = let rec h (i: nat {i <= len}): Tac (list 'a)
-     = if i = len then [] else f i :: h (i + 1)
-    in h 0
-
-private let tuple_proj (n: nat) (i: nat): Tac term
-  = if n = 1 then `(id) else
-    let name = "__proj__Mktuple" ^ string_of_int n ^ "__item___" ^ string_of_int (i + 1) in
-    Tv_FVar (pack_fv ["FStar";"Pervasives";"Native";name])
-
-private let tuple_type (n: nat): Tac term
-  = if n = 1 then `(id) else
-    let name = "tuple" ^ string_of_int n in
-    Tv_FVar (pack_fv ["FStar";"Pervasives";"Native";name])
-
-open Rust_primitives.Integers
-open Libcrux.Kem.Kyber.Arithmetic
-
-// let create4 (x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10: 'a)
-//   : Pure 
-//     (t_Array 'a (sz 11))
-//     (requires True)
-//     (ensures fun (r: t_Array 'a (sz 11)) -> 
-//       r.[sz 0] == x0 /\
-//       r.[sz 1] == x1 /\
-//       r.[sz 2] == x2 /\
-//       r.[sz 3] == x3 /\
-//       r.[sz 4] == x4 /\
-//       r.[sz 5] == x5 /\
-//       r.[sz 6] == x6 /\
-//       r.[sz 7] == x7 /\
-//       True
-//       )
-//   = Libcrux.Kem.Kyber.Arithmetic.createi
-//     (sz 11) 
-//     (fun x -> match v x with
-//       | 0 -> x0
-//       | 1 -> x1
-//       | 2 -> x2
-//       | 3 -> x3
-//       | 4 -> x4
-//       | 5 -> x5
-//       | 6 -> x6
-//       | 7 -> x7
-//       | 8 -> x8
-//       | 9 -> x9
-//       | 10 -> x10
-//       )
-
-private let create_gen_tac (n: nat): Tac sigelt
-  = let typ_bd = {fresh_binder_named "t" (`Type0) with qual = FStar.Reflection.V2.Q_Implicit} in
-    let typ = binder_to_term typ_bd in
-    let input_typ = mk_e_app (tuple_type n) (init n (fun _ -> typ)) in
-    let input_bd = fresh_binder_named "tup" input_typ in
-    let output_type = `t_Array (`#typ) (sz (`@n)) in
-    let nth i = `((`#(tuple_proj n i)) (`#input_bd)) in
-    let mk_and: term -> term -> Tac term = fun t u -> `(`#t /\ `#u) in
-    let post =
-      let mk_inv s i = `(Seq.index (`#s) (`@i) == (`#(tuple_proj n i)) (`#input_bd)) in
-      let invs s = Tactics.fold_left mk_and (`(Seq.length (`#s) == (`@n))) (init n (mk_inv s)) in
-      let bd = fresh_binder_named "s" output_type in
-      mk_abs [bd] (invs bd)
-    in
-    let comp = C_Eff [] ["Prims"; "Pure"]
-      (`t_Array (`#typ) (sz (`@n)))
-      [ (`(requires True), Q_Explicit); (post, Q_Explicit)] []
-    in
-    let args = [typ_bd; input_bd] in
-    let l = Tactics.fold_right (fun hd tl -> `((`#hd)::(`#tl))) (init n nth) (`[]) in
-    let indexes =
-      let f i = `((`#(nth i)) == List.Tot.index (`#l) (`@i)) in
-      Tactics.fold_left mk_and (`True) (init n f)
-    in
-    let lb_def = mk_abs args (`(
-      let l = `#l in
-      let s = Seq.createL l <: t_Array (`#typ) (sz (`@n)) in
-      FStar.Classical.forall_intro (Seq.lemma_index_is_nth s);
-      assert (`#indexes) by (Tactics.norm [primops; iota; delta; zeta]);
-      s
-    )) in
-    let lb_typ = mk_arr args (pack_comp comp) in
-    let open FStar.List.Tot in
-    let lb_fv = pack_fv (cur_module () @ ["create" ^ string_of_int n]) in
-    Sg_Let { isrec = false; lbs = [{ lb_fv; lb_us = []; lb_typ; lb_def }] }
-
-%splice[] (init 13 (fun i -> create_gen_tac (i + 1)))
diff -ruN extraction-edited/Spec.Kyber.fst extraction-secret-independent/Spec.Kyber.fst
--- extraction-edited/Spec.Kyber.fst	1970-01-01 01:00:00.000000000 +0100
+++ extraction-secret-independent/Spec.Kyber.fst	1970-01-01 01:00:00.000000000 +0100
@@ -1,435 +0,0 @@
-module Spec.Kyber
-#set-options "--fuel 0 --ifuel 1 --z3rlimit 100"
-open Core
-open FStar.Mul
-
-(** Utils *)
-let map' #a #b
-  (f:(x:a -> b))
-  (s: t_Slice a): t_Slice b
-  = createi (length s) (fun i -> f (Seq.index s (v i)))
-
-#push-options "--fuel 0 --ifuel 0 --z3rlimit 500"
-let flatten #t #n
-  (#m: usize {range (v n * v m) usize_inttype})
-  (x: t_Array (t_Array t m) n)
-  : t_Array t (m *! n)
-  = createi (m *! n) (fun i -> Seq.index (Seq.index x (v i / v m)) (v i % v m))
-#pop-options
-
-(** Constants *)
-let v_BITS_PER_COEFFICIENT: usize = sz 12
-
-let v_COEFFICIENTS_IN_RING_ELEMENT: usize = sz 256
-
-let v_BITS_PER_RING_ELEMENT: usize = sz 3072 // v_COEFFICIENTS_IN_RING_ELEMENT *! sz 12
-
-let v_BYTES_PER_RING_ELEMENT: usize = sz 384 // v_BITS_PER_RING_ELEMENT /! sz 8
-
-let v_CPA_PKE_KEY_GENERATION_SEED_SIZE: usize = sz 32
-
-let v_FIELD_MODULUS: i32 = 3329l
-
-let v_H_DIGEST_SIZE: usize = sz 32 
-//  Libcrux.Digest.digest_size (Libcrux.Digest.Algorithm_Sha3_256_ <: Libcrux.Digest.t_Algorithm)
-
-let v_REJECTION_SAMPLING_SEED_SIZE: usize =  sz 840 // sz 168 *! sz 5
-
-let v_SHARED_SECRET_SIZE: usize = v_H_DIGEST_SIZE
-
-type params_ = {
-    v_RANK: usize;
-    v_ETA1: usize;
-    v_ETA2: usize;
-    v_VECTOR_U_COMPRESSION_FACTOR: usize;
-    v_VECTOR_V_COMPRESSION_FACTOR: usize;
-}
-
-let valid_params p =
-  (p.v_RANK = sz 2 || p.v_RANK = sz 3 || p.v_RANK = sz 4) &&
-  (p.v_ETA1 = sz 2 || p.v_ETA1 = sz 3) &&
-  p.v_ETA2 =. sz 2 &&
-  (p.v_VECTOR_U_COMPRESSION_FACTOR = sz 10 || p.v_VECTOR_U_COMPRESSION_FACTOR = sz 11) &&
-  (p.v_VECTOR_V_COMPRESSION_FACTOR = sz 4 || p.v_VECTOR_V_COMPRESSION_FACTOR = sz 5)
-
-let params = p:params_{valid_params p}
-
-val v_ETA1_RANDOMNESS_SIZE (p:params) : u:usize{u == sz 128 \/ u == sz 192}
-let v_ETA1_RANDOMNESS_SIZE (p:params) = p.v_ETA1 *! sz 64
-
-val v_ETA2_RANDOMNESS_SIZE (p:params) : u:usize{u == sz 128}
-let v_ETA2_RANDOMNESS_SIZE (p:params) = p.v_ETA2 *! sz 64
-
-val v_RANKED_BYTES_PER_RING_ELEMENT (p:params) : u:usize{u = sz 768 \/ u = sz 1152 \/ u = sz 1536}
-let v_RANKED_BYTES_PER_RING_ELEMENT (p:params)  = p.v_RANK *! v_BYTES_PER_RING_ELEMENT
-
-let v_T_AS_NTT_ENCODED_SIZE (p:params) = v_RANKED_BYTES_PER_RING_ELEMENT p
-let v_CPA_PKE_SECRET_KEY_SIZE (p:params) = v_RANKED_BYTES_PER_RING_ELEMENT p
-
-val v_CPA_PKE_PUBLIC_KEY_SIZE (p:params) : u:usize{u = sz 800 \/ u = sz 1184 \/ u = sz 1568}
-let v_CPA_PKE_PUBLIC_KEY_SIZE (p:params) = v_RANKED_BYTES_PER_RING_ELEMENT p +! sz 32
-
-val v_SECRET_KEY_SIZE (p:params) : u:usize{u = sz 1632 \/ u = sz 2400 \/ u = sz 3168}
-let v_SECRET_KEY_SIZE (p:params) =
-  (v_CPA_PKE_SECRET_KEY_SIZE p +! v_CPA_PKE_PUBLIC_KEY_SIZE p +! v_H_DIGEST_SIZE +! v_SHARED_SECRET_SIZE)
-
-val v_C1_BLOCK_SIZE (p:params): u:usize{(u = sz 320 \/ u = sz 352) /\ v u == 32 * v p.v_VECTOR_U_COMPRESSION_FACTOR}
-let v_C1_BLOCK_SIZE (p:params) = sz 32 *! p.v_VECTOR_U_COMPRESSION_FACTOR
-
-val v_C1_SIZE (p:params) : u:usize{(u >=. sz 640 \/ u <=. sz 1448) /\ 
-                                    v u == v (v_C1_BLOCK_SIZE p) * v p.v_RANK}
-let v_C1_SIZE (p:params) = v_C1_BLOCK_SIZE p *! p.v_RANK
-
-val v_C2_SIZE (p:params) : u:usize{(u = sz 128 \/ u = sz 160) /\ v u == 32 * v p.v_VECTOR_V_COMPRESSION_FACTOR }
-let v_C2_SIZE (p:params) = sz 32 *! p.v_VECTOR_V_COMPRESSION_FACTOR
-
-val v_CPA_PKE_CIPHERTEXT_SIZE (p:params) : u:usize {v u = v (v_C1_SIZE p) + v (v_C2_SIZE p)}
-let v_CPA_PKE_CIPHERTEXT_SIZE (p:params) = v_C1_SIZE p +! v_C2_SIZE p
-
-val v_IMPLICIT_REJECTION_HASH_INPUT_SIZE (p:params): u:usize{v u == v v_SHARED_SECRET_SIZE + 
-                                                                    v (v_CPA_PKE_CIPHERTEXT_SIZE p)}
-let v_IMPLICIT_REJECTION_HASH_INPUT_SIZE (p:params) =
-    v_SHARED_SECRET_SIZE +! v_CPA_PKE_CIPHERTEXT_SIZE p
-
-val v_KEY_GENERATION_SEED_SIZE: u:usize{u = sz 64}
-let v_KEY_GENERATION_SEED_SIZE: usize =
-  v_CPA_PKE_KEY_GENERATION_SEED_SIZE +!
-  v_SHARED_SECRET_SIZE
-
-(** Types *)
-
-type t_Error = | Error_RejectionSampling : t_Error
-
-type t_Result a b = 
-  | Ok: a -> t_Result a b
-  | Err: b -> t_Result a b
-
-type t_KyberPublicKey (p:params) = t_Array u8 (v_CPA_PKE_PUBLIC_KEY_SIZE p)
-type t_KyberPrivateKey (p:params) = t_Array u8 (v_SECRET_KEY_SIZE p)
-type t_KyberKeyPair (p:params) = t_KyberPrivateKey p & t_KyberPublicKey p
-
-type t_KyberCPAPrivateKey (p:params) = t_Array u8 (v_CPA_PKE_SECRET_KEY_SIZE p)
-type t_KyberCPAKeyPair (p:params) = t_KyberCPAPrivateKey p & t_KyberPublicKey p
-
-type t_KyberCiphertext (p:params) = t_Array u8 (v_CPA_PKE_CIPHERTEXT_SIZE p)
-type t_KyberSharedSecret = t_Array u8 (v_SHARED_SECRET_SIZE)
-
-(** Utility and Hash Function *)
-assume val v_G (input: t_Slice u8) : t_Array u8 (sz 64)
-assume val v_H (input: t_Slice u8) : t_Array u8 (sz 32)
-assume val v_PRF (v_LEN: usize) (input: t_Slice u8) : t_Array u8 v_LEN
-let v_J (input: t_Slice u8) : t_Array u8 (sz 32) = v_PRF (sz 32) input
-assume val v_XOF (v_LEN: usize) (input: t_Slice u8) : t_Array u8 v_LEN
-
-(** Kyber Math and Sampling *)
-
-type field_element = n:nat{n < v v_FIELD_MODULUS}
-type polynomial = arr: t_Array nat (sz 256) {forall i. Seq.index arr i < v v_FIELD_MODULUS}
-type vector (p:params) = t_Array polynomial p.v_RANK
-type matrix (p:params) = t_Array (vector p) p.v_RANK
-
-assume val poly_add: polynomial -> polynomial -> polynomial
-assume val poly_sub: polynomial -> polynomial -> polynomial
-assume val vector_add: #p:params -> vector p -> vector p -> vector p
-assume val vector_dot_product: #p:params -> vector p -> vector p -> polynomial
-
-assume val matrix_transpose: #p:params -> matrix p -> matrix p
-assume val matrix_vector_mul: #p:params -> matrix p -> vector p -> vector p
-val compute_As_plus_e: #p:params -> a:matrix p -> s:vector p -> e:vector p -> vector p
-let compute_As_plus_e #p a s e = vector_add (matrix_vector_mul a s) e
-
-assume val poly_inv_ntt: #p:params -> polynomial -> polynomial
-assume val vector_ntt: #p:params -> vector p -> vector p
-assume val vector_inv_ntt: #p:params -> vector p -> vector p
-
-// note we take seed of size 32 not 34 as in hacspec
-assume val sample_matrix_A: #p:params -> seed:t_Array u8 (sz 32) -> matrix p
-// note we take seed of size 32 not 33 as in hacspec
-assume val sample_vector_cbd: #p:params -> seed:t_Array u8 (sz 32) -> domain_sep:usize -> vector p
-// note we take seed of size 32 not 33 as in hacspec
-
-assume val sample_poly_binomial: v_ETA:usize{v v_ETA <= 3}  -> t_Array u8 (v_ETA *! sz 64) -> polynomial
-
-open Rust_primitives.Integers
-
-val sample_poly_cbd: #p:params -> seed:t_Array u8 (sz 32) -> domain_sep:usize{v domain_sep < 256} -> polynomial
-let sample_poly_cbd #p seed domain_sep =
-  let prf_input = Seq.append seed (Seq.create 1 (mk_int #u8_inttype (v domain_sep))) in
-  let prf_output = v_PRF (v_ETA2_RANDOMNESS_SIZE p) prf_input in
-  sample_poly_binomial p.v_ETA2 prf_output
-
-let sample_vector_cbd_then_ntt (#p:params) (seed:t_Array u8 (sz 32)) (domain_sep:usize) =
-  vector_ntt (sample_vector_cbd #p seed domain_sep)
-
-type dT = d: nat {d = 1 \/ d = 4 \/ d = 5 \/ d = 10 \/ d = 11 \/ d = 12}
-
-let compress_d (d: dT {d <> 12}) (x: field_element): field_element
-  = (pow2 d * x + 1664) / v v_FIELD_MODULUS
-
-let bits_to_bytes (#bytes: usize) (bv: bit_vec (v bytes * 8))
-  : Pure (t_Array u8 bytes)
-         (requires True)
-         (ensures fun r -> (forall i. bit_vec_of_int_t_array r 8 i == bv i))
-  = bit_vec_to_int_t_array 8 bv
-
-let bytes_to_bits (#bytes: usize) (r: t_Array u8 bytes)
-  : Pure (i: bit_vec (v bytes * 8))
-         (requires True)
-         (ensures fun f -> (forall i. bit_vec_of_int_t_array r 8 i == f i))
-  = bit_vec_of_int_t_array r 8
-
-unfold let retype_bit_vector #a #b (#_:unit{a == b}) (x: a): b = x
-
-let byte_encode (d: dT) (coefficients: polynomial): t_Array u8 (sz (32 * d))
-  = bits_to_bytes #(sz (32 * d))
-       (retype_bit_vector (bit_vec_of_nat_array coefficients d))
-
-let byte_decode (d: dT) (coefficients: t_Array u8 (sz (32 * d))): polynomial
-  = let bv = bit_vec_of_int_t_array coefficients 8 in
-    let arr: t_Array nat (sz 256) = bit_vec_to_nat_array d (retype_bit_vector bv) in
-    let p = map' (fun (x: nat) -> x % v v_FIELD_MODULUS <: nat) arr in
-    introduce forall i. Seq.index p i < v v_FIELD_MODULUS
-    with assert (Seq.index p i == Seq.index p (v (sz i)));
-    p
-
-let vector_encode_12 (#p:params) (v: vector p): t_Array u8 (v_T_AS_NTT_ENCODED_SIZE p)
-  = let s: t_Array (t_Array _ (sz 384)) p.v_RANK = map' (byte_encode 12) v in
-    flatten s
-
-let vector_decode_12 (#p:params) (arr: t_Array u8 (v_T_AS_NTT_ENCODED_SIZE p)): vector p
-  = createi p.v_RANK (fun block -> 
-      let block_size = (sz (32 * 12)) in
-      let slice = Seq.slice arr (v block * v block_size) 
-                                (v block * v block_size + v block_size) in
-      byte_decode 12 slice
-    )
-
-let compress_then_byte_encode (d: dT {d <> 12}) (coefficients: polynomial): t_Array u8 (sz (32 * d))
-  = let coefs: t_Array nat (sz 256) = map (fun (f: nat {f < v v_FIELD_MODULUS}) ->
-           compress_d d f <: nat
-         ) coefficients
-    in
-    byte_encode d coefficients
-
-let compress_then_encode_message: polynomial -> t_Array u8 v_SHARED_SECRET_SIZE
-  = byte_encode 1
-
-let decode_then_decompress_message: t_Array u8 v_SHARED_SECRET_SIZE -> polynomial
-  = byte_decode 1
-
-let compress_then_encode_u (p:params) (vec: vector p): t_Array u8 (v_C1_SIZE p)
-  = let d = p.v_VECTOR_U_COMPRESSION_FACTOR in
-    flatten (map #_ #_ #(fun _ -> True) (byte_encode (v d)) vec)
-
-let decode_then_decompress_u (p:params) (arr: t_Array u8 (v_C1_SIZE p)): vector p
-  = let d = p.v_VECTOR_U_COMPRESSION_FACTOR in
-    createi p.v_RANK (fun block -> 
-      let block_size = v_C1_BLOCK_SIZE p in
-      let slice = Seq.slice arr (v block * v block_size) 
-                                (v block * v block_size + v block_size) in
-      byte_decode (v d) slice
-    )
-
-let compress_then_encode_v (p:params): polynomial -> t_Array u8 (v_C2_SIZE p)
-  = byte_encode (v p.v_VECTOR_V_COMPRESSION_FACTOR)
-
-let decode_then_decompress_v (p:params): t_Array u8 (v_C2_SIZE p) -> polynomial
-  = byte_decode (v p.v_VECTOR_V_COMPRESSION_FACTOR)
-
-(** IND-CPA Functions *)
-
-/// This function implements most of <strong>Algorithm 12</strong> of the
-/// NIST FIPS 203 specification; this is the Kyber CPA-PKE key generation algorithm.
-///
-/// We say "most of" since Algorithm 12 samples the required randomness within
-/// the function itself, whereas this implementation expects it to be provided
-/// through the `key_generation_seed` parameter.
-
-val ind_cpa_generate_keypair (p:params) (randomness:t_Array u8 v_CPA_PKE_KEY_GENERATION_SEED_SIZE) :
-                             t_KyberCPAKeyPair p
-let ind_cpa_generate_keypair p randomness =
-    let hashed = v_G randomness in
-    let (seed_for_A, seed_for_secret_and_error) = split hashed (sz 32) in
-    let matrix_A_as_ntt = sample_matrix_A #p seed_for_A in
-    let secret_as_ntt = sample_vector_cbd_then_ntt #p seed_for_secret_and_error (sz 0) in
-    let error_as_ntt = sample_vector_cbd_then_ntt #p seed_for_secret_and_error p.v_RANK in
-    let t_as_ntt = compute_As_plus_e #p matrix_A_as_ntt secret_as_ntt error_as_ntt in
-    let public_key_serialized = Seq.append (vector_encode_12 #p t_as_ntt) seed_for_A in
-    let secret_key_serialized = vector_encode_12 #p secret_as_ntt in
-    (secret_key_serialized,public_key_serialized)
-
-/// This function implements <strong>Algorithm 13</strong> of the
-/// NIST FIPS 203 specification; this is the Kyber CPA-PKE encryption algorithm.
-
-val ind_cpa_encrypt (p:params) (public_key: t_KyberPublicKey p)
-                    (message: t_Array u8 v_SHARED_SECRET_SIZE)
-                    (randomness:t_Array u8 v_SHARED_SECRET_SIZE) :
-                    t_KyberCiphertext p
-
-let ind_cpa_encrypt p public_key message randomness =
-    let (t_as_ntt_bytes, seed_for_A) = split public_key (v_T_AS_NTT_ENCODED_SIZE p) in
-    let t_as_ntt = vector_decode_12 #p t_as_ntt_bytes in 
-    let matrix_A_as_ntt = sample_matrix_A #p seed_for_A in
-    let r_as_ntt = sample_vector_cbd_then_ntt #p randomness (sz 0) in
-    let error_1 = sample_vector_cbd #p randomness p.v_RANK in
-    let error_2 = sample_poly_cbd #p randomness (p.v_RANK +! p.v_RANK) in
-    let u = vector_add (vector_inv_ntt (matrix_vector_mul (matrix_transpose matrix_A_as_ntt) r_as_ntt)) error_1 in
-    let mu = decode_then_decompress_message message in
-    let v = poly_add (poly_add (vector_dot_product t_as_ntt r_as_ntt) error_2) mu in  
-    let c1 = compress_then_encode_u p u in
-    let c2 = compress_then_encode_v p v in
-    concat c1 c2
-
-/// This function implements <strong>Algorithm 14</strong> of the
-/// NIST FIPS 203 specification; this is the Kyber CPA-PKE decryption algorithm.
-
-val ind_cpa_decrypt (p:params) (secret_key: t_KyberCPAPrivateKey p)
-                    (ciphertext: t_KyberCiphertext p): 
-                    t_KyberSharedSecret
-
-let ind_cpa_decrypt p secret_key ciphertext =
-    let (c1,c2) = split ciphertext (v_C1_SIZE p) in
-    let u = decode_then_decompress_u p c1 in
-    let v = decode_then_decompress_v p c2 in
-    let secret_as_ntt = vector_decode_12 #p secret_key in
-    let w = poly_sub v (poly_inv_ntt #p (vector_dot_product secret_as_ntt (vector_ntt u))) in
-    compress_then_encode_message w
-
-(** IND-CCA Functions *)
-
-
-/// This function implements most of Algorithm 15 of the
-/// NIST FIPS 203 specification; this is the Kyber CCA-KEM key generation algorithm.
-///
-/// We say "most of" since Algorithm 15 samples the required randomness within
-/// the function itself, whereas this implementation expects it to be provided
-/// through the `randomness` parameter.
-/// 
-/// TODO: input validation
-
-val ind_cca_generate_keypair (p:params) (randomness:t_Array u8 v_KEY_GENERATION_SEED_SIZE) :
-                             t_KyberKeyPair p
-let ind_cca_generate_keypair p randomness =
-    let (ind_cpa_keypair_randomness, implicit_rejection_value) =
-        split randomness v_CPA_PKE_KEY_GENERATION_SEED_SIZE in
-        
-    let (ind_cpa_secret_key,ind_cpa_public_key) = ind_cpa_generate_keypair p ind_cpa_keypair_randomness in
-    let ind_cca_secret_key = Seq.append ind_cpa_secret_key (
-                             Seq.append ind_cpa_public_key (
-                             Seq.append (v_H ind_cpa_public_key) implicit_rejection_value)) in
-    (ind_cca_secret_key, ind_cpa_public_key)
-
-/// This function implements most of Algorithm 16 of the
-/// NIST FIPS 203 specification; this is the Kyber CCA-KEM encapsulation algorithm.
-///
-/// We say "most of" since Algorithm 16 samples the required randomness within
-/// the function itself, whereas this implementation expects it to be provided
-/// through the `randomness` parameter.
-///
-/// TODO: input validation
-
-val ind_cca_encapsulate (p:params) (public_key: t_KyberPublicKey p)
-                        (randomness:t_Array u8 v_SHARED_SECRET_SIZE) :
-                        (t_KyberCiphertext p &  t_KyberSharedSecret)
-let ind_cca_encapsulate p public_key randomness =
-    let to_hash = concat randomness (v_H public_key) in
-    let hashed = v_G to_hash in
-    let (shared_secret, pseudorandomness) = split hashed v_SHARED_SECRET_SIZE in
-    let ciphertext = ind_cpa_encrypt p public_key randomness pseudorandomness in
-    (ciphertext,shared_secret)
-    
-
-/// This function implements Algorithm 17 of the
-/// NIST FIPS 203 specification; this is the Kyber CCA-KEM encapsulation algorithm.
-
-val ind_cca_decapsulate (p:params) (secret_key: t_KyberPrivateKey p)
-                        (ciphertext: t_KyberCiphertext p): 
-                         t_KyberSharedSecret
-let ind_cca_decapsulate p secret_key ciphertext =
-    let (ind_cpa_secret_key,rest) = split secret_key (v_CPA_PKE_SECRET_KEY_SIZE p) in
-    let (ind_cpa_public_key,rest) = split rest (v_CPA_PKE_PUBLIC_KEY_SIZE p) in
-    let (ind_cpa_public_key_hash,implicit_rejection_value) = split rest v_H_DIGEST_SIZE in
-    
-    let decrypted = ind_cpa_decrypt p ind_cpa_secret_key ciphertext in
-    let to_hash = concat decrypted ind_cpa_public_key_hash in
-    let hashed = v_G to_hash in
-    let (success_shared_secret, pseudorandomness) = split hashed v_SHARED_SECRET_SIZE in
-
-    assert (Seq.length implicit_rejection_value = 32);
-    let to_hash = concat implicit_rejection_value ciphertext in
-    let rejection_shared_secret = v_J to_hash in
-
-    let reencrypted = ind_cpa_encrypt p ind_cpa_public_key decrypted pseudorandomness in
-    if reencrypted = ciphertext
-    then success_shared_secret
-    else rejection_shared_secret
-   
-
-(** Kyber-768 Instantiation *)
-
-let kyber768_params : params = {
-    v_RANK = sz 3;
-    v_ETA1 = sz 2;
-    v_ETA2 = sz 2;
-    v_VECTOR_U_COMPRESSION_FACTOR = sz 10;
-    v_VECTOR_V_COMPRESSION_FACTOR = sz 4;
-}
-
-let kyber768_generate_keypair (randomness:t_Array u8 (sz 64)):
-                              (t_Array u8 (sz 2400) & t_Array u8 (sz 1184)) =
-    ind_cca_generate_keypair kyber768_params randomness
-
-let kyber768_encapsulate (public_key: t_Array u8 (sz 1184)) (randomness: t_Array u8 (sz 32)):
-                         (t_Array u8 (sz 1088) & t_Array u8 (sz 32)) =
-    ind_cca_encapsulate kyber768_params public_key randomness
-
-
-let kyber768_decapsulate (secret_key: t_Array u8 (sz 2400)) (ciphertext: t_Array u8 (sz 1088)):
-                         t_Array u8 (sz 32) =
-    ind_cca_decapsulate kyber768_params secret_key ciphertext
-
-(** Kyber-1024 Instantiation *)
-
-let kyber1024_params : params = {
-    v_RANK = sz 4;
-    v_ETA1 = sz 2;
-    v_ETA2 = sz 2;
-    v_VECTOR_U_COMPRESSION_FACTOR = sz 11;
-    v_VECTOR_V_COMPRESSION_FACTOR = sz 5;
-}
-
-let kyber1024_generate_keypair (randomness:t_Array u8 (sz 64)):
-                               (t_Array u8 (sz 3168) & t_Array u8 (sz 1568)) =
-    ind_cca_generate_keypair kyber1024_params randomness
-
-let kyber1024_encapsulate (public_key: t_Array u8 (sz 1568)) (randomness: t_Array u8 (sz 32)):
-                          (t_Array u8 (sz 1568) & t_Array u8 (sz 32)) =
-    ind_cca_encapsulate kyber1024_params public_key randomness
-
-
-let kyber1024_decapsulate (secret_key: t_Array u8 (sz 3168)) (ciphertext: t_Array u8 (sz 1568)):
-                           t_Array u8 (sz 32) =
-    ind_cca_decapsulate kyber1024_params secret_key ciphertext
-
-(** Kyber-512 Instantiation *)
-
-let kyber512_params : params = {
-    v_RANK = sz 2;
-    v_ETA1 = sz 3;
-    v_ETA2 = sz 2;
-    v_VECTOR_U_COMPRESSION_FACTOR = sz 10;
-    v_VECTOR_V_COMPRESSION_FACTOR = sz 4;
-}
-
-let kyber512_generate_keypair (randomness:t_Array u8 (sz 64)):
-                              (t_Array u8 (sz 1632) & t_Array u8 (sz 800))  =
-    ind_cca_generate_keypair kyber512_params randomness
-
-let kyber512_encapsulate (public_key: t_Array u8 (sz 800)) (randomness: t_Array u8 (sz 32)):
-                         (t_Array u8 (sz 768) & t_Array u8 (sz 32)) =
-    ind_cca_encapsulate kyber512_params public_key randomness
-
-
-let kyber512_decapsulate (secret_key: t_Array u8 (sz 1632)) (ciphertext: t_Array u8 (sz 768)):
-                         t_Array u8 (sz 32) =
-    ind_cca_decapsulate kyber512_params secret_key ciphertext
