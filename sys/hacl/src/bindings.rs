/* automatically generated by rust-bindgen 0.63.0 */

pub type FStar_UInt128_uint128 = u128;
extern "C" {
    #[doc = "Encrypt a message `m` with key `k`.\n\nThe arguments `k`, `n`, `aadlen`, and `aad` are same in encryption/decryption.\nNote: Encryption and decryption can be executed in-place, i.e., `m` and `cipher` can point to the same memory.\n\n@param k Pointer to 32 bytes of memory where the AEAD key is read from.\n@param n Pointer to 12 bytes of memory where the AEAD nonce is read from.\n@param aadlen Length of the associated data.\n@param aad Pointer to `aadlen` bytes of memory where the associated data is read from.\n\n@param mlen Length of the message.\n@param m Pointer to `mlen` bytes of memory where the message is read from.\n@param cipher Pointer to `mlen` bytes of memory where the ciphertext is written to.\n@param mac Pointer to 16 bytes of memory where the mac is written to."]
    pub fn Hacl_Chacha20Poly1305_32_aead_encrypt(
        k: *mut u8,
        n: *mut u8,
        aadlen: u32,
        aad: *mut u8,
        mlen: u32,
        m: *mut u8,
        cipher: *mut u8,
        mac: *mut u8,
    );
}
extern "C" {
    #[doc = "Decrypt a ciphertext `cipher` with key `k`.\n\nThe arguments `k`, `n`, `aadlen`, and `aad` are same in encryption/decryption.\nNote: Encryption and decryption can be executed in-place, i.e., `m` and `cipher` can point to the same memory.\n\nIf decryption succeeds, the resulting plaintext is stored in `m` and the function returns the success code 0.\nIf decryption fails, the array `m` remains unchanged and the function returns the error code 1.\n\n@param k Pointer to 32 bytes of memory where the AEAD key is read from.\n@param n Pointer to 12 bytes of memory where the AEAD nonce is read from.\n@param aadlen Length of the associated data.\n@param aad Pointer to `aadlen` bytes of memory where the associated data is read from.\n\n@param mlen Length of the ciphertext.\n@param m Pointer to `mlen` bytes of memory where the message is written to.\n@param cipher Pointer to `mlen` bytes of memory where the ciphertext is read from.\n@param mac Pointer to 16 bytes of memory where the mac is read from.\n\n@returns 0 on succeess; 1 on failure."]
    pub fn Hacl_Chacha20Poly1305_32_aead_decrypt(
        k: *mut u8,
        n: *mut u8,
        aadlen: u32,
        aad: *mut u8,
        mlen: u32,
        m: *mut u8,
        cipher: *mut u8,
        mac: *mut u8,
    ) -> u32;
}
extern "C" {
    #[doc = "Compute the scalar multiple of a point.\n\n@param out Pointer to 32 bytes of memory, allocated by the caller, where the resulting point is written to.\n@param priv Pointer to 32 bytes of memory where the secret/private key is read from.\n@param pub Pointer to 32 bytes of memory where the public point is read from."]
    pub fn Hacl_Curve25519_51_scalarmult(out: *mut u8, priv_: *mut u8, pub_: *mut u8);
}
extern "C" {
    #[doc = "Calculate a public point from a secret/private key.\n\nThis computes a scalar multiplication of the secret/private key with the curve's basepoint.\n\n@param pub Pointer to 32 bytes of memory, allocated by the caller, where the resulting point is written to.\n@param priv Pointer to 32 bytes of memory where the secret/private key is read from."]
    pub fn Hacl_Curve25519_51_secret_to_public(pub_: *mut u8, priv_: *mut u8);
}
extern "C" {
    #[doc = "Execute the diffie-hellmann key exchange.\n\n@param out Pointer to 32 bytes of memory, allocated by the caller, where the resulting point is written to.\n@param priv Pointer to 32 bytes of memory where **our** secret/private key is read from.\n@param pub Pointer to 32 bytes of memory where **their** public point is read from."]
    pub fn Hacl_Curve25519_51_ecdh(out: *mut u8, priv_: *mut u8, pub_: *mut u8) -> bool;
}
extern "C" {
    pub fn Hacl_Hash_SHA2_update_multi_224(s: *mut u32, blocks: *mut u8, n_blocks: u32);
}
extern "C" {
    pub fn Hacl_Hash_SHA2_update_multi_256(s: *mut u32, blocks: *mut u8, n_blocks: u32);
}
extern "C" {
    pub fn Hacl_Hash_SHA2_update_last_224(
        s: *mut u32,
        prev_len: u64,
        input: *mut u8,
        input_len: u32,
    );
}
extern "C" {
    pub fn Hacl_Hash_SHA2_update_last_256(
        s: *mut u32,
        prev_len: u64,
        input: *mut u8,
        input_len: u32,
    );
}
extern "C" {
    pub fn Hacl_Hash_SHA2_hash_224(input: *mut u8, input_len: u32, dst: *mut u8);
}
extern "C" {
    pub fn Hacl_Hash_SHA2_hash_256(input: *mut u8, input_len: u32, dst: *mut u8);
}
extern "C" {
    pub fn Hacl_Hash_SHA2_hash_384(input: *mut u8, input_len: u32, dst: *mut u8);
}
extern "C" {
    pub fn Hacl_Hash_SHA2_hash_512(input: *mut u8, input_len: u32, dst: *mut u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Hacl_Streaming_SHA2_state_sha2_224_s {
    pub block_state: *mut u32,
    pub buf: *mut u8,
    pub total_len: u64,
}
pub type Hacl_Streaming_SHA2_state_sha2_224 = Hacl_Streaming_SHA2_state_sha2_224_s;
pub type Hacl_Streaming_SHA2_state_sha2_256 = Hacl_Streaming_SHA2_state_sha2_224;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Hacl_Streaming_SHA2_state_sha2_384_s {
    pub block_state: *mut u64,
    pub buf: *mut u8,
    pub total_len: u64,
}
pub type Hacl_Streaming_SHA2_state_sha2_384 = Hacl_Streaming_SHA2_state_sha2_384_s;
pub type Hacl_Streaming_SHA2_state_sha2_512 = Hacl_Streaming_SHA2_state_sha2_384;
extern "C" {
    pub fn Hacl_Streaming_SHA2_create_in_224() -> *mut Hacl_Streaming_SHA2_state_sha2_224;
}
extern "C" {
    pub fn Hacl_Streaming_SHA2_init_224(s: *mut Hacl_Streaming_SHA2_state_sha2_224);
}
extern "C" {
    #[doc = "0 = success, 1 = max length exceeded"]
    pub fn Hacl_Streaming_SHA2_update_224(
        p: *mut Hacl_Streaming_SHA2_state_sha2_224,
        data: *mut u8,
        len: u32,
    ) -> u32;
}
extern "C" {
    pub fn Hacl_Streaming_SHA2_finish_224(p: *mut Hacl_Streaming_SHA2_state_sha2_224, dst: *mut u8);
}
extern "C" {
    pub fn Hacl_Streaming_SHA2_free_224(s: *mut Hacl_Streaming_SHA2_state_sha2_224);
}
extern "C" {
    pub fn Hacl_Streaming_SHA2_create_in_256() -> *mut Hacl_Streaming_SHA2_state_sha2_224;
}
extern "C" {
    pub fn Hacl_Streaming_SHA2_init_256(s: *mut Hacl_Streaming_SHA2_state_sha2_224);
}
extern "C" {
    #[doc = "0 = success, 1 = max length exceeded"]
    pub fn Hacl_Streaming_SHA2_update_256(
        p: *mut Hacl_Streaming_SHA2_state_sha2_224,
        data: *mut u8,
        len: u32,
    ) -> u32;
}
extern "C" {
    pub fn Hacl_Streaming_SHA2_finish_256(p: *mut Hacl_Streaming_SHA2_state_sha2_224, dst: *mut u8);
}
extern "C" {
    pub fn Hacl_Streaming_SHA2_free_256(s: *mut Hacl_Streaming_SHA2_state_sha2_224);
}
extern "C" {
    pub fn Hacl_Streaming_SHA2_create_in_384() -> *mut Hacl_Streaming_SHA2_state_sha2_384;
}
extern "C" {
    pub fn Hacl_Streaming_SHA2_init_384(s: *mut Hacl_Streaming_SHA2_state_sha2_384);
}
extern "C" {
    #[doc = "0 = success, 1 = max length exceeded"]
    pub fn Hacl_Streaming_SHA2_update_384(
        p: *mut Hacl_Streaming_SHA2_state_sha2_384,
        data: *mut u8,
        len: u32,
    ) -> u32;
}
extern "C" {
    pub fn Hacl_Streaming_SHA2_finish_384(p: *mut Hacl_Streaming_SHA2_state_sha2_384, dst: *mut u8);
}
extern "C" {
    pub fn Hacl_Streaming_SHA2_free_384(s: *mut Hacl_Streaming_SHA2_state_sha2_384);
}
extern "C" {
    pub fn Hacl_Streaming_SHA2_create_in_512() -> *mut Hacl_Streaming_SHA2_state_sha2_384;
}
extern "C" {
    pub fn Hacl_Streaming_SHA2_init_512(s: *mut Hacl_Streaming_SHA2_state_sha2_384);
}
extern "C" {
    #[doc = "0 = success, 1 = max length exceeded"]
    pub fn Hacl_Streaming_SHA2_update_512(
        p: *mut Hacl_Streaming_SHA2_state_sha2_384,
        data: *mut u8,
        len: u32,
    ) -> u32;
}
extern "C" {
    pub fn Hacl_Streaming_SHA2_finish_512(p: *mut Hacl_Streaming_SHA2_state_sha2_384, dst: *mut u8);
}
extern "C" {
    pub fn Hacl_Streaming_SHA2_free_512(s: *mut Hacl_Streaming_SHA2_state_sha2_384);
}
extern "C" {
    pub fn Hacl_SHA3_shake128_hacl(
        inputByteLen: u32,
        input: *mut u8,
        outputByteLen: u32,
        output: *mut u8,
    );
}
extern "C" {
    pub fn Hacl_SHA3_shake256_hacl(
        inputByteLen: u32,
        input: *mut u8,
        outputByteLen: u32,
        output: *mut u8,
    );
}
extern "C" {
    pub fn Hacl_SHA3_sha3_224(inputByteLen: u32, input: *mut u8, output: *mut u8);
}
extern "C" {
    pub fn Hacl_SHA3_sha3_256(inputByteLen: u32, input: *mut u8, output: *mut u8);
}
extern "C" {
    pub fn Hacl_SHA3_sha3_384(inputByteLen: u32, input: *mut u8, output: *mut u8);
}
extern "C" {
    pub fn Hacl_SHA3_sha3_512(inputByteLen: u32, input: *mut u8, output: *mut u8);
}
extern "C" {
    pub fn Hacl_Streaming_SHA3_create_in_256() -> *mut Hacl_Streaming_SHA2_state_sha2_384;
}
extern "C" {
    pub fn Hacl_Streaming_SHA3_init_256(s: *mut Hacl_Streaming_SHA2_state_sha2_384);
}
extern "C" {
    #[doc = "0 = success, 1 = max length exceeded. Due to internal limitations, there is currently an arbitrary limit of 2^64-1 bytes that can be hashed through this interface."]
    pub fn Hacl_Streaming_SHA3_update_256(
        p: *mut Hacl_Streaming_SHA2_state_sha2_384,
        data: *mut u8,
        len: u32,
    ) -> u32;
}
extern "C" {
    pub fn Hacl_Streaming_SHA3_finish_256(p: *mut Hacl_Streaming_SHA2_state_sha2_384, dst: *mut u8);
}
extern "C" {
    pub fn Hacl_Streaming_SHA3_free_256(s: *mut Hacl_Streaming_SHA2_state_sha2_384);
}
extern "C" {
    pub fn Hacl_Blake2b_32_blake2b_init(hash: *mut u64, kk: u32, nn: u32);
}
extern "C" {
    pub fn Hacl_Blake2b_32_blake2b_update_key(
        wv: *mut u64,
        hash: *mut u64,
        kk: u32,
        k: *mut u8,
        ll: u32,
    );
}
extern "C" {
    pub fn Hacl_Blake2b_32_blake2b_update_multi(
        len: u32,
        wv: *mut u64,
        hash: *mut u64,
        prev: FStar_UInt128_uint128,
        blocks: *mut u8,
        nb: u32,
    );
}
extern "C" {
    pub fn Hacl_Blake2b_32_blake2b_update_last(
        len: u32,
        wv: *mut u64,
        hash: *mut u64,
        prev: FStar_UInt128_uint128,
        rem: u32,
        d: *mut u8,
    );
}
extern "C" {
    pub fn Hacl_Blake2b_32_blake2b_finish(nn: u32, output: *mut u8, hash: *mut u64);
}
extern "C" {
    #[doc = "Write the BLAKE2b digest of message `d` using key `k` into `output`.\n\n@param nn Length of the to-be-generated digest with 1 <= `nn` <= 64.\n@param output Pointer to `nn` bytes of memory where the digest is written to.\n@param ll Length of the input message.\n@param d Pointer to `ll` bytes of memory where the input message is read from.\n@param kk Length of the key. Can be 0.\n@param k Pointer to `kk` bytes of memory where the key is read from."]
    pub fn Hacl_Blake2b_32_blake2b(
        nn: u32,
        output: *mut u8,
        ll: u32,
        d: *mut u8,
        kk: u32,
        k: *mut u8,
    );
}
extern "C" {
    pub fn Hacl_Blake2s_32_blake2s_init(hash: *mut u32, kk: u32, nn: u32);
}
extern "C" {
    pub fn Hacl_Blake2s_32_blake2s_update_key(
        wv: *mut u32,
        hash: *mut u32,
        kk: u32,
        k: *mut u8,
        ll: u32,
    );
}
extern "C" {
    pub fn Hacl_Blake2s_32_blake2s_update_multi(
        len: u32,
        wv: *mut u32,
        hash: *mut u32,
        prev: u64,
        blocks: *mut u8,
        nb: u32,
    );
}
extern "C" {
    pub fn Hacl_Blake2s_32_blake2s_update_last(
        len: u32,
        wv: *mut u32,
        hash: *mut u32,
        prev: u64,
        rem: u32,
        d: *mut u8,
    );
}
extern "C" {
    pub fn Hacl_Blake2s_32_blake2s_finish(nn: u32, output: *mut u8, hash: *mut u32);
}
extern "C" {
    #[doc = "Write the BLAKE2s digest of message `d` using key `k` into `output`.\n\n@param nn Length of to-be-generated digest with 1 <= `nn` <= 32.\n@param output Pointer to `nn` bytes of memory where the digest is written to.\n@param ll Length of the input message.\n@param d Pointer to `ll` bytes of memory where the input message is read from.\n@param kk Length of the key. Can be 0.\n@param k Pointer to `kk` bytes of memory where the key is read from."]
    pub fn Hacl_Blake2s_32_blake2s(
        nn: u32,
        output: *mut u8,
        ll: u32,
        d: *mut u8,
        kk: u32,
        k: *mut u8,
    );
}
