//! Key-centric signature API with owned key types.
//!
//! This module provides a higher-level, key-centric interface for signature operations
//! using owned key wrapper types. It builds on the foundational `arrayref` and `owned` APIs
//! to provide a more ergonomic interface where keys are wrapped in type-safe structs.
//!
//! # Key Features
//! - Type-safe key wrappers that prevent mixing different algorithm keys
//! - Automatic key pair management with convenient constructors
//! - Seamless integration with lower-level APIs

use libcrux_secrets::U8;

pub use super::owned::{KeyGenError, SignError, VerifyError};

/// Constants defining the sizes of cryptographic elements for a signature algorithm.
pub trait SignConsts {
    /// Length of verification (public) keys in bytes.
    const VERIFICATION_KEY_LEN: usize;
    /// Length of signing (private) keys in bytes.
    const SIGNING_KEY_LEN: usize;
    /// Length of signatures in bytes.
    const SIGNATURE_LEN: usize;
    /// Length of randomness required for key generation in bytes.
    const RAND_KEYGEN_LEN: usize;
}

/// Associated types for signature algorithm components.
///
/// This trait defines the concrete types used by a signature algorithm for keys,
/// signatures, randomness, and auxiliary signing data.
pub trait SignTypes {
    /// The type representing signing (private) keys.
    type SigningKey;
    /// The type representing verification (public) keys.
    type VerificationKey;
    /// The type representing signatures.
    type Signature;
    /// The type representing randomness needed for key generation.
    type KeyGenRandomness;
    /// Auxiliary information needed for signing operations.
    ///
    /// This is algorithm-specific and may include salts or nonces required for the signing process.
    type SignAux<'a>;
}

/// A wrapper for signing (private) keys that associates them with a specific algorithm.
///
/// This type provides type safety by ensuring that signing keys can only be used
/// with their corresponding signature algorithm implementation.
pub struct SigningKey<Algorithm: SignTypes> {
    key: Algorithm::SigningKey,
}

/// A wrapper for verification (public) keys that associates them with a specific algorithm.
///
/// This type provides type safety by ensuring that verification keys can only be used
/// with their corresponding signature algorithm implementation.
pub struct VerificationKey<Algorithm: SignTypes> {
    key: Algorithm::VerificationKey,
}

/// A pair of signing and verification keys for a specific signature algorithm.
///
/// This struct conveniently groups together the private and public keys
/// generated by the same key generation operation.
pub struct KeyPair<Algorithm: SignTypes> {
    /// The signing (private) key.
    pub signing_key: SigningKey<Algorithm>,
    /// The verification (public) key.
    pub verification_key: VerificationKey<Algorithm>,
}

impl<
        const SIGNING_KEY_LEN: usize,
        const VERIFICATION_KEY_LEN: usize,
        const SIGNATURE_LEN: usize,
        const RAND_KEYGEN_LEN: usize,
        Algorithm: SignTypes<
                SigningKey = [U8; SIGNING_KEY_LEN],
                VerificationKey = [u8; VERIFICATION_KEY_LEN],
                Signature = [u8; SIGNATURE_LEN],
                KeyGenRandomness = [U8; RAND_KEYGEN_LEN],
            > + super::owned::Sign<
                SIGNING_KEY_LEN,
                VERIFICATION_KEY_LEN,
                SIGNATURE_LEN,
                RAND_KEYGEN_LEN,
            >,
    > SigningKey<Algorithm>
{
    /// Sign a payload using this signing key.
    ///
    /// # Parameters
    /// - `payload`: The data to be signed
    /// - `aux`: Algorithm-specific auxiliary data required for signing
    ///
    /// # Returns
    /// The signature on success, or [`SignError`] if signing fails.
    pub fn sign(
        &self,
        payload: &[u8],
        aux: <Algorithm as super::key_centric_owned::SignTypes>::SignAux<'_>,
    ) -> Result<Algorithm::Signature, SignError> {
        Algorithm::sign(payload, &self.key, aux)
    }
}

impl<
        const SIGNING_KEY_LEN: usize,
        const VERIFICATION_KEY_LEN: usize,
        const SIGNATURE_LEN: usize,
        const RAND_KEYGEN_LEN: usize,
        Algorithm: super::key_centric_owned::SignTypes<
                SigningKey = [U8; SIGNING_KEY_LEN],
                VerificationKey = [u8; VERIFICATION_KEY_LEN],
                Signature = [u8; SIGNATURE_LEN],
                KeyGenRandomness = [U8; RAND_KEYGEN_LEN],
            > + super::owned::Sign<
                SIGNING_KEY_LEN,
                VERIFICATION_KEY_LEN,
                SIGNATURE_LEN,
                RAND_KEYGEN_LEN,
            >,
    > VerificationKey<Algorithm>
{
    /// Verify a signature using this verification key.
    ///
    /// # Parameters
    /// - `payload`: The original data that was signed
    /// - `signature`: The signature to verify
    ///
    /// # Returns
    /// `Ok(())` if the signature is valid, or [`VerifyError`] if verification fails.
    pub fn verify(
        &self,
        payload: &[u8],
        signature: &Algorithm::Signature,
    ) -> Result<(), VerifyError> {
        Algorithm::verify(payload, &self.key, signature)
    }
}

impl<
        const SIGNING_KEY_LEN: usize,
        const VERIFICATION_KEY_LEN: usize,
        const SIGNATURE_LEN: usize,
        const RAND_KEYGEN_LEN: usize,
        Algorithm: super::key_centric_owned::SignTypes<
                SigningKey = [U8; SIGNING_KEY_LEN],
                VerificationKey = [u8; VERIFICATION_KEY_LEN],
                Signature = [u8; SIGNATURE_LEN],
                KeyGenRandomness = [U8; RAND_KEYGEN_LEN],
            > + super::owned::Sign<
                SIGNING_KEY_LEN,
                VERIFICATION_KEY_LEN,
                SIGNATURE_LEN,
                RAND_KEYGEN_LEN,
            >,
    > KeyPair<Algorithm>
{
    /// Create a key pair from existing signing and verification keys.
    ///
    /// # Parameters
    /// - `signing_key`: The signing (private) key
    /// - `verification_key`: The verification (public) key
    ///
    /// # Returns
    /// A new [`KeyPair`] containing the provided keys.
    ///
    /// # Security
    /// This function does not validate the key.
    pub fn from_keys(
        signing_key: Algorithm::SigningKey,
        verification_key: Algorithm::VerificationKey,
    ) -> Self {
        Self {
            signing_key: SigningKey { key: signing_key },
            verification_key: VerificationKey {
                key: verification_key,
            },
        }
    }

    /// Generate a new random key pair.
    ///
    /// # Parameters
    /// - `rng`: A cryptographic random number generator
    ///
    /// # Returns
    /// A [`KeyPair`] containing both keys on success, or [`KeyGenError`] if generation fails.
    pub fn generate(rng: &mut impl rand::CryptoRng) -> Result<Self, KeyGenError> {
        Algorithm::keygen(rng).map(|(signing_key, verification_key)| {
            KeyPair::from_keys(signing_key, verification_key)
        })
    }
}

/// Macro to implement `SignTypes` trait for signature algorithms.
///
/// This macro provides a convenient way to implement the `SignTypes` trait
/// for signature algorithms with standard array-based key and signature types.
///
/// # Parameters
/// - `$ty`: The type implementing the signature algorithm
/// - `$signing_key_len`: Length of signing keys in bytes
/// - `$verification_key_len`: Length of verification keys in bytes
/// - `$signature_len`: Length of signatures in bytes
/// - `$rand_keygen_len`: Length of key generation randomness in bytes
/// - `$sign_aux`: Type for auxiliary signing data
#[macro_export]
macro_rules! impl_sign_types {
    ($ty:ty, $signing_key_len:expr, $verification_key_len:expr, $signature_len:expr, $rand_keygen_len:expr, $sign_aux:ty) => {
        impl $crate::signature::key_centric_owned::SignTypes for $ty {
            type SigningKey = [$crate::libcrux_secrets::U8; $signing_key_len];
            type VerificationKey = [u8; $verification_key_len];
            type Signature = [u8; $signature_len];
            type KeyGenRandomness = [$crate::libcrux_secrets::U8; $rand_keygen_len];
            type SignAux<'a> = $sign_aux;
        }
    };
}

pub use impl_sign_types;

impl<const L: usize, Algorithm: SignTypes<SigningKey = [U8; L]>> From<[U8; L]>
    for SigningKey<Algorithm>
{
    fn from(bytes: [U8; L]) -> Self {
        Self { key: bytes }
    }
}

impl<const L: usize, Algorithm: SignTypes<VerificationKey = [u8; L]>> From<[u8; L]>
    for VerificationKey<Algorithm>
{
    fn from(bytes: [u8; L]) -> Self {
        Self { key: bytes }
    }
}
